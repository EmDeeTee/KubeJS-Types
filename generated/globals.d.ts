declare class Rarity extends Internal.Enum<Rarity> implements Internal.IExtensibleEnum {
    getStyleModifier(): Internal.UnaryOperator<Internal.Style>;
    init(): void;
    static create(arg0: string, arg1: Internal.UnaryOperator_<Internal.Style_>): Rarity;
    static valueOf(arg0: string): Rarity;
    static create(arg0: string, arg1: Internal.ChatFormatting_): Rarity;
    static values(): Rarity[];
    get styleModifier(): Internal.UnaryOperator<Internal.Style>
    readonly static "COMMON": Rarity;
    /**
     * @java.lang.Deprecated(forRemoval=false, since="")
    */
    readonly "color": Internal.ChatFormatting;
    readonly static "UNCOMMON": Rarity;
    readonly static "EPIC": Rarity;
    readonly static "RARE": Rarity;
}
type Rarity_ = Rarity | "uncommon" | "epic" | "rare" | "common";
declare class BlockPos extends Vec3i {
    constructor(arg0: Vec3_)
    constructor(arg0: Vec3i_)
    constructor(arg0: Internal.Position_)
    constructor(arg0: number, arg1: number, arg2: number)
    constructor(arg0: number, arg1: number, arg2: number)
    mutable(): Internal.BlockPos$MutableBlockPos;
    south(): this;
    offset(arg0: Vec3i_): this;
    static getX(arg0: number): number;
    east(): this;
    below(): this;
    static betweenClosed(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): Internal.Iterable<BlockPos>;
    static getY(arg0: number): number;
    static getZ(arg0: number): number;
    static findClosestMatch(arg0: BlockPos_, arg1: number, arg2: number, arg3: Internal.Predicate_<BlockPos_>): Internal.Optional<BlockPos>;
    static betweenClosedStream(arg0: BlockPos_, arg1: BlockPos_): Internal.Stream<BlockPos>;
    atY(arg0: number): this;
    east(arg0: number): Vec3i;
    multiply(arg0: number): this;
    rotate(arg0: Internal.Rotation_): this;
    asLong(): number;
    relative(arg0: Internal.Direction_, arg1: number): this;
    static offset(arg0: number, arg1: number, arg2: number, arg3: number): number;
    west(): this;
    static betweenClosedStream(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): Internal.Stream<BlockPos>;
    static spiralAround(arg0: BlockPos_, arg1: number, arg2: Internal.Direction_, arg3: Internal.Direction_): Internal.Iterable<Internal.BlockPos$MutableBlockPos>;
    west(arg0: number): this;
    static randomInCube(arg0: Internal.Random_, arg1: number, arg2: BlockPos_, arg3: number): Internal.Iterable<BlockPos>;
    north(): this;
    above(): Vec3i;
    offset(arg0: number, arg1: number, arg2: number): Vec3i;
    static withinManhattanStream(arg0: BlockPos_, arg1: number, arg2: number, arg3: number): Internal.Stream<BlockPos>;
    south(arg0: number): this;
    immutable(): this;
    below(arg0: number): this;
    static asLong(arg0: number, arg1: number, arg2: number): number;
    north(arg0: number): Vec3i;
    static betweenClosedStream(arg0: Internal.BoundingBox_): Internal.Stream<BlockPos>;
    static getFlatIndex(arg0: number): number;
    static randomBetweenClosed(arg0: Internal.Random_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): Internal.Iterable<BlockPos>;
    static of(arg0: number): BlockPos;
    relative(arg0: Internal.Direction_): this;
    static withinManhattan(arg0: BlockPos_, arg1: number, arg2: number, arg3: number): Internal.Iterable<BlockPos>;
    static betweenClosedStream(arg0: Internal.AABB_): Internal.Stream<BlockPos>;
    static betweenClosed(arg0: BlockPos_, arg1: BlockPos_): Internal.Iterable<BlockPos>;
    subtract(arg0: Vec3i_): Vec3i;
    static offset(arg0: number, arg1: Internal.Direction_): number;
    offset(arg0: number, arg1: number, arg2: number): this;
    relative(arg0: Internal.Direction$Axis_, arg1: number): this;
    cross(arg0: Vec3i_): this;
    above(arg0: number): this;
    readonly static "PACKED_Y_LENGTH": 12;
    readonly static "CODEC": any;
    readonly static "ZERO": BlockPos;
}
type BlockPos_ = BlockPos;
declare interface BlockStatePredicate {
    of(o: any): this;
    fromString(s: string): this;
    asRuleTest(): Internal.RuleTest;
    ruleTestOf(o: any): Internal.RuleTest;
    getBlockIds(): Internal.Set<ResourceLocation>;
    check(targetStates: Internal.List_<Internal.OreConfiguration$TargetBlockState_>): boolean;
    test(arg0: Internal.BlockState_): boolean;
    getBlockStates(): Internal.Collection<Internal.BlockState>;
    getBlocks(): Internal.Collection<Internal.Block>;
    get blockIds(): Internal.Set<ResourceLocation>
    get blockStates(): Internal.Collection<Internal.BlockState>
    get blocks(): Internal.Collection<Internal.Block>
    readonly static "AIR_ID": ResourceLocation;
}
type BlockStatePredicate_ = BlockStatePredicate;
declare const BlockStatePredicate: BlockStatePredicate;
declare class Block {
    constructor()
    static getBlock(id: ResourceLocation_): Internal.Block;
    static custom(predicate: Internal.BlockPredicate_): Internal.BlockPredicate;
    static id(id: ResourceLocation_): Internal.BlockIDPredicate;
    static entity(id: ResourceLocation_): Internal.BlockEntityPredicate;
    static getTypeList(): Internal.List<string>;
    static getFacing(): Internal.Map<string, Internal.Direction>;
    static id(id: ResourceLocation_, properties: Internal.Map_<string, any>): Internal.BlockIDPredicate;
    static getMaterial(): Internal.Map<string, Internal.MaterialJS>;
    static getTaggedIds(tag: ResourceLocation_): Internal.List<ResourceLocation>;
    get typeList(): Internal.List<string>
    get facing(): Internal.Map<string, Internal.Direction>
    get material(): Internal.Map<string, Internal.MaterialJS>
}
type Block_ = Block;
declare class Vec3 implements Internal.Position {
    constructor(arg0: number, arg1: number, arg2: number)
    constructor(arg0: Internal.Vector3f_)
    normalize(): this;
    horizontalDistance(): number;
    get(arg0: Internal.Direction$Axis_): number;
    lerp(arg0: Vec3_, arg1: number): this;
    distanceToSqr(arg0: Vec3_): number;
    lengthSqr(): number;
    add(arg0: number, arg1: number, arg2: number): this;
    static directionFromRotation(arg0: Internal.Vec2_): Vec3;
    cross(arg0: Vec3_): this;
    static atCenterOf(arg0: Vec3i_): Vec3;
    add(arg0: Vec3_): this;
    yRot(arg0: number): this;
    with(arg0: Internal.Direction$Axis_, arg1: number): this;
    z(): number;
    static atBottomCenterOf(arg0: Vec3i_): Vec3;
    horizontalDistanceSqr(): number;
    xRot(arg0: number): this;
    dot(arg0: Vec3_): number;
    multiply(arg0: number, arg1: number, arg2: number): this;
    y(): number;
    align(arg0: Internal.EnumSet_<Internal.Direction$Axis_>): this;
    x(): number;
    closerThan(arg0: Internal.Position_, arg1: number): boolean;
    vectorTo(arg0: Vec3_): this;
    toString(): string;
    static atLowerCornerOf(arg0: Vec3i_): Vec3;
    static fromRGB24(arg0: number): Vec3;
    subtract(arg0: Vec3_): this;
    multiply(arg0: Vec3_): this;
    distanceTo(arg0: Vec3_): number;
    static upFromBottomCenterOf(arg0: Vec3i_, arg1: number): Vec3;
    reverse(): this;
    scale(arg0: number): this;
    hashCode(): number;
    length(): number;
    distanceToSqr(arg0: number, arg1: number, arg2: number): number;
    static directionFromRotation(arg0: number, arg1: number): Vec3;
    subtract(arg0: number, arg1: number, arg2: number): this;
    zRot(arg0: number): this;
    equals(arg0: any): boolean;
    readonly "z": number;
    readonly static "ZERO": Vec3;
    readonly "x": number;
    readonly "y": number;
}
type Vec3_ = Vec3;
declare class ResourceLocation implements Internal.SpecialEquality, Internal.Comparable<ResourceLocation> {
    constructor(arg0: string, arg1: string)
    constructor(arg0: string)
    compareNamespaced(arg0: ResourceLocation_): number;
    static of(arg0: string, arg1: string): ResourceLocation;
    compareTo(arg0: ResourceLocation_): number;
    toString(): string;
    static read(arg0: string): Internal.DataResult<ResourceLocation>;
    specialEquals(o: any, shallow: boolean): boolean;
    static read(arg0: Internal.StringReader_): ResourceLocation;
    compareTo(arg0: any): number;
    static isValidResourceLocation(arg0: string): boolean;
    hashCode(): number;
    static isAllowedInResourceLocation(arg0: string): boolean;
    static tryParse(arg0: string): ResourceLocation;
    static validPathChar(arg0: string): boolean;
    toDebugFileName(): string;
    getPath(): string;
    equals(arg0: any): boolean;
    getNamespace(): string;
    get path(): string
    get namespace(): string
    readonly static "REALMS_NAMESPACE": "realms";
    readonly static "CODEC": any;
    readonly static "NAMESPACE_SEPARATOR": ":";
    readonly static "DEFAULT_NAMESPACE": "minecraft";
}
type ResourceLocation_ = ResourceLocation | Special.ResourceLocation;
declare interface NBTIO {
    write(path: Internal.Path_, nbt: Internal.CompoundTag_): void;
    read(path: Internal.Path_): Internal.CompoundTag;
}
type NBTIO_ = NBTIO;
declare const NBTIO: NBTIO;
declare class EquipmentSlot extends Internal.Enum<EquipmentSlot> {
    static values(): EquipmentSlot[];
    getType(): Internal.EquipmentSlot$Type;
    getFilterFlag(): number;
    static byName(arg0: string): EquipmentSlot;
    getName(): string;
    static valueOf(arg0: string): EquipmentSlot;
    getIndex(arg0: number): number;
    static byTypeAndIndex(arg0: Internal.EquipmentSlot$Type_, arg1: number): EquipmentSlot;
    getIndex(): number;
    get type(): Internal.EquipmentSlot$Type
    get filterFlag(): number
    get name(): string
    get index(): number
    readonly static "HEAD": EquipmentSlot;
    readonly static "FEET": EquipmentSlot;
    readonly static "LEGS": EquipmentSlot;
    readonly static "OFFHAND": EquipmentSlot;
    readonly static "MAINHAND": EquipmentSlot;
    readonly static "CHEST": EquipmentSlot;
}
type EquipmentSlot_ = "feet" | EquipmentSlot | "mainhand" | "offhand" | "head" | "legs" | "chest";
declare class Component {
    constructor()
    static join(separator: Internal.MutableComponent_, texts: Internal.Iterable_<any>): Internal.MutableComponent;
    static lightPurple(text: any): Internal.MutableComponent;
    static blue(text: any): Internal.MutableComponent;
    static clickEventOf(o: any): Internal.ClickEvent;
    static prettyPrintNbt(tag: Internal.Tag_): Internal.Component;
    static gold(text: any): Internal.MutableComponent;
    static red(text: any): Internal.MutableComponent;
    static darkGreen(text: any): Internal.MutableComponent;
    static white(text: any): Internal.MutableComponent;
    static green(text: any): Internal.MutableComponent;
    static translate(key: string, ...objects: any[]): Internal.MutableComponent;
    static keybind(keybind: string): Internal.MutableComponent;
    static translate(key: string): Internal.MutableComponent;
    static darkAqua(text: any): Internal.MutableComponent;
    static yellow(text: any): Internal.MutableComponent;
    static darkPurple(text: any): Internal.MutableComponent;
    static of(o: any): Internal.MutableComponent;
    static string(text: string): Internal.MutableComponent;
    static aqua(text: any): Internal.MutableComponent;
    static gray(text: any): Internal.MutableComponent;
    static black(text: any): Internal.MutableComponent;
    static darkGray(text: any): Internal.MutableComponent;
    static darkBlue(text: any): Internal.MutableComponent;
    static darkRed(text: any): Internal.MutableComponent;
}
type Component_ = Component;
declare class Fluid {
    constructor()
    static of(o: Internal.FluidStackJS_): Internal.FluidStackJS;
    static getEmpty(): Internal.FluidStackJS;
    static lava(): Internal.FluidStackJS;
    static getType(id: ResourceLocation_): Internal.Fluid;
    static of(o: Internal.FluidStackJS_, nbt: Internal.CompoundTag_): Internal.FluidStackJS;
    static getTypes(): Internal.List<string>;
    static of(o: Internal.FluidStackJS_, amount: number, nbt: Internal.CompoundTag_): Internal.FluidStackJS;
    static water(amount: number): Internal.FluidStackJS;
    static lava(amount: number): Internal.FluidStackJS;
    static of(o: Internal.FluidStackJS_, amount: number): Internal.FluidStackJS;
    static exists(id: ResourceLocation_): boolean;
    static water(): Internal.FluidStackJS;
    get empty(): Internal.FluidStackJS
    get types(): Internal.List<string>
    readonly static "LAVA_ID": ResourceLocation;
    readonly static "WATER_ID": ResourceLocation;
}
type Fluid_ = Fluid;
declare interface Color {
    of(o: any): Internal.Color;
    rgba(r: number, g: number, b: number, a: number): Internal.Color;
    createMapped(o: any, ...names: string[]): Internal.Color;
    readonly static "DARK_PURPLE": Internal.ChatFormatting;
    readonly static "YELLOW": Internal.ChatFormatting;
    readonly static "CYAN_DYE": Internal.DyeColor;
    readonly static "GRAY": Internal.ChatFormatting;
    readonly static "BROWN_DYE": Internal.DyeColor;
    readonly static "LIGHT_PURPLE": Internal.ChatFormatting;
    readonly static "PURPLE_DYE": Internal.DyeColor;
    readonly static "DARK_AQUA": Internal.ChatFormatting;
    readonly static "GREEN": Internal.ChatFormatting;
    readonly static "LIGHT_GRAY_DYE": Internal.DyeColor;
    readonly static "WHITE": Internal.ChatFormatting;
    readonly static "MAGENTA_DYE": Internal.DyeColor;
    readonly static "RED": Internal.ChatFormatting;
    readonly static "BLACK_DYE": Internal.DyeColor;
    readonly static "TEXT": {"dark_red": Internal.ChatFormatting, "green": Internal.ChatFormatting, "underline": Internal.ChatFormatting, "dark_green": Internal.ChatFormatting, "black": Internal.ChatFormatting, "yellow": Internal.ChatFormatting, "bold": Internal.ChatFormatting, "italic": Internal.ChatFormatting, "dark_blue": Internal.ChatFormatting, "dark_purple": Internal.ChatFormatting, "gold": Internal.ChatFormatting, "red": Internal.ChatFormatting, "aqua": Internal.ChatFormatting, "gray": Internal.ChatFormatting, "light_purple": Internal.ChatFormatting, "blue": Internal.ChatFormatting, "white": Internal.ChatFormatting, "dark_aqua": Internal.ChatFormatting, "dark_gray": Internal.ChatFormatting, "reset": Internal.ChatFormatting, "strikethrough": Internal.ChatFormatting, "obfuscated": Internal.ChatFormatting};
    readonly static "RED_DYE": Internal.DyeColor;
    readonly static "GRAY_DYE": Internal.DyeColor;
    readonly static "DARK_GRAY": Internal.ChatFormatting;
    readonly static "NONE": any;
    readonly static "ORANGE_DYE": Internal.DyeColor;
    readonly static "WHITE_DYE": Internal.DyeColor;
    readonly static "DYE": {"magenta": Internal.DyeColor, "pink": Internal.DyeColor, "green": Internal.DyeColor, "lime": Internal.DyeColor, "light_gray": Internal.DyeColor, "yellow": Internal.DyeColor, "black": Internal.DyeColor, "light_blue": Internal.DyeColor, "brown": Internal.DyeColor, "cyan": Internal.DyeColor, "orange": Internal.DyeColor, "red": Internal.DyeColor, "gray": Internal.DyeColor, "white": Internal.DyeColor, "blue": Internal.DyeColor, "purple": Internal.DyeColor};
    readonly static "BLACK": Internal.ChatFormatting;
    readonly static "BLUE": Internal.ChatFormatting;
    readonly static "DARK_GREEN": Internal.ChatFormatting;
    readonly static "DARK_RED": Internal.ChatFormatting;
    readonly static "GOLD": Internal.ChatFormatting;
    readonly static "MAP": {"": any, "light_blue_dye": Internal.DyeColor, "BLUE_DYE": Internal.DyeColor, "purple_dye": Internal.DyeColor, "dark_red": Internal.ChatFormatting, "lightGrayDye": Internal.DyeColor, "DARK_AQUA": Internal.ChatFormatting, "none": any, "green_dye": Internal.DyeColor, "blackDye": Internal.DyeColor, "dark_blue": Internal.ChatFormatting, "red": Internal.ChatFormatting, "pink_dye": Internal.DyeColor, "aqua": Internal.ChatFormatting, "white": Internal.ChatFormatting, "WHITE_DYE": Internal.DyeColor, "dark_gray": Internal.ChatFormatting, "LIGHT_PURPLE": Internal.ChatFormatting, "BROWN_DYE": Internal.DyeColor, "BLACK": Internal.ChatFormatting, "darkPurple": Internal.ChatFormatting, "NONE": any, "LIGHT_BLUE_DYE": Internal.DyeColor, "AQUA": Internal.ChatFormatting, "lightBlueDye": Internal.DyeColor, "limeDye": Internal.DyeColor, "PURPLE_DYE": Internal.DyeColor, "GREEN_DYE": Internal.DyeColor, "magenta_dye": Internal.DyeColor, "-": any, "lime_dye": Internal.DyeColor, "yellowDye": Internal.DyeColor, "grayDye": Internal.DyeColor, "purpleDye": Internal.DyeColor, "DARK_PURPLE": Internal.ChatFormatting, "ORANGE_DYE": Internal.DyeColor, "darkGray": Internal.ChatFormatting, "brownDye": Internal.DyeColor, "YELLOW": Internal.ChatFormatting, "LIME_DYE": Internal.DyeColor, "blueDye": Internal.DyeColor, "white_dye": Internal.DyeColor, "pinkDye": Internal.DyeColor, "blue_dye": Internal.DyeColor, "cyanDye": Internal.DyeColor, "GOLD": Internal.ChatFormatting, "GRAY": Internal.ChatFormatting, "MAGENTA_DYE": Internal.DyeColor, "BLUE": Internal.ChatFormatting, "yellow": Internal.ChatFormatting, "darkBlue": Internal.ChatFormatting, "transparent": any, "orange_dye": Internal.DyeColor, "red_dye": Internal.DyeColor, "dark_purple": Internal.ChatFormatting, "gold": Internal.ChatFormatting, "gray": Internal.ChatFormatting, "light_purple": Internal.ChatFormatting, "darkRed": Internal.ChatFormatting, "greenDye": Internal.DyeColor, "DARK_RED": Internal.ChatFormatting, "redDye": Internal.DyeColor, "GRAY_DYE": Internal.DyeColor, "orangeDye": Internal.DyeColor, "yellow_dye": Internal.DyeColor, "black_dye": Internal.DyeColor, "magentaDye": Internal.DyeColor, "WHITE": Internal.ChatFormatting, "green": Internal.ChatFormatting, "LIGHT_GRAY_DYE": Internal.DyeColor, "BLACK_DYE": Internal.DyeColor, "darkGreen": Internal.ChatFormatting, "RED_DYE": Internal.DyeColor, "dark_green": Internal.ChatFormatting, "black": Internal.ChatFormatting, "lightPurple": Internal.ChatFormatting, "PINK_DYE": Internal.DyeColor, "DARK_BLUE": Internal.ChatFormatting, "GREEN": Internal.ChatFormatting, "darkAqua": Internal.ChatFormatting, "gray_dye": Internal.DyeColor, "CYAN_DYE": Internal.DyeColor, "RED": Internal.ChatFormatting, "brown_dye": Internal.DyeColor, "cyan_dye": Internal.DyeColor, "blue": Internal.ChatFormatting, "whiteDye": Internal.DyeColor, "dark_aqua": Internal.ChatFormatting, "YELLOW_DYE": Internal.DyeColor, "DARK_GREEN": Internal.ChatFormatting, "DARK_GRAY": Internal.ChatFormatting};
    readonly static "GREEN_DYE": Internal.DyeColor;
    readonly static "LIGHT_BLUE_DYE": Internal.DyeColor;
    readonly static "AQUA": Internal.ChatFormatting;
    readonly static "DARK_BLUE": Internal.ChatFormatting;
    readonly static "PINK_DYE": Internal.DyeColor;
    readonly static "BLUE_DYE": Internal.DyeColor;
    readonly static "YELLOW_DYE": Internal.DyeColor;
    readonly static "LIME_DYE": Internal.DyeColor;
}
type Color_ = Color;
declare const Color: Color;
declare class JsonIO {
    constructor()
    static toPrettyString(json: Internal.JsonElement_): string;
    static toArray(element: Internal.JsonElement_): Internal.JsonArray;
    static write(path: Internal.Path_, json: Internal.JsonElement_): void;
    static parse(string: string): any;
    static toObject(json: Internal.JsonElement_): any;
    static primitiveOf(o: any): Internal.JsonPrimitive;
    static toPrimitive(element: Internal.JsonElement_): any;
    static read(path: Internal.Path_): Internal.MapJS;
    static copy(element: Internal.JsonElement_): Internal.JsonElement;
    static writeJsonHash(stream: Internal.DataOutputStream_, element: Internal.JsonElement_): void;
    static parseRaw(string: string): Internal.JsonElement;
    static getJsonHashBytes(json: Internal.JsonElement_): number[];
    static toString(json: Internal.JsonElement_): string;
    static of(o: any): Internal.JsonElement;
}
type JsonIO_ = JsonIO;
declare class Platform {
    constructor()
    static isDevelopmentEnvironment(): boolean;
    static getMcVersion(): string;
    static getList(): Internal.Set<string>;
    static getInfo(modID: string): Internal.PlatformWrapper$ModInfo;
    static getMods(): Internal.Map<string, Internal.PlatformWrapper$ModInfo>;
    static isLoaded(modId: string): boolean;
    static getName(): string;
    static isClientEnvironment(): boolean;
    static isForge(): boolean;
    static isFabric(): boolean;
    static getModVersion(): string;
    get developmentEnvironment(): boolean
    get mcVersion(): string
    get list(): Internal.Set<string>
    get mods(): Internal.Map<string, Internal.PlatformWrapper$ModInfo>
    get name(): string
    get clientEnvironment(): boolean
    get forge(): boolean
    get fabric(): boolean
    get modVersion(): string
}
type Platform_ = Platform;
declare class Item {
    constructor()
    static clearListCache(): void;
    static of(in_: Internal.ItemStackJS_, count: number, nbt: Internal.CompoundTag_): Internal.ItemStackJS;
    static of(in_: Internal.ItemStackJS_, tag: Internal.CompoundTag_): Internal.ItemStackJS;
    static getTypeList(): Internal.ListJS;
    static of(in_: Internal.ItemStackJS_, count: number): Internal.ItemStackJS;
    static getEmpty(): Internal.ItemStackJS;
    static withChance(in_: Internal.ItemStackJS_, c: number): Internal.ItemStackJS;
    static withNBT(in_: Internal.ItemStackJS_, nbt: Internal.CompoundTag_): Internal.ItemStackJS;
    static getItem(id: ResourceLocation_): Internal.Item;
    static findGroup(id: string): Internal.CreativeModeTab;
    static fireworks(properties: Internal.Map_<string, any>): Internal.FireworksJS;
    static getList(): Internal.ListJS;
    static of(in_: Internal.ItemStackJS_): Internal.ItemStackJS;
    static exists(id: ResourceLocation_): boolean;
    static isItem(o: any): boolean;
    get typeList(): Internal.ListJS
    get empty(): Internal.ItemStackJS
    get list(): Internal.ListJS
}
type Item_ = Item;
declare interface UUID {
    digits(sb: Internal.StringBuilder_, val: number, digits: number): void;
    toString(id: Internal.UUID_): string;
    fromString(o: any): Internal.UUID;
}
type UUID_ = UUID;
declare const UUID: UUID;
declare interface Facing {
    readonly static "south": Internal.Direction;
    readonly static "up": Internal.Direction;
    readonly static "UP": Internal.Direction;
    readonly static "NORTH": Internal.Direction;
    readonly static "east": Internal.Direction;
    readonly static "DOWN": Internal.Direction;
    readonly static "EAST": Internal.Direction;
    readonly static "west": Internal.Direction;
    readonly static "north": Internal.Direction;
    readonly static "down": Internal.Direction;
    readonly static "ALL": {"east": Internal.Direction, "south": Internal.Direction, "north": Internal.Direction, "west": Internal.Direction, "up": Internal.Direction, "down": Internal.Direction};
    readonly static "WEST": Internal.Direction;
    readonly static "SOUTH": Internal.Direction;
}
type Facing_ = Facing;
declare const Facing: Facing;
declare class CarvingGenerationStep extends Internal.Enum<CarvingGenerationStep> implements Internal.StringRepresentable {
    getSerializedName(): string;
    getName(): string;
    static valueOf(arg0: string): CarvingGenerationStep;
    static byName(arg0: string): CarvingGenerationStep;
    static values(): CarvingGenerationStep[];
    get serializedName(): string
    get name(): string
    readonly static "AIR": CarvingGenerationStep;
    readonly static "LIQUID": CarvingGenerationStep;
    readonly static "CODEC": any;
}
type CarvingGenerationStep_ = "liquid" | CarvingGenerationStep | "air";
declare class Ingredient {
    constructor()
    static registerCustomIngredientAction(id: string, callback: Internal.CustomIngredientActionCallback_): void;
    static custom(predicate: Internal.Predicate_<Internal.ItemStackJS_>): Internal.IngredientJS;
    static matchAny(objects: any): Internal.IngredientJS;
    static of(object: any): Internal.IngredientJS;
    static of(object: any, count: number): Internal.IngredientJS;
    static getAll(): Internal.IngredientJS;
    static customNBT(in_: Internal.IngredientJS_, predicate: Internal.Predicate_<Internal.CompoundTag_>): Internal.IngredientJS;
    static isIngredient(o: any): boolean;
    static custom(in_: Internal.IngredientJS_, predicate: Internal.Predicate_<Internal.ItemStackJS_>): Internal.IngredientJS;
    static getNone(): Internal.IngredientJS;
    get all(): Internal.IngredientJS
    get none(): Internal.IngredientJS
}
type Ingredient_ = Ingredient;
declare class JavaMath {
    static asin(arg0: number): number;
    static addExact(arg0: number, arg1: number): number;
    static expm1(arg0: number): number;
    static ceil(arg0: number): number;
    static nextAfter(arg0: number, arg1: number): number;
    static atan(arg0: number): number;
    static exp(arg0: number): number;
    static min(arg0: number, arg1: number): number;
    static multiplyExact(arg0: number, arg1: number): number;
    static floorDiv(arg0: number, arg1: number): number;
    static copySign(arg0: number, arg1: number): number;
    static ulp(arg0: number): number;
    static max(arg0: number, arg1: number): number;
    static random(): number;
    static nextUp(arg0: number): number;
    static sqrt(arg0: number): number;
    static min(arg0: number, arg1: number): number;
    static fma(arg0: number, arg1: number, arg2: number): number;
    static addExact(arg0: number, arg1: number): number;
    static multiplyExact(arg0: number, arg1: number): number;
    static fma(arg0: number, arg1: number, arg2: number): number;
    static round(arg0: number): number;
    static abs(arg0: number): number;
    static hypot(arg0: number, arg1: number): number;
    static round(arg0: number): number;
    static floor(arg0: number): number;
    static subtractExact(arg0: number, arg1: number): number;
    static abs(arg0: number): number;
    static rint(arg0: number): number;
    static floorMod(arg0: number, arg1: number): number;
    static log(arg0: number): number;
    static absExact(arg0: number): number;
    static signum(arg0: number): number;
    static log10(arg0: number): number;
    static abs(arg0: number): number;
    static floorDiv(arg0: number, arg1: number): number;
    static signum(arg0: number): number;
    static floorDiv(arg0: number, arg1: number): number;
    static cos(arg0: number): number;
    static tan(arg0: number): number;
    static floorMod(arg0: number, arg1: number): number;
    static min(arg0: number, arg1: number): number;
    static nextUp(arg0: number): number;
    static ulp(arg0: number): number;
    static min(arg0: number, arg1: number): number;
    static sin(arg0: number): number;
    static max(arg0: number, arg1: number): number;
    static atan2(arg0: number, arg1: number): number;
    static cosh(arg0: number): number;
    static toIntExact(arg0: number): number;
    static toRadians(arg0: number): number;
    static decrementExact(arg0: number): number;
    static incrementExact(arg0: number): number;
    static negateExact(arg0: number): number;
    static sinh(arg0: number): number;
    static max(arg0: number, arg1: number): number;
    static incrementExact(arg0: number): number;
    static copySign(arg0: number, arg1: number): number;
    static decrementExact(arg0: number): number;
    static toDegrees(arg0: number): number;
    static nextAfter(arg0: number, arg1: number): number;
    static negateExact(arg0: number): number;
    static max(arg0: number, arg1: number): number;
    static tanh(arg0: number): number;
    static nextDown(arg0: number): number;
    static floorMod(arg0: number, arg1: number): number;
    static IEEEremainder(arg0: number, arg1: number): number;
    static getExponent(arg0: number): number;
    static nextDown(arg0: number): number;
    static abs(arg0: number): number;
    static scalb(arg0: number, arg1: number): number;
    static multiplyFull(arg0: number, arg1: number): number;
    static multiplyHigh(arg0: number, arg1: number): number;
    static absExact(arg0: number): number;
    static pow(arg0: number, arg1: number): number;
    static getExponent(arg0: number): number;
    static multiplyExact(arg0: number, arg1: number): number;
    static scalb(arg0: number, arg1: number): number;
    static cbrt(arg0: number): number;
    static log1p(arg0: number): number;
    static acos(arg0: number): number;
    static subtractExact(arg0: number, arg1: number): number;
    readonly static "PI": 3.141592653589793;
    readonly static "E": 2.718281828459045;
}
type JavaMath_ = JavaMath;
declare class BlockProperties {
    constructor()
    readonly static "MAX_ROTATIONS_16": 15;
    readonly static "LEVEL_FLOWING": Internal.IntegerProperty;
    readonly static "PERSISTENT": Internal.BooleanProperty;
    readonly static "HORIZONTAL_FACING": Internal.DirectionProperty;
    readonly static "WEST_REDSTONE": Internal.EnumProperty<any>;
    readonly static "NOTE": Internal.IntegerProperty;
    readonly static "AGE_5": Internal.IntegerProperty;
    readonly static "EGGS": Internal.IntegerProperty;
    readonly static "NORTH": Internal.BooleanProperty;
    readonly static "HAS_RECORD": Internal.BooleanProperty;
    readonly static "SCULK_SENSOR_PHASE": Internal.EnumProperty<any>;
    readonly static "EAST_WALL": Internal.EnumProperty<any>;
    readonly static "HALF": Internal.EnumProperty<any>;
    readonly static "RESPAWN_ANCHOR_CHARGES": Internal.IntegerProperty;
    readonly static "HANGING": Internal.BooleanProperty;
    readonly static "TILT": Internal.EnumProperty<any>;
    readonly static "STABILITY_DISTANCE": Internal.IntegerProperty;
    readonly static "HAS_BOTTLE_2": Internal.BooleanProperty;
    readonly static "LAYERS": Internal.IntegerProperty;
    readonly static "SOUTH_REDSTONE": Internal.EnumProperty<any>;
    readonly static "CONDITIONAL": Internal.BooleanProperty;
    readonly static "LOCKED": Internal.BooleanProperty;
    readonly static "POWER": Internal.IntegerProperty;
    readonly static "EYE": Internal.BooleanProperty;
    readonly static "SOUTH_WALL": Internal.EnumProperty<any>;
    readonly static "MAX_AGE_1": 1;
    readonly static "ATTACHED": Internal.BooleanProperty;
    readonly static "MAX_LEVEL_15": 15;
    readonly static "BELL_ATTACHMENT": Internal.EnumProperty<any>;
    readonly static "MAX_DISTANCE": 7;
    readonly static "EXTENDED": Internal.BooleanProperty;
    readonly static "INVERTED": Internal.BooleanProperty;
    readonly static "MODE_COMPARATOR": Internal.EnumProperty<any>;
    readonly static "MOISTURE": Internal.IntegerProperty;
    readonly static "LIT": Internal.BooleanProperty;
    readonly static "DISTANCE": Internal.IntegerProperty;
    readonly static "NORTH_REDSTONE": Internal.EnumProperty<any>;
    readonly static "AGE_3": Internal.IntegerProperty;
    readonly static "STAIRS_SHAPE": Internal.EnumProperty<any>;
    readonly static "MAX_LEVEL_8": 8;
    readonly static "MIN_RESPAWN_ANCHOR_CHARGES": 0;
    readonly static "BAMBOO_LEAVES": Internal.EnumProperty<any>;
    readonly static "HORIZONTAL_AXIS": Internal.EnumProperty<any>;
    readonly static "FALLING": Internal.BooleanProperty;
    readonly static "ENABLED": Internal.BooleanProperty;
    readonly static "ATTACH_FACE": Internal.EnumProperty<any>;
    readonly static "OPEN": Internal.BooleanProperty;
    readonly static "UNSTABLE": Internal.BooleanProperty;
    readonly static "VINE_END": Internal.BooleanProperty;
    readonly static "EAST": Internal.BooleanProperty;
    readonly static "ORIENTATION": Internal.EnumProperty<any>;
    readonly static "DOUBLE_BLOCK_HALF": Internal.EnumProperty<any>;
    readonly static "MAX_RESPAWN_ANCHOR_CHARGES": 4;
    readonly static "CHEST_TYPE": Internal.EnumProperty<any>;
    readonly static "MAX_AGE_7": 7;
    readonly static "DOWN": Internal.BooleanProperty;
    readonly static "AGE_15": Internal.IntegerProperty;
    readonly static "STRUCTUREBLOCK_MODE": Internal.EnumProperty<any>;
    readonly static "SLAB_TYPE": Internal.EnumProperty<any>;
    readonly static "EAST_REDSTONE": Internal.EnumProperty<any>;
    readonly static "WATERLOGGED": Internal.BooleanProperty;
    readonly static "AGE_1": Internal.IntegerProperty;
    readonly static "FACING_HOPPER": Internal.DirectionProperty;
    readonly static "VERTICAL_DIRECTION": Internal.DirectionProperty;
    readonly static "PICKLES": Internal.IntegerProperty;
    readonly static "MAX_AGE_25": 25;
    readonly static "LEVEL_HONEY": Internal.IntegerProperty;
    readonly static "PISTON_TYPE": Internal.EnumProperty<any>;
    readonly static "HATCH": Internal.IntegerProperty;
    readonly static "SNOWY": Internal.BooleanProperty;
    readonly static "TRIGGERED": Internal.BooleanProperty;
    readonly static "SIGNAL_FIRE": Internal.BooleanProperty;
    readonly static "LEVEL_CAULDRON": Internal.IntegerProperty;
    readonly static "AXIS": Internal.EnumProperty<any>;
    readonly static "AGE_2": Internal.IntegerProperty;
    readonly static "DRAG": Internal.BooleanProperty;
    readonly static "LEVEL": Internal.IntegerProperty;
    readonly static "STAGE": Internal.IntegerProperty;
    readonly static "MAX_AGE_5": 5;
    readonly static "NORTH_WALL": Internal.EnumProperty<any>;
    readonly static "UP": Internal.BooleanProperty;
    readonly static "BITES": Internal.IntegerProperty;
    readonly static "IN_WALL": Internal.BooleanProperty;
    readonly static "AGE_25": Internal.IntegerProperty;
    readonly static "STABILITY_MAX_DISTANCE": 7;
    readonly static "HAS_BOTTLE_1": Internal.BooleanProperty;
    readonly static "AGE_7": Internal.IntegerProperty;
    readonly static "SOUTH": Internal.BooleanProperty;
    readonly static "MAX_AGE_15": 15;
    readonly static "DISARMED": Internal.BooleanProperty;
    readonly static "RAIL_SHAPE": Internal.EnumProperty<any>;
    readonly static "DOOR_HINGE": Internal.EnumProperty<any>;
    readonly static "LEVEL_COMPOSTER": Internal.IntegerProperty;
    readonly static "DELAY": Internal.IntegerProperty;
    readonly static "MIN_LEVEL": 0;
    readonly static "RAIL_SHAPE_STRAIGHT": Internal.EnumProperty<any>;
    readonly static "MIN_LEVEL_CAULDRON": 1;
    readonly static "BOTTOM": Internal.BooleanProperty;
    readonly static "HAS_BOOK": Internal.BooleanProperty;
    readonly static "CANDLES": Internal.IntegerProperty;
    readonly static "NOTEBLOCK_INSTRUMENT": Internal.EnumProperty<any>;
    readonly static "WEST": Internal.BooleanProperty;
    readonly static "SHORT": Internal.BooleanProperty;
    readonly static "BERRIES": Internal.BooleanProperty;
    readonly static "MAX_AGE_2": 2;
    readonly static "HAS_BOTTLE_0": Internal.BooleanProperty;
    readonly static "WEST_WALL": Internal.EnumProperty<any>;
    readonly static "ROTATION_16": Internal.IntegerProperty;
    readonly static "MAX_LEVEL_3": 3;
    readonly static "BED_PART": Internal.EnumProperty<any>;
    readonly static "POWERED": Internal.BooleanProperty;
    readonly static "MAX_AGE_3": 3;
    readonly static "OCCUPIED": Internal.BooleanProperty;
    readonly static "DRIPSTONE_THICKNESS": Internal.EnumProperty<any>;
    readonly static "FACING": Internal.DirectionProperty;
}
type BlockProperties_ = BlockProperties;
declare class DecorationGenerationStep extends Internal.Enum<DecorationGenerationStep> {
    static valueOf(arg0: string): DecorationGenerationStep;
    static values(): DecorationGenerationStep[];
    readonly static "UNDERGROUND_STRUCTURES": DecorationGenerationStep;
    readonly static "RAW_GENERATION": DecorationGenerationStep;
    readonly static "UNDERGROUND_ORES": DecorationGenerationStep;
    readonly static "STRONGHOLDS": DecorationGenerationStep;
    readonly static "SURFACE_STRUCTURES": DecorationGenerationStep;
    readonly static "LOCAL_MODIFICATIONS": DecorationGenerationStep;
    readonly static "VEGETAL_DECORATION": DecorationGenerationStep;
    readonly static "TOP_LAYER_MODIFICATION": DecorationGenerationStep;
    readonly static "LAKES": DecorationGenerationStep;
    readonly static "FLUID_SPRINGS": DecorationGenerationStep;
    readonly static "UNDERGROUND_DECORATION": DecorationGenerationStep;
}
type DecorationGenerationStep_ = "underground_ores" | "top_layer_modification" | "fluid_springs" | "strongholds" | "lakes" | "local_modifications" | DecorationGenerationStep | "surface_structures" | "underground_structures" | "underground_decoration" | "raw_generation" | "vegetal_decoration";
declare interface NBT {
    accessTagMap(tag: Internal.CompoundTag_): Internal.Map<string, Internal.Tag>;
    read(buf: Internal.FriendlyByteBuf_): Internal.OrderedCompoundTag;
    toTagCollection(c: Internal.Collection_<any>): Internal.CollectionTag<any>;
    quoteAndEscapeForJS(stringBuilder: Internal.StringBuilder_, string: string): void;
    l(v: number): Internal.Tag;
    b(v: number): Internal.Tag;
    byteArrayTag(v: number[]): Internal.Tag;
    listTag(): Internal.Tag;
    floatTag(v: number): Internal.Tag;
    byteTag(v: number): Internal.Tag;
    s(v: number): Internal.Tag;
    listTag(list: Internal.List_<any>): Internal.Tag;
    ia(v: number[]): Internal.Tag;
    d(v: number): Internal.Tag;
    longArrayTag(v: number[]): Internal.Tag;
    isTagCollection(o: any): boolean;
    longTag(v: number): Internal.Tag;
    compoundTag(): Internal.Tag;
    intTag(v: number): Internal.Tag;
    shortTag(v: number): Internal.Tag;
    la(v: number[]): Internal.Tag;
    stringTag(v: string): Internal.Tag;
    convertType(tagType: Internal.TagType_<any>): Internal.TagType<any>;
    toTagCollection(v: any): Internal.CollectionTag<any>;
    f(v: number): Internal.Tag;
    fromTag(t: Internal.Tag_): any;
    toTag(v: any): Internal.Tag;
    toTagCompound(v: any): Internal.CompoundTag;
    toTagList(list: any): Internal.ListTag;
    isTagCompound(o: any): boolean;
    doubleTag(v: number): Internal.Tag;
    intArrayTag(v: number[]): Internal.Tag;
    compoundTag(map: Internal.Map_<any, any>): Internal.Tag;
    ba(v: number[]): Internal.Tag;
    i(v: number): Internal.Tag;
    readonly static "VALUE_UNWRAPPER": any;
    readonly static "LIST_TYPE": any;
    readonly static "COMPOUND_TYPE": any;
}
type NBT_ = NBT;
declare const NBT: NBT;
declare class Hand extends Internal.Enum<Hand> {
    static valueOf(arg0: string): Hand;
    static values(): Hand[];
    readonly static "MAIN_HAND": Hand;
    readonly static "OFF_HAND": Hand;
}
type Hand_ = "main_hand" | "off_hand" | Hand;
declare class Vec3i implements Internal.Comparable<Vec3i> {
    constructor(arg0: number, arg1: number, arg2: number)
    constructor(arg0: number, arg1: number, arg2: number)
    north(): this;
    distToCenterSqr(arg0: Internal.Position_): number;
    getX(): number;
    getY(): number;
    static offsetCodec(arg0: number): Internal.Codec<Vec3i>;
    south(arg0: number): this;
    toShortString(): string;
    above(arg0: number): this;
    west(arg0: number): this;
    compareTo(arg0: any): number;
    east(arg0: number): this;
    distToLowCornerSqr(arg0: number, arg1: number, arg2: number): number;
    relative(arg0: Internal.Direction_): this;
    multiply(arg0: number): this;
    getZ(): number;
    closerThan(arg0: Vec3i_, arg1: number): boolean;
    below(arg0: number): this;
    offset(arg0: number, arg1: number, arg2: number): this;
    above(): this;
    toString(): string;
    north(arg0: number): this;
    east(): this;
    below(): this;
    west(): this;
    distManhattan(arg0: Vec3i_): number;
    relative(arg0: Internal.Direction$Axis_, arg1: number): this;
    get(arg0: Internal.Direction$Axis_): number;
    offset(arg0: Vec3i_): this;
    cross(arg0: Vec3i_): this;
    south(): this;
    hashCode(): number;
    distSqr(arg0: Vec3i_): number;
    subtract(arg0: Vec3i_): this;
    relative(arg0: Internal.Direction_, arg1: number): this;
    offset(arg0: number, arg1: number, arg2: number): this;
    compareTo(arg0: Vec3i_): number;
    closerToCenterThan(arg0: Internal.Position_, arg1: number): boolean;
    equals(arg0: any): boolean;
    distToCenterSqr(arg0: number, arg1: number, arg2: number): number;
    get x(): number
    get y(): number
    get z(): number
    readonly static "ZERO": Vec3i;
    readonly static "CODEC": any;
}
type Vec3i_ = Vec3i;
declare class BiomeDictionary {
    constructor()
    static addTypes(biomes: ResourceLocation_[], tags: Internal.BiomeDictionary$Type_[]): void;
    static printBiomes(type: Internal.BiomeDictionary$Type_): void;
    static getBiomeType(o: any): Internal.BiomeDictionary$Type;
    static printTags(biome: ResourceLocation_): void;
}
type BiomeDictionary_ = BiomeDictionary;
declare interface Utils {
    getClientLevel(): Internal.LevelJS;
    toTitleCase(s: string): string;
    rollChestLoot(id: ResourceLocation_): Internal.ListJS;
    getStat(id: ResourceLocation_): Internal.Stat<ResourceLocation>;
    newCountingMap(): Internal.CountingMap;
    getRegistries(): Internal.ClassWrapper<Internal.KubeJSRegistries>;
    lazy(supplier: Internal.Supplier_<T>): Internal.Supplier<T>;
    createConsole(name: string): Internal.ConsoleJS;
    parseDouble(object: any, def: number): number;
    getRandom(): Internal.Random;
    mapOf(o: any): Internal.MapJS;
    newList(): Internal.ListJS;
    getRegistry(id: ResourceLocation_): Internal.Registrar<any>;
    newRandom(seed: number): Internal.Random;
    getSystemTime(): number;
    emptyList(): Internal.List<T>;
    id(namespace: string, path: string): ResourceLocation;
    isWrapped(o: any): boolean;
    getRegistryIds(id: ResourceLocation_): Internal.Collection<ResourceLocation>;
    emptyMap(): Internal.Map<K, V>;
    getSound(id: ResourceLocation_): Internal.SoundEvent;
    randomOf(random: Internal.Random_, objects: Internal.Collection_<any>): any;
    getServer(): Internal.ServerJS;
    getLevel(level: Internal.Level_): Internal.LevelJS;
    copy(o: any): any;
    id(id: ResourceLocation_): ResourceLocation;
    regex(pattern: string, flags: number): Internal.Pattern;
    listOrSelf(o: any): Internal.ListJS;
    regex(s: any): Internal.Pattern;
    rollChestLoot(id: ResourceLocation_, entity: Internal.EntityJS_): Internal.ListJS;
    queueIO(runnable: Internal.Runnable_): void;
    newMap(): Internal.MapJS;
    expiringLazy(supplier: Internal.Supplier_<T>, time: number): Internal.Supplier<T>;
    parseInt(object: any, def: number): number;
    listOf(o: any): Internal.ListJS;
    get clientLevel(): Internal.LevelJS
    get registries(): Internal.ClassWrapper<Internal.KubeJSRegistries>
    get random(): Internal.Random
    get systemTime(): number
    get server(): Internal.ServerJS
}
type Utils_ = Utils;
declare const Utils: Utils;
declare interface AABB {
    ofSize(vec3: Vec3_, x: number, y: number, z: number): Internal.AABB;
    ofBlock(pos: BlockPos_): Internal.AABB;
    of(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.AABB;
    ofSize(x: number, y: number, z: number): Internal.AABB;
    ofBlocks(pos1: BlockPos_, pos2: BlockPos_): Internal.AABB;
    wrap(o: any): Internal.AABB;
    readonly static "CUBE": Internal.AABB;
    readonly static "EMPTY": Internal.AABB;
}
type AABB_ = AABB;
declare const AABB: AABB;
declare namespace net.minecraft.world.level.levelgen.blockpredicates {
    interface BlockPredicate extends Internal.BiPredicate<Internal.WorldGenLevel, BlockPos> {
        hasSturdyFace(arg0: Internal.Direction_): this;
        matchesBlock(arg0: Internal.Block_, arg1: Vec3i_): this;
        matchesTag(arg0: Internal.TagKey_<Internal.Block_>, arg1: Vec3i_): this;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        anyOf(arg0: Internal.List_<net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_>): this;
        anyOf(arg0: net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_, arg1: net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_): this;
        negate(): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        matchesFluid(arg0: Internal.Fluid_, arg1: Vec3i_): this;
        solid(arg0: Vec3i_): this;
        insideWorld(arg0: Vec3i_): this;
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        matchesFluids(arg0: Internal.List_<Internal.Fluid_>, arg1: Vec3i_): this;
        matchesBlocks(arg0: Internal.List_<Internal.Block_>, arg1: Vec3i_): this;
        matchesTag(arg0: Internal.TagKey_<Internal.Block_>): this;
        solid(): this;
        alwaysTrue(): this;
        type(): Internal.BlockPredicateType<any>;
        allOf(...arg0: net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_[]): this;
        replaceable(): this;
        wouldSurvive(arg0: Internal.BlockState_, arg1: Vec3i_): this;
        not(arg0: net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_): this;
        allOf(arg0: Internal.List_<net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_>): this;
        allOf(arg0: net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_, arg1: net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_): this;
        anyOf(...arg0: net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_[]): this;
        replaceable(arg0: Vec3i_): this;
        hasSturdyFace(arg0: Vec3i_, arg1: Internal.Direction_): this;
        matchesBlocks(arg0: Internal.List_<Internal.Block_>): this;
        readonly static "CODEC": any;
        readonly static "ONLY_IN_AIR_PREDICATE": Internal.MatchingBlocksPredicate;
        readonly static "ONLY_IN_AIR_OR_WATER_PREDICATE": Internal.MatchingBlocksPredicate;
    }
    type BlockPredicate_ = BlockPredicate | (()=>Internal.BlockPredicateType_<any>);
}
declare namespace net.minecraft.util {
    class Unit extends Internal.Enum<net.minecraft.util.Unit> {
        static values(): net.minecraft.util.Unit[];
        static valueOf(arg0: string): net.minecraft.util.Unit;
        readonly static "INSTANCE": net.minecraft.util.Unit;
    }
    type Unit_ = "instance" | Unit;
}
declare namespace net.minecraft.world.level.pathfinder {
    class Path {
        constructor(arg0: Internal.List_<Internal.Node_>, arg1: BlockPos_, arg2: boolean)
        notStarted(): boolean;
        getEndNode(): Internal.Node;
        replaceNode(arg0: number, arg1: Internal.Node_): void;
        canReach(): boolean;
        getPreviousNode(): Internal.Node;
        getNode(arg0: number): Internal.Node;
        getNodePos(arg0: number): BlockPos;
        advance(): void;
        getNodeCount(): number;
        sameAs(arg0: net.minecraft.world.level.pathfinder.Path_): boolean;
        getOpenSet(): Internal.Node[];
        getTarget(): BlockPos;
        getDistToTarget(): number;
        truncateNodes(arg0: number): void;
        getNextEntityPos(arg0: Internal.Entity_): Vec3;
        getEntityPosAtNode(arg0: Internal.Entity_, arg1: number): Vec3;
        toString(): string;
        getNextNodeIndex(): number;
        isDone(): boolean;
        static createFromStream(arg0: Internal.FriendlyByteBuf_): net.minecraft.world.level.pathfinder.Path;
        getClosedSet(): Internal.Node[];
        writeToStream(arg0: Internal.FriendlyByteBuf_): void;
        getNextNode(): Internal.Node;
        setNextNodeIndex(arg0: number): void;
        getNextNodePos(): BlockPos;
        get endNode(): Internal.Node
        get previousNode(): Internal.Node
        get nodeCount(): number
        get openSet(): Internal.Node[]
        get target(): BlockPos
        get distToTarget(): number
        get nextNodeIndex(): number
        get done(): boolean
        get closedSet(): Internal.Node[]
        get nextNode(): Internal.Node
        set nextNodeIndex(arg0: number)
        get nextNodePos(): BlockPos
    }
    type Path_ = Path;
}
declare namespace dev.architectury.event {
    interface Event <T> {
        invoker(): T;
        unregister(arg0: T): void;
        register(arg0: T): void;
        isRegistered(arg0: T): boolean;
        clearListeners(): void;
    }
    type Event_<T> = Event<T>;
}
declare namespace org.slf4j {
    interface Marker extends Internal.Serializable {
        hasChildren(): boolean;
        hashCode(): number;
        remove(arg0: org.slf4j.Marker_): boolean;
        getName(): string;
        add(arg0: org.slf4j.Marker_): void;
        iterator(): Internal.Iterator<org.slf4j.Marker>;
        equals(arg0: any): boolean;
        hasReferences(): boolean;
        contains(arg0: org.slf4j.Marker_): boolean;
        contains(arg0: string): boolean;
        get name(): string
        readonly static "ANY_NON_NULL_MARKER": "+";
        readonly static "ANY_MARKER": "*";
    }
    type Marker_ = Marker;
}
declare namespace Internal {
    interface BaseMapCodec <K, V> {
        keyCodec(): Internal.Codec<K>;
        elementCodec(): Internal.Codec<V>;
        encode(arg0: Internal.Map_<K, V>, arg1: Internal.DynamicOps_<T>, arg2: Internal.RecordBuilder_<T>): Internal.RecordBuilder<T>;
        decode(arg0: Internal.DynamicOps_<T>, arg1: Internal.MapLike_<T>): Internal.DataResult<Internal.Map<K, V>>;
    }
    type BaseMapCodec_<K, V> = BaseMapCodec<K, V>;
    class ServerStatus$Players {
        constructor(arg0: number, arg1: number)
        setSample(arg0: Internal.GameProfile_[]): void;
        getSample(): Internal.GameProfile[];
        getMaxPlayers(): number;
        getNumPlayers(): number;
        set sample(arg0: Internal.GameProfile_[])
        get sample(): Internal.GameProfile[]
        get maxPlayers(): number
        get numPlayers(): number
    }
    type ServerStatus$Players_ = ServerStatus$Players;
    class SurfaceRules$Context {
    }
    type SurfaceRules$Context_ = SurfaceRules$Context;
    class Zombie extends Internal.Monster {
        constructor(arg0: Internal.Level_)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        isUnderWaterConverting(): boolean;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getMobType(): Internal.MobType;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setBaby(arg0: boolean): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        static getSpawnAsBabyOdds(arg0: Internal.Random_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        setCanBreakDoors(arg0: boolean): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        canBreakDoors(): boolean;
        killed(arg0: Internal.ServerLevel_, arg1: Internal.LivingEntity_): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMyRidingOffset(): number;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isBaby(): boolean;
        tick(): void;
        canHoldItem(arg0: Internal.ItemStack_): boolean;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        wantsToPickUp(arg0: Internal.ItemStack_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get underWaterConverting(): boolean
        get mobType(): Internal.MobType
        get stepHeight(): number
        set baby(arg0: boolean)
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        set canBreakDoors(arg0: boolean)
        get myRidingOffset(): number
        get baby(): boolean
        readonly static "ZOMBIE_LEADER_CHANCE": 0.05;
        readonly static "REINFORCEMENT_RANGE_MIN": 7;
        readonly static "REINFORCEMENT_RANGE_MAX": 40;
        readonly static "REINFORCEMENT_ATTEMPTS": 50;
    }
    type Zombie_ = Zombie;
    class RemoveOresProperties {
        constructor()
        "worldgenLayer": DecorationGenerationStep;
        "biomes": Internal.BiomeFilter;
        "blocks": BlockStatePredicate;
    }
    type RemoveOresProperties_ = RemoveOresProperties;
    interface Int2BooleanFunction extends Internal.IntPredicate, it.unimi.dsi.fastutil.Function<number, boolean> {
        composeReference(arg0: Internal.Reference2IntFunction_<any>): Internal.Reference2BooleanFunction<T>;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2BooleanFunction;
        getOrDefault(arg0: any, arg1: any): any;
        or(arg0: Internal.IntPredicate_): Internal.IntPredicate;
        negate(): Internal.IntPredicate;
        andThenReference(arg0: Internal.Boolean2ReferenceFunction_<any>): Internal.Int2ReferenceFunction<T>;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2BooleanFunction;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2BooleanFunction;
        containsKey(arg0: number): boolean;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Int2IntFunction;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Int2CharFunction;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2BooleanFunction;
        put(arg0: number, arg1: boolean): boolean;
        containsKey(arg0: any): boolean;
        apply(arg0: number): boolean;
        get(arg0: any): boolean;
        get(arg0: number): boolean;
        put(arg0: any, arg1: any): any;
        composeInt(arg0: Internal.Int2IntFunction_): this;
        defaultReturnValue(): boolean;
        andThenObject(arg0: Internal.Boolean2ObjectFunction_<any>): Internal.Int2ObjectFunction<T>;
        and(arg0: Internal.IntPredicate_): Internal.IntPredicate;
        remove(arg0: number): boolean;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Int2ShortFunction;
        getOrDefault(arg0: any, arg1: boolean): boolean;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        test(arg0: number): boolean;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, boolean>;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Int2DoubleFunction;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2BooleanFunction;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Int2LongFunction;
        size(): number;
        composeObject(arg0: Internal.Object2IntFunction_<any>): Internal.Object2BooleanFunction<T>;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Int2FloatFunction;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Int2ByteFunction;
        clear(): void;
        put(arg0: number, arg1: boolean): boolean;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2BooleanFunction;
        remove(arg0: any): any;
        getOrDefault(arg0: number, arg1: boolean): boolean;
        defaultReturnValue(arg0: boolean): void;
    }
    type Int2BooleanFunction_ = Int2BooleanFunction | ((arg0: number)=>boolean);
    interface ConstProperties {
        isConst(arg0: string): boolean;
        defineConst(arg0: string, arg1: Internal.Scriptable_): void;
        putConst(arg0: string, arg1: Internal.Scriptable_, arg2: any): void;
    }
    type ConstProperties_ = ConstProperties;
    interface CharSequence {
        compare(arg0: Internal.CharSequence_, arg1: Internal.CharSequence_): number;
        subSequence(arg0: number, arg1: number): this;
        toString(): string;
        chars(): Internal.IntStream;
        charAt(arg0: number): string;
        isEmpty(): boolean;
        length(): number;
        codePoints(): Internal.IntStream;
        get empty(): boolean
    }
    type CharSequence_ = CharSequence;
    class Enchantment$Rarity extends Internal.Enum<Internal.Enchantment$Rarity> {
        static values(): Internal.Enchantment$Rarity[];
        getWeight(): number;
        static valueOf(arg0: string): Internal.Enchantment$Rarity;
        get weight(): number
        readonly static "VERY_RARE": Internal.Enchantment$Rarity;
        readonly static "RARE": Internal.Enchantment$Rarity;
        readonly static "UNCOMMON": Internal.Enchantment$Rarity;
        readonly static "COMMON": Internal.Enchantment$Rarity;
    }
    type Enchantment$Rarity_ = "uncommon" | "rare" | "common" | "very_rare" | Enchantment$Rarity;
    abstract class BaseSpawner {
        constructor()
        broadcastEvent(arg0: Internal.Level_, arg1: BlockPos_, arg2: number): void;
        onEventTriggered(arg0: Internal.Level_, arg1: number): boolean;
        getOrCreateDisplayEntity(arg0: Internal.Level_): Internal.Entity;
        setEntityId(arg0: Internal.EntityType_<any>): void;
        load(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.CompoundTag_): void;
        save(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        getSpin(): number;
        serverTick(arg0: Internal.ServerLevel_, arg1: BlockPos_): void;
        getoSpin(): number;
        getSpawnerBlockEntity(): Internal.BlockEntity;
        setNextSpawnData(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.SpawnData_): void;
        getSpawnerEntity(): Internal.Entity;
        clientTick(arg0: Internal.Level_, arg1: BlockPos_): void;
        set entityId(arg0: Internal.EntityType_<any>)
        get spin(): number
        get oSpin(): number
        get spawnerBlockEntity(): Internal.BlockEntity
        get spawnerEntity(): Internal.Entity
    }
    type BaseSpawner_ = BaseSpawner;
    interface InjectedEntityTypeExtension extends Internal.InjectedRegistryEntryExtension<Internal.EntityType<any>> {
        arch$holder(): Internal.Holder<Internal.EntityType<any>>;
        arch$registryName(): ResourceLocation;
    }
    type InjectedEntityTypeExtension_ = InjectedEntityTypeExtension;
    class Markings extends Internal.Enum<Internal.Markings> {
        static byId(arg0: number): Internal.Markings;
        static values(): Internal.Markings[];
        getId(): number;
        static valueOf(arg0: string): Internal.Markings;
        get id(): number
        readonly static "BLACK_DOTS": Internal.Markings;
        readonly static "WHITE_FIELD": Internal.Markings;
        readonly static "NONE": Internal.Markings;
        readonly static "WHITE": Internal.Markings;
        readonly static "WHITE_DOTS": Internal.Markings;
    }
    type Markings_ = "white_field" | "white" | "black_dots" | Markings | "white_dots" | "none";
    interface ShortListIterator extends Internal.ListIterator<number>, Internal.ShortBidirectionalIterator {
        add(arg0: any): void;
        set(arg0: number): void;
        forEachRemaining(arg0: any): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): any;
        set(arg0: any): void;
        skip(arg0: number): number;
        forEachRemaining(arg0: Internal.IntConsumer_): void;
        forEachRemaining(arg0: Internal.ShortConsumer_): void;
        add(arg0: number): void;
        remove(): void;
        back(arg0: number): number;
        set(arg0: number): void;
        previous(): any;
        add(arg0: number): void;
    }
    type ShortListIterator_ = ShortListIterator;
    class ClientboundPlayerLookAtPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.EntityAnchorArgument$Anchor_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityAnchorArgument$Anchor_, arg1: Internal.Entity_, arg2: Internal.EntityAnchorArgument$Anchor_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getPosition(arg0: Internal.Level_): Vec3;
        isSkippable(): boolean;
        getFromAnchor(): Internal.EntityAnchorArgument$Anchor;
        get skippable(): boolean
        get fromAnchor(): Internal.EntityAnchorArgument$Anchor
    }
    type ClientboundPlayerLookAtPacket_ = ClientboundPlayerLookAtPacket;
    interface Shader {
        getFragmentProgram(): Internal.Program;
        markDirty(): void;
        attachToProgram(): void;
        getVertexProgram(): Internal.Program;
        getId(): number;
        get fragmentProgram(): Internal.Program
        get vertexProgram(): Internal.Program
        get id(): number
    }
    type Shader_ = Shader;
    class NormalNoise$NoiseParameters extends Internal.Record {
        constructor(arg0: number, arg1: Internal.DoubleList_)
        constructor(arg0: number, arg1: number, ...arg2: number[])
        constructor(arg0: number, arg1: Internal.List_<number>)
        hashCode(): number;
        toString(): string;
        amplitudes(): Internal.DoubleList;
        equals(arg0: any): boolean;
        firstOctave(): number;
        readonly static "DIRECT_CODEC": any;
        readonly static "CODEC": any;
    }
    type NormalNoise$NoiseParameters_ = Special.NormalNoise$NoiseParameters | NormalNoise$NoiseParameters;
    class DrawSelectionEvent$HighlightBlock extends Internal.DrawSelectionEvent {
        constructor()
        constructor(arg0: Internal.LevelRenderer_, arg1: Internal.Camera_, arg2: Internal.HitResult_, arg3: number, arg4: Internal.PoseStack_, arg5: Internal.MultiBufferSource_)
        getTarget(): Internal.HitResult;
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get target(): Internal.HitResult
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type DrawSelectionEvent$HighlightBlock_ = DrawSelectionEvent$HighlightBlock;
    class Currency implements Internal.Serializable {
        static getInstance(arg0: string): Internal.Currency;
        getSymbol(arg0: Internal.Locale_): string;
        toString(): string;
        getNumericCode(): number;
        getNumericCodeAsString(): string;
        getDisplayName(): string;
        static getAvailableCurrencies(): Internal.Set<Internal.Currency>;
        getDisplayName(arg0: Internal.Locale_): string;
        getSymbol(): string;
        getDefaultFractionDigits(): number;
        getCurrencyCode(): string;
        static getInstance(arg0: Internal.Locale_): Internal.Currency;
        get numericCode(): number
        get numericCodeAsString(): string
        get displayName(): string
        get availableCurrencies(): Internal.Set<Internal.Currency>
        get symbol(): string
        get defaultFractionDigits(): number
        get currencyCode(): string
    }
    type Currency_ = Currency;
    class ClientboundSetActionBarTextPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.Component_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getText(): Internal.Component;
        isSkippable(): boolean;
        get text(): Internal.Component
        get skippable(): boolean
    }
    type ClientboundSetActionBarTextPacket_ = ClientboundSetActionBarTextPacket;
    class LinkedHashMap <K, V> extends Internal.HashMap<K, V> implements Internal.Map<K, V> {
        constructor()
        constructor(arg0: number)
        constructor(arg0: number, arg1: number, arg2: boolean)
        constructor(arg0: Internal.Map_<any, any>)
        constructor(arg0: number, arg1: number)
        replace(arg0: K, arg1: V): V;
        keySet(): Internal.Set<K>;
        putIfAbsent(arg0: K, arg1: V): V;
        values(): Internal.Collection<V>;
        containsValue(arg0: any): boolean;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        getOrDefault(arg0: any, arg1: V): V;
        remove(arg0: any, arg1: any): boolean;
        computeIfAbsent(arg0: K, arg1: Internal.Function_<any, any>): V;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        replaceAll(arg0: Internal.BiFunction_<any, any, any>): void;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        clear(): void;
        get(arg0: any): V;
        compute(arg0: K, arg1: Internal.BiFunction_<any, any, any>): V;
        merge(arg0: K, arg1: V, arg2: Internal.BiFunction_<any, any, any>): V;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<any, any, any>): V;
    }
    type LinkedHashMap_<K, V> = LinkedHashMap<K, V>;
    interface InterruptibleChannel extends Internal.Channel {
        close(): void;
    }
    type InterruptibleChannel_ = InterruptibleChannel;
    class DummySensor extends Internal.Sensor<Internal.LivingEntity> {
        constructor()
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
    }
    type DummySensor_ = DummySensor;
    class ServerData {
        constructor(arg0: string, arg1: string, arg2: boolean)
        isLan(): boolean;
        setResourcePackStatus(arg0: Internal.ServerData$ServerPackStatus_): void;
        write(): Internal.CompoundTag;
        getIconB64(): string;
        static read(arg0: Internal.CompoundTag_): Internal.ServerData;
        setIconB64(arg0: string): void;
        copyFrom(arg0: Internal.ServerData_): void;
        getResourcePackStatus(): Internal.ServerData$ServerPackStatus;
        get lan(): boolean
        set resourcePackStatus(arg0: Internal.ServerData$ServerPackStatus_)
        get iconB64(): string
        set iconB64(arg0: string)
        get resourcePackStatus(): Internal.ServerData$ServerPackStatus
        "name": string;
        "playerList": Internal.List<Internal.Component>;
        "ip": string;
        "ping": number;
        "motd": Internal.Component;
        "pinged": boolean;
        "forgeData": Internal.ExtendedServerListData;
        "version": Internal.Component;
        "status": Internal.Component;
        "protocol": number;
    }
    type ServerData_ = ServerData;
    class FoodProperties {
        getSaturationModifier(): number;
        getEffects(): Internal.List<com.mojang.datafixers.util.Pair<Internal.MobEffectInstance, number>>;
        getNutrition(): number;
        isMeat(): boolean;
        isFastFood(): boolean;
        canAlwaysEat(): boolean;
        get saturationModifier(): number
        get effects(): Internal.List<com.mojang.datafixers.util.Pair<Internal.MobEffectInstance, number>>
        get nutrition(): number
        get meat(): boolean
        get fastFood(): boolean
    }
    type FoodProperties_ = FoodProperties;
    class NoiseEffect extends Internal.Enum<Internal.NoiseEffect> {
        static valueOf(arg0: string): Internal.NoiseEffect;
        static values(): Internal.NoiseEffect[];
        readonly static "NONE": Internal.NoiseEffect;
        readonly static "BEARD": Internal.NoiseEffect;
        readonly static "BURY": Internal.NoiseEffect;
    }
    type NoiseEffect_ = "bury" | NoiseEffect | "none" | "beard";
    class ClientWrapper {
        constructor()
        setCurrentScreen(gui: Internal.Screen_): void;
        setTitle(t: string): void;
        getMinecraft(): Internal.Minecraft;
        getCurrentWorldName(): string;
        getLanguage(): Internal.Language;
        getCurrentScreen(): Internal.Screen;
        getLevel(): Internal.ClientLevelJS;
        isKeyDown(key: number): boolean;
        getPlayer(): Internal.ClientPlayerJS;
        set currentScreen(gui: Internal.Screen_)
        set title(t: string)
        get minecraft(): Internal.Minecraft
        get currentWorldName(): string
        get language(): Internal.Language
        get currentScreen(): Internal.Screen
        get level(): Internal.ClientLevelJS
        get player(): Internal.ClientPlayerJS
    }
    type ClientWrapper_ = ClientWrapper;
    interface ToIntFunction <T> {
        applyAsInt(arg0: T): number;
    }
    type ToIntFunction_<T> = ToIntFunction<T> | ((arg0: T)=>number);
    class Holder$Kind extends Internal.Enum<Internal.Holder$Kind> {
        static values(): Internal.Holder$Kind[];
        static valueOf(arg0: string): Internal.Holder$Kind;
        readonly static "DIRECT": Internal.Holder$Kind;
        readonly static "REFERENCE": Internal.Holder$Kind;
    }
    type Holder$Kind_ = "reference" | Holder$Kind | "direct";
    class BlendMode {
        constructor()
        constructor(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number)
        constructor(arg0: number, arg1: number, arg2: number)
        hashCode(): number;
        isOpaque(): boolean;
        static stringToBlendFactor(arg0: string): number;
        equals(arg0: any): boolean;
        static stringToBlendFunc(arg0: string): number;
        apply(): void;
        get opaque(): boolean
    }
    type BlendMode_ = BlendMode;
    class Module implements Internal.AnnotatedElement {
        isNamed(): boolean;
        addOpens(arg0: string, arg1: Internal.Module_): this;
        getDeclaredAnnotationsByType(arg0: Internal.Class_<T>): T[];
        isOpen(arg0: string, arg1: Internal.Module_): boolean;
        addReads(arg0: Internal.Module_): this;
        isExported(arg0: string): boolean;
        getName(): string;
        addUses(arg0: Internal.Class_<any>): this;
        getClassLoader(): Internal.ClassLoader;
        getDeclaredAnnotations(): Internal.Annotation[];
        getResourceAsStream(arg0: string): Internal.InputStream;
        getAnnotationsByType(arg0: Internal.Class_<T>): T[];
        getDeclaredAnnotation(arg0: Internal.Class_<T>): T;
        toString(): string;
        getAnnotation(arg0: Internal.Class_<T>): T;
        isExported(arg0: string, arg1: Internal.Module_): boolean;
        getLayer(): Internal.ModuleLayer;
        isOpen(arg0: string): boolean;
        addExports(arg0: string, arg1: Internal.Module_): this;
        getPackages(): Internal.Set<string>;
        canRead(arg0: Internal.Module_): boolean;
        getAnnotations(): Internal.Annotation[];
        isAnnotationPresent(arg0: Internal.Class_<any>): boolean;
        getDescriptor(): Internal.ModuleDescriptor;
        canUse(arg0: Internal.Class_<any>): boolean;
        get named(): boolean
        get name(): string
        get classLoader(): Internal.ClassLoader
        get declaredAnnotations(): Internal.Annotation[]
        get layer(): Internal.ModuleLayer
        get packages(): Internal.Set<string>
        get annotations(): Internal.Annotation[]
        get descriptor(): Internal.ModuleDescriptor
    }
    type Module_ = Module;
    class OceanRuinConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.OceanRuinFeature$Type_, arg1: number, arg2: number)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "biomeTemp": Internal.OceanRuinFeature$Type;
        readonly "clusterProbability": number;
        readonly static "CODEC": any;
        readonly "largeProbability": number;
    }
    type OceanRuinConfiguration_ = OceanRuinConfiguration;
    class LakeFeature$Configuration extends Internal.Record implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.BlockStateProvider_, arg1: Internal.BlockStateProvider_)
        hashCode(): number;
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        toString(): string;
        barrier(): Internal.BlockStateProvider;
        fluid(): Internal.BlockStateProvider;
        equals(arg0: any): boolean;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
    }
    type LakeFeature$Configuration_ = LakeFeature$Configuration;
    abstract class RandomizableContainerBlockEntity extends Internal.BaseContainerBlockEntity {
        setLootTable(arg0: ResourceLocation_, arg1: number): void;
        stopOpen(arg0: Internal.Player_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        countItem(arg0: Internal.Item_): number;
        static setLootTable(arg0: Internal.BlockGetter_, arg1: Internal.Random_, arg2: BlockPos_, arg3: ResourceLocation_): void;
        isEmpty(): boolean;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        createMenu(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Player_): Internal.AbstractContainerMenu;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        removeItem(arg0: number, arg1: number): Internal.ItemStack;
        onLoad(): void;
        setItem(arg0: number, arg1: Internal.ItemStack_): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMaxStackSize(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        removeItemNoUpdate(arg0: number): Internal.ItemStack;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        stillValid(arg0: Internal.Player_): boolean;
        unpackLootTable(arg0: Internal.Player_): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getItem(arg0: number): Internal.ItemStack;
        canOpen(arg0: Internal.Player_): boolean;
        clearContent(): void;
        getRenderBoundingBox(): Internal.AABB;
        get empty(): boolean
        get modelData(): Internal.IModelData
        get maxStackSize(): number
        get renderBoundingBox(): Internal.AABB
        readonly static "LOOT_TABLE_SEED_TAG": "LootTableSeed";
        readonly static "LOOT_TABLE_TAG": "LootTable";
    }
    type RandomizableContainerBlockEntity_ = RandomizableContainerBlockEntity;
    class RegistryEvent$IdMappingEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.Map_<ResourceLocation_, Internal.Map_<ResourceLocation_, number[]>>, arg1: boolean)
        getRegistries(): Internal.ImmutableSet<ResourceLocation>;
        getRemaps(arg0: ResourceLocation_): Internal.ImmutableList<Internal.RegistryEvent$IdMappingEvent$ModRemapping>;
        getListenerList(): Internal.ListenerList;
        get registries(): Internal.ImmutableSet<ResourceLocation>
        get listenerList(): Internal.ListenerList
        readonly "isFrozen": boolean;
    }
    type RegistryEvent$IdMappingEvent_ = RegistryEvent$IdMappingEvent;
    class BellBlockEntity extends Internal.BlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        static serverTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BellBlockEntity_): void;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        triggerEvent(arg0: number, arg1: number): boolean;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        serializeNBT(): Internal.CompoundTag;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        static clientTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BellBlockEntity_): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        onHit(arg0: Internal.Direction_): void;
        get modelData(): Internal.IModelData
        get renderBoundingBox(): Internal.AABB
        "shaking": boolean;
        "clickDirection": Internal.Direction;
        "ticks": number;
    }
    type BellBlockEntity_ = BellBlockEntity;
    interface ByteBufAllocator {
        compositeDirectBuffer(arg0: number): Internal.CompositeByteBuf;
        directBuffer(arg0: number, arg1: number): Internal.ByteBuf;
        buffer(): Internal.ByteBuf;
        compositeHeapBuffer(arg0: number): Internal.CompositeByteBuf;
        heapBuffer(arg0: number, arg1: number): Internal.ByteBuf;
        compositeDirectBuffer(): Internal.CompositeByteBuf;
        compositeBuffer(): Internal.CompositeByteBuf;
        ioBuffer(): Internal.ByteBuf;
        heapBuffer(): Internal.ByteBuf;
        heapBuffer(arg0: number): Internal.ByteBuf;
        ioBuffer(arg0: number): Internal.ByteBuf;
        compositeBuffer(arg0: number): Internal.CompositeByteBuf;
        directBuffer(): Internal.ByteBuf;
        isDirectBufferPooled(): boolean;
        directBuffer(arg0: number): Internal.ByteBuf;
        calculateNewCapacity(arg0: number, arg1: number): number;
        ioBuffer(arg0: number, arg1: number): Internal.ByteBuf;
        buffer(arg0: number, arg1: number): Internal.ByteBuf;
        compositeHeapBuffer(): Internal.CompositeByteBuf;
        buffer(arg0: number): Internal.ByteBuf;
        get directBufferPooled(): boolean
        readonly static "DEFAULT": any;
    }
    type ByteBufAllocator_ = ByteBufAllocator;
    class Item$Properties {
        constructor()
        rarity(arg0: Rarity_): this;
        durability(arg0: number): this;
        setNoRepair(): this;
        fireResistant(): this;
        craftRemainder(arg0: Internal.Item_): this;
        food(arg0: Internal.FoodProperties_): this;
        defaultDurability(arg0: number): this;
        tab(arg0: Internal.CreativeModeTab_): this;
        stacksTo(arg0: number): this;
    }
    type Item$Properties_ = Item$Properties;
    class BiomeSource$StepFeatureData extends Internal.Record {
        constructor(arg0: Internal.List_<Internal.PlacedFeature_>, arg1: Internal.ToIntFunction_<Internal.PlacedFeature_>)
        hashCode(): number;
        toString(): string;
        equals(arg0: any): boolean;
        features(): Internal.List<Internal.PlacedFeature>;
        indexMapping(): Internal.ToIntFunction<Internal.PlacedFeature>;
    }
    type BiomeSource$StepFeatureData_ = BiomeSource$StepFeatureData;
    interface AsynchronousChannel extends Internal.Channel {
        close(): void;
    }
    type AsynchronousChannel_ = AsynchronousChannel;
    class Villager extends Internal.AbstractVillager implements Internal.VillagerDataHolder, Internal.ReputationEventHandler {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_, arg2: Internal.VillagerType_)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        setGossips(arg0: Internal.Tag_): void;
        setTradingPlayer(arg0: Internal.Player_): void;
        getVillagerData(): Internal.VillagerData;
        restock(): void;
        hasExcessFood(): boolean;
        refreshBrain(arg0: Internal.ServerLevel_): void;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): this;
        getGossips(): Internal.GossipContainer;
        getStepHeight(): number;
        hasFarmSeeds(): boolean;
        getPlayerReputation(arg0: Internal.Player_): number;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        wantsMoreFood(): boolean;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        startSleeping(arg0: BlockPos_): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getBrain(): Internal.Brain<Internal.Villager>;
        isClientSide(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setChasing(arg0: boolean): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        openTradingScreen(arg0: Internal.Player_, arg1: Internal.Component_, arg2: number): void;
        tick(): void;
        alwaysAccepts(): boolean;
        die(arg0: Internal.DamageSource_): void;
        setOffers(arg0: Internal.MerchantOffers_): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        eatAndDigestFood(): void;
        setVillagerData(arg0: Internal.VillagerData_): void;
        thunderHit(arg0: Internal.ServerLevel_, arg1: Internal.LightningBolt_): void;
        setLastHurtByMob(arg0: Internal.LivingEntity_): void;
        setVillagerXp(arg0: number): void;
        shouldRestock(): boolean;
        asKJS(): Internal.EntityJS;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        onReputationEventFrom(arg0: Internal.ReputationEventType_, arg1: Internal.Entity_): void;
        wantsToSpawnGolem(arg0: number): boolean;
        serializeNBT(): Internal.Tag;
        isChasing(): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getVillagerXp(): number;
        handleEntityEvent(arg0: number): void;
        canBreed(): boolean;
        playWorkSound(): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        spawnGolemIfNeeded(arg0: Internal.ServerLevel_, arg1: number, arg2: number): void;
        canRestock(): boolean;
        assignProfessionWhenSpawned(): boolean;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        wantsToPickUp(arg0: Internal.ItemStack_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        releasePoi(arg0: Internal.MemoryModuleType_<Internal.GlobalPos_>): void;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getClassification(arg0: boolean): Internal.MobCategory;
        removeWhenFarAway(arg0: number): boolean;
        gossip(arg0: Internal.ServerLevel_, arg1: Internal.Villager_, arg2: number): void;
        stopSleeping(): void;
        set gossips(arg0: Internal.Tag_)
        set tradingPlayer(arg0: Internal.Player_)
        get villagerData(): Internal.VillagerData
        get gossips(): Internal.GossipContainer
        get stepHeight(): number
        get brain(): Internal.Brain<Internal.Villager>
        get clientSide(): boolean
        set chasing(arg0: boolean)
        set offers(arg0: Internal.MerchantOffers_)
        set villagerData(arg0: Internal.VillagerData_)
        set lastHurtByMob(arg0: Internal.LivingEntity_)
        set villagerXp(arg0: number)
        get multipartEntity(): boolean
        get chasing(): boolean
        get parts(): Internal.PartEntity<any>[]
        get villagerXp(): number
        readonly static "FOOD_POINTS": {[key: Internal.Item]: 4, [key: any]: 1, [key: any]: 1, [key: Internal.Item]: 1};
        readonly static "SPEED_MODIFIER": 0.5;
        readonly static "BREEDING_FOOD_THRESHOLD": 12;
        readonly static "POI_MEMORIES": {[key: Internal.MemoryModuleType<any>]: any, [key: Internal.MemoryModuleType<any>]: any, [key: Internal.MemoryModuleType<any>]: any, [key: Internal.MemoryModuleType<any>]: any};
    }
    type Villager_ = Villager;
    interface Float2IntFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleToIntFunction {
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Float2ShortFunction;
        composeFloat(arg0: Internal.Float2FloatFunction_): this;
        andThenReference(arg0: Internal.Int2ReferenceFunction_<any>): Internal.Float2ReferenceFunction<T>;
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        defaultReturnValue(): number;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2IntFunction;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2IntFunction;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Float2ByteFunction;
        put(arg0: number, arg1: number): number;
        containsKey(arg0: any): boolean;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2IntFunction;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Float2LongFunction;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Float2FloatFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        put(arg0: any, arg1: any): any;
        containsKey(arg0: number): boolean;
        put(arg0: number, arg1: number): number;
        composeObject(arg0: Internal.Object2FloatFunction_<any>): Internal.Object2IntFunction<T>;
        getOrDefault(arg0: number, arg1: number): number;
        composeReference(arg0: Internal.Reference2FloatFunction_<any>): Internal.Reference2IntFunction<T>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Float2CharFunction;
        getOrDefault(arg0: any, arg1: number): number;
        andThenInt(arg0: Internal.Int2IntFunction_): this;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2IntFunction;
        andThenObject(arg0: Internal.Int2ObjectFunction_<any>): Internal.Float2ObjectFunction<T>;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Float2DoubleFunction;
        apply(arg0: number): number;
        size(): number;
        defaultReturnValue(arg0: number): void;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2IntFunction;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2IntFunction;
        clear(): void;
        remove(arg0: any): any;
        get(arg0: number): number;
        remove(arg0: number): number;
        applyAsInt(arg0: number): number;
    }
    type Float2IntFunction_ = ((arg0: number)=>number) | Float2IntFunction;
    class TemptingSensor extends Internal.Sensor<Internal.PathfinderMob> {
        constructor(arg0: Internal.Ingredient_)
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
        readonly static "TEMPTATION_RANGE": 10;
    }
    type TemptingSensor_ = TemptingSensor;
    interface DSL$TypeReference {
        in(arg0: Internal.Schema_): Internal.TypeTemplate;
        typeName(): string;
    }
    type DSL$TypeReference_ = DSL$TypeReference;
    class ScreenEvent$DrawScreenEvent extends Internal.ScreenEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: Internal.PoseStack_, arg2: number, arg3: number, arg4: number)
        getPoseStack(): Internal.PoseStack;
        getListenerList(): Internal.ListenerList;
        getPartialTicks(): number;
        getMouseY(): number;
        getMouseX(): number;
        get poseStack(): Internal.PoseStack
        get listenerList(): Internal.ListenerList
        get partialTicks(): number
        get mouseY(): number
        get mouseX(): number
    }
    type ScreenEvent$DrawScreenEvent_ = ScreenEvent$DrawScreenEvent;
    class PlayerSocialManager {
        constructor(arg0: Internal.Minecraft_, arg1: any_)
        addPlayer(arg0: Internal.PlayerInfo_): void;
        isBlocked(arg0: Internal.UUID_): boolean;
        isHidden(arg0: Internal.UUID_): boolean;
        startOnlineMode(): void;
        removePlayer(arg0: Internal.UUID_): void;
        stopOnlineMode(): void;
        shouldHideMessageFrom(arg0: Internal.UUID_): boolean;
        getDiscoveredUUID(arg0: string): Internal.UUID;
        getHiddenPlayers(): Internal.Set<Internal.UUID>;
        showPlayer(arg0: Internal.UUID_): void;
        hidePlayer(arg0: Internal.UUID_): void;
        get hiddenPlayers(): Internal.Set<Internal.UUID>
    }
    type PlayerSocialManager_ = PlayerSocialManager;
    class ServerScoreboard$Method extends Internal.Enum<Internal.ServerScoreboard$Method> {
        static valueOf(arg0: string): Internal.ServerScoreboard$Method;
        static values(): Internal.ServerScoreboard$Method[];
        readonly static "REMOVE": Internal.ServerScoreboard$Method;
        readonly static "CHANGE": Internal.ServerScoreboard$Method;
    }
    type ServerScoreboard$Method_ = "remove" | "change" | ServerScoreboard$Method;
    interface CriterionTriggerInstance {
        serializeToJson(arg0: Internal.SerializationContext_): Internal.JsonObject;
        getCriterion(): ResourceLocation;
        get criterion(): ResourceLocation
    }
    type CriterionTriggerInstance_ = CriterionTriggerInstance;
    class Fox$Type extends Internal.Enum<Internal.Fox$Type> {
        static byName(arg0: string): Internal.Fox$Type;
        static byId(arg0: number): Internal.Fox$Type;
        static byBiome(arg0: Internal.Holder_<Internal.Biome_>): Internal.Fox$Type;
        static values(): Internal.Fox$Type[];
        getName(): string;
        static valueOf(arg0: string): Internal.Fox$Type;
        getId(): number;
        get name(): string
        get id(): number
        readonly static "RED": Internal.Fox$Type;
        readonly static "SNOW": Internal.Fox$Type;
    }
    type Fox$Type_ = "snow" | Fox$Type | "red";
    interface FloatPredicate extends Internal.DoublePredicate, Internal.Predicate<number> {
        test(arg0: any): boolean;
        test(arg0: number): boolean;
        or(arg0: Internal.DoublePredicate_): this;
        test(arg0: number): boolean;
        and(arg0: Internal.DoublePredicate_): Internal.DoublePredicate;
        or(arg0: Internal.FloatPredicate_): this;
        test(arg0: number): boolean;
        and(arg0: Internal.Predicate_<any>): Internal.Predicate<number>;
        and(arg0: Internal.FloatPredicate_): this;
        or(arg0: Internal.Predicate_<any>): Internal.Predicate<number>;
        negate(): Internal.DoublePredicate;
    }
    type FloatPredicate_ = FloatPredicate | ((arg0: number)=>boolean);
    class ModuleDescriptor$Exports implements Internal.Comparable<Internal.ModuleDescriptor$Exports> {
        hashCode(): number;
        isQualified(): boolean;
        toString(): string;
        targets(): Internal.Set<string>;
        source(): string;
        compareTo(arg0: Internal.ModuleDescriptor$Exports_): number;
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Exports$Modifier>;
        equals(arg0: any): boolean;
        compareTo(arg0: any): number;
        get qualified(): boolean
    }
    type ModuleDescriptor$Exports_ = ModuleDescriptor$Exports;
    class UnitContext {
        constructor()
        pushDebug(): void;
        debugInfo(s: string, values: Internal.Collection_<any>): void;
        sub(): this;
        popDebug(): void;
        addConstant(s: string, u: Internal.Unit_): void;
        parse(input: string): Internal.Unit;
        getFunctionFactory(name: string): Internal.FunctionFactory;
        debugInfo(s: string): void;
        createStream(input: string): Internal.UnitTokenStream;
        addFunction(factory: Internal.FunctionFactory_): void;
        isDebug(): boolean;
        get debug(): boolean
        readonly static "DEFAULT": Internal.UnitContext;
        readonly "constants": Internal.Map<string, Internal.Unit>;
    }
    type UnitContext_ = UnitContext;
    class Llama extends Internal.AbstractChestedHorse implements Internal.RangedAttackMob {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        isWearingArmor(): boolean;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        canMate(arg0: Internal.Animal_): boolean;
        getStepHeight(): number;
        setVariant(arg0: number): void;
        getSwag(): Internal.DyeColor;
        asKJS(): Internal.EntityJS;
        performRangedAttack(arg0: Internal.LivingEntity_, arg1: number): void;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): this;
        getVariant(): number;
        isFood(arg0: Internal.ItemStack_): boolean;
        leaveCaravan(): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        makeMad(): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getCaravanHead(): this;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        isTraderLlama(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        isArmor(arg0: Internal.ItemStack_): boolean;
        joinCaravan(arg0: Internal.Llama_): void;
        hasCaravanTail(): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        getInventoryColumns(): number;
        canBeControlledByRider(): boolean;
        canWearArmor(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getMaxTemper(): number;
        getPassengersRidingOffset(): number;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        positionRider(arg0: Internal.Entity_): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getStrength(): number;
        getLeashOffset(): Vec3;
        getClassification(arg0: boolean): Internal.MobCategory;
        containerChanged(arg0: Internal.Container_): void;
        inCaravan(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        isSaddleable(): boolean;
        canEatGrass(): boolean;
        get wearingArmor(): boolean
        get stepHeight(): number
        set variant(arg0: number)
        get swag(): Internal.DyeColor
        get variant(): number
        get multipartEntity(): boolean
        get caravanHead(): Internal.Llama
        get parts(): Internal.PartEntity<any>[]
        get traderLlama(): boolean
        get inventoryColumns(): number
        get maxTemper(): number
        get passengersRidingOffset(): number
        get strength(): number
        get leashOffset(): Vec3
        get saddleable(): boolean
    }
    type Llama_ = Llama;
    class ItemRightClickEventJS extends Internal.PlayerEventJS {
        constructor(player: Internal.Player_, hand: Hand_)
        getEntity(): Internal.EntityJS;
        canCancel(): boolean;
        getHand(): Hand;
        getItem(): Internal.ItemStackJS;
        get entity(): Internal.EntityJS
        get hand(): Hand
        get item(): Internal.ItemStackJS
    }
    type ItemRightClickEventJS_ = ItemRightClickEventJS;
    interface TickingBlockEntity {
        getPos(): BlockPos;
        isRemoved(): boolean;
        getType(): string;
        tick(): void;
        get pos(): BlockPos
        get removed(): boolean
        get type(): string
    }
    type TickingBlockEntity_ = TickingBlockEntity;
    abstract class RenderTooltipEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.ItemStack_, arg1: Internal.PoseStack_, arg2: number, arg3: number, arg4: Internal.Font_, arg5: Internal.List_<Internal.ClientTooltipComponent_>)
        getPoseStack(): Internal.PoseStack;
        getFont(): Internal.Font;
        getX(): number;
        getY(): number;
        getListenerList(): Internal.ListenerList;
        getComponents(): Internal.List<Internal.ClientTooltipComponent>;
        getItemStack(): Internal.ItemStack;
        get poseStack(): Internal.PoseStack
        get font(): Internal.Font
        get x(): number
        get y(): number
        get listenerList(): Internal.ListenerList
        get components(): Internal.List<Internal.ClientTooltipComponent>
        get itemStack(): Internal.ItemStack
    }
    type RenderTooltipEvent_ = RenderTooltipEvent;
    interface SurfaceRules$ConditionSource extends Internal.Function<Internal.SurfaceRules$Context, Internal.SurfaceRules$Condition> {
        bootstrap(arg0: Internal.Registry_<Internal.Codec_<any>>): Internal.Codec<any>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<Internal.SurfaceRules$Context, V>;
        codec(): Internal.Codec<any>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, Internal.SurfaceRules$Condition>;
        readonly static "CODEC": any;
    }
    type SurfaceRules$ConditionSource_ = (()=>Internal.Codec_<any>) | SurfaceRules$ConditionSource;
    class DisplayInfo {
        constructor(arg0: Internal.ItemStack_, arg1: Internal.Component_, arg2: Internal.Component_, arg3: ResourceLocation_, arg4: Internal.FrameType_, arg5: boolean, arg6: boolean, arg7: boolean)
        setLocation(arg0: number, arg1: number): void;
        getX(): number;
        serializeToJson(): Internal.JsonElement;
        getY(): number;
        static fromNetwork(arg0: Internal.FriendlyByteBuf_): Internal.DisplayInfo;
        isHidden(): boolean;
        getIcon(): Internal.ItemStack;
        shouldShowToast(): boolean;
        getBackground(): ResourceLocation;
        getFrame(): Internal.FrameType;
        getTitle(): Internal.Component;
        static fromJson(arg0: Internal.JsonObject_): Internal.DisplayInfo;
        shouldAnnounceChat(): boolean;
        serializeToNetwork(arg0: Internal.FriendlyByteBuf_): void;
        getDescription(): Internal.Component;
        get x(): number
        get y(): number
        get hidden(): boolean
        get icon(): Internal.ItemStack
        get background(): ResourceLocation
        get frame(): Internal.FrameType
        get title(): Internal.Component
        get description(): Internal.Component
    }
    type DisplayInfo_ = DisplayInfo;
    interface Pointer {
        address(): number;
        readonly static "CLONG_SIZE": 4;
        readonly static "POINTER_SHIFT": 3;
        readonly static "CLONG_SHIFT": 2;
        readonly static "BITS64": true;
        readonly static "BITS32": false;
        readonly static "POINTER_SIZE": 8;
    }
    type Pointer_ = Pointer;
    class OctahedralGroup extends Internal.Enum<Internal.OctahedralGroup> implements Internal.StringRepresentable {
        inverse(): this;
        rotate(arg0: Internal.Direction_): Internal.Direction;
        static valueOf(arg0: string): Internal.OctahedralGroup;
        toString(): string;
        inverts(arg0: Internal.Direction$Axis_): boolean;
        getSerializedName(): string;
        static values(): Internal.OctahedralGroup[];
        rotate(arg0: Internal.FrontAndTop_): Internal.FrontAndTop;
        compose(arg0: Internal.OctahedralGroup_): this;
        transformation(): Internal.Matrix3f;
        get serializedName(): string
        readonly static "ROT_180_EDGE_XY_NEG": Internal.OctahedralGroup;
        readonly static "ROT_180_EDGE_YZ_POS": Internal.OctahedralGroup;
        readonly static "SWAP_XZ": Internal.OctahedralGroup;
        readonly static "ROT_90_REF_Y_NEG": Internal.OctahedralGroup;
        readonly static "INVERT_Z": Internal.OctahedralGroup;
        readonly static "SWAP_YZ": Internal.OctahedralGroup;
        readonly static "INVERT_X": Internal.OctahedralGroup;
        readonly static "ROT_180_EDGE_XY_POS": Internal.OctahedralGroup;
        readonly static "ROT_180_EDGE_YZ_NEG": Internal.OctahedralGroup;
        readonly static "ROT_90_Z_POS": Internal.OctahedralGroup;
        readonly static "SWAP_NEG_YZ": Internal.OctahedralGroup;
        readonly static "ROT_180_FACE_XY": Internal.OctahedralGroup;
        readonly static "SWAP_NEG_XZ": Internal.OctahedralGroup;
        readonly static "ROT_90_Z_NEG": Internal.OctahedralGroup;
        readonly static "ROT_60_REF_PNN": Internal.OctahedralGroup;
        readonly static "ROT_60_REF_PPP": Internal.OctahedralGroup;
        readonly static "ROT_60_REF_PNP": Internal.OctahedralGroup;
        readonly static "ROT_60_REF_NNP": Internal.OctahedralGroup;
        readonly static "ROT_60_REF_NNN": Internal.OctahedralGroup;
        readonly static "ROT_60_REF_NPP": Internal.OctahedralGroup;
        readonly static "ROT_60_REF_PPN": Internal.OctahedralGroup;
        readonly static "ROT_90_REF_Y_POS": Internal.OctahedralGroup;
        readonly static "ROT_60_REF_NPN": Internal.OctahedralGroup;
        readonly static "ROT_90_X_NEG": Internal.OctahedralGroup;
        readonly static "ROT_120_PNP": Internal.OctahedralGroup;
        readonly static "INVERT_Y": Internal.OctahedralGroup;
        readonly static "ROT_180_EDGE_XZ_POS": Internal.OctahedralGroup;
        readonly static "SWAP_XY": Internal.OctahedralGroup;
        readonly static "ROT_120_NPN": Internal.OctahedralGroup;
        readonly static "ROT_90_REF_Z_POS": Internal.OctahedralGroup;
        readonly static "ROT_120_NNP": Internal.OctahedralGroup;
        readonly static "ROT_90_REF_X_POS": Internal.OctahedralGroup;
        readonly static "ROT_120_PPN": Internal.OctahedralGroup;
        readonly static "ROT_120_NNN": Internal.OctahedralGroup;
        readonly static "ROT_120_NPP": Internal.OctahedralGroup;
        readonly static "ROT_90_X_POS": Internal.OctahedralGroup;
        readonly static "ROT_120_PNN": Internal.OctahedralGroup;
        readonly static "ROT_120_PPP": Internal.OctahedralGroup;
        readonly static "ROT_90_REF_X_NEG": Internal.OctahedralGroup;
        readonly static "IDENTITY": Internal.OctahedralGroup;
        readonly static "SWAP_NEG_XY": Internal.OctahedralGroup;
        readonly static "ROT_180_FACE_YZ": Internal.OctahedralGroup;
        readonly static "ROT_180_FACE_XZ": Internal.OctahedralGroup;
        readonly static "ROT_180_EDGE_XZ_NEG": Internal.OctahedralGroup;
        readonly static "ROT_90_REF_Z_NEG": Internal.OctahedralGroup;
        readonly static "ROT_90_Y_NEG": Internal.OctahedralGroup;
        readonly static "ROT_90_Y_POS": Internal.OctahedralGroup;
        readonly static "INVERSION": Internal.OctahedralGroup;
    }
    type OctahedralGroup_ = "inversion" | "rot_180_face_xz" | "invert_z" | "rot_180_edge_xy_pos" | "rot_120_pnp" | "rot_120_ppp" | "rot_120_nnn" | "rot_120_npn" | "rot_90_ref_z_neg" | "rot_180_edge_xz_pos" | "swap_xy" | "rot_90_x_neg" | "swap_neg_yz" | "identity" | "rot_90_z_neg" | "rot_90_ref_z_pos" | "rot_60_ref_ppn" | "rot_60_ref_npp" | "rot_60_ref_pnn" | "rot_60_ref_nnp" | "rot_180_edge_yz_pos" | "swap_yz" | "rot_90_y_pos" | "rot_90_ref_y_neg" | "rot_90_ref_y_pos" | "rot_90_x_pos" | "rot_180_face_yz" | "rot_180_edge_xy_neg" | "rot_120_nnp" | "rot_120_pnn" | "rot_120_npp" | "rot_120_ppn" | "swap_neg_xz" | "rot_90_ref_x_pos" | "invert_x" | OctahedralGroup | "rot_180_edge_xz_neg" | "rot_90_ref_x_neg" | "rot_180_face_xy" | "rot_90_z_pos" | "rot_60_ref_nnn" | "rot_60_ref_ppp" | "rot_90_y_neg" | "rot_180_edge_yz_neg" | "swap_xz" | "rot_60_ref_npn" | "invert_y" | "rot_60_ref_pnp" | "swap_neg_xy";
    class FloatTag extends Internal.NumericTag {
        getAsDouble(): number;
        accept(arg0: Internal.TagVisitor_): void;
        getAsLong(): number;
        getAsFloat(): number;
        hashCode(): number;
        getAsString(): string;
        getAsInt(): number;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        getAsByte(): number;
        getAsNumber(): Internal.Number;
        write(arg0: Internal.DataOutput_): void;
        getId(): number;
        copy(): this;
        getAsShort(): number;
        getType(): Internal.TagType<Internal.FloatTag>;
        equals(arg0: any): boolean;
        static valueOf(arg0: number): Internal.FloatTag;
        accept(arg0: Internal.StreamTagVisitor_): Internal.StreamTagVisitor$ValueResult;
        get asDouble(): number
        get asLong(): number
        get asFloat(): number
        get asString(): string
        get asInt(): number
        get asByte(): number
        get asNumber(): Internal.Number
        get id(): number
        get asShort(): number
        get type(): Internal.TagType<Internal.FloatTag>
        readonly static "TYPE": any;
        readonly static "ZERO": Internal.FloatTag;
    }
    type FloatTag_ = FloatTag;
    class Program {
        attachToShader(arg0: Internal.Shader_): void;
        static compileShader(arg0: Internal.Program$Type_, arg1: string, arg2: Internal.InputStream_, arg3: string, arg4: Internal.GlslPreprocessor_): Internal.Program;
        close(): void;
        getName(): string;
        get name(): string
    }
    type Program_ = Program;
    abstract class AbstractStringBuilder implements Internal.CharSequence, Internal.Appendable {
        reverse(): this;
        append(arg0: string): this;
        codePointAt(arg0: number): number;
        insert(arg0: number, arg1: string): this;
        append(arg0: number): this;
        append(arg0: boolean): this;
        lastIndexOf(arg0: string): number;
        append(arg0: number): this;
        insert(arg0: number, arg1: number): this;
        indexOf(arg0: string): number;
        getChars(arg0: number, arg1: number, arg2: string[], arg3: number): void;
        lastIndexOf(arg0: string, arg1: number): number;
        append(arg0: number): this;
        insert(arg0: number, arg1: boolean): this;
        charAt(arg0: number): string;
        length(): number;
        replace(arg0: number, arg1: number, arg2: string): this;
        trimToSize(): void;
        insert(arg0: number, arg1: number): this;
        append(arg0: string): this;
        delete(arg0: number, arg1: number): this;
        indexOf(arg0: string, arg1: number): number;
        ensureCapacity(arg0: number): void;
        chars(): Internal.IntStream;
        insert(arg0: number, arg1: Internal.CharSequence_): this;
        insert(arg0: number, arg1: string): this;
        insert(arg0: number, arg1: any): this;
        append(arg0: number): this;
        capacity(): number;
        codePointCount(arg0: number, arg1: number): number;
        append(arg0: string[]): this;
        substring(arg0: number): string;
        setCharAt(arg0: number, arg1: string): void;
        setLength(arg0: number): void;
        isEmpty(): boolean;
        codePointBefore(arg0: number): number;
        append(arg0: string[], arg1: number, arg2: number): this;
        deleteCharAt(arg0: number): this;
        subSequence(arg0: number, arg1: number): Internal.CharSequence;
        append(arg0: Internal.StringBuffer_): this;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): this;
        appendCodePoint(arg0: number): this;
        substring(arg0: number, arg1: number): string;
        insert(arg0: number, arg1: number): this;
        toString(): string;
        insert(arg0: number, arg1: Internal.CharSequence_, arg2: number, arg3: number): this;
        insert(arg0: number, arg1: number): this;
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): this;
        offsetByCodePoints(arg0: number, arg1: number): number;
        insert(arg0: number, arg1: string[]): this;
        append(arg0: any): this;
        append(arg0: Internal.CharSequence_): this;
        codePoints(): Internal.IntStream;
        set length(arg0: number)
        get empty(): boolean
    }
    type AbstractStringBuilder_ = AbstractStringBuilder;
    class StageChangeEvent {
        getPlayerStages(): Internal.Stages;
        getPlayer(): Internal.Player;
        getStage(): string;
        get playerStages(): Internal.Stages
        get player(): Internal.Player
        get stage(): string
    }
    type StageChangeEvent_ = StageChangeEvent;
    class ClassData {
        getMember(name: string): Internal.ClassMember;
        getConstructor(sig: Internal.MethodSignature_): Internal.Constructor<any>;
        getParent(): this;
        get parent(): Internal.ClassData
        readonly "type": Internal.Class<any>;
        readonly "cache": Internal.ClassDataCache;
    }
    type ClassData_ = ClassData;
    class UpgradeData {
        constructor(arg0: Internal.CompoundTag_, arg1: Internal.LevelHeightAccessor_)
        upgrade(arg0: Internal.LevelChunk_): void;
        write(): Internal.CompoundTag;
        isEmpty(): boolean;
        get empty(): boolean
        readonly static "EMPTY": Internal.UpgradeData;
    }
    type UpgradeData_ = UpgradeData;
    class StructureMode extends Internal.Enum<Internal.StructureMode> implements Internal.StringRepresentable {
        static values(): Internal.StructureMode[];
        getDisplayName(): Internal.Component;
        getSerializedName(): string;
        static valueOf(arg0: string): Internal.StructureMode;
        get displayName(): Internal.Component
        get serializedName(): string
        readonly static "SAVE": Internal.StructureMode;
        readonly static "CORNER": Internal.StructureMode;
        readonly static "LOAD": Internal.StructureMode;
        readonly static "DATA": Internal.StructureMode;
    }
    type StructureMode_ = "load" | StructureMode | "save" | "data" | "corner";
    interface Channel$Unsafe {
        deregister(arg0: Internal.ChannelPromise_): void;
        localAddress(): Internal.SocketAddress;
        recvBufAllocHandle(): Internal.RecvByteBufAllocator$Handle;
        closeForcibly(): void;
        close(arg0: Internal.ChannelPromise_): void;
        beginRead(): void;
        outboundBuffer(): Internal.ChannelOutboundBuffer;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.SocketAddress_, arg2: Internal.ChannelPromise_): void;
        flush(): void;
        bind(arg0: Internal.SocketAddress_, arg1: Internal.ChannelPromise_): void;
        disconnect(arg0: Internal.ChannelPromise_): void;
        register(arg0: Internal.EventLoop_, arg1: Internal.ChannelPromise_): void;
        write(arg0: any, arg1: Internal.ChannelPromise_): void;
        remoteAddress(): Internal.SocketAddress;
        voidPromise(): Internal.ChannelPromise;
    }
    type Channel$Unsafe_ = Channel$Unsafe;
    interface IPlantable {
        getPlant(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.BlockState;
        getPlantType(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.PlantType;
    }
    type IPlantable_ = IPlantable;
    interface LootItemFunction extends Internal.LootContextUser, Internal.BiFunction<Internal.ItemStack, Internal.LootContext, Internal.ItemStack> {
        decorate(arg0: Internal.BiFunction_<Internal.ItemStack_, Internal.LootContext_, Internal.ItemStack_>, arg1: Internal.Consumer_<Internal.ItemStack_>, arg2: Internal.LootContext_): Internal.Consumer<Internal.ItemStack>;
        getReferencedContextParams(): Internal.Set<Internal.LootContextParam<any>>;
        validate(arg0: Internal.ValidationContext_): void;
        getType(): Internal.LootItemFunctionType;
        andThen(arg0: Internal.Function_<any, any>): Internal.BiFunction<Internal.ItemStack, Internal.LootContext, V>;
        get referencedContextParams(): Internal.Set<Internal.LootContextParam<any>>
        get type(): Internal.LootItemFunctionType
    }
    type LootItemFunction_ = LootItemFunction | (()=>Internal.LootItemFunctionType_);
    class ClientboundContainerSetDataPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: number, arg2: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getValue(): number;
        getContainerId(): number;
        isSkippable(): boolean;
        getId(): number;
        get value(): number
        get containerId(): number
        get skippable(): boolean
        get id(): number
    }
    type ClientboundContainerSetDataPacket_ = ClientboundContainerSetDataPacket;
    class Block extends Internal.BlockBehaviour implements Internal.ItemLike, Internal.IForgeBlock, Internal.InjectedBlockExtension {
        constructor(arg0: Internal.BlockBehaviour$Properties_)
        isFlammable(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        collisionExtendsVertically(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        getSoundType(arg0: Internal.BlockState_): Internal.SoundType;
        getExpDrop(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: number, arg4: number): number;
        static updateOrDestroy(arg0: Internal.BlockState_, arg1: Internal.BlockState_, arg2: Internal.LevelAccessor_, arg3: BlockPos_, arg4: number, arg5: number): void;
        static dropResources(arg0: Internal.BlockState_, arg1: Internal.LevelAccessor_, arg2: BlockPos_, arg3: Internal.BlockEntity_): void;
        static canSupportRigidBlock(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        static popResource(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.ItemStack_): void;
        isStickyBlock(arg0: Internal.BlockState_): boolean;
        getDescriptionId(): string;
        getBeaconColorMultiplier(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): number[];
        onBlockExploded(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Explosion_): void;
        stepOn(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.Entity_): void;
        fallOn(arg0: Internal.Level_, arg1: Internal.BlockState_, arg2: BlockPos_, arg3: Internal.Entity_, arg4: number): void;
        shouldDisplayFluidOverlay(arg0: Internal.BlockState_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_, arg3: Internal.FluidState_): boolean;
        canEntityDestroy(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        getExplosionResistance(): number;
        asItem(): Internal.Item;
        rotate(arg0: Internal.BlockState_, arg1: Internal.LevelAccessor_, arg2: BlockPos_, arg3: Internal.Rotation_): Internal.BlockState;
        isValidSpawn(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.SpawnPlacements$Type_, arg4: Internal.EntityType_<any>): boolean;
        getJumpFactor(): number;
        getSpeedFactor(): number;
        getFlammability(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        static canSupportCenter(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        playerDestroy(arg0: Internal.Level_, arg1: Internal.Player_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: Internal.BlockEntity_, arg5: Internal.ItemStack_): void;
        playerWillDestroy(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.Player_): void;
        isLadder(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        getCloneItemStack(arg0: Internal.BlockState_, arg1: Internal.HitResult_, arg2: Internal.BlockGetter_, arg3: BlockPos_, arg4: Internal.Player_): Internal.ItemStack;
        onDestroyedByPlayer(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: boolean, arg5: Internal.FluidState_): boolean;
        getRenderPropertiesInternal(): any;
        isPortalFrame(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        onCaughtFire(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.LivingEntity_): void;
        getStateDefinition(): Internal.StateDefinition<Internal.Block, Internal.BlockState>;
        getBedDirection(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): Internal.Direction;
        fillItemCategory(arg0: Internal.CreativeModeTab_, arg1: Internal.NonNullList_<Internal.ItemStack_>): void;
        addLandingEffects(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: Internal.LivingEntity_, arg5: number): boolean;
        getEnchantPowerBonus(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): number;
        toString(): string;
        getId(): string;
        static pushEntitiesUp(arg0: Internal.BlockState_, arg1: Internal.BlockState_, arg2: Internal.Level_, arg3: BlockPos_): Internal.BlockState;
        initializeClient(arg0: Internal.Consumer_<Internal.IBlockRenderProperties_>): void;
        propagatesSkylightDown(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        setPlacedBy(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.LivingEntity_, arg4: Internal.ItemStack_): void;
        builtInRegistryHolder(): Internal.Holder$Reference<Internal.Block>;
        getFriction(): number;
        static popResourceFromFace(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Direction_, arg3: Internal.ItemStack_): void;
        handlePrecipitation(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Biome$Precipitation_): void;
        getSoundType(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): Internal.SoundType;
        getMapColor(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.MaterialColor_): Internal.MaterialColor;
        getRespawnPosition(arg0: Internal.BlockState_, arg1: Internal.EntityType_<any>, arg2: Internal.LevelReader_, arg3: BlockPos_, arg4: number, arg5: Internal.LivingEntity_): Internal.Optional<Vec3>;
        supportsExternalFaceHiding(arg0: Internal.BlockState_): boolean;
        isFertile(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        onBlockStateChange(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BlockState_): void;
        getWeakChanges(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): boolean;
        static dropResources(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.BlockEntity_, arg4: Internal.Entity_, arg5: Internal.ItemStack_): void;
        static isFaceFull(arg0: Internal.VoxelShape_, arg1: Internal.Direction_): boolean;
        getBlockStatesKJS(): Internal.List<Internal.BlockState>;
        static byItem(arg0: Internal.Item_): Internal.Block;
        static updateFromNeighbourShapes(arg0: Internal.BlockState_, arg1: Internal.LevelAccessor_, arg2: BlockPos_): Internal.BlockState;
        destroy(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: Internal.BlockState_): void;
        getFriction(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): number;
        canConnectRedstone(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        isFireSource(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        shouldCheckWeakPower(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        static dropResources(arg0: Internal.BlockState_, arg1: Internal.LootContext$Builder_): void;
        static dropResources(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_): void;
        isSlimeBlock(arg0: Internal.BlockState_): boolean;
        defaultBlockState(): Internal.BlockState;
        getStateForPlacement(arg0: Internal.BlockPlaceContext_): Internal.BlockState;
        canHarvestBlock(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.UseOnContext_, arg2: Internal.ToolAction_, arg3: boolean): Internal.BlockState;
        arch$holder(): Internal.Holder<Internal.Block>;
        animateTick(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Random_): void;
        getCloneItemStack(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_): Internal.ItemStack;
        hasDynamicShape(): boolean;
        getAiPathNodeType(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Mob_): Internal.BlockPathTypes;
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.BlockState_): boolean;
        onNeighborChange(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): void;
        dropFromExplosion(arg0: Internal.Explosion_): boolean;
        static isShapeFullBlock(arg0: Internal.VoxelShape_): boolean;
        isRandomlyTicking(arg0: Internal.BlockState_): boolean;
        withPropertiesOf(arg0: Internal.BlockState_): Internal.BlockState;
        static isExceptionForConnection(arg0: Internal.BlockState_): boolean;
        isScaffolding(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        hidesNeighborFace(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: Internal.Direction_): boolean;
        getStateAtViewpoint(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Vec3_): Internal.BlockState;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: Internal.ItemStack_, arg5: Internal.ToolAction_): Internal.BlockState;
        appendHoverText(arg0: Internal.ItemStack_, arg1: Internal.BlockGetter_, arg2: Internal.List_<Internal.Component_>, arg3: Internal.TooltipFlag_): void;
        static box(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): Internal.VoxelShape;
        isBed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        wasExploded(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Explosion_): void;
        getName(): Internal.MutableComponent;
        getExplosionResistance(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        updateEntityAfterFallOn(arg0: Internal.BlockGetter_, arg1: Internal.Entity_): void;
        canStickTo(arg0: Internal.BlockState_, arg1: Internal.BlockState_): boolean;
        isPossibleToRespawnInThis(): boolean;
        getFireSpreadSpeed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        getLightEmission(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): number;
        setBedOccupied(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.LivingEntity_, arg4: boolean): void;
        arch$registryName(): ResourceLocation;
        canDropFromExplosion(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): boolean;
        isConduitFrame(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): boolean;
        addRunningEffects(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        static updateOrDestroy(arg0: Internal.BlockState_, arg1: Internal.BlockState_, arg2: Internal.LevelAccessor_, arg3: BlockPos_, arg4: number): void;
        static stateById(arg0: number): Internal.BlockState;
        static getDrops(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.BlockEntity_, arg4: Internal.Entity_, arg5: Internal.ItemStack_): Internal.List<Internal.ItemStack>;
        popExperience(arg0: Internal.ServerLevel_, arg1: BlockPos_, arg2: number): void;
        static getId(arg0: Internal.BlockState_): number;
        canSustainPlant(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.IPlantable_): boolean;
        static getDrops(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.BlockEntity_): Internal.List<Internal.ItemStack>;
        isBurning(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        static shouldRenderFace(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: BlockPos_): boolean;
        get descriptionId(): string
        get explosionResistance(): number
        get jumpFactor(): number
        get speedFactor(): number
        get renderPropertiesInternal(): any
        get stateDefinition(): Internal.StateDefinition<Internal.Block, Internal.BlockState>
        get id(): string
        get friction(): number
        get blockStatesKJS(): Internal.List<Internal.BlockState>
        get name(): Internal.MutableComponent
        get possibleToRespawnInThis(): boolean
        readonly static "UPDATE_ALL_IMMEDIATE": 11;
        readonly static "INDESTRUCTIBLE": -1.0;
        readonly static "UPDATE_KNOWN_SHAPE": 16;
        readonly static "UPDATE_IMMEDIATE": 8;
        readonly static "UPDATE_SUPPRESS_DROPS": 32;
        readonly static "UPDATE_ALL": 3;
        readonly static "UPDATE_CLIENTS": 2;
        readonly static "UPDATE_INVISIBLE": 4;
        readonly static "UPDATE_LIMIT": 512;
        readonly static "UPDATE_SUPPRESS_LIGHT": 128;
        readonly static "UPDATE_NONE": 4;
        readonly static "INSTANT": 0.0;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "BLOCK_STATE_REGISTRY": any;
        readonly static "UPDATE_NEIGHBORS": 1;
        readonly static "UPDATE_MOVE_BY_PISTON": 64;
    }
    type Block_ = Special.Block | Block;
    class BitSet implements Internal.Cloneable, Internal.Serializable {
        constructor()
        constructor(arg0: number)
        clone(): any;
        set(arg0: number): void;
        cardinality(): number;
        xor(arg0: Internal.BitSet_): void;
        set(arg0: number, arg1: number, arg2: boolean): void;
        isEmpty(): boolean;
        intersects(arg0: Internal.BitSet_): boolean;
        get(arg0: number, arg1: number): this;
        set(arg0: number, arg1: boolean): void;
        static valueOf(arg0: number[]): Internal.BitSet;
        previousSetBit(arg0: number): number;
        or(arg0: Internal.BitSet_): void;
        get(arg0: number): boolean;
        set(arg0: number, arg1: number): void;
        andNot(arg0: Internal.BitSet_): void;
        and(arg0: Internal.BitSet_): void;
        stream(): Internal.IntStream;
        length(): number;
        toString(): string;
        static valueOf(arg0: Internal.LongBuffer_): Internal.BitSet;
        flip(arg0: number): void;
        flip(arg0: number, arg1: number): void;
        clear(arg0: number): void;
        clear(arg0: number, arg1: number): void;
        nextClearBit(arg0: number): number;
        static valueOf(arg0: number[]): Internal.BitSet;
        static valueOf(arg0: Internal.ByteBuffer_): Internal.BitSet;
        previousClearBit(arg0: number): number;
        nextSetBit(arg0: number): number;
        toByteArray(): number[];
        hashCode(): number;
        toLongArray(): number[];
        size(): number;
        clear(): void;
        equals(arg0: any): boolean;
        get empty(): boolean
    }
    type BitSet_ = BitSet;
    class ChunkRenderDispatcher {
        constructor(arg0: Internal.ClientLevel_, arg1: Internal.LevelRenderer_, arg2: Internal.Executor_, arg3: boolean, arg4: Internal.ChunkBufferBuilderPack_)
        constructor(arg0: Internal.ClientLevel_, arg1: Internal.LevelRenderer_, arg2: Internal.Executor_, arg3: boolean, arg4: Internal.ChunkBufferBuilderPack_, arg5: number)
        getFreeBufferCount(): number;
        setCamera(arg0: Vec3_): void;
        rebuildChunkSync(arg0: Internal.ChunkRenderDispatcher$RenderChunk_, arg1: Internal.RenderRegionCache_): void;
        uploadChunkLayer(arg0: Internal.BufferBuilder_, arg1: Internal.VertexBuffer_): Internal.CompletableFuture<void>;
        getCameraPosition(): Vec3;
        schedule(arg0: Internal.ChunkRenderDispatcher$RenderChunk$ChunkCompileTask_): void;
        uploadAllPendingUploads(): void;
        getToBatchCount(): number;
        getToUpload(): number;
        dispose(): void;
        isQueueEmpty(): boolean;
        blockUntilClear(): void;
        getStats(): string;
        setLevel(arg0: Internal.ClientLevel_): void;
        get freeBufferCount(): number
        set camera(arg0: Vec3_)
        get cameraPosition(): Vec3
        get toBatchCount(): number
        get toUpload(): number
        get queueEmpty(): boolean
        get stats(): string
        set level(arg0: Internal.ClientLevel_)
    }
    type ChunkRenderDispatcher_ = ChunkRenderDispatcher;
    interface RuleTestType <P> {
        codec(): Internal.Codec<P>;
        register(arg0: string, arg1: Internal.Codec_<P>): this;
        readonly static "TAG_TEST": any;
        readonly static "RANDOM_BLOCKSTATE_TEST": any;
        readonly static "BLOCKSTATE_TEST": any;
        readonly static "ALWAYS_TRUE_TEST": any;
        readonly static "RANDOM_BLOCK_TEST": any;
        readonly static "BLOCK_TEST": any;
    }
    type RuleTestType_<P> = Special.RuleTestType | RuleTestType<P>;
    abstract class ThrowableItemProjectile extends Internal.ThrowableProjectile implements Internal.ItemSupplier {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.LivingEntity_, arg2: Internal.Level_)
        constructor(arg0: Internal.EntityType_<any>, arg1: number, arg2: number, arg3: number, arg4: Internal.Level_)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getItem(): Internal.ItemStack;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        setItem(arg0: Internal.ItemStack_): void;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get item(): Internal.ItemStack
        get stepHeight(): number
        get multipartEntity(): boolean
        set item(arg0: Internal.ItemStack_)
        get parts(): Internal.PartEntity<any>[]
    }
    type ThrowableItemProjectile_ = ThrowableItemProjectile;
    class ChunkWatchEvent$UnWatch extends Internal.ChunkWatchEvent {
        constructor()
        constructor(arg0: Internal.ServerPlayer_, arg1: Internal.ChunkPos_, arg2: Internal.ServerLevel_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ChunkWatchEvent$UnWatch_ = ChunkWatchEvent$UnWatch;
    class ClientboundSetChunkCacheRadiusPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getRadius(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get radius(): number
        get skippable(): boolean
    }
    type ClientboundSetChunkCacheRadiusPacket_ = ClientboundSetChunkCacheRadiusPacket;
    class PacketFlow extends Internal.Enum<Internal.PacketFlow> {
        getOpposite(): this;
        static values(): Internal.PacketFlow[];
        static valueOf(arg0: string): Internal.PacketFlow;
        get opposite(): Internal.PacketFlow
        readonly static "CLIENTBOUND": Internal.PacketFlow;
        readonly static "SERVERBOUND": Internal.PacketFlow;
    }
    type PacketFlow_ = "serverbound" | "clientbound" | PacketFlow;
    class ServerboundResourcePackPacket$Action extends Internal.Enum<Internal.ServerboundResourcePackPacket$Action> {
        static valueOf(arg0: string): Internal.ServerboundResourcePackPacket$Action;
        static values(): Internal.ServerboundResourcePackPacket$Action[];
        readonly static "SUCCESSFULLY_LOADED": Internal.ServerboundResourcePackPacket$Action;
        readonly static "FAILED_DOWNLOAD": Internal.ServerboundResourcePackPacket$Action;
        readonly static "ACCEPTED": Internal.ServerboundResourcePackPacket$Action;
        readonly static "DECLINED": Internal.ServerboundResourcePackPacket$Action;
    }
    type ServerboundResourcePackPacket$Action_ = "declined" | "failed_download" | "successfully_loaded" | ServerboundResourcePackPacket$Action | "accepted";
    class SearchRegistry$Key <T> {
        constructor()
    }
    type SearchRegistry$Key_<T> = SearchRegistry$Key<T>;
    interface IForgeMinecraft {
        popGuiLayer(): void;
        pushGuiLayer(arg0: Internal.Screen_): void;
    }
    type IForgeMinecraft_ = IForgeMinecraft;
    class ClientboundRecipePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.ClientboundRecipePacket$State_, arg1: Internal.Collection_<ResourceLocation_>, arg2: Internal.Collection_<ResourceLocation_>, arg3: Internal.RecipeBookSettings_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        getRecipes(): Internal.List<ResourceLocation>;
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getHighlights(): Internal.List<ResourceLocation>;
        getState(): Internal.ClientboundRecipePacket$State;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getBookSettings(): Internal.RecipeBookSettings;
        isSkippable(): boolean;
        get recipes(): Internal.List<ResourceLocation>
        get highlights(): Internal.List<ResourceLocation>
        get state(): Internal.ClientboundRecipePacket$State
        get bookSettings(): Internal.RecipeBookSettings
        get skippable(): boolean
    }
    type ClientboundRecipePacket_ = ClientboundRecipePacket;
    abstract class PathNavigation {
        constructor(arg0: Internal.Mob_, arg1: Internal.Level_)
        createPath(arg0: Internal.Stream_<BlockPos_>, arg1: number): net.minecraft.world.level.pathfinder.Path;
        moveTo(arg0: Internal.Entity_, arg1: number): boolean;
        createPath(arg0: Internal.Entity_, arg1: number): net.minecraft.world.level.pathfinder.Path;
        canFloat(): boolean;
        recomputePath(): void;
        createPath(arg0: number, arg1: number, arg2: number, arg3: number): net.minecraft.world.level.pathfinder.Path;
        setCanFloat(arg0: boolean): void;
        createPath(arg0: BlockPos_, arg1: number, arg2: number): net.minecraft.world.level.pathfinder.Path;
        isInProgress(): boolean;
        getTargetPos(): BlockPos;
        isStuck(): boolean;
        getPath(): net.minecraft.world.level.pathfinder.Path;
        resetMaxVisitedNodesMultiplier(): void;
        moveTo(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getNodeEvaluator(): Internal.NodeEvaluator;
        moveTo(arg0: net.minecraft.world.level.pathfinder.Path_, arg1: number): boolean;
        setSpeedModifier(arg0: number): void;
        shouldRecomputePath(arg0: BlockPos_): boolean;
        isDone(): boolean;
        tick(): void;
        getMaxDistanceToWaypoint(): number;
        setMaxVisitedNodesMultiplier(arg0: number): void;
        createPath(arg0: BlockPos_, arg1: number): net.minecraft.world.level.pathfinder.Path;
        stop(): void;
        createPath(arg0: Internal.Set_<BlockPos_>, arg1: number): net.minecraft.world.level.pathfinder.Path;
        isStableDestination(arg0: BlockPos_): boolean;
        set canFloat(arg0: boolean)
        get inProgress(): boolean
        get targetPos(): BlockPos
        get stuck(): boolean
        get path(): net.minecraft.world.level.pathfinder.Path
        get nodeEvaluator(): Internal.NodeEvaluator
        set speedModifier(arg0: number)
        get done(): boolean
        get maxDistanceToWaypoint(): number
        set maxVisitedNodesMultiplier(arg0: number)
    }
    type PathNavigation_ = PathNavigation;
    class Agent {
        constructor(arg0: string, arg1: number)
        toString(): string;
        getName(): string;
        getVersion(): number;
        get name(): string
        get version(): number
        readonly static "SCROLLS": Internal.Agent;
        readonly static "MINECRAFT": Internal.Agent;
    }
    type Agent_ = Agent;
    class EventPriority extends Internal.Enum<Internal.EventPriority> implements Internal.IEventListener {
        invoke(arg0: Internal.Event_): void;
        static values(): Internal.EventPriority[];
        static valueOf(arg0: string): Internal.EventPriority;
        listenerName(): string;
        readonly static "NORMAL": Internal.EventPriority;
        readonly static "LOWEST": Internal.EventPriority;
        readonly static "LOW": Internal.EventPriority;
        readonly static "HIGH": Internal.EventPriority;
        readonly static "HIGHEST": Internal.EventPriority;
    }
    type EventPriority_ = "normal" | "high" | "low" | "lowest" | "highest" | EventPriority;
    class ChunkDataEvent extends Internal.ChunkEvent {
        constructor()
        constructor(arg0: Internal.ChunkAccess_, arg1: Internal.CompoundTag_)
        constructor(arg0: Internal.ChunkAccess_, arg1: Internal.LevelAccessor_, arg2: Internal.CompoundTag_)
        getListenerList(): Internal.ListenerList;
        getData(): Internal.CompoundTag;
        get listenerList(): Internal.ListenerList
        get data(): Internal.CompoundTag
    }
    type ChunkDataEvent_ = ChunkDataEvent;
    class LightLayer extends Internal.Enum<Internal.LightLayer> {
        static valueOf(arg0: string): Internal.LightLayer;
        static values(): Internal.LightLayer[];
        readonly static "BLOCK": Internal.LightLayer;
        readonly static "SKY": Internal.LightLayer;
        readonly "surrounding": number;
    }
    type LightLayer_ = "block" | LightLayer | "sky";
    interface StringBuilderAppendable {
        appendString(arg0: Internal.StringBuilder_): void;
    }
    type StringBuilderAppendable_ = StringBuilderAppendable;
    interface ServerGamePacketListener extends Internal.ServerPacketListener {
        handleTeleportToEntityPacket(arg0: Internal.ServerboundTeleportToEntityPacket_): void;
        handleInteract(arg0: Internal.ServerboundInteractPacket_): void;
        handlePlayerAbilities(arg0: Internal.ServerboundPlayerAbilitiesPacket_): void;
        handlePlayerInput(arg0: Internal.ServerboundPlayerInputPacket_): void;
        handleClientCommand(arg0: Internal.ServerboundClientCommandPacket_): void;
        handleResourcePackResponse(arg0: Internal.ServerboundResourcePackPacket_): void;
        handleSetCarriedItem(arg0: Internal.ServerboundSetCarriedItemPacket_): void;
        handlePickItem(arg0: Internal.ServerboundPickItemPacket_): void;
        handleSetCreativeModeSlot(arg0: Internal.ServerboundSetCreativeModeSlotPacket_): void;
        handleContainerClose(arg0: Internal.ServerboundContainerClosePacket_): void;
        handleChangeDifficulty(arg0: Internal.ServerboundChangeDifficultyPacket_): void;
        handleSeenAdvancements(arg0: Internal.ServerboundSeenAdvancementsPacket_): void;
        handleClientInformation(arg0: Internal.ServerboundClientInformationPacket_): void;
        handleKeepAlive(arg0: Internal.ServerboundKeepAlivePacket_): void;
        handleRecipeBookChangeSettingsPacket(arg0: Internal.ServerboundRecipeBookChangeSettingsPacket_): void;
        handleContainerClick(arg0: Internal.ServerboundContainerClickPacket_): void;
        handleUseItem(arg0: Internal.ServerboundUseItemPacket_): void;
        handlePaddleBoat(arg0: Internal.ServerboundPaddleBoatPacket_): void;
        handleSetStructureBlock(arg0: Internal.ServerboundSetStructureBlockPacket_): void;
        handleCustomCommandSuggestions(arg0: Internal.ServerboundCommandSuggestionPacket_): void;
        handleAcceptTeleportPacket(arg0: Internal.ServerboundAcceptTeleportationPacket_): void;
        handleMovePlayer(arg0: Internal.ServerboundMovePlayerPacket_): void;
        handleCustomPayload(arg0: Internal.ServerboundCustomPayloadPacket_): void;
        handleSelectTrade(arg0: Internal.ServerboundSelectTradePacket_): void;
        handleJigsawGenerate(arg0: Internal.ServerboundJigsawGeneratePacket_): void;
        handlePlayerAction(arg0: Internal.ServerboundPlayerActionPacket_): void;
        handleLockDifficulty(arg0: Internal.ServerboundLockDifficultyPacket_): void;
        handleAnimate(arg0: Internal.ServerboundSwingPacket_): void;
        handleSetJigsawBlock(arg0: Internal.ServerboundSetJigsawBlockPacket_): void;
        handleSetCommandMinecart(arg0: Internal.ServerboundSetCommandMinecartPacket_): void;
        handleRenameItem(arg0: Internal.ServerboundRenameItemPacket_): void;
        shouldPropagateHandlingExceptions(): boolean;
        handleEntityTagQuery(arg0: Internal.ServerboundEntityTagQuery_): void;
        handleSetCommandBlock(arg0: Internal.ServerboundSetCommandBlockPacket_): void;
        handleRecipeBookSeenRecipePacket(arg0: Internal.ServerboundRecipeBookSeenRecipePacket_): void;
        handleBlockEntityTagQuery(arg0: Internal.ServerboundBlockEntityTagQuery_): void;
        handleSignUpdate(arg0: Internal.ServerboundSignUpdatePacket_): void;
        handleChat(arg0: Internal.ServerboundChatPacket_): void;
        handleContainerButtonClick(arg0: Internal.ServerboundContainerButtonClickPacket_): void;
        handleSetBeaconPacket(arg0: Internal.ServerboundSetBeaconPacket_): void;
        handlePong(arg0: Internal.ServerboundPongPacket_): void;
        handlePlaceRecipe(arg0: Internal.ServerboundPlaceRecipePacket_): void;
        handleUseItemOn(arg0: Internal.ServerboundUseItemOnPacket_): void;
        handlePlayerCommand(arg0: Internal.ServerboundPlayerCommandPacket_): void;
        handleEditBook(arg0: Internal.ServerboundEditBookPacket_): void;
        handleMoveVehicle(arg0: Internal.ServerboundMoveVehiclePacket_): void;
    }
    type ServerGamePacketListener_ = ServerGamePacketListener;
    class FireworkRocketRecipe extends Internal.CustomRecipe {
        constructor(arg0: ResourceLocation_)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        matches(arg0: Internal.CraftingContainer_, arg1: Internal.Level_): boolean;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        getSerializer(): Internal.RecipeSerializer<any>;
        isIncomplete(): boolean;
        assemble(arg0: Internal.CraftingContainer_): Internal.ItemStack;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getResultItem(): Internal.ItemStack;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get serializer(): Internal.RecipeSerializer<any>
        get incomplete(): boolean
        get resultItem(): Internal.ItemStack
    }
    type FireworkRocketRecipe_ = FireworkRocketRecipe;
    class TickTask implements Internal.Runnable {
        constructor(arg0: number, arg1: Internal.Runnable_)
        run(): void;
        getTick(): number;
        get tick(): number
    }
    type TickTask_ = TickTask;
    class RandomSpreadStructurePlacement extends Internal.Record implements Internal.StructurePlacement {
        constructor(arg0: number, arg1: number, arg2: Internal.RandomSpreadType_, arg3: number)
        constructor(arg0: number, arg1: number, arg2: Internal.RandomSpreadType_, arg3: number, arg4: Vec3i_)
        hashCode(): number;
        getPotentialFeatureChunk(arg0: number, arg1: number, arg2: number): Internal.ChunkPos;
        isFeatureChunk(arg0: Internal.ChunkGenerator_, arg1: number, arg2: number, arg3: number): boolean;
        toString(): string;
        spacing(): number;
        locateOffset(): Vec3i;
        separation(): number;
        salt(): number;
        equals(arg0: any): boolean;
        type(): Internal.StructurePlacementType<any>;
        spreadType(): Internal.RandomSpreadType;
        readonly static "CODEC": any;
    }
    type RandomSpreadStructurePlacement_ = RandomSpreadStructurePlacement;
    class FeaturePlaceContext <FC> {
        constructor(arg0: Internal.Optional_<Internal.ConfiguredFeature_<any, any>>, arg1: Internal.WorldGenLevel_, arg2: Internal.ChunkGenerator_, arg3: Internal.Random_, arg4: BlockPos_, arg5: FC)
        config(): FC;
        topFeature(): Internal.Optional<Internal.ConfiguredFeature<any, any>>;
        origin(): BlockPos;
        random(): Internal.Random;
        level(): Internal.WorldGenLevel;
        chunkGenerator(): Internal.ChunkGenerator;
    }
    type FeaturePlaceContext_<FC> = FeaturePlaceContext<FC>;
    class IpBanList extends Internal.StoredUserList<string, Internal.IpBanListEntry> {
        constructor(arg0: Internal.File_)
        isBanned(arg0: string): boolean;
        isBanned(arg0: Internal.SocketAddress_): boolean;
        get(arg0: Internal.SocketAddress_): Internal.IpBanListEntry;
    }
    type IpBanList_ = IpBanList;
    class Horse extends Internal.AbstractHorse {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        canMate(arg0: Internal.Animal_): boolean;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        getMarkings(): Internal.Markings;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        getArmor(): Internal.ItemStack;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        isArmor(arg0: Internal.ItemStack_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        getVariant(): Internal.Variant;
        canWearArmor(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getClassification(arg0: boolean): Internal.MobCategory;
        containerChanged(arg0: Internal.Container_): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get markings(): Internal.Markings
        get multipartEntity(): boolean
        get armor(): Internal.ItemStack
        get parts(): Internal.PartEntity<any>[]
        get variant(): Internal.Variant
    }
    type Horse_ = Horse;
    interface CustomJavaToJsWrapper {
        convertJavaToJs(arg0: Internal.SharedContextData_, arg1: Internal.Scriptable_, arg2: Internal.Class_<any>): Internal.Scriptable;
    }
    type CustomJavaToJsWrapper_ = CustomJavaToJsWrapper | ((arg0: Internal.SharedContextData, arg1: Internal.Scriptable, arg2: Internal.Class<any>)=>Internal.Scriptable_);
    interface ChannelPipeline extends Internal.Iterable<Internal.Map$Entry<string, Internal.ChannelHandler>>, Internal.ChannelOutboundInvoker, Internal.ChannelInboundInvoker {
        context(arg0: Internal.ChannelHandler_): Internal.ChannelHandlerContext;
        fireExceptionCaught(arg0: Internal.Throwable_): this;
        context(arg0: Internal.Class_<any>): Internal.ChannelHandlerContext;
        addLast(...arg0: Internal.ChannelHandler_[]): this;
        fireChannelInactive(): this;
        firstContext(): Internal.ChannelHandlerContext;
        addBefore(arg0: Internal.EventExecutorGroup_, arg1: string, arg2: string, arg3: Internal.ChannelHandler_): this;
        addFirst(arg0: Internal.EventExecutorGroup_, arg1: string, arg2: Internal.ChannelHandler_): this;
        addFirst(arg0: Internal.EventExecutorGroup_, ...arg1: Internal.ChannelHandler_[]): this;
        forEach(arg0: Internal.Consumer_<any>): void;
        addAfter(arg0: string, arg1: string, arg2: Internal.ChannelHandler_): this;
        removeFirst(): Internal.ChannelHandler;
        remove(arg0: Internal.Class_<T>): T;
        fireChannelRegistered(): this;
        replace(arg0: Internal.Class_<T>, arg1: string, arg2: Internal.ChannelHandler_): T;
        replace(arg0: Internal.ChannelHandler_, arg1: string, arg2: Internal.ChannelHandler_): this;
        fireChannelWritabilityChanged(): this;
        context(arg0: string): Internal.ChannelHandlerContext;
        fireChannelRead(arg0: any): this;
        fireUserEventTriggered(arg0: any): this;
        addAfter(arg0: Internal.EventExecutorGroup_, arg1: string, arg2: string, arg3: Internal.ChannelHandler_): this;
        names(): Internal.List<string>;
        toMap(): Internal.Map<string, Internal.ChannelHandler>;
        addLast(arg0: Internal.EventExecutorGroup_, ...arg1: Internal.ChannelHandler_[]): this;
        fireChannelReadComplete(): this;
        addFirst(arg0: string, arg1: Internal.ChannelHandler_): this;
        fireChannelActive(): this;
        last(): Internal.ChannelHandler;
        get(arg0: Internal.Class_<T>): T;
        spliterator(): Internal.Spliterator<Internal.Map$Entry<string, Internal.ChannelHandler>>;
        channel(): io.netty.channel.Channel;
        replace(arg0: string, arg1: string, arg2: Internal.ChannelHandler_): Internal.ChannelHandler;
        addBefore(arg0: string, arg1: string, arg2: Internal.ChannelHandler_): this;
        first(): Internal.ChannelHandler;
        remove(arg0: string): Internal.ChannelHandler;
        remove(arg0: Internal.ChannelHandler_): this;
        addLast(arg0: Internal.EventExecutorGroup_, arg1: string, arg2: Internal.ChannelHandler_): this;
        get(arg0: string): Internal.ChannelHandler;
        lastContext(): Internal.ChannelHandlerContext;
        addFirst(...arg0: Internal.ChannelHandler_[]): this;
        fireChannelUnregistered(): this;
        removeLast(): Internal.ChannelHandler;
        flush(): this;
        addLast(arg0: string, arg1: Internal.ChannelHandler_): this;
    }
    type ChannelPipeline_ = ChannelPipeline;
    class ServerStartedEvent extends Internal.ServerLifecycleEvent {
        constructor()
        constructor(arg0: Internal.MinecraftServer_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ServerStartedEvent_ = ServerStartedEvent;
    interface ObjectCollection <K> extends Internal.Collection<K>, Internal.ObjectIterable<K> {
        parallelStream(): Internal.Stream<K>;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        iterator(): Internal.Iterator<any>;
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.ObjectSpliterator<K>;
        stream(): Internal.Stream<K>;
    }
    type ObjectCollection_<K> = ObjectCollection<K>;
    class NbtAccounter {
        constructor(arg0: number)
        accountBits(arg0: number): void;
        readUTF(arg0: string): string;
        readonly static "UNLIMITED": any;
    }
    type NbtAccounter_ = NbtAccounter;
    abstract class Language {
        constructor()
        getVisualOrder(arg0: Internal.FormattedText_): Internal.FormattedCharSequence;
        has(arg0: string): boolean;
        static loadFromJson(arg0: Internal.InputStream_, arg1: Internal.BiConsumer_<string, string>): void;
        static getInstance(): Internal.Language;
        getLanguageData(): Internal.Map<string, string>;
        static inject(arg0: Internal.Language_): void;
        getVisualOrder(arg0: Internal.List_<Internal.FormattedText_>): Internal.List<Internal.FormattedCharSequence>;
        isDefaultRightToLeft(): boolean;
        getOrDefault(arg0: string): string;
        get instance(): Internal.Language
        get languageData(): Internal.Map<string, string>
        get defaultRightToLeft(): boolean
        readonly static "DEFAULT": "en_us";
    }
    type Language_ = Language;
    class VariantBlockStateGenerator$Model {
        constructor()
        uvlock(): this;
        x(_x: number): this;
        y(_y: number): this;
        model(s: string): this;
        toJson(): Internal.JsonObject;
    }
    type VariantBlockStateGenerator$Model_ = VariantBlockStateGenerator$Model;
    class FoodBuilder {
        constructor()
        constructor(properties: Internal.FoodProperties_)
        fastToEat(flag: boolean): this;
        hunger(h: number): this;
        alwaysEdible(flag: boolean): this;
        eaten(e: Internal.Consumer_<Internal.ItemFoodEatenEventJS_>): this;
        saturation(s: number): this;
        build(): Internal.FoodProperties;
        alwaysEdible(): this;
        effect(mobEffectId: ResourceLocation_, duration: number, amplifier: number, probability: number): this;
        meat(flag: boolean): this;
        meat(): this;
        removeEffect(mobEffect: Internal.MobEffect_): this;
        fastToEat(): this;
        "eaten": Internal.Consumer<Internal.ItemFoodEatenEventJS>;
    }
    type FoodBuilder_ = FoodBuilder;
    class BlockPlaceContext extends Internal.UseOnContext {
        constructor(arg0: Internal.Player_, arg1: Hand_, arg2: Internal.ItemStack_, arg3: Internal.BlockHitResult_)
        constructor(arg0: Internal.Level_, arg1: Internal.Player_, arg2: Hand_, arg3: Internal.ItemStack_, arg4: Internal.BlockHitResult_)
        constructor(arg0: Internal.UseOnContext_)
        getNearestLookingDirection(): Internal.Direction;
        getNearestLookingVerticalDirection(): Internal.Direction;
        getNearestLookingDirections(): Internal.Direction[];
        replacingClickedOnBlock(): boolean;
        getClickedPos(): BlockPos;
        static at(arg0: Internal.BlockPlaceContext_, arg1: BlockPos_, arg2: Internal.Direction_): Internal.BlockPlaceContext;
        canPlace(): boolean;
        get nearestLookingDirection(): Internal.Direction
        get nearestLookingVerticalDirection(): Internal.Direction
        get nearestLookingDirections(): Internal.Direction[]
        get clickedPos(): BlockPos
    }
    type BlockPlaceContext_ = BlockPlaceContext;
    interface Object2ShortFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToIntFunction<K> {
        put(arg0: K, arg1: number): number;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Object2FloatFunction<K>;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2ShortFunction;
        getOrDefault(arg0: any, arg1: any): any;
        remove(arg0: any): number;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2ShortFunction;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2ShortFunction;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Object2IntFunction<K>;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2ShortFunction;
        containsKey(arg0: any): boolean;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Object2LongFunction<K>;
        andThenReference(arg0: Internal.Short2ReferenceFunction_<any>): Internal.Object2ReferenceFunction<K, T>;
        defaultReturnValue(): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): this;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2ShortFunction;
        composeObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Object2ShortFunction<T>;
        getOrDefault(arg0: any, arg1: number): number;
        apply(arg0: K): number;
        put(arg0: any, arg1: any): any;
        composeReference(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Reference2ShortFunction<T>;
        getShort(arg0: any): number;
        removeShort(arg0: any): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        put(arg0: K, arg1: number): number;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Object2CharFunction<K>;
        applyAsInt(arg0: K): number;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Object2ByteFunction<K>;
        size(): number;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2ShortFunction;
        defaultReturnValue(arg0: number): void;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        clear(): void;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2ShortFunction;
        getOrDefault(arg0: any, arg1: number): number;
        get(arg0: any): any;
        andThenObject(arg0: Internal.Short2ObjectFunction_<any>): Internal.Object2ObjectFunction<K, T>;
    }
    type Object2ShortFunction_<K> = Object2ShortFunction<K> | ((arg0: any)=>number);
    class ServerboundPlaceRecipePacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: Internal.Recipe_<any>, arg2: boolean)
        handle(arg0: Internal.PacketListener_): void;
        getRecipe(): ResourceLocation;
        write(arg0: Internal.FriendlyByteBuf_): void;
        isShiftDown(): boolean;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getContainerId(): number;
        isSkippable(): boolean;
        get recipe(): ResourceLocation
        get shiftDown(): boolean
        get containerId(): number
        get skippable(): boolean
    }
    type ServerboundPlaceRecipePacket_ = ServerboundPlaceRecipePacket;
    interface ProfileResults {
        saveResults(arg0: Internal.Path_): boolean;
        getTimes(arg0: string): Internal.List<Internal.ResultField>;
        getNanoDuration(): number;
        getStartTimeTicks(): number;
        getTickDuration(): number;
        getEndTimeNano(): number;
        getEndTimeTicks(): number;
        getStartTimeNano(): number;
        demanglePath(arg0: string): string;
        getProfilerResults(): string;
        get nanoDuration(): number
        get startTimeTicks(): number
        get tickDuration(): number
        get endTimeNano(): number
        get endTimeTicks(): number
        get startTimeNano(): number
        get profilerResults(): string
        readonly static "PATH_SEPARATOR": "\u001e";
    }
    type ProfileResults_ = ProfileResults;
    class CarvingContext extends Internal.WorldGenerationContext {
        constructor(arg0: Internal.NoiseBasedChunkGenerator_, arg1: Internal.RegistryAccess_, arg2: Internal.LevelHeightAccessor_, arg3: Internal.NoiseChunk_)
        topMaterial(arg0: Internal.Function_<BlockPos_, Internal.Holder_<Internal.Biome_>>, arg1: Internal.ChunkAccess_, arg2: BlockPos_, arg3: boolean): Internal.Optional<Internal.BlockState>;
        registryAccess(): Internal.RegistryAccess;
    }
    type CarvingContext_ = CarvingContext;
    interface ListBuilder <T> {
        build(arg0: Internal.DataResult_<T>): Internal.DataResult<T>;
        add(arg0: T): this;
        withErrorsFrom(arg0: Internal.DataResult_<any>): this;
        ops(): Internal.DynamicOps<T>;
        add(arg0: Internal.DataResult_<T>): this;
        add(arg0: E, arg1: Internal.Encoder_<E>): this;
        addAll(arg0: Internal.Iterable_<E>, arg1: Internal.Encoder_<E>): this;
        build(arg0: T): Internal.DataResult<T>;
        mapError(arg0: Internal.UnaryOperator_<string>): this;
    }
    type ListBuilder_<T> = ListBuilder<T>;
    class FormatStyle extends Internal.Enum<Internal.FormatStyle> {
        static values(): Internal.FormatStyle[];
        static valueOf(arg0: string): Internal.FormatStyle;
        readonly static "SHORT": Internal.FormatStyle;
        readonly static "FULL": Internal.FormatStyle;
        readonly static "LONG": Internal.FormatStyle;
        readonly static "MEDIUM": Internal.FormatStyle;
    }
    type FormatStyle_ = "medium" | "short" | "full" | FormatStyle | "long";
    interface Float2ByteFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleToIntFunction {
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Float2IntFunction;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Float2CharFunction;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Float2ShortFunction;
        getOrDefault(arg0: any, arg1: any): any;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2ByteFunction;
        put(arg0: number, arg1: number): number;
        put(arg0: number, arg1: number): number;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2ByteFunction;
        containsKey(arg0: any): boolean;
        defaultReturnValue(arg0: number): void;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Float2FloatFunction;
        apply(arg0: number): number;
        andThenByte(arg0: Internal.Byte2ByteFunction_): this;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2ByteFunction;
        composeFloat(arg0: Internal.Float2FloatFunction_): this;
        put(arg0: any, arg1: any): any;
        getOrDefault(arg0: number, arg1: number): number;
        defaultReturnValue(): number;
        containsKey(arg0: number): boolean;
        remove(arg0: number): number;
        get(arg0: any): number;
        andThenObject(arg0: Internal.Byte2ObjectFunction_<any>): Internal.Float2ObjectFunction<T>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2ByteFunction;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2ByteFunction;
        getOrDefault(arg0: any, arg1: number): number;
        size(): number;
        andThenReference(arg0: Internal.Byte2ReferenceFunction_<any>): Internal.Float2ReferenceFunction<T>;
        composeReference(arg0: Internal.Reference2FloatFunction_<any>): Internal.Reference2ByteFunction<T>;
        clear(): void;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2ByteFunction;
        remove(arg0: any): any;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Float2LongFunction;
        composeObject(arg0: Internal.Object2FloatFunction_<any>): Internal.Object2ByteFunction<T>;
        get(arg0: number): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Float2DoubleFunction;
        applyAsInt(arg0: number): number;
    }
    type Float2ByteFunction_ = ((arg0: number)=>number) | Float2ByteFunction;
    class Vector3d {
        constructor(arg0: number, arg1: number, arg2: number)
        set(arg0: Internal.Vector3d_): void;
        scale(arg0: number): void;
        add(arg0: Internal.Vector3d_): void;
        set(arg0: number, arg1: number, arg2: number): void;
        "z": number;
        "x": number;
        "y": number;
    }
    type Vector3d_ = Vector3d;
    abstract class SupportType extends Internal.Enum<Internal.SupportType> {
        static values(): Internal.SupportType[];
        static valueOf(arg0: string): Internal.SupportType;
        isSupporting(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        readonly static "CENTER": any;
        readonly static "RIGID": any;
        readonly static "FULL": any;
    }
    type SupportType_ = "center" | SupportType | "full" | "rigid";
    class ArgumentCommandNode <S, T> extends Internal.CommandNode<S> {
        constructor(arg0: string, arg1: Internal.ArgumentType_<T>, arg2: Internal.Command_<S>, arg3: Internal.Predicate_<S>, arg4: Internal.CommandNode_<S>, arg5: Internal.RedirectModifier_<S>, arg6: boolean, arg7: Internal.SuggestionProvider_<S>)
        isValidInput(arg0: string): boolean;
        getType(): Internal.ArgumentType<T>;
        hashCode(): number;
        getExamples(): Internal.Collection<string>;
        toString(): string;
        parse(arg0: Internal.StringReader_, arg1: Internal.CommandContextBuilder_<S>): void;
        getName(): string;
        createBuilder(): Internal.ArgumentBuilder<any, any>;
        listSuggestions(arg0: Internal.CommandContext_<S>, arg1: Internal.SuggestionsBuilder_): Internal.CompletableFuture<Internal.Suggestions>;
        getUsageText(): string;
        getCustomSuggestions(): Internal.SuggestionProvider<S>;
        equals(arg0: any): boolean;
        get type(): Internal.ArgumentType<T>
        get examples(): Internal.Collection<string>
        get name(): string
        get usageText(): string
        get customSuggestions(): Internal.SuggestionProvider<S>
    }
    type ArgumentCommandNode_<S, T> = ArgumentCommandNode<S, T>;
    class ImmutableSetMultimap$Builder <K, V> extends Internal.ImmutableMultimap$Builder<K, V> {
        constructor()
        orderKeysBy(arg0: Internal.Comparator_<any>): this;
        put(arg0: Internal.Map$Entry_<any, any>): this;
        put(arg0: any, arg1: any): Internal.ImmutableMultimap$Builder<any, any>;
        build(): Internal.ImmutableMultimap<any, any>;
        orderValuesBy(arg0: Internal.Comparator_<any>): this;
        putAll(arg0: Internal.Iterable_<any>): Internal.ImmutableMultimap$Builder<any, any>;
        putAll(arg0: any, arg1: Internal.Iterable_<any>): Internal.ImmutableMultimap$Builder<any, any>;
        putAll(arg0: Internal.Multimap_<any, any>): Internal.ImmutableMultimap$Builder<any, any>;
        putAll(arg0: any, arg1: any[]): Internal.ImmutableMultimap$Builder<any, any>;
    }
    type ImmutableSetMultimap$Builder_<K, V> = ImmutableSetMultimap$Builder<K, V>;
    interface Object2LongFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToLongFunction<K> {
        andThenLong(arg0: Internal.Long2LongFunction_): this;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Object2FloatFunction<K>;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Object2ByteFunction<K>;
        getOrDefault(arg0: any, arg1: any): any;
        andThenObject(arg0: Internal.Long2ObjectFunction_<any>): Internal.Object2ObjectFunction<K, T>;
        removeLong(arg0: any): number;
        put(arg0: K, arg1: number): number;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2LongFunction;
        containsKey(arg0: any): boolean;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2LongFunction;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2LongFunction;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        getLong(arg0: any): number;
        remove(arg0: any): number;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Object2CharFunction<K>;
        put(arg0: any, arg1: any): any;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2LongFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        applyAsLong(arg0: K): number;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2LongFunction;
        andThenReference(arg0: Internal.Long2ReferenceFunction_<any>): Internal.Object2ReferenceFunction<K, T>;
        defaultReturnValue(): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Object2IntFunction<K>;
        apply(arg0: K): number;
        composeObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Object2LongFunction<T>;
        getOrDefault(arg0: any, arg1: number): number;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2LongFunction;
        getOrDefault(arg0: any, arg1: number): number;
        size(): number;
        composeReference(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Reference2LongFunction<T>;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Object2ShortFunction<K>;
        clear(): void;
        get(arg0: any): any;
        defaultReturnValue(arg0: number): void;
        put(arg0: K, arg1: number): number;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2LongFunction;
    }
    type Object2LongFunction_<K> = ((arg0: any)=>number) | Object2LongFunction<K>;
    class Vector3f {
        constructor()
        constructor(arg0: Vec3_)
        constructor(arg0: number[])
        constructor(arg0: Internal.Vector4f_)
        constructor(arg0: number, arg1: number, arg2: number)
        setX(arg0: number): void;
        rotation(arg0: number): Internal.Quaternion;
        transform(arg0: Internal.Quaternion_): void;
        normalize(): boolean;
        lerp(arg0: Internal.Vector3f_, arg1: number): void;
        cross(arg0: Internal.Vector3f_): void;
        add(arg0: Internal.Vector3f_): void;
        mul(arg0: number, arg1: number, arg2: number): void;
        map(arg0: Internal.Float2FloatFunction_): void;
        load(arg0: Internal.Vector3f_): void;
        copy(): this;
        setY(arg0: number): void;
        setZ(arg0: number): void;
        mul(arg0: number): void;
        y(): number;
        set(arg0: number, arg1: number, arg2: number): void;
        z(): number;
        sub(arg0: Internal.Vector3f_): void;
        x(): number;
        toString(): string;
        transform(arg0: Internal.Matrix3f_): void;
        add(arg0: number, arg1: number, arg2: number): void;
        rotationDegrees(arg0: number): Internal.Quaternion;
        set(arg0: number[]): void;
        clamp(arg0: number, arg1: number): void;
        hashCode(): number;
        dot(arg0: Internal.Vector3f_): number;
        clamp(arg0: Internal.Vector3f_, arg1: Internal.Vector3f_): void;
        equals(arg0: any): boolean;
        set x(arg0: number)
        set y(arg0: number)
        set z(arg0: number)
        static "ZERO": Internal.Vector3f;
        static "XN": Internal.Vector3f;
        static "ZP": Internal.Vector3f;
        static "YP": Internal.Vector3f;
        static "XP": Internal.Vector3f;
        readonly static "CODEC": any;
        static "ZN": Internal.Vector3f;
        static "YN": Internal.Vector3f;
    }
    type Vector3f_ = Vector3f;
    interface DoubleStream$Builder extends Internal.DoubleConsumer {
        add(arg0: number): this;
        accept(arg0: number): void;
        andThen(arg0: Internal.DoubleConsumer_): Internal.DoubleConsumer;
        build(): Internal.DoubleStream;
    }
    type DoubleStream$Builder_ = DoubleStream$Builder;
    class ItemFoodEatenEventJS extends Internal.PlayerEventJS {
        constructor(p: Internal.ServerPlayer_, is: Internal.ItemStack_)
        getEntity(): Internal.EntityJS;
        canCancel(): boolean;
        getItem(): Internal.ItemStackJS;
        get entity(): Internal.EntityJS
        get item(): Internal.ItemStackJS
    }
    type ItemFoodEatenEventJS_ = ItemFoodEatenEventJS;
    class Stray extends Internal.AbstractSkeleton {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        static checkStraySpawnRules(arg0: Internal.EntityType_<Internal.Stray_>, arg1: Internal.ServerLevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type Stray_ = Stray;
    class FossilFeatureConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.List_<ResourceLocation_>, arg1: Internal.List_<ResourceLocation_>, arg2: Internal.Holder_<Internal.StructureProcessorList_>, arg3: Internal.Holder_<Internal.StructureProcessorList_>, arg4: number)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "overlayStructures": Internal.List<ResourceLocation>;
        readonly "fossilStructures": Internal.List<ResourceLocation>;
        readonly "maxEmptyCornersAllowed": number;
        readonly "fossilProcessors": Internal.Holder<Internal.StructureProcessorList>;
        readonly "overlayProcessors": Internal.Holder<Internal.StructureProcessorList>;
        readonly static "CODEC": any;
    }
    type FossilFeatureConfiguration_ = FossilFeatureConfiguration;
    abstract class ImmutableMultiset <E> extends Internal.ImmutableMultisetGwtSerializationDependencies<E> implements Internal.Multiset<E> {
        remove(arg0: any, arg1: number): number;
        static copyOf(arg0: E[]): Internal.ImmutableMultiset<E>;
        setCount(arg0: E, arg1: number): number;
        forEach(arg0: Internal.Consumer_<any>): void;
        parallelStream(): Internal.Stream<E>;
        static builder(): Internal.ImmutableMultiset$Builder<E>;
        static of(): Internal.ImmutableMultiset<E>;
        static of(arg0: E): Internal.ImmutableMultiset<E>;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        setCount(arg0: E, arg1: number, arg2: number): boolean;
        add(arg0: E, arg1: number): number;
        entrySet(): Internal.ImmutableSet<Internal.Multiset$Entry<E>>;
        contains(arg0: any): boolean;
        static copyOf(arg0: Internal.Iterable_<any>): Internal.ImmutableMultiset<E>;
        toString(): string;
        iterator(): Internal.Iterator<any>;
        forEachEntry(arg0: Internal.ObjIntConsumer_<any>): void;
        static of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, ...arg6: E[]): Internal.ImmutableMultiset<E>;
        static toImmutableMultiset(): Internal.Collector<E, any, Internal.ImmutableMultiset<E>>;
        static of(arg0: E, arg1: E, arg2: E): Internal.ImmutableMultiset<E>;
        static of(arg0: E, arg1: E, arg2: E, arg3: E): Internal.ImmutableMultiset<E>;
        static copyOf(arg0: Internal.Iterator_<any>): Internal.ImmutableMultiset<E>;
        elementSet(): Internal.Set<any>;
        static toImmutableMultiset(arg0: Internal.Function_<any, any>, arg1: Internal.ToIntFunction_<any>): Internal.Collector<T, any, Internal.ImmutableMultiset<E>>;
        asList(): Internal.ImmutableList<E>;
        static of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): Internal.ImmutableMultiset<E>;
        static of(arg0: E, arg1: E): Internal.ImmutableMultiset<E>;
        hashCode(): number;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        stream(): Internal.Stream<E>;
        spliterator(): Internal.Spliterator<E>;
        equals(arg0: any): boolean;
    }
    type ImmutableMultiset_<E> = ImmutableMultiset<E>;
    abstract class AmbientCreature extends Internal.Mob {
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        canBeLeashed(arg0: Internal.Player_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type AmbientCreature_ = AmbientCreature;
    class IngredientActionFilter {
        constructor()
        static filterOf(o: any): Internal.IngredientActionFilter;
        copyFrom(filter: Internal.IngredientActionFilter_): void;
        checkFilter(index: number, stack: Internal.ItemStack_): boolean;
        "filterIndex": number;
        "filterIngredient": Internal.IngredientJS;
    }
    type IngredientActionFilter_ = IngredientActionFilter;
    class Properties extends Internal.Hashtable<any, any> {
        constructor()
        constructor(arg0: number)
        constructor(arg0: Internal.Properties_)
        store(arg0: Internal.OutputStream_, arg1: string): void;
        clone(): any;
        save(arg0: Internal.OutputStream_, arg1: string): void;
        storeToXML(arg0: Internal.OutputStream_, arg1: string, arg2: Internal.Charset_): void;
        stringPropertyNames(): Internal.Set<string>;
        containsValue(arg0: any): boolean;
        storeToXML(arg0: Internal.OutputStream_, arg1: string): void;
        getOrDefault(arg0: any, arg1: any): any;
        list(arg0: Internal.PrintWriter_): void;
        putAll(arg0: Internal.Map_<any, any>): void;
        isEmpty(): boolean;
        getProperty(arg0: string, arg1: string): string;
        keys(): Internal.Enumeration<any>;
        containsKey(arg0: any): boolean;
        keySet(): Internal.Set<any>;
        replaceAll(arg0: Internal.BiFunction_<any, any, any>): void;
        setProperty(arg0: string, arg1: string): any;
        store(arg0: Internal.Writer_, arg1: string): void;
        replace(arg0: any, arg1: any, arg2: any): boolean;
        put(arg0: any, arg1: any): any;
        contains(arg0: any): boolean;
        values(): Internal.Collection<any>;
        load(arg0: Internal.Reader_): void;
        load(arg0: Internal.InputStream_): void;
        toString(): string;
        loadFromXML(arg0: Internal.InputStream_): void;
        computeIfAbsent(arg0: any, arg1: Internal.Function_<any, any>): any;
        propertyNames(): Internal.Enumeration<any>;
        remove(arg0: any, arg1: any): boolean;
        list(arg0: Internal.PrintStream_): void;
        size(): number;
        hashCode(): number;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        entrySet(): Internal.Set<Internal.Map$Entry<any, any>>;
        elements(): Internal.Enumeration<any>;
        clear(): void;
        replace(arg0: any, arg1: any): any;
        getProperty(arg0: string): string;
        merge(arg0: any, arg1: any, arg2: Internal.BiFunction_<any, any, any>): any;
        remove(arg0: any): any;
        equals(arg0: any): boolean;
        compute(arg0: any, arg1: Internal.BiFunction_<any, any, any>): any;
        get(arg0: any): any;
        storeToXML(arg0: Internal.OutputStream_, arg1: string, arg2: string): void;
        computeIfPresent(arg0: any, arg1: Internal.BiFunction_<any, any, any>): any;
        putIfAbsent(arg0: any, arg1: any): any;
        get empty(): boolean
    }
    type Properties_ = Properties;
    interface LongStream extends Internal.BaseStream<number, Internal.LongStream> {
        builder(): Internal.LongStream$Builder;
        mapMulti(arg0: Internal.LongStream$LongMapMultiConsumer_): this;
        limit(arg0: number): this;
        flatMap(arg0: Internal.LongFunction_<any>): this;
        parallel(): this;
        allMatch(arg0: Internal.LongPredicate_): boolean;
        range(arg0: number, arg1: number): this;
        rangeClosed(arg0: number, arg1: number): this;
        sequential(): Internal.BaseStream<any, any>;
        peek(arg0: Internal.LongConsumer_): this;
        sorted(): this;
        sum(): number;
        summaryStatistics(): Internal.LongSummaryStatistics;
        toArray(): number[];
        forEach(arg0: Internal.LongConsumer_): void;
        max(): Internal.OptionalLong;
        count(): number;
        iterate(arg0: number, arg1: Internal.LongUnaryOperator_): this;
        anyMatch(arg0: Internal.LongPredicate_): boolean;
        of(...arg0: number[]): this;
        iterator(): Internal.Iterator<any>;
        of(arg0: number): this;
        empty(): this;
        findAny(): Internal.OptionalLong;
        skip(arg0: number): this;
        takeWhile(arg0: Internal.LongPredicate_): this;
        asDoubleStream(): Internal.DoubleStream;
        spliterator(): Internal.Spliterator$OfLong;
        distinct(): this;
        map(arg0: Internal.LongUnaryOperator_): this;
        iterate(arg0: number, arg1: Internal.LongPredicate_, arg2: Internal.LongUnaryOperator_): this;
        min(): Internal.OptionalLong;
        filter(arg0: Internal.LongPredicate_): this;
        mapToDouble(arg0: Internal.LongToDoubleFunction_): Internal.DoubleStream;
        findFirst(): Internal.OptionalLong;
        forEachOrdered(arg0: Internal.LongConsumer_): void;
        mapToObj(arg0: Internal.LongFunction_<any>): Internal.Stream<U>;
        dropWhile(arg0: Internal.LongPredicate_): this;
        reduce(arg0: Internal.LongBinaryOperator_): Internal.OptionalLong;
        noneMatch(arg0: Internal.LongPredicate_): boolean;
        mapToInt(arg0: Internal.LongToIntFunction_): Internal.IntStream;
        concat(arg0: Internal.LongStream_, arg1: Internal.LongStream_): this;
        boxed(): Internal.Stream<number>;
        reduce(arg0: number, arg1: Internal.LongBinaryOperator_): number;
        average(): Internal.OptionalDouble;
        generate(arg0: Internal.LongSupplier_): this;
        collect(arg0: Internal.Supplier_<R>, arg1: Internal.ObjLongConsumer_<R>, arg2: Internal.BiConsumer_<R, R>): R;
    }
    type LongStream_ = LongStream;
    interface Executor {
        execute(arg0: Internal.Runnable_): void;
    }
    type Executor_ = Executor;
    abstract class AbstractDragonSittingPhase extends Internal.AbstractDragonPhaseInstance {
        constructor(arg0: Internal.EnderDragon_)
        onHurt(arg0: Internal.DamageSource_, arg1: number): number;
        isSitting(): boolean;
        get sitting(): boolean
    }
    type AbstractDragonSittingPhase_ = AbstractDragonSittingPhase;
    interface ByteProcessor {
        process(arg0: number): boolean;
        readonly static "FIND_NUL": any;
        readonly static "FIND_LINEAR_WHITESPACE": any;
        readonly static "FIND_CRLF": any;
        readonly static "FIND_SEMI_COLON": any;
        readonly static "FIND_NON_CR": any;
        readonly static "FIND_LF": any;
        readonly static "FIND_CR": any;
        readonly static "FIND_NON_LF": any;
        readonly static "FIND_NON_NUL": any;
        readonly static "FIND_ASCII_SPACE": any;
        readonly static "FIND_NON_LINEAR_WHITESPACE": any;
        readonly static "FIND_NON_CRLF": any;
        readonly static "FIND_COMMA": any;
    }
    type ByteProcessor_ = ByteProcessor;
    class Vector4f {
        constructor()
        constructor(arg0: Internal.Vector3f_)
        constructor(arg0: number, arg1: number, arg2: number, arg3: number)
        setW(arg0: number): void;
        y(): number;
        setX(arg0: number): void;
        z(): number;
        w(): number;
        x(): number;
        transform(arg0: Internal.Matrix4f_): void;
        toString(): string;
        transform(arg0: Internal.Quaternion_): void;
        normalize(): boolean;
        lerp(arg0: Internal.Vector4f_, arg1: number): void;
        set(arg0: number[]): void;
        hashCode(): number;
        dot(arg0: Internal.Vector4f_): number;
        set(arg0: number, arg1: number, arg2: number, arg3: number): void;
        perspectiveDivide(): void;
        mul(arg0: Internal.Vector3f_): void;
        equals(arg0: any): boolean;
        setY(arg0: number): void;
        add(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setZ(arg0: number): void;
        mul(arg0: number): void;
        set w(arg0: number)
        set x(arg0: number)
        set y(arg0: number)
        set z(arg0: number)
    }
    type Vector4f_ = Vector4f;
    class SynchedEntityData {
        constructor(arg0: Internal.Entity_)
        clearDirty(): void;
        set(arg0: Internal.EntityDataAccessor_<T>, arg1: T): void;
        get(arg0: Internal.EntityDataAccessor_<T>): T;
        packDirty(): Internal.List<Internal.SynchedEntityData$DataItem<any>>;
        assignValues(arg0: Internal.List_<Internal.SynchedEntityData$DataItem_<any>>): void;
        isEmpty(): boolean;
        isDirty(): boolean;
        getAll(): Internal.List<Internal.SynchedEntityData$DataItem<any>>;
        static defineId(arg0: Internal.Class_<any>, arg1: Internal.EntityDataSerializer_<T>): Internal.EntityDataAccessor<T>;
        static unpack(arg0: Internal.FriendlyByteBuf_): Internal.List<Internal.SynchedEntityData$DataItem<any>>;
        define(arg0: Internal.EntityDataAccessor_<T>, arg1: T): void;
        static pack(arg0: Internal.List_<Internal.SynchedEntityData$DataItem_<any>>, arg1: Internal.FriendlyByteBuf_): void;
        get empty(): boolean
        get dirty(): boolean
        get all(): Internal.List<Internal.SynchedEntityData$DataItem<any>>
    }
    type SynchedEntityData_ = SynchedEntityData;
    class ChronoUnit extends Internal.Enum<Internal.ChronoUnit> implements Internal.TemporalUnit {
        between(arg0: Internal.Temporal_, arg1: Internal.Temporal_): number;
        isTimeBased(): boolean;
        static valueOf(arg0: string): Internal.ChronoUnit;
        addTo(arg0: R, arg1: number): R;
        toString(): string;
        getDuration(): Internal.Duration;
        isDurationEstimated(): boolean;
        isDateBased(): boolean;
        isSupportedBy(arg0: Internal.Temporal_): boolean;
        static values(): Internal.ChronoUnit[];
        get timeBased(): boolean
        get duration(): Internal.Duration
        get durationEstimated(): boolean
        get dateBased(): boolean
        readonly static "NANOS": Internal.ChronoUnit;
        readonly static "ERAS": Internal.ChronoUnit;
        readonly static "MINUTES": Internal.ChronoUnit;
        readonly static "HOURS": Internal.ChronoUnit;
        readonly static "MONTHS": Internal.ChronoUnit;
        readonly static "HALF_DAYS": Internal.ChronoUnit;
        readonly static "MILLIS": Internal.ChronoUnit;
        readonly static "DAYS": Internal.ChronoUnit;
        readonly static "SECONDS": Internal.ChronoUnit;
        readonly static "WEEKS": Internal.ChronoUnit;
        readonly static "MILLENNIA": Internal.ChronoUnit;
        readonly static "DECADES": Internal.ChronoUnit;
        readonly static "MICROS": Internal.ChronoUnit;
        readonly static "FOREVER": Internal.ChronoUnit;
        readonly static "CENTURIES": Internal.ChronoUnit;
        readonly static "YEARS": Internal.ChronoUnit;
    }
    type ChronoUnit_ = "minutes" | "years" | "weeks" | "decades" | "eras" | "half_days" | "centuries" | "hours" | "forever" | "months" | "millennia" | "micros" | "nanos" | "seconds" | "days" | "millis" | ChronoUnit;
    class TickEvent$RenderTickEvent extends Internal.TickEvent {
        constructor()
        constructor(arg0: Internal.TickEvent$Phase_, arg1: number)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
        readonly "renderTickTime": number;
    }
    type TickEvent$RenderTickEvent_ = TickEvent$RenderTickEvent;
    class EventJS {
        constructor()
        canCancel(): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        cancel(): void;
        isCancelled(): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        get cancelled(): boolean
    }
    type EventJS_ = EventJS;
    abstract class LongBuffer extends Internal.Buffer implements Internal.Comparable<Internal.LongBuffer> {
        reset(): Internal.Buffer;
        isDirect(): boolean;
        limit(arg0: number): this;
        arrayOffset(): number;
        compareTo(arg0: any): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): this;
        duplicate(): this;
        flip(): Internal.Buffer;
        clear(): Internal.Buffer;
        order(): Internal.ByteOrder;
        mismatch(arg0: Internal.LongBuffer_): number;
        compareTo(arg0: Internal.LongBuffer_): number;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.LongBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): this;
        hasArray(): boolean;
        put(arg0: number, arg1: number): this;
        static allocate(arg0: number): Internal.LongBuffer;
        put(arg0: number, arg1: number[]): this;
        get(arg0: number, arg1: number[]): this;
        get(): number;
        toString(): string;
        position(arg0: number): this;
        get(arg0: number[]): this;
        rewind(): Internal.Buffer;
        put(arg0: number[]): this;
        put(arg0: number): this;
        mark(): Internal.Buffer;
        asReadOnlyBuffer(): this;
        put(arg0: number[], arg1: number, arg2: number): this;
        static wrap(arg0: number[]): Internal.LongBuffer;
        hashCode(): number;
        put(arg0: Internal.LongBuffer_): this;
        slice(): Internal.Buffer;
        put(arg0: number, arg1: Internal.LongBuffer_, arg2: number, arg3: number): this;
        slice(arg0: number, arg1: number): Internal.Buffer;
        get(arg0: number): number;
        equals(arg0: any): boolean;
        array(): number[];
        compact(): this;
        get(arg0: number[], arg1: number, arg2: number): this;
        get direct(): boolean
    }
    type LongBuffer_ = LongBuffer;
    class ElderGuardian extends Internal.Guardian {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        getAttackDuration(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get attackDuration(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        readonly static "ELDER_SIZE_SCALE": 2.35;
    }
    type ElderGuardian_ = ElderGuardian;
    interface SpecialEquality {
        checkSpecialEquality(o: any, o1: any, shallow: boolean): boolean;
        specialEquals(o: any, shallow: boolean): boolean;
    }
    type SpecialEquality_ = SpecialEquality;
    class SpawnData extends Internal.Record {
        constructor()
        constructor(arg0: Internal.CompoundTag_, arg1: Internal.Optional_<Internal.SpawnData$CustomSpawnRules_>)
        hashCode(): number;
        toString(): string;
        customSpawnRules(): Internal.Optional<Internal.SpawnData$CustomSpawnRules>;
        getEntityToSpawn(): Internal.CompoundTag;
        equals(arg0: any): boolean;
        entityToSpawn(): Internal.CompoundTag;
        getCustomSpawnRules(): Internal.Optional<Internal.SpawnData$CustomSpawnRules>;
        get entityToSpawn(): Internal.CompoundTag
        get customSpawnRules(): Internal.Optional<Internal.SpawnData$CustomSpawnRules>
        readonly static "LIST_CODEC": any;
        readonly static "DEFAULT_TYPE": "minecraft:pig";
        readonly static "CODEC": any;
    }
    type SpawnData_ = SpawnData;
    class Direction extends Internal.Enum<Internal.Direction> implements Internal.StringRepresentable {
        static fromYRot(arg0: number): Internal.Direction;
        static valueOf(arg0: string): Internal.Direction;
        getX(): number;
        getY(): number;
        getSerializedName(): string;
        getNormal(): Vec3i;
        getHorizontalIndex(): number;
        static fromNormal(arg0: number, arg1: number, arg2: number): Internal.Direction;
        getIndex(): number;
        static getNearest(arg0: number, arg1: number, arg2: number): Internal.Direction;
        getClockWise(): this;
        getAxis(): Internal.Direction$Axis;
        static orderedByNearest(arg0: Internal.Entity_): Internal.Direction[];
        getClockWise(arg0: Internal.Direction$Axis_): this;
        getPitch(): number;
        static getFacingAxis(arg0: Internal.Entity_, arg1: Internal.Direction$Axis_): Internal.Direction;
        getName(): string;
        static values(): Internal.Direction[];
        getZ(): number;
        static fromAxisAndDirection(arg0: Internal.Direction$Axis_, arg1: Internal.Direction$AxisDirection_): Internal.Direction;
        getOpposite(): this;
        static from2DDataValue(arg0: number): Internal.Direction;
        getAxisDirection(): Internal.Direction$AxisDirection;
        static from3DDataValue(arg0: number): Internal.Direction;
        step(): Internal.Vector3f;
        getCounterClockWise(arg0: Internal.Direction$Axis_): this;
        toString(): string;
        getRotation(): Internal.Quaternion;
        isFacingAngle(arg0: number): boolean;
        static byName(arg0: string): Internal.Direction;
        static getNearest(arg0: number, arg1: number, arg2: number): Internal.Direction;
        getYaw(): number;
        static fromNormal(arg0: BlockPos_): Internal.Direction;
        static get(arg0: Internal.Direction$AxisDirection_, arg1: Internal.Direction$Axis_): Internal.Direction;
        static rotate(arg0: Internal.Matrix4f_, arg1: Internal.Direction_): Internal.Direction;
        getCounterClockWise(): this;
        static getRandom(arg0: Internal.Random_): Internal.Direction;
        get x(): number
        get y(): number
        get serializedName(): string
        get normal(): Vec3i
        get horizontalIndex(): number
        get index(): number
        get clockWise(): Internal.Direction
        get axis(): Internal.Direction$Axis
        get pitch(): number
        get name(): string
        get z(): number
        get opposite(): Internal.Direction
        get axisDirection(): Internal.Direction$AxisDirection
        get rotation(): Internal.Quaternion
        get yaw(): number
        get counterClockWise(): Internal.Direction
        readonly static "UP": Internal.Direction;
        readonly static "NORTH": Internal.Direction;
        readonly static "DOWN": Internal.Direction;
        readonly static "EAST": Internal.Direction;
        readonly static "WEST": Internal.Direction;
        readonly static "CODEC": any;
        readonly static "SOUTH": Internal.Direction;
        readonly static "VERTICAL_CODEC": any;
    }
    type Direction_ = "west" | "east" | "south" | "up" | "down" | "north" | Direction;
    class RuinedPortalFeature$Type extends Internal.Enum<Internal.RuinedPortalFeature$Type> implements Internal.StringRepresentable {
        static values(): Internal.RuinedPortalFeature$Type[];
        getSerializedName(): string;
        getName(): string;
        static valueOf(arg0: string): Internal.RuinedPortalFeature$Type;
        static byName(arg0: string): Internal.RuinedPortalFeature$Type;
        get serializedName(): string
        get name(): string
        readonly static "MOUNTAIN": Internal.RuinedPortalFeature$Type;
        readonly static "STANDARD": Internal.RuinedPortalFeature$Type;
        readonly static "DESERT": Internal.RuinedPortalFeature$Type;
        readonly static "CODEC": any;
        readonly static "JUNGLE": Internal.RuinedPortalFeature$Type;
        readonly static "OCEAN": Internal.RuinedPortalFeature$Type;
        readonly static "SWAMP": Internal.RuinedPortalFeature$Type;
        readonly static "NETHER": Internal.RuinedPortalFeature$Type;
    }
    type RuinedPortalFeature$Type_ = "jungle" | "standard" | "mountain" | "ocean" | "nether" | RuinedPortalFeature$Type | "desert" | "swamp";
    class PieceGeneratorSupplier$Context <C> extends Internal.Record {
        constructor(arg0: Internal.ChunkGenerator_, arg1: Internal.BiomeSource_, arg2: number, arg3: Internal.ChunkPos_, arg4: C, arg5: Internal.LevelHeightAccessor_, arg6: Internal.Predicate_<Internal.Holder_<Internal.Biome_>>, arg7: Internal.StructureManager_, arg8: Internal.RegistryAccess_)
        validBiomeOnTop(arg0: Internal.Heightmap$Types_): boolean;
        toString(): string;
        seed(): number;
        registryAccess(): Internal.RegistryAccess;
        chunkGenerator(): Internal.ChunkGenerator;
        config(): C;
        chunkPos(): Internal.ChunkPos;
        biomeSource(): Internal.BiomeSource;
        hashCode(): number;
        getLowestY(arg0: number, arg1: number): number;
        getCornerHeights(arg0: number, arg1: number, arg2: number, arg3: number): number[];
        heightAccessor(): Internal.LevelHeightAccessor;
        structureManager(): Internal.StructureManager;
        validBiome(): Internal.Predicate<Internal.Holder<Internal.Biome>>;
        equals(arg0: any): boolean;
    }
    type PieceGeneratorSupplier$Context_<C> = PieceGeneratorSupplier$Context<C>;
    interface ItemBuilder$ReleaseUsingCallback {
        releaseUsing(arg0: Internal.ItemStackJS_, arg1: Internal.LevelJS_, arg2: Internal.LivingEntityJS_, arg3: number): void;
    }
    type ItemBuilder$ReleaseUsingCallback_ = ((arg0: Internal.ItemStackJS, arg1: Internal.LevelJS, arg2: Internal.LivingEntityJS, arg3: number)=>void) | ItemBuilder$ReleaseUsingCallback;
    interface WatchKey {
        isValid(): boolean;
        pollEvents(): Internal.List<Internal.WatchEvent<any>>;
        watchable(): Internal.Watchable;
        cancel(): void;
        reset(): boolean;
        get valid(): boolean
    }
    type WatchKey_ = WatchKey;
    class Rotation extends Internal.Enum<Internal.Rotation> {
        static getShuffled(arg0: Internal.Random_): Internal.List<Internal.Rotation>;
        rotate(arg0: Internal.Direction_): Internal.Direction;
        static valueOf(arg0: string): Internal.Rotation;
        static getRandom(arg0: Internal.Random_): Internal.Rotation;
        rotation(): Internal.OctahedralGroup;
        static values(): Internal.Rotation[];
        rotate(arg0: number, arg1: number): number;
        getRotated(arg0: Internal.Rotation_): this;
        readonly static "NONE": Internal.Rotation;
        readonly static "CLOCKWISE_90": Internal.Rotation;
        readonly static "CLOCKWISE_180": Internal.Rotation;
        readonly static "COUNTERCLOCKWISE_90": Internal.Rotation;
    }
    type Rotation_ = "clockwise_90" | "clockwise_180" | "counterclockwise_90" | Rotation | "none";
    class ServerStatus {
        constructor()
        getJson(): string;
        setPlayers(arg0: Internal.ServerStatus$Players_): void;
        setForgeData(arg0: Internal.ServerStatusPing_): void;
        getPlayers(): Internal.ServerStatus$Players;
        getFavicon(): string;
        setVersion(arg0: Internal.ServerStatus$Version_): void;
        getForgeData(): Internal.ServerStatusPing;
        getVersion(): Internal.ServerStatus$Version;
        setFavicon(arg0: string): void;
        invalidateJson(): void;
        setDescription(arg0: Internal.Component_): void;
        getDescription(): Internal.Component;
        get json(): string
        set players(arg0: Internal.ServerStatus$Players_)
        set forgeData(arg0: Internal.ServerStatusPing_)
        get players(): Internal.ServerStatus$Players
        get favicon(): string
        set version(arg0: Internal.ServerStatus$Version_)
        get forgeData(): Internal.ServerStatusPing
        get version(): Internal.ServerStatus$Version
        set favicon(arg0: string)
        set description(arg0: Internal.Component_)
        get description(): Internal.Component
        readonly static "FAVICON_WIDTH": 64;
        readonly static "FAVICON_HEIGHT": 64;
    }
    type ServerStatus_ = ServerStatus;
    class LivingAttackEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.LivingEntity_, arg1: Internal.DamageSource_, arg2: number)
        isCancelable(): boolean;
        getAmount(): number;
        getListenerList(): Internal.ListenerList;
        getSource(): Internal.DamageSource;
        get cancelable(): boolean
        get amount(): number
        get listenerList(): Internal.ListenerList
        get source(): Internal.DamageSource
    }
    type LivingAttackEvent_ = LivingAttackEvent;
    class PlayMessages$SpawnEntity {
        static encode(arg0: Internal.PlayMessages$SpawnEntity_, arg1: Internal.FriendlyByteBuf_): void;
        getVelY(): number;
        getVelZ(): number;
        getHeadYaw(): number;
        getVelX(): number;
        static decode(arg0: Internal.FriendlyByteBuf_): Internal.PlayMessages$SpawnEntity;
        getTypeId(): number;
        getEntity(): Internal.Entity;
        getPosZ(): number;
        getPosY(): number;
        static handle(arg0: Internal.PlayMessages$SpawnEntity_, arg1: Internal.Supplier_<Internal.NetworkEvent$Context_>): void;
        getPosX(): number;
        getEntityId(): number;
        getAdditionalData(): Internal.FriendlyByteBuf;
        getUuid(): Internal.UUID;
        getPitch(): number;
        getYaw(): number;
        get velY(): number
        get velZ(): number
        get headYaw(): number
        get velX(): number
        get typeId(): number
        get entity(): Internal.Entity
        get posZ(): number
        get posY(): number
        get posX(): number
        get entityId(): number
        get additionalData(): Internal.FriendlyByteBuf
        get uuid(): Internal.UUID
        get pitch(): number
        get yaw(): number
    }
    type PlayMessages$SpawnEntity_ = PlayMessages$SpawnEntity;
    class FeaturePoolElement extends Internal.StructurePoolElement {
        getType(): Internal.StructurePoolElementType<any>;
        getSize(arg0: Internal.StructureManager_, arg1: Internal.Rotation_): Vec3i;
        toString(): string;
        place(arg0: Internal.StructureManager_, arg1: Internal.WorldGenLevel_, arg2: Internal.StructureFeatureManager_, arg3: Internal.ChunkGenerator_, arg4: BlockPos_, arg5: BlockPos_, arg6: Internal.Rotation_, arg7: Internal.BoundingBox_, arg8: Internal.Random_, arg9: boolean): boolean;
        getShuffledJigsawBlocks(arg0: Internal.StructureManager_, arg1: BlockPos_, arg2: Internal.Rotation_, arg3: Internal.Random_): Internal.List<Internal.StructureTemplate$StructureBlockInfo>;
        getBoundingBox(arg0: Internal.StructureManager_, arg1: BlockPos_, arg2: Internal.Rotation_): Internal.BoundingBox;
        get type(): Internal.StructurePoolElementType<any>
        readonly static "CODEC": any;
    }
    type FeaturePoolElement_ = FeaturePoolElement;
    interface Color extends Internal.SpecialEquality {
        getSerializeJS(): string;
        createTextColorJS(): Internal.TextColor;
        getArgbJS(): number;
        specialEquals(o: any, shallow: boolean): boolean;
        getHexJS(): string;
        getRgbJS(): number;
        getFireworkColorJS(): number;
        get serializeJS(): string
        get argbJS(): number
        get hexJS(): string
        get rgbJS(): number
        get fireworkColorJS(): number
    }
    type Color_ = Color;
    class AttributeMap {
        constructor(arg0: Internal.AttributeSupplier_)
        load(arg0: Internal.ListTag_): void;
        getDirtyAttributes(): Internal.Set<Internal.AttributeInstance>;
        removeAttributeModifiers(arg0: Internal.Multimap_<Internal.Attribute_, Internal.AttributeModifier_>): void;
        hasModifier(arg0: Internal.Attribute_, arg1: Internal.UUID_): boolean;
        getInstance(arg0: Internal.Attribute_): Internal.AttributeInstance;
        assignValues(arg0: Internal.AttributeMap_): void;
        hasAttribute(arg0: Internal.Attribute_): boolean;
        getBaseValue(arg0: Internal.Attribute_): number;
        getSyncableAttributes(): Internal.Collection<Internal.AttributeInstance>;
        save(): Internal.ListTag;
        getValue(arg0: Internal.Attribute_): number;
        addTransientAttributeModifiers(arg0: Internal.Multimap_<Internal.Attribute_, Internal.AttributeModifier_>): void;
        getModifierValue(arg0: Internal.Attribute_, arg1: Internal.UUID_): number;
        get dirtyAttributes(): Internal.Set<Internal.AttributeInstance>
        get syncableAttributes(): Internal.Collection<Internal.AttributeInstance>
    }
    type AttributeMap_ = AttributeMap;
    class ClientboundSetHealthPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: number, arg2: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getHealth(): number;
        getFood(): number;
        getSaturation(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get health(): number
        get food(): number
        get saturation(): number
        get skippable(): boolean
    }
    type ClientboundSetHealthPacket_ = ClientboundSetHealthPacket;
    interface Predicate <T> {
        negate(): this;
        or(arg0: Internal.Predicate_<any>): this;
        test(arg0: T): boolean;
        not(arg0: Internal.Predicate_<any>): this;
        and(arg0: Internal.Predicate_<any>): this;
        isEqual(arg0: any): this;
    }
    type Predicate_<T> = Predicate<T> | ((arg0: T)=>boolean);
    interface FileAttributeView extends Internal.AttributeView {
    }
    type FileAttributeView_ = FileAttributeView;
    interface DensityFunction$FunctionContext {
        blockX(): number;
        getBlender(): Internal.Blender;
        blockZ(): number;
        blockY(): number;
        get blender(): Internal.Blender
    }
    type DensityFunction$FunctionContext_ = DensityFunction$FunctionContext;
    class NopProcessor extends Internal.StructureProcessor {
        processBlock(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.StructureTemplate$StructureBlockInfo_, arg4: Internal.StructureTemplate$StructureBlockInfo_, arg5: Internal.StructurePlaceSettings_): Internal.StructureTemplate$StructureBlockInfo;
        readonly static "CODEC": any;
        readonly static "INSTANCE": Internal.NopProcessor;
    }
    type NopProcessor_ = NopProcessor;
    class RandomTickCallbackJS {
        constructor(containerJS: Internal.BlockContainerJS_, random: Internal.Random_)
        getLevel(): Internal.LevelJS;
        getServer(): Internal.ServerJS;
        get level(): Internal.LevelJS
        get server(): Internal.ServerJS
        "random": Internal.Random;
        "block": Internal.BlockContainerJS;
    }
    type RandomTickCallbackJS_ = RandomTickCallbackJS;
    class ItemModificationEventJS extends Internal.EventJS {
        constructor()
        modify(in_: Internal.IngredientJS_, c: Internal.Consumer_<Internal.ItemModificationProperties_>): void;
    }
    type ItemModificationEventJS_ = ItemModificationEventJS;
    abstract class Certificate implements Internal.Serializable {
        hashCode(): number;
        verify(arg0: Internal.PublicKey_, arg1: string): void;
        toString(): string;
        getPublicKey(): Internal.PublicKey;
        getType(): string;
        verify(arg0: Internal.PublicKey_, arg1: Internal.Provider_): void;
        getEncoded(): number[];
        equals(arg0: any): boolean;
        verify(arg0: Internal.PublicKey_): void;
        get publicKey(): Internal.PublicKey
        get type(): string
        get encoded(): number[]
    }
    type Certificate_ = Certificate;
    interface SortedMap <K, V> extends Internal.Map<K, V> {
        replace(arg0: K, arg1: V): V;
        keySet(): Internal.Set<K>;
        subMap(arg0: K, arg1: K): this;
        comparator(): Internal.Comparator<any>;
        putIfAbsent(arg0: K, arg1: V): V;
        values(): Internal.Collection<V>;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        getOrDefault(arg0: any, arg1: V): V;
        remove(arg0: any, arg1: any): boolean;
        tailMap(arg0: K): this;
        computeIfAbsent(arg0: K, arg1: Internal.Function_<any, any>): V;
        lastKey(): K;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        replaceAll(arg0: Internal.BiFunction_<any, any, any>): void;
        headMap(arg0: K): this;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        firstKey(): K;
        compute(arg0: K, arg1: Internal.BiFunction_<any, any, any>): V;
        merge(arg0: K, arg1: V, arg2: Internal.BiFunction_<any, any, any>): V;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<any, any, any>): V;
    }
    type SortedMap_<K, V> = SortedMap<K, V>;
    interface Double2ObjectFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: any, arg1: V): V;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Double2DoubleFunction;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Double2LongFunction;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2ObjectFunction<V>;
        remove(arg0: number): V;
        composeDouble(arg0: Internal.Double2DoubleFunction_): this;
        containsKey(arg0: any): boolean;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Double2CharFunction;
        put(arg0: number, arg1: V): V;
        composeObject(arg0: Internal.Object2DoubleFunction_<any>): Internal.Object2ObjectFunction<T, V>;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2ObjectFunction<V>;
        composeReference(arg0: Internal.Reference2DoubleFunction_<any>): Internal.Reference2ObjectFunction<T, V>;
        get(arg0: any): V;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): V;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Double2ByteFunction;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Double2ShortFunction;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2ObjectFunction<V>;
        apply(arg0: number): V;
        andThenObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Double2ObjectFunction<T>;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2ObjectFunction<V>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
        apply(arg0: number): V;
        put(arg0: number, arg1: V): V;
        andThenReference(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Double2ReferenceFunction<T>;
        get(arg0: number): V;
        containsKey(arg0: number): boolean;
        getOrDefault(arg0: number, arg1: V): V;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Double2FloatFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        size(): number;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Double2IntFunction;
        clear(): void;
        defaultReturnValue(): V;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2ObjectFunction<V>;
        defaultReturnValue(arg0: V): void;
    }
    type Double2ObjectFunction_<V> = ((arg0: number)=>V) | Double2ObjectFunction<V>;
    class AtomicReference <V> implements Internal.Serializable {
        constructor()
        constructor(arg0: V)
        weakCompareAndSetPlain(arg0: V, arg1: V): boolean;
        updateAndGet(arg0: Internal.UnaryOperator_<V>): V;
        getAndSet(arg0: V): V;
        weakCompareAndSetRelease(arg0: V, arg1: V): boolean;
        setPlain(arg0: V): void;
        toString(): string;
        weakCompareAndSetAcquire(arg0: V, arg1: V): boolean;
        getAndUpdate(arg0: Internal.UnaryOperator_<V>): V;
        getOpaque(): V;
        getAcquire(): V;
        compareAndExchangeAcquire(arg0: V, arg1: V): V;
        weakCompareAndSetVolatile(arg0: V, arg1: V): boolean;
        lazySet(arg0: V): void;
        get(): V;
        setRelease(arg0: V): void;
        compareAndExchangeRelease(arg0: V, arg1: V): V;
        compareAndSet(arg0: V, arg1: V): boolean;
        weakCompareAndSet(arg0: V, arg1: V): boolean;
        setOpaque(arg0: V): void;
        compareAndExchange(arg0: V, arg1: V): V;
        accumulateAndGet(arg0: V, arg1: Internal.BinaryOperator_<V>): V;
        getPlain(): V;
        getAndAccumulate(arg0: V, arg1: Internal.BinaryOperator_<V>): V;
        set(arg0: V): void;
        set plain(arg0: V)
        get opaque(): V
        get acquire(): V
        set release(arg0: V)
        set opaque(arg0: V)
        get plain(): V
    }
    type AtomicReference_<V> = AtomicReference<V>;
    class SerializerType <T> {
        constructor(arg0: Internal.Serializer_<any>)
        getSerializer(): Internal.Serializer<any>;
        get serializer(): Internal.Serializer<any>
    }
    type SerializerType_<T> = SerializerType<T>;
    class BlockRenderDispatcher implements Internal.ResourceManagerReloadListener {
        constructor(arg0: Internal.BlockModelShaper_, arg1: Internal.BlockEntityWithoutLevelRenderer_, arg2: Internal.BlockColors_)
        renderSingleBlock(arg0: Internal.BlockState_, arg1: Internal.PoseStack_, arg2: Internal.MultiBufferSource_, arg3: number, arg4: number): void;
        renderBatched(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.BlockAndTintGetter_, arg3: Internal.PoseStack_, arg4: Internal.VertexConsumer_, arg5: boolean, arg6: Internal.Random_, arg7: Internal.IModelData_): boolean;
        renderLiquid(arg0: BlockPos_, arg1: Internal.BlockAndTintGetter_, arg2: Internal.VertexConsumer_, arg3: Internal.BlockState_, arg4: Internal.FluidState_): boolean;
        renderBreakingTexture(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.BlockAndTintGetter_, arg3: Internal.PoseStack_, arg4: Internal.VertexConsumer_, arg5: Internal.IModelData_): void;
        onResourceManagerReload(arg0: Internal.ResourceManager_): void;
        getBlockModelShaper(): Internal.BlockModelShaper;
        renderBatched(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.BlockAndTintGetter_, arg3: Internal.PoseStack_, arg4: Internal.VertexConsumer_, arg5: boolean, arg6: Internal.Random_): boolean;
        renderSingleBlock(arg0: Internal.BlockState_, arg1: Internal.PoseStack_, arg2: Internal.MultiBufferSource_, arg3: number, arg4: number, arg5: Internal.IModelData_): void;
        getModelRenderer(): Internal.ModelBlockRenderer;
        getBlockModel(arg0: Internal.BlockState_): Internal.BakedModel;
        getName(): string;
        renderBreakingTexture(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.BlockAndTintGetter_, arg3: Internal.PoseStack_, arg4: Internal.VertexConsumer_): void;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        get blockModelShaper(): Internal.BlockModelShaper
        get modelRenderer(): Internal.ModelBlockRenderer
        get name(): string
    }
    type BlockRenderDispatcher_ = BlockRenderDispatcher;
    class PickaxeItemBuilder extends Internal.HandheldItemBuilder {
        constructor(i: ResourceLocation_)
        createObject(): Internal.Item;
    }
    type PickaxeItemBuilder_ = PickaxeItemBuilder;
    abstract class StructureFeature <C> extends Internal.ForgeRegistryEntry<Internal.StructureFeature<any>> {
        constructor(arg0: Internal.Codec_<C>, arg1: Internal.PieceGeneratorSupplier_<C>, arg2: Internal.PostPlacementProcessor_)
        constructor(arg0: Internal.Codec_<C>, arg1: Internal.PieceGeneratorSupplier_<C>)
        configuredStructureCodec(): Internal.Codec<Internal.ConfiguredStructureFeature<C, Internal.StructureFeature<C>>>;
        configured(arg0: C, arg1: Internal.TagKey_<Internal.Biome_>, arg2: Internal.Map_<Internal.MobCategory_, Internal.StructureSpawnOverride_>): Internal.ConfiguredStructureFeature<C, any>;
        canGenerate(arg0: Internal.RegistryAccess_, arg1: Internal.ChunkGenerator_, arg2: Internal.BiomeSource_, arg3: Internal.StructureManager_, arg4: number, arg5: Internal.ChunkPos_, arg6: C, arg7: Internal.LevelHeightAccessor_, arg8: Internal.Predicate_<Internal.Holder_<Internal.Biome_>>): boolean;
        step(): DecorationGenerationStep;
        static getLocatePos(arg0: Internal.RandomSpreadStructurePlacement_, arg1: Internal.ChunkPos_): BlockPos;
        getPostPlacementProcessor(): Internal.PostPlacementProcessor;
        configured(arg0: C, arg1: Internal.TagKey_<Internal.Biome_>, arg2: boolean): Internal.ConfiguredStructureFeature<C, any>;
        static bootstrap(): void;
        configured(arg0: C, arg1: Internal.TagKey_<Internal.Biome_>): Internal.ConfiguredStructureFeature<C, any>;
        pieceGeneratorSupplier(): Internal.PieceGeneratorSupplier<C>;
        configured(arg0: C, arg1: Internal.TagKey_<Internal.Biome_>, arg2: boolean, arg3: Internal.Map_<Internal.MobCategory_, Internal.StructureSpawnOverride_>): Internal.ConfiguredStructureFeature<C, any>;
        static loadStaticStart(arg0: Internal.StructurePieceSerializationContext_, arg1: Internal.CompoundTag_, arg2: number): Internal.StructureStart;
        get postPlacementProcessor(): Internal.PostPlacementProcessor
        readonly static "JUNGLE_TEMPLE": any;
        readonly static "OCEAN_RUIN": any;
        readonly static "BURIED_TREASURE": any;
        readonly static "WOODLAND_MANSION": any;
        readonly static "VILLAGE": any;
        readonly static "NETHER_FOSSIL": any;
        readonly static "MAX_STRUCTURE_RANGE": 8;
        readonly static "SWAMP_HUT": any;
        readonly static "OCEAN_MONUMENT": any;
        readonly static "MINESHAFT": any;
        readonly static "STRONGHOLD": any;
        readonly static "RUINED_PORTAL": any;
        readonly static "SHIPWRECK": any;
        readonly static "BASTION_REMNANT": any;
        readonly static "PILLAGER_OUTPOST": any;
        readonly static "IGLOO": any;
        readonly static "FORTRESS": any;
        readonly static "END_CITY": any;
        readonly static "DESERT_PYRAMID": any;
    }
    type StructureFeature_<C> = Special.StructureFeature | StructureFeature<C>;
    class TickEvent$Type extends Internal.Enum<Internal.TickEvent$Type> {
        static valueOf(arg0: string): Internal.TickEvent$Type;
        static values(): Internal.TickEvent$Type[];
        readonly static "RENDER": Internal.TickEvent$Type;
        readonly static "WORLD": Internal.TickEvent$Type;
        readonly static "CLIENT": Internal.TickEvent$Type;
        readonly static "SERVER": Internal.TickEvent$Type;
        readonly static "PLAYER": Internal.TickEvent$Type;
    }
    type TickEvent$Type_ = "player" | "world" | "server" | "client" | TickEvent$Type | "render";
    interface WorldGenLevel extends Internal.ServerLevelAccessor {
        getBlockTint(arg0: BlockPos_, arg1: Internal.ColorResolver_): number;
        getMinSection(): number;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_): Internal.Player;
        findFreePosition(arg0: Internal.Entity_, arg1: Internal.VoxelShape_, arg2: Vec3_, arg3: number, arg4: number, arg5: number): Internal.Optional<Vec3>;
        getSeed(): number;
        dayTime(): number;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        isUnobstructed(arg0: Internal.Entity_, arg1: Internal.VoxelShape_): boolean;
        getMaxSection(): number;
        gameEvent(arg0: Internal.GameEvent_, arg1: Internal.Entity_): void;
        getBrightness(arg0: Internal.LightLayer_, arg1: BlockPos_): number;
        getNearestPlayer(arg0: Internal.Entity_, arg1: number): Internal.Player;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getBlockStatesIfLoaded(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getSectionYFromSectionIndex(arg0: number): number;
        isEmptyBlock(arg0: BlockPos_): boolean;
        getMaxLocalRawBrightness(arg0: BlockPos_, arg1: number): number;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        getBlockCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        getRawBrightness(arg0: BlockPos_, arg1: number): number;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        getTimeOfDay(arg0: number): number;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getHeightmapPos(arg0: Internal.Heightmap$Types_, arg1: BlockPos_): BlockPos;
        blockUpdated(arg0: BlockPos_, arg1: Internal.Block_): void;
        getDifficulty(): Internal.Difficulty;
        canSeeSky(arg0: BlockPos_): boolean;
        getMoonPhase(): number;
        isUnobstructed(arg0: Internal.Entity_): boolean;
        getEntities(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.Entity>;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_): Internal.List<T>;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        addFreshEntityWithPassengers(arg0: Internal.Entity_): void;
        getBrightness(arg0: BlockPos_): number;
        getNearestEntity(arg0: Internal.List_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number): T;
        getPlayerByUUID(arg0: Internal.UUID_): Internal.Player;
        canSeeSkyFromBelowWater(arg0: BlockPos_): boolean;
        getSectionsCount(): number;
        getMinBuildHeight(): number;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Fluid_, arg2: number): void;
        getSectionIndexFromSectionY(arg0: number): number;
        getNearbyPlayers(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: Internal.AABB_): Internal.List<Internal.Player>;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): Internal.Player;
        setBlock(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: number): boolean;
        noCollision(arg0: Internal.Entity_): boolean;
        getChunk(arg0: number, arg1: number, arg2: Internal.ChunkStatus_): Internal.ChunkAccess;
        hasChunkAt(arg0: number, arg1: number): boolean;
        getSectionIndex(arg0: number): number;
        ensureCanWrite(arg0: BlockPos_): boolean;
        hasChunk(arg0: number, arg1: number): boolean;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: number, arg2: number, arg3: number): Internal.Player;
        getMaxBuildHeight(): number;
        getNearbyEntities(arg0: Internal.Class_<T>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: Internal.AABB_): Internal.List<T>;
        hasChunksAt(arg0: BlockPos_, arg1: BlockPos_): boolean;
        destroyBlock(arg0: BlockPos_, arg1: boolean): boolean;
        getMoonBrightness(): number;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Block_, arg2: number): void;
        addFreshEntity(arg0: Internal.Entity_): boolean;
        noCollision(arg0: Internal.AABB_): boolean;
        getChunk(arg0: number, arg1: number): Internal.ChunkAccess;
        isWaterAt(arg0: BlockPos_): boolean;
        getDirectSignal(arg0: BlockPos_, arg1: Internal.Direction_): number;
        getCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        destroyBlock(arg0: BlockPos_, arg1: boolean, arg2: Internal.Entity_): boolean;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        getEntityCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.VoxelShape>;
        collidesWithSuffocatingBlock(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getHeight(): number;
        getNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        setCurrentlyGenerating(arg0: Internal.Supplier_<string>): void;
        noCollision(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getChunk(arg0: BlockPos_): Internal.ChunkAccess;
        gameEvent(arg0: Internal.GameEvent_, arg1: BlockPos_): void;
        isOutsideBuildHeight(arg0: number): boolean;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Fluid_, arg2: number, arg3: Internal.TickPriority_): void;
        gameEvent(arg0: Internal.Entity_, arg1: Internal.GameEvent_, arg2: Internal.Entity_): void;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Predicate_<Internal.Entity_>): Internal.Player;
        getMaxLocalRawBrightness(arg0: BlockPos_): number;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getNearestEntity(arg0: Internal.Class_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number, arg6: Internal.AABB_): T;
        isUnobstructed(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.CollisionContext_): boolean;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_, arg2: Internal.Predicate_<any>): Internal.List<T>;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        hasChunkAt(arg0: BlockPos_): boolean;
        levelEvent(arg0: number, arg1: BlockPos_, arg2: number): void;
        getBiome(arg0: BlockPos_): Internal.Holder<Internal.Biome>;
        getChunkForCollisions(arg0: number, arg1: number): Internal.BlockGetter;
        containsAnyLiquid(arg0: Internal.AABB_): boolean;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Block_, arg2: number, arg3: Internal.TickPriority_): void;
        hasNearbyAlivePlayer(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getMaxLightLevel(): number;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: number, arg3: number, arg4: number): Internal.Player;
        get minSection(): number
        get seed(): number
        get maxSection(): number
        get difficulty(): Internal.Difficulty
        get moonPhase(): number
        get sectionsCount(): number
        get minBuildHeight(): number
        get maxBuildHeight(): number
        get moonBrightness(): number
        get height(): number
        set currentlyGenerating(arg0: Internal.Supplier_<string>)
        get maxLightLevel(): number
    }
    type WorldGenLevel_ = WorldGenLevel;
    abstract class ByteBuf implements Internal.Comparable<Internal.ByteBuf>, Internal.ReferenceCounted {
        constructor()
        getBytes(arg0: number, arg1: Internal.OutputStream_, arg2: number): this;
        indexOf(arg0: number, arg1: number, arg2: number): number;
        readShortLE(): number;
        readableBytes(): number;
        writeInt(arg0: number): this;
        readDouble(): number;
        maxFastWritableBytes(): number;
        skipBytes(arg0: number): this;
        forEachByteDesc(arg0: Internal.ByteProcessor_): number;
        markReaderIndex(): this;
        nioBufferCount(): number;
        markWriterIndex(): this;
        nioBuffers(): Internal.ByteBuffer[];
        writeBytes(arg0: number[], arg1: number, arg2: number): this;
        getShortLE(arg0: number): number;
        getFloat(arg0: number): number;
        writeFloat(arg0: number): this;
        setBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        memoryAddress(): number;
        setFloat(arg0: number, arg1: number): this;
        ensureWritable(arg0: number): this;
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        resetWriterIndex(): this;
        isReadable(arg0: number): boolean;
        getMediumLE(arg0: number): number;
        maxWritableBytes(): number;
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel_, arg2: number): number;
        readUnsignedMedium(): number;
        isReadable(): boolean;
        readIntLE(): number;
        getByte(arg0: number): number;
        writeShort(arg0: number): this;
        getMedium(arg0: number): number;
        bytesBefore(arg0: number, arg1: number): number;
        writeBytes(arg0: Internal.InputStream_, arg1: number): number;
        retain(arg0: number): Internal.ReferenceCounted;
        compareTo(arg0: Internal.ByteBuf_): number;
        touch(arg0: any): Internal.ReferenceCounted;
        readUnsignedMediumLE(): number;
        readBoolean(): boolean;
        writeIntLE(arg0: number): this;
        setMediumLE(arg0: number, arg1: number): this;
        slice(): this;
        writeMedium(arg0: number): this;
        copy(arg0: number, arg1: number): this;
        setCharSequence(arg0: number, arg1: Internal.CharSequence_, arg2: Internal.Charset_): number;
        isReadOnly(): boolean;
        resetReaderIndex(): this;
        setDoubleLE(arg0: number, arg1: number): this;
        writeLongLE(arg0: number): this;
        writeCharSequence(arg0: Internal.CharSequence_, arg1: Internal.Charset_): number;
        readBytes(arg0: number[]): this;
        getBytes(arg0: number, arg1: Internal.ByteBuf_): this;
        readByte(): number;
        writerIndex(arg0: number): this;
        readUnsignedShort(): number;
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        writeMediumLE(arg0: number): this;
        writeBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        forEachByte(arg0: Internal.ByteProcessor_): number;
        setBytes(arg0: number, arg1: Internal.ByteBuf_): this;
        isContiguous(): boolean;
        setLongLE(arg0: number, arg1: number): this;
        arrayOffset(): number;
        readBytes(arg0: Internal.ByteBuffer_): this;
        retainedSlice(arg0: number, arg1: number): this;
        getUnsignedByte(arg0: number): number;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): this;
        readBytes(arg0: Internal.ByteBuf_, arg1: number): this;
        readBytes(arg0: number[], arg1: number, arg2: number): this;
        retainedSlice(): this;
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        setShort(arg0: number, arg1: number): this;
        getUnsignedInt(arg0: number): number;
        getUnsignedMedium(arg0: number): number;
        getUnsignedMediumLE(arg0: number): number;
        toString(): string;
        readDoubleLE(): number;
        getBoolean(arg0: number): boolean;
        writeZero(arg0: number): this;
        maxCapacity(): number;
        nioBuffer(): Internal.ByteBuffer;
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset_): Internal.CharSequence;
        clear(): this;
        readBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        readMedium(): number;
        unwrap(): this;
        retain(): Internal.ReferenceCounted;
        readUnsignedShortLE(): number;
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        writeBytes(arg0: number[]): this;
        discardReadBytes(): this;
        writeChar(arg0: number): this;
        setBytes(arg0: number, arg1: Internal.InputStream_, arg2: number): number;
        getFloatLE(arg0: number): number;
        duplicate(): this;
        isWritable(): boolean;
        readerIndex(): number;
        getDouble(arg0: number): number;
        setByte(arg0: number, arg1: number): this;
        readBytes(arg0: Internal.GatheringByteChannel_, arg1: number): number;
        capacity(arg0: number): this;
        isDirect(): boolean;
        readUnsignedInt(): number;
        writeDouble(arg0: number): this;
        writerIndex(): number;
        retainedDuplicate(): this;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): this;
        touch(): this;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): this;
        setShortLE(arg0: number, arg1: number): this;
        compareTo(arg0: any): number;
        setFloatLE(arg0: number, arg1: number): this;
        setLong(arg0: number, arg1: number): this;
        readMediumLE(): number;
        writeFloatLE(arg0: number): this;
        writableBytes(): number;
        order(): Internal.ByteOrder;
        getUnsignedIntLE(arg0: number): number;
        getChar(arg0: number): string;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number): this;
        readChar(): string;
        setInt(arg0: number, arg1: number): this;
        discardSomeReadBytes(): this;
        bytesBefore(arg0: number, arg1: number, arg2: number): number;
        isWritable(arg0: number): boolean;
        alloc(): Internal.ByteBufAllocator;
        bytesBefore(arg0: number): number;
        readInt(): number;
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        readRetainedSlice(arg0: number): this;
        setChar(arg0: number, arg1: number): this;
        setBytes(arg0: number, arg1: number[]): this;
        readFloatLE(): number;
        writeBytes(arg0: Internal.ByteBuffer_): this;
        writeShortLE(arg0: number): this;
        array(): number[];
        readShort(): number;
        getLong(arg0: number): number;
        getIntLE(arg0: number): number;
        readBytes(arg0: Internal.OutputStream_, arg1: number): this;
        slice(arg0: number, arg1: number): this;
        capacity(): number;
        readerIndex(arg0: number): this;
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): this;
        readCharSequence(arg0: number, arg1: Internal.Charset_): Internal.CharSequence;
        writeDoubleLE(arg0: number): this;
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): this;
        asReadOnly(): this;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): this;
        hasMemoryAddress(): boolean;
        getLongLE(arg0: number): number;
        setZero(arg0: number, arg1: number): this;
        readSlice(arg0: number): this;
        readLongLE(): number;
        getShort(arg0: number): number;
        writeLong(arg0: number): this;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): this;
        readFloat(): number;
        readBytes(arg0: Internal.ByteBuf_): this;
        getDoubleLE(arg0: number): number;
        readUnsignedIntLE(): number;
        getBytes(arg0: number, arg1: Internal.ByteBuffer_): this;
        getInt(arg0: number): number;
        writeBoolean(arg0: boolean): this;
        getBytes(arg0: number, arg1: number[]): this;
        writeBytes(arg0: Internal.ScatteringByteChannel_, arg1: number): number;
        setIndex(arg0: number, arg1: number): this;
        setMedium(arg0: number, arg1: number): this;
        hasArray(): boolean;
        setBoolean(arg0: number, arg1: boolean): this;
        writeBytes(arg0: Internal.ByteBuf_): this;
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel_, arg2: number): number;
        readLong(): number;
        writeByte(arg0: number): this;
        copy(): this;
        readBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): this;
        ensureWritable(arg0: number, arg1: boolean): number;
        getUnsignedShort(arg0: number): number;
        readBytes(arg0: number): this;
        getBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        setDouble(arg0: number, arg1: number): this;
        readUnsignedByte(): number;
        getUnsignedShortLE(arg0: number): number;
        setIntLE(arg0: number, arg1: number): this;
        hashCode(): number;
        toString(arg0: Internal.Charset_): string;
        order(arg0: Internal.ByteOrder_): this;
        setBytes(arg0: number, arg1: Internal.ByteBuffer_): this;
        equals(arg0: any): boolean;
        toString(arg0: number, arg1: number, arg2: Internal.Charset_): string;
        get readable(): boolean
        get readOnly(): boolean
        get contiguous(): boolean
        get writable(): boolean
        get direct(): boolean
    }
    type ByteBuf_ = ByteBuf;
    class ClipContext {
        constructor(arg0: Vec3_, arg1: Vec3_, arg2: any_, arg3: any_, arg4: Internal.Entity_)
        getFluidShape(arg0: Internal.FluidState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): Internal.VoxelShape;
        getFrom(): Vec3;
        getTo(): Vec3;
        getBlockShape(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): Internal.VoxelShape;
        get from(): Vec3
        get to(): Vec3
    }
    type ClipContext_ = ClipContext;
    class CarverDebugSettings {
        static of(arg0: boolean, arg1: Internal.BlockState_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: Internal.BlockState_): Internal.CarverDebugSettings;
        getAirState(): Internal.BlockState;
        getBarrierState(): Internal.BlockState;
        getWaterState(): Internal.BlockState;
        getLavaState(): Internal.BlockState;
        static of(arg0: boolean, arg1: Internal.BlockState_): Internal.CarverDebugSettings;
        static of(arg0: Internal.BlockState_, arg1: Internal.BlockState_, arg2: Internal.BlockState_, arg3: Internal.BlockState_): Internal.CarverDebugSettings;
        isDebugMode(): boolean;
        get airState(): Internal.BlockState
        get barrierState(): Internal.BlockState
        get waterState(): Internal.BlockState
        get lavaState(): Internal.BlockState
        get debugMode(): boolean
        readonly static "DEFAULT": Internal.CarverDebugSettings;
        readonly static "CODEC": any;
    }
    type CarverDebugSettings_ = CarverDebugSettings;
    class WorldBorder {
        constructor()
        getDamagePerBlock(): number;
        getLerpRemainingTime(): number;
        getMaxZ(): number;
        clampToBounds(arg0: number, arg1: number, arg2: number): BlockPos;
        removeListener(arg0: Internal.BorderChangeListener_): void;
        getMaxX(): number;
        getAbsoluteMaxSize(): number;
        getLerpSpeed(): number;
        getCenterZ(): number;
        isWithinBounds(arg0: number, arg1: number, arg2: number): boolean;
        getCenterX(): number;
        setWarningTime(arg0: number): void;
        getCollisionShape(): Internal.VoxelShape;
        getStatus(): Internal.BorderStatus;
        setCenter(arg0: number, arg1: number): void;
        setDamageSafeZone(arg0: number): void;
        getWarningTime(): number;
        setSize(arg0: number): void;
        applySettings(arg0: Internal.WorldBorder$Settings_): void;
        getMinX(): number;
        getWarningBlocks(): number;
        createSettings(): Internal.WorldBorder$Settings;
        getMinZ(): number;
        addListener(arg0: Internal.BorderChangeListener_): void;
        isWithinBounds(arg0: Internal.AABB_): boolean;
        getDistanceToBorder(arg0: Internal.Entity_): number;
        getDamageSafeZone(): number;
        getSize(): number;
        lerpSizeBetween(arg0: number, arg1: number, arg2: number): void;
        tick(): void;
        setDamagePerBlock(arg0: number): void;
        getLerpTarget(): number;
        getDistanceToBorder(arg0: number, arg1: number): number;
        setAbsoluteMaxSize(arg0: number): void;
        isWithinBounds(arg0: BlockPos_): boolean;
        isInsideCloseToBorder(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        isWithinBounds(arg0: number, arg1: number): boolean;
        isWithinBounds(arg0: Internal.ChunkPos_): boolean;
        setWarningBlocks(arg0: number): void;
        get damagePerBlock(): number
        get lerpRemainingTime(): number
        get maxZ(): number
        get maxX(): number
        get absoluteMaxSize(): number
        get lerpSpeed(): number
        get centerZ(): number
        get centerX(): number
        set warningTime(arg0: number)
        get collisionShape(): Internal.VoxelShape
        get status(): Internal.BorderStatus
        set damageSafeZone(arg0: number)
        get warningTime(): number
        set size(arg0: number)
        get minX(): number
        get warningBlocks(): number
        get minZ(): number
        get damageSafeZone(): number
        get size(): number
        set damagePerBlock(arg0: number)
        get lerpTarget(): number
        set absoluteMaxSize(arg0: number)
        set warningBlocks(arg0: number)
        readonly static "MAX_CENTER_COORDINATE": 2.9999984E7;
        readonly static "MAX_SIZE": 5.9999968E7;
        readonly static "DEFAULT_SETTINGS": Internal.WorldBorder$Settings;
    }
    type WorldBorder_ = WorldBorder;
    class TrapezoidHeight extends Internal.HeightProvider {
        static of(arg0: Internal.VerticalAnchor_, arg1: Internal.VerticalAnchor_): Internal.TrapezoidHeight;
        static of(arg0: Internal.VerticalAnchor_, arg1: Internal.VerticalAnchor_, arg2: number): Internal.TrapezoidHeight;
        toString(): string;
        sample(arg0: Internal.Random_, arg1: Internal.WorldGenerationContext_): number;
        getType(): Internal.HeightProviderType<any>;
        get type(): Internal.HeightProviderType<any>
        readonly static "CODEC": any;
    }
    type TrapezoidHeight_ = TrapezoidHeight;
    abstract class PatrollingMonster extends Internal.Monster {
        hasPatrolTarget(): boolean;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        canBeLeader(): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getPatrolTarget(): BlockPos;
        static checkPatrollingMonsterSpawnRules(arg0: Internal.EntityType_<any>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        canJoinPatrol(): boolean;
        serializeNBT(): Internal.Tag;
        setPatrolTarget(arg0: BlockPos_): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        setPatrolLeader(arg0: boolean): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMyRidingOffset(): number;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        findPatrolTarget(): void;
        isPatrolLeader(): boolean;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        removeWhenFarAway(arg0: number): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get patrolTarget(): BlockPos
        get multipartEntity(): boolean
        set patrolTarget(arg0: BlockPos_)
        get parts(): Internal.PartEntity<any>[]
        set patrolLeader(arg0: boolean)
        get myRidingOffset(): number
        get patrolLeader(): boolean
    }
    type PatrollingMonster_ = PatrollingMonster;
    class ContainerScreenEvent$DrawForeground extends Internal.ContainerScreenEvent {
        constructor()
        constructor(arg0: Internal.AbstractContainerScreen_<any>, arg1: Internal.PoseStack_, arg2: number, arg3: number)
        getPoseStack(): Internal.PoseStack;
        getListenerList(): Internal.ListenerList;
        getMouseY(): number;
        getMouseX(): number;
        get poseStack(): Internal.PoseStack
        get listenerList(): Internal.ListenerList
        get mouseY(): number
        get mouseX(): number
    }
    type ContainerScreenEvent$DrawForeground_ = ContainerScreenEvent$DrawForeground;
    class RecipeCollection {
        constructor(arg0: Internal.List_<Internal.Recipe_<any>>)
        hasKnownRecipes(): boolean;
        hasSingleResultItem(): boolean;
        hasFitting(): boolean;
        canCraft(arg0: Internal.StackedContents_, arg1: number, arg2: number, arg3: Internal.RecipeBook_): void;
        hasCraftable(): boolean;
        getRecipes(arg0: boolean): Internal.List<Internal.Recipe<any>>;
        isCraftable(arg0: Internal.Recipe_<any>): boolean;
        getDisplayRecipes(arg0: boolean): Internal.List<Internal.Recipe<any>>;
        updateKnownRecipes(arg0: Internal.RecipeBook_): void;
        getRecipes(): Internal.List<Internal.Recipe<any>>;
        get recipes(): Internal.List<Internal.Recipe<any>>
    }
    type RecipeCollection_ = RecipeCollection;
    class ChestType extends Internal.Enum<Internal.ChestType> implements Internal.StringRepresentable {
        static valueOf(arg0: string): Internal.ChestType;
        getSerializedName(): string;
        getOpposite(): this;
        static values(): Internal.ChestType[];
        get serializedName(): string
        get opposite(): Internal.ChestType
        readonly static "SINGLE": Internal.ChestType;
        readonly static "LEFT": Internal.ChestType;
        readonly static "RIGHT": Internal.ChestType;
        readonly static "BY_ID": any;
    }
    type ChestType_ = "single" | ChestType | "right" | "left";
    abstract class OutputStream implements Internal.Closeable, Internal.Flushable {
        constructor()
        flush(): void;
        write(arg0: number): void;
        static nullOutputStream(): Internal.OutputStream;
        close(): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        write(arg0: number[]): void;
    }
    type OutputStream_ = OutputStream;
    class AttachedData extends Internal.HashMap<string, any> {
        constructor(p: any)
        getParent(): any;
        get parent(): any
    }
    type AttachedData_ = AttachedData;
    class Wolf extends Internal.TamableAnimal implements Internal.NeutralMob {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        playerDied(arg0: Internal.Player_): void;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        isAngry(): boolean;
        canMate(arg0: Internal.Animal_): boolean;
        getStepHeight(): number;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): this;
        startPersistentAngerTimer(): void;
        getBodyRollAngle(arg0: number, arg1: number): number;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getMaxSpawnClusterSize(): number;
        setRemainingPersistentAngerTime(arg0: number): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getMaxHeadXRot(): number;
        isWet(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        setTame(arg0: boolean): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        readPersistentAngerSaveData(arg0: Internal.Level_, arg1: Internal.CompoundTag_): void;
        stopBeingAngry(): void;
        alwaysAccepts(): boolean;
        die(arg0: Internal.DamageSource_): void;
        setPersistentAngerTarget(arg0: Internal.UUID_): void;
        getLeashOffset(): Vec3;
        foodEatenKJS(is: Internal.ItemStack_): void;
        setCollarColor(arg0: Internal.DyeColor_): void;
        setIsInterested(arg0: boolean): void;
        getWetShade(arg0: number): number;
        forgetCurrentTargetAndRefreshUniversalAnger(): void;
        asKJS(): Internal.EntityJS;
        isFood(arg0: Internal.ItemStack_): boolean;
        getTailAngle(): number;
        canRiderInteract(): boolean;
        addPersistentAngerSaveData(arg0: Internal.CompoundTag_): void;
        isInterested(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        isAngryAt(arg0: Internal.LivingEntity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        getRemainingPersistentAngerTime(): number;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        getPersistentAngerTarget(): Internal.UUID;
        deserializeNBT(arg0: Internal.Tag_): void;
        canBeLeashed(arg0: Internal.Player_): boolean;
        aiStep(): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getHeadRollAngle(arg0: number): number;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        updatePersistentAnger(arg0: Internal.ServerLevel_, arg1: boolean): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        isAngryAtAllPlayers(arg0: Internal.Level_): boolean;
        wantsToAttack(arg0: Internal.LivingEntity_, arg1: Internal.LivingEntity_): boolean;
        static checkWolfSpawnRules(arg0: Internal.EntityType_<Internal.Wolf_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        getCollarColor(): Internal.DyeColor;
        get angry(): boolean
        get stepHeight(): number
        get maxSpawnClusterSize(): number
        set remainingPersistentAngerTime(arg0: number)
        get maxHeadXRot(): number
        get wet(): boolean
        set tame(arg0: boolean)
        set persistentAngerTarget(arg0: Internal.UUID_)
        get leashOffset(): Vec3
        set collarColor(arg0: Internal.DyeColor_)
        set isInterested(arg0: boolean)
        get tailAngle(): number
        get interested(): boolean
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get remainingPersistentAngerTime(): number
        get persistentAngerTarget(): Internal.UUID
        get collarColor(): Internal.DyeColor
        readonly static "PREY_SELECTOR": any;
    }
    type Wolf_ = Wolf;
    class EndCrystal extends Internal.Entity {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        kill(): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        getAddEntityPacket(): Internal.Packet<any>;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRenderAtSqrDistance(arg0: number): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        setBeamTarget(arg0: BlockPos_): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isPickable(): boolean;
        getBeamTarget(): BlockPos;
        tick(): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getPickResult(): Internal.ItemStack;
        setShowBottom(arg0: boolean): void;
        showsBottom(): boolean;
        get stepHeight(): number
        get addEntityPacket(): Internal.Packet<any>
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        set beamTarget(arg0: BlockPos_)
        get pickable(): boolean
        get beamTarget(): BlockPos
        get pickResult(): Internal.ItemStack
        set showBottom(arg0: boolean)
        "time": number;
    }
    type EndCrystal_ = EndCrystal;
    interface ExternalArrayData {
        getArrayElement(arg0: number): any;
        getArrayLength(): number;
        setArrayElement(arg0: number, arg1: any): void;
        get arrayLength(): number
    }
    type ExternalArrayData_ = ExternalArrayData;
    class ParticleStatus extends Internal.Enum<Internal.ParticleStatus> {
        static values(): Internal.ParticleStatus[];
        getKey(): string;
        static byId(arg0: number): Internal.ParticleStatus;
        static valueOf(arg0: string): Internal.ParticleStatus;
        getId(): number;
        get key(): string
        get id(): number
        readonly static "ALL": Internal.ParticleStatus;
        readonly static "DECREASED": Internal.ParticleStatus;
        readonly static "MINIMAL": Internal.ParticleStatus;
    }
    type ParticleStatus_ = ParticleStatus | "minimal" | "decreased" | "all";
    class ClientboundSetBorderWarningDistancePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.WorldBorder_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getWarningBlocks(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get warningBlocks(): number
        get skippable(): boolean
    }
    type ClientboundSetBorderWarningDistancePacket_ = ClientboundSetBorderWarningDistancePacket;
    class RailShape extends Internal.Enum<Internal.RailShape> implements Internal.StringRepresentable {
        static values(): Internal.RailShape[];
        isAscending(): boolean;
        toString(): string;
        getSerializedName(): string;
        getName(): string;
        static valueOf(arg0: string): Internal.RailShape;
        get ascending(): boolean
        get serializedName(): string
        get name(): string
        readonly static "NORTH_EAST": Internal.RailShape;
        readonly static "NORTH_WEST": Internal.RailShape;
        readonly static "SOUTH_EAST": Internal.RailShape;
        readonly static "ASCENDING_WEST": Internal.RailShape;
        readonly static "ASCENDING_EAST": Internal.RailShape;
        readonly static "ASCENDING_NORTH": Internal.RailShape;
        readonly static "ASCENDING_SOUTH": Internal.RailShape;
        readonly static "NORTH_SOUTH": Internal.RailShape;
        readonly static "EAST_WEST": Internal.RailShape;
        readonly static "SOUTH_WEST": Internal.RailShape;
    }
    type RailShape_ = "north_west" | "north_east" | "ascending_west" | "south_west" | "ascending_east" | RailShape | "north_south" | "east_west" | "ascending_south" | "ascending_north" | "south_east";
    interface PackSource {
        passThrough(): this;
        decorating(arg0: string): this;
        decorate(arg0: Internal.Component_): Internal.Component;
        readonly static "DEFAULT": any;
        readonly static "SERVER": any;
        readonly static "BUILT_IN": any;
        readonly static "WORLD": any;
    }
    type PackSource_ = PackSource;
    interface GameVersion {
        isStable(): boolean;
        getWorldVersion(): number;
        getName(): string;
        getPackVersion(arg0: com.mojang.bridge.game.PackType_): number;
        getSeriesId(): string;
        getProtocolVersion(): number;
        getId(): string;
        getBuildTime(): Internal.Date;
        getPackVersion(): number;
        getReleaseTarget(): string;
        get stable(): boolean
        get worldVersion(): number
        get name(): string
        get seriesId(): string
        get protocolVersion(): number
        get id(): string
        get buildTime(): Internal.Date
        get packVersion(): number
        get releaseTarget(): string
    }
    type GameVersion_ = GameVersion;
    class Monitor {
        constructor(arg0: number)
        getModeCount(): number;
        getX(): number;
        toString(): string;
        getY(): number;
        getPreferredVidMode(arg0: Internal.Optional_<Internal.VideoMode_>): Internal.VideoMode;
        getMode(arg0: number): Internal.VideoMode;
        getMonitor(): number;
        getCurrentMode(): Internal.VideoMode;
        refreshVideoModes(): void;
        getVideoModeIndex(arg0: Internal.VideoMode_): number;
        get modeCount(): number
        get x(): number
        get y(): number
        get monitor(): number
        get currentMode(): Internal.VideoMode
    }
    type Monitor_ = Monitor;
    interface FireworkRocketEntityKJS {
        setLifetimeKJS(arg0: number): void;
        set lifetimeKJS(arg0: number)
    }
    type FireworkRocketEntityKJS_ = FireworkRocketEntityKJS;
    interface StackedContentsCompatible {
        fillStackedContents(arg0: Internal.StackedContents_): void;
    }
    type StackedContentsCompatible_ = StackedContentsCompatible;
    class ServerStatsCounter extends Internal.StatsCounter {
        constructor(arg0: Internal.MinecraftServer_, arg1: Internal.File_)
        parseLocal(arg0: Internal.DataFixer_, arg1: string): void;
        sendStats(arg0: Internal.ServerPlayer_): void;
        setValue(arg0: Internal.Player_, arg1: Internal.Stat_<any>, arg2: number): void;
        markAllDirty(): void;
        save(): void;
    }
    type ServerStatsCounter_ = ServerStatsCounter;
    class GameProfileCache$GameProfileInfo {
        getLastAccess(): number;
        getProfile(): Internal.GameProfile;
        setLastAccess(arg0: number): void;
        getExpirationDate(): Internal.Date;
        get lastAccess(): number
        get profile(): Internal.GameProfile
        set lastAccess(arg0: number)
        get expirationDate(): Internal.Date
    }
    type GameProfileCache$GameProfileInfo_ = GameProfileCache$GameProfileInfo;
    interface IVertexProducer {
        pipe(arg0: Internal.IVertexConsumer_): void;
    }
    type IVertexProducer_ = IVertexProducer;
    class AcaciaFoliagePlacer extends Internal.FoliagePlacer {
        constructor(arg0: Internal.IntProvider_, arg1: Internal.IntProvider_)
        foliageHeight(arg0: Internal.Random_, arg1: number, arg2: Internal.TreeConfiguration_): number;
        readonly static "CODEC": any;
    }
    type AcaciaFoliagePlacer_ = AcaciaFoliagePlacer;
    abstract class GlslPreprocessor {
        constructor()
        process(arg0: string): Internal.List<string>;
        applyImport(arg0: boolean, arg1: string): string;
    }
    type GlslPreprocessor_ = GlslPreprocessor;
    class HoverEvent$ItemStackInfo {
        constructor(arg0: Internal.ItemStack_)
        hashCode(): number;
        equals(arg0: any): boolean;
        getItemStack(): Internal.ItemStack;
        get itemStack(): Internal.ItemStack
    }
    type HoverEvent$ItemStackInfo_ = HoverEvent$ItemStackInfo;
    interface Reference2IntFunction <K> extends Internal.ToIntFunction<K>, it.unimi.dsi.fastutil.Function<K, number> {
        put(arg0: K, arg1: number): number;
        andThenReference(arg0: Internal.Int2ReferenceFunction_<any>): Internal.Reference2ReferenceFunction<K, T>;
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        defaultReturnValue(): number;
        removeInt(arg0: any): number;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2IntFunction;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Reference2ByteFunction<K>;
        apply(arg0: K): number;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Reference2ShortFunction<K>;
        containsKey(arg0: any): boolean;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2IntFunction;
        getInt(arg0: any): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Reference2LongFunction<K>;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2IntFunction;
        put(arg0: any, arg1: any): any;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2IntFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        composeReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Reference2IntFunction<T>;
        put(arg0: K, arg1: number): number;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2IntFunction;
        getOrDefault(arg0: any, arg1: number): number;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2IntFunction;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2IntFunction;
        applyAsInt(arg0: K): number;
        composeObject(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Object2IntFunction<T>;
        size(): number;
        defaultReturnValue(arg0: number): void;
        andThenObject(arg0: Internal.Int2ObjectFunction_<any>): Internal.Reference2ObjectFunction<K, T>;
        clear(): void;
        getOrDefault(arg0: any, arg1: number): number;
        remove(arg0: any): any;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Reference2DoubleFunction<K>;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Reference2CharFunction<K>;
        andThenInt(arg0: Internal.Int2IntFunction_): this;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Reference2FloatFunction<K>;
    }
    type Reference2IntFunction_<K> = ((arg0: any)=>number) | Reference2IntFunction<K>;
    class ClientboundSetCameraPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.Entity_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getEntity(arg0: Internal.Level_): Internal.Entity;
        isSkippable(): boolean;
        get skippable(): boolean
    }
    type ClientboundSetCameraPacket_ = ClientboundSetCameraPacket;
    abstract class EnumSet <E> extends Internal.AbstractSet<E> implements Internal.Cloneable, Internal.Serializable {
        static of(arg0: E, ...arg1: E[]): Internal.EnumSet<E>;
        static of(arg0: E): Internal.EnumSet<E>;
        static of(arg0: E, arg1: E): Internal.EnumSet<E>;
        forEach(arg0: Internal.Consumer_<any>): void;
        static of(arg0: E, arg1: E, arg2: E, arg3: E): Internal.EnumSet<E>;
        static complementOf(arg0: Internal.EnumSet_<E>): Internal.EnumSet<E>;
        parallelStream(): Internal.Stream<E>;
        static of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): Internal.EnumSet<E>;
        static of(arg0: E, arg1: E, arg2: E): Internal.EnumSet<E>;
        static allOf(arg0: Internal.Class_<E>): Internal.EnumSet<E>;
        static copyOf(arg0: Internal.Collection_<E>): Internal.EnumSet<E>;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        static noneOf(arg0: Internal.Class_<E>): Internal.EnumSet<E>;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        stream(): Internal.Stream<E>;
        static range(arg0: E, arg1: E): Internal.EnumSet<E>;
        static copyOf(arg0: Internal.EnumSet_<E>): Internal.EnumSet<E>;
        spliterator(): Internal.Spliterator<E>;
        clone(): this;
    }
    type EnumSet_<E> = EnumSet<E>;
    class BeehiveBlockEntity extends Internal.BlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        getOccupantCount(): number;
        static getHoneyLevel(arg0: Internal.BlockState_): number;
        isFull(): boolean;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        emptyAllLivingFromHive(arg0: Internal.Player_, arg1: Internal.BlockState_, arg2: Internal.BeehiveBlockEntity$BeeReleaseStatus_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isEmpty(): boolean;
        isSedated(): boolean;
        serializeNBT(): Internal.CompoundTag;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        static serverTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BeehiveBlockEntity_): void;
        addOccupantWithPresetTicks(arg0: Internal.Entity_, arg1: boolean, arg2: number): void;
        isFireNearby(): boolean;
        load(arg0: Internal.CompoundTag_): void;
        setChanged(): void;
        addOccupant(arg0: Internal.Entity_, arg1: boolean): void;
        onLoad(): void;
        storeBee(arg0: Internal.CompoundTag_, arg1: number, arg2: boolean): void;
        writeBees(): Internal.ListTag;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get occupantCount(): number
        get full(): boolean
        get modelData(): Internal.IModelData
        get empty(): boolean
        get sedated(): boolean
        get fireNearby(): boolean
        get renderBoundingBox(): Internal.AABB
        readonly static "TICKS_IN_HIVE": "TicksInHive";
        readonly static "BEES": "Bees";
        readonly static "HAS_NECTAR": "HasNectar";
        readonly static "TAG_FLOWER_POS": "FlowerPos";
        readonly static "MIN_OCCUPATION_TICKS_NECTARLESS": 600;
        readonly static "MIN_OCCUPATION_TICKS": "MinOccupationTicks";
        readonly static "ENTITY_DATA": "EntityData";
        readonly static "MAX_OCCUPANTS": 3;
    }
    type BeehiveBlockEntity_ = BeehiveBlockEntity;
    class ArmorItemBuilder$Boots extends Internal.ArmorItemBuilder {
        constructor(i: ResourceLocation_)
        createObject(): any;
    }
    type ArmorItemBuilder$Boots_ = ArmorItemBuilder$Boots;
    class Type$FieldNotFoundException extends Internal.Type$TypeError {
        constructor(arg0: string)
    }
    type Type$FieldNotFoundException_ = Type$FieldNotFoundException;
    class LivingHealEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.LivingEntity_, arg1: number)
        isCancelable(): boolean;
        setAmount(arg0: number): void;
        getAmount(): number;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        set amount(arg0: number)
        get amount(): number
        get listenerList(): Internal.ListenerList
    }
    type LivingHealEvent_ = LivingHealEvent;
    interface ProfilerFiller {
        markForCharting(arg0: Internal.MetricCategory_): void;
        push(arg0: Internal.Supplier_<string>): void;
        incrementCounter(arg0: string, arg1: number): void;
        tee(arg0: Internal.ProfilerFiller_, arg1: Internal.ProfilerFiller_): this;
        popPush(arg0: string): void;
        push(arg0: string): void;
        incrementCounter(arg0: Internal.Supplier_<string>): void;
        pop(): void;
        incrementCounter(arg0: Internal.Supplier_<string>, arg1: number): void;
        incrementCounter(arg0: string): void;
        endTick(): void;
        popPush(arg0: Internal.Supplier_<string>): void;
        startTick(): void;
        readonly static "ROOT": "root";
    }
    type ProfilerFiller_ = ProfilerFiller;
    interface DoubleList extends Internal.Comparable<Internal.List<any>>, Internal.DoubleCollection, Internal.List<number> {
        getDouble(arg0: number): number;
        iterator(): Internal.DoubleListIterator;
        addAll(arg0: number, arg1: Internal.DoubleList_): boolean;
        removeIf(arg0: Internal.DoublePredicate_): boolean;
        add(arg0: number, arg1: any): void;
        stream(): Internal.Stream<number>;
        replaceAll(arg0: Internal.UnaryOperator_<number>): void;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        subList(arg0: number, arg1: number): this;
        replaceAll(arg0: it.unimi.dsi.fastutil.doubles.DoubleUnaryOperator_): void;
        addElements(arg0: number, arg1: number[]): void;
        of(...arg0: number[]): this;
        removeDouble(arg0: number): number;
        listIterator(): Internal.ListIterator<any>;
        size(arg0: number): void;
        add(arg0: number, arg1: number): void;
        forEach(arg0: it.unimi.dsi.fastutil.doubles.DoubleConsumer_): void;
        addElements(arg0: number, arg1: number[], arg2: number, arg3: number): void;
        indexOf(arg0: any): number;
        remove(arg0: any): boolean;
        toDoubleArray(arg0: number[]): number[];
        addAll(arg0: number, arg1: Internal.DoubleCollection_): boolean;
        sort(arg0: Internal.Comparator_<any>): void;
        of(): this;
        add(arg0: any): boolean;
        parallelStream(): Internal.Stream<number>;
        spliterator(): Internal.Spliterator<any>;
        unstableSort(arg0: Internal.DoubleComparator_): void;
        sort(arg0: Internal.DoubleComparator_): void;
        unstableSort(arg0: Internal.Comparator_<any>): void;
        set(arg0: number, arg1: number): number;
        set(arg0: number, arg1: any): any;
        lastIndexOf(arg0: any): number;
        addAll(arg0: Internal.DoubleList_): boolean;
        add(arg0: number): boolean;
        get(arg0: number): number;
        removeElements(arg0: number, arg1: number): void;
        remove(arg0: number): any;
        set(arg0: number, arg1: number): number;
        getElements(arg0: number, arg1: number[], arg2: number, arg3: number): void;
        forEach(arg0: Internal.Consumer_<any>): void;
        of(arg0: number, arg1: number): this;
        setElements(arg0: number, arg1: number[]): void;
        add(arg0: number): boolean;
        listIterator(arg0: number): Internal.ListIterator<any>;
        doubleParallelStream(): Internal.DoubleStream;
        setElements(arg0: number, arg1: number[], arg2: number, arg3: number): void;
        add(arg0: number, arg1: number): void;
        of(arg0: number): this;
        doubleStream(): Internal.DoubleStream;
        of(arg0: number, arg1: number, arg2: number): this;
        indexOf(arg0: number): number;
        contains(arg0: any): boolean;
        replaceAll(arg0: Internal.DoubleUnaryOperator_): void;
        removeIf(arg0: it.unimi.dsi.fastutil.doubles.DoublePredicate_): boolean;
        doubleIterator(): Internal.DoubleIterator;
        lastIndexOf(arg0: number): number;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        doubleSpliterator(): Internal.DoubleSpliterator;
        forEach(arg0: Internal.DoubleConsumer_): void;
        setElements(arg0: number[]): void;
        set elements(arg0: number[])
    }
    type DoubleList_ = DoubleList;
    class LootTable$Builder implements Internal.FunctionUserBuilder<Internal.LootTable$Builder> {
        constructor()
        build(): Internal.LootTable;
        unwrap(): any;
        setParamSet(arg0: Internal.LootContextParamSet_): this;
        withPool(arg0: Internal.LootPool$Builder_): this;
        apply(arg0: Internal.LootItemFunction$Builder_): any;
        set paramSet(arg0: Internal.LootContextParamSet_)
    }
    type LootTable$Builder_ = LootTable$Builder;
    class GpuWarnlistManager extends Internal.SimplePreparableReloadListener<any> {
        constructor()
        showWarning(): void;
        getRendererWarnings(): string;
        hasWarnings(): boolean;
        resetWarnings(): void;
        getVersionWarnings(): string;
        getName(): string;
        getVendorWarnings(): string;
        getAllWarnings(): string;
        willShowWarning(): boolean;
        dismissWarning(): void;
        dismissWarningAndSkipFabulous(): void;
        isSkippingFabulous(): boolean;
        isShowingWarning(): boolean;
        get rendererWarnings(): string
        get versionWarnings(): string
        get name(): string
        get vendorWarnings(): string
        get allWarnings(): string
        get skippingFabulous(): boolean
        get showingWarning(): boolean
    }
    type GpuWarnlistManager_ = GpuWarnlistManager;
    class Style {
        applyFormats(...arg0: Internal.ChatFormatting_[]): this;
        getInsertion(): string;
        withHoverEvent(arg0: Internal.HoverEvent_): this;
        isBold(): boolean;
        isStrikethrough(): boolean;
        isEmpty(): boolean;
        isObfuscated(): boolean;
        withBold(arg0: boolean): this;
        getFont(): ResourceLocation;
        getHoverEvent(): Internal.HoverEvent;
        isItalic(): boolean;
        isUnderlined(): boolean;
        setStrikethrough(arg0: boolean): this;
        withStrikethrough(arg0: boolean): this;
        withObfuscated(arg0: boolean): this;
        setObfuscated(arg0: boolean): this;
        withColor(arg0: Internal.ChatFormatting_): this;
        toString(): string;
        applyTo(arg0: Internal.Style_): this;
        setUnderlined(arg0: boolean): this;
        withInsertion(arg0: string): this;
        withColor(arg0: number): this;
        getColor(): Internal.TextColor;
        getClickEvent(): Internal.ClickEvent;
        hashCode(): number;
        withUnderlined(arg0: boolean): this;
        withFont(arg0: ResourceLocation_): this;
        withColor(arg0: Internal.TextColor_): this;
        withClickEvent(arg0: Internal.ClickEvent_): this;
        withItalic(arg0: boolean): this;
        applyLegacyFormat(arg0: Internal.ChatFormatting_): this;
        equals(arg0: any): boolean;
        applyFormat(arg0: Internal.ChatFormatting_): this;
        get insertion(): string
        get bold(): boolean
        get strikethrough(): boolean
        get empty(): boolean
        get obfuscated(): boolean
        get font(): ResourceLocation
        get hoverEvent(): Internal.HoverEvent
        get italic(): boolean
        get underlined(): boolean
        set strikethrough(arg0: boolean)
        set obfuscated(arg0: boolean)
        set underlined(arg0: boolean)
        get color(): Internal.TextColor
        get clickEvent(): Internal.ClickEvent
        readonly static "EMPTY": Internal.Style;
        readonly static "DEFAULT_FONT": ResourceLocation;
    }
    type Style_ = Style;
    interface TypeTemplate {
        toSimpleType(): com.mojang.datafixers.types.Type<any>;
        size(): number;
        findFieldOrType(arg0: number, arg1: string, arg2: com.mojang.datafixers.types.Type_<A>, arg3: com.mojang.datafixers.types.Type_<B>): Internal.Either<Internal.TypeTemplate, Internal.Type$FieldNotFoundException>;
        apply(arg0: Internal.TypeFamily_): Internal.TypeFamily;
        applyO(arg0: Internal.FamilyOptic_<A, B>, arg1: com.mojang.datafixers.types.Type_<A>, arg2: com.mojang.datafixers.types.Type_<B>): Internal.FamilyOptic<A, B>;
        hmap(arg0: Internal.TypeFamily_, arg1: Internal.IntFunction_<Internal.RewriteResult_<any, any>>): Internal.IntFunction<Internal.RewriteResult<any, any>>;
    }
    type TypeTemplate_ = TypeTemplate;
    class BlastingRecipe extends Internal.AbstractCookingRecipe {
        constructor(arg0: ResourceLocation_, arg1: string, arg2: Internal.Ingredient_, arg3: Internal.ItemStack_, arg4: number, arg5: number)
        isSpecial(): boolean;
        getSerializer(): Internal.RecipeSerializer<any>;
        getToastSymbol(): Internal.ItemStack;
        isIncomplete(): boolean;
        getRemainingItems(arg0: Internal.Container_): Internal.NonNullList<Internal.ItemStack>;
        get special(): boolean
        get serializer(): Internal.RecipeSerializer<any>
        get toastSymbol(): Internal.ItemStack
        get incomplete(): boolean
    }
    type BlastingRecipe_ = BlastingRecipe;
    interface EventListener {
    }
    type EventListener_ = EventListener;
    class BlockStateMatchTest extends Internal.RuleTest {
        constructor(arg0: Internal.BlockState_)
        test(arg0: Internal.BlockState_, arg1: Internal.Random_): boolean;
        readonly static "CODEC": any;
    }
    type BlockStateMatchTest_ = BlockStateMatchTest;
    class TagsUpdatedEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.RegistryAccess_, arg1: boolean, arg2: boolean)
        constructor(arg0: Internal.RegistryAccess_)
        shouldUpdateStaticData(): boolean;
        getUpdateCause(): Internal.TagsUpdatedEvent$UpdateCause;
        getListenerList(): Internal.ListenerList;
        getTagManager(): Internal.RegistryAccess;
        get updateCause(): Internal.TagsUpdatedEvent$UpdateCause
        get listenerList(): Internal.ListenerList
        get tagManager(): Internal.RegistryAccess
    }
    type TagsUpdatedEvent_ = TagsUpdatedEvent;
    class ScreenEvent$MouseReleasedEvent$Post extends Internal.ScreenEvent$MouseReleasedEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number, arg3: number, arg4: boolean)
        hasResult(): boolean;
        wasHandled(): boolean;
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$MouseReleasedEvent$Post_ = ScreenEvent$MouseReleasedEvent$Post;
    abstract class ArgumentBuilder <S, T> {
        constructor()
        redirect(arg0: Internal.CommandNode_<S>): T;
        build(): Internal.CommandNode<S>;
        then(arg0: Internal.CommandNode_<S>): T;
        redirect(arg0: Internal.CommandNode_<S>, arg1: Internal.SingleRedirectModifier_<S>): T;
        then(arg0: Internal.ArgumentBuilder_<S, any>): T;
        getArguments(): Internal.Collection<Internal.CommandNode<S>>;
        fork(arg0: Internal.CommandNode_<S>, arg1: Internal.RedirectModifier_<S>): T;
        getRedirectModifier(): Internal.RedirectModifier<S>;
        getRequirement(): Internal.Predicate<S>;
        forward(arg0: Internal.CommandNode_<S>, arg1: Internal.RedirectModifier_<S>, arg2: boolean): T;
        executes(arg0: Internal.Command_<S>): T;
        requires(arg0: Internal.Predicate_<S>): T;
        getRedirect(): Internal.CommandNode<S>;
        isFork(): boolean;
        getCommand(): Internal.Command<S>;
        get arguments(): Internal.Collection<Internal.CommandNode<S>>
        get redirectModifier(): Internal.RedirectModifier<S>
        get requirement(): Internal.Predicate<S>
        get redirect(): Internal.CommandNode<S>
        get fork(): boolean
        get command(): Internal.Command<S>
    }
    type ArgumentBuilder_<S, T> = ArgumentBuilder<S, T>;
    class ClientboundHorseScreenOpenPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: number, arg2: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getSize(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getEntityId(): number;
        getContainerId(): number;
        isSkippable(): boolean;
        get size(): number
        get entityId(): number
        get containerId(): number
        get skippable(): boolean
    }
    type ClientboundHorseScreenOpenPacket_ = ClientboundHorseScreenOpenPacket;
    interface FilenameFilter {
        accept(arg0: Internal.File_, arg1: string): boolean;
    }
    type FilenameFilter_ = FilenameFilter | ((arg0: Internal.File, arg1: string)=>boolean);
    class ClientboundSetExperiencePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: number, arg2: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getExperienceLevel(): number;
        isSkippable(): boolean;
        getExperienceProgress(): number;
        getTotalExperience(): number;
        get experienceLevel(): number
        get skippable(): boolean
        get experienceProgress(): number
        get totalExperience(): number
    }
    type ClientboundSetExperiencePacket_ = ClientboundSetExperiencePacket;
    class LecternBlockEntity extends Internal.BlockEntity implements Internal.MenuProvider, Internal.Clearable {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        getDisplayName(): Internal.Component;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        setBook(arg0: Internal.ItemStack_, arg1: Internal.Player_): void;
        serializeNBT(): Internal.CompoundTag;
        getPage(): number;
        createMenu(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Player_): Internal.AbstractContainerMenu;
        getBook(): Internal.ItemStack;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onlyOpCanSetNbt(): boolean;
        load(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        setBook(arg0: Internal.ItemStack_): void;
        getRedstoneSignal(): number;
        clearContent(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        hasBook(): boolean;
        get displayName(): Internal.Component
        get modelData(): Internal.IModelData
        get page(): number
        get book(): Internal.ItemStack
        set book(arg0: Internal.ItemStack_)
        get redstoneSignal(): number
        get renderBoundingBox(): Internal.AABB
        readonly static "NUM_DATA": 1;
        readonly static "DATA_PAGE": 0;
        readonly static "NUM_SLOTS": 1;
        readonly static "SLOT_BOOK": 0;
    }
    type LecternBlockEntity_ = LecternBlockEntity;
    class RenderGameOverlayEvent$PostLayer extends Internal.RenderGameOverlayEvent$Post {
        constructor()
        constructor(arg0: Internal.PoseStack_, arg1: Internal.RenderGameOverlayEvent_, arg2: Internal.IIngameOverlay_)
        getOverlay(): Internal.IIngameOverlay;
        getListenerList(): Internal.ListenerList;
        get overlay(): Internal.IIngameOverlay
        get listenerList(): Internal.ListenerList
    }
    type RenderGameOverlayEvent$PostLayer_ = RenderGameOverlayEvent$PostLayer;
    class UserBanList extends Internal.StoredUserList<Internal.GameProfile, any> {
        constructor(arg0: Internal.File_)
        getUserList(): string[];
        isBanned(arg0: Internal.GameProfile_): boolean;
        get userList(): string[]
    }
    type UserBanList_ = UserBanList;
    class EndDragonFight {
        constructor(arg0: Internal.ServerLevel_, arg1: number, arg2: Internal.CompoundTag_)
        getCrystalsAlive(): number;
        resetSpikeCrystals(): void;
        updateDragon(arg0: Internal.EnderDragon_): void;
        removePlayer(arg0: Internal.ServerPlayer_): void;
        setDragonKilled(arg0: Internal.EnderDragon_): void;
        addPlayer(arg0: Internal.ServerPlayer_): void;
        saveData(): Internal.CompoundTag;
        tick(): void;
        hasPreviouslyKilledDragon(): boolean;
        onCrystalDestroyed(arg0: Internal.EndCrystal_, arg1: Internal.DamageSource_): void;
        tryRespawn(): void;
        get crystalsAlive(): number
        set dragonKilled(arg0: Internal.EnderDragon_)
        readonly static "DRAGON_SPAWN_Y": 128;
        readonly static "ARENA_TICKET_LEVEL": 9;
    }
    type EndDragonFight_ = EndDragonFight;
    class Dolphin extends Internal.WaterAnimal {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getMaxAirSupply(): number;
        gotFish(): boolean;
        travel(arg0: Vec3_): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        setGotFish(arg0: boolean): void;
        getMaxHeadYRot(): number;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        setMoisntessLevel(arg0: number): void;
        canTakeItem(arg0: Internal.ItemStack_): boolean;
        getMaxHeadXRot(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canBeLeashed(arg0: Internal.Player_): boolean;
        setTreasurePos(arg0: BlockPos_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getTreasurePos(): BlockPos;
        tick(): void;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        canBreatheUnderwater(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getMoistnessLevel(): number;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get maxAirSupply(): number
        get stepHeight(): number
        get multipartEntity(): boolean
        set gotFish(arg0: boolean)
        get maxHeadYRot(): number
        get parts(): Internal.PartEntity<any>[]
        set moisntessLevel(arg0: number)
        get maxHeadXRot(): number
        set treasurePos(arg0: BlockPos_)
        get treasurePos(): BlockPos
        get moistnessLevel(): number
        readonly static "ALLOWED_ITEMS": any;
        readonly static "TOTAL_AIR_SUPPLY": 4800;
    }
    type Dolphin_ = Dolphin;
    class MouseHandler {
        constructor(arg0: Internal.Minecraft_)
        getXVelocity(): number;
        isRightPressed(): boolean;
        isMiddlePressed(): boolean;
        isMouseGrabbed(): boolean;
        setIgnoreFirstMove(): void;
        isLeftPressed(): boolean;
        setup(arg0: number): void;
        grabMouse(): void;
        xpos(): number;
        ypos(): number;
        turnPlayer(): void;
        cursorEntered(): void;
        releaseMouse(): void;
        getYVelocity(): number;
        get XVelocity(): number
        get rightPressed(): boolean
        get middlePressed(): boolean
        get mouseGrabbed(): boolean
        get leftPressed(): boolean
        set up(arg0: number)
        get YVelocity(): number
    }
    type MouseHandler_ = MouseHandler;
    class VillagerProfession extends Internal.ForgeRegistryEntry<Internal.VillagerProfession> {
        constructor(arg0: string, arg1: Internal.PoiType_, arg2: Internal.ImmutableSet_<Internal.Item_>, arg3: Internal.ImmutableSet_<Internal.Block_>, arg4: Internal.SoundEvent_)
        getJobPoiType(): Internal.PoiType;
        toString(): string;
        getWorkSound(): Internal.SoundEvent;
        getName(): string;
        getRequestedItems(): Internal.ImmutableSet<Internal.Item>;
        getSecondaryPoi(): Internal.ImmutableSet<Internal.Block>;
        get jobPoiType(): Internal.PoiType
        get workSound(): Internal.SoundEvent
        get name(): string
        get requestedItems(): Internal.ImmutableSet<Internal.Item>
        get secondaryPoi(): Internal.ImmutableSet<Internal.Block>
        readonly static "WEAPONSMITH": Internal.VillagerProfession;
        readonly static "FISHERMAN": Internal.VillagerProfession;
        readonly static "TOOLSMITH": Internal.VillagerProfession;
        readonly static "ARMORER": Internal.VillagerProfession;
        readonly static "CLERIC": Internal.VillagerProfession;
        readonly static "BUTCHER": Internal.VillagerProfession;
        readonly static "NONE": Internal.VillagerProfession;
        readonly static "FARMER": Internal.VillagerProfession;
        readonly static "LEATHERWORKER": Internal.VillagerProfession;
        readonly static "LIBRARIAN": Internal.VillagerProfession;
        readonly static "NITWIT": Internal.VillagerProfession;
        readonly static "CARTOGRAPHER": Internal.VillagerProfession;
        readonly static "MASON": Internal.VillagerProfession;
        readonly static "SHEPHERD": Internal.VillagerProfession;
        readonly static "FLETCHER": Internal.VillagerProfession;
    }
    type VillagerProfession_ = VillagerProfession | Special.VillagerProfession;
    class PlaySoundAtEntityEvent extends Internal.EntityEvent {
        constructor()
        constructor(arg0: Internal.Entity_, arg1: Internal.SoundEvent_, arg2: Internal.SoundSource_, arg3: number, arg4: number)
        getVolume(): number;
        isCancelable(): boolean;
        setSound(arg0: Internal.SoundEvent_): void;
        setPitch(arg0: number): void;
        getPitch(): number;
        getDefaultVolume(): number;
        getListenerList(): Internal.ListenerList;
        getSound(): Internal.SoundEvent;
        getCategory(): Internal.SoundSource;
        setVolume(arg0: number): void;
        getDefaultPitch(): number;
        setCategory(arg0: Internal.SoundSource_): void;
        get volume(): number
        get cancelable(): boolean
        set sound(arg0: Internal.SoundEvent_)
        set pitch(arg0: number)
        get pitch(): number
        get defaultVolume(): number
        get listenerList(): Internal.ListenerList
        get sound(): Internal.SoundEvent
        get category(): Internal.SoundSource
        set volume(arg0: number)
        get defaultPitch(): number
        set category(arg0: Internal.SoundSource_)
    }
    type PlaySoundAtEntityEvent_ = PlaySoundAtEntityEvent;
    class ScreenEvent$MouseClickedEvent$Post extends Internal.ScreenEvent$MouseClickedEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number, arg3: number, arg4: boolean)
        hasResult(): boolean;
        wasHandled(): boolean;
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$MouseClickedEvent$Post_ = ScreenEvent$MouseClickedEvent$Post;
    class StackTraceElement implements Internal.Serializable {
        constructor(arg0: string, arg1: string, arg2: string, arg3: number)
        constructor(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: number)
        getModuleName(): string;
        hashCode(): number;
        getFileName(): string;
        getLineNumber(): number;
        toString(): string;
        getModuleVersion(): string;
        getClassLoaderName(): string;
        getClassName(): string;
        isNativeMethod(): boolean;
        equals(arg0: any): boolean;
        getMethodName(): string;
        get moduleName(): string
        get fileName(): string
        get lineNumber(): number
        get moduleVersion(): string
        get classLoaderName(): string
        get className(): string
        get nativeMethod(): boolean
        get methodName(): string
    }
    type StackTraceElement_ = StackTraceElement;
    interface Double2DoubleFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleUnaryOperator {
        compose(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        getOrDefault(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2DoubleFunction;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2DoubleFunction;
        apply(arg0: number): number;
        andThenReference(arg0: Internal.Double2ReferenceFunction_<any>): Internal.Double2ReferenceFunction<T>;
        identity(): this;
        containsKey(arg0: any): boolean;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Double2CharFunction;
        andThenObject(arg0: Internal.Double2ObjectFunction_<any>): Internal.Double2ObjectFunction<T>;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2DoubleFunction;
        put(arg0: any, arg1: any): any;
        defaultReturnValue(arg0: number): void;
        getOrDefault(arg0: number, arg1: number): number;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2DoubleFunction;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Double2ByteFunction;
        remove(arg0: any): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Double2LongFunction;
        getOrDefault(arg0: any, arg1: number): number;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2DoubleFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeReference(arg0: Internal.Reference2DoubleFunction_<any>): Internal.Reference2DoubleFunction<T>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        applyAsDouble(arg0: number): number;
        composeObject(arg0: Internal.Object2DoubleFunction_<any>): Internal.Object2DoubleFunction<T>;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Double2ShortFunction;
        defaultReturnValue(): number;
        containsKey(arg0: number): boolean;
        put(arg0: number, arg1: number): number;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Double2IntFunction;
        size(): number;
        composeDouble(arg0: Internal.Double2DoubleFunction_): this;
        andThen(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2DoubleFunction;
        clear(): void;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): this;
        remove(arg0: number): number;
        get(arg0: number): number;
        get(arg0: any): any;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Double2FloatFunction;
    }
    type Double2DoubleFunction_ = ((arg0: number)=>number) | Double2DoubleFunction;
    class ClientboundBlockEventPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: BlockPos_, arg1: Internal.Block_, arg2: number, arg3: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getPos(): BlockPos;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        getBlock(): Internal.Block;
        getB0(): number;
        getB1(): number;
        get pos(): BlockPos
        get skippable(): boolean
        get block(): Internal.Block
        get b0(): number
        get b1(): number
    }
    type ClientboundBlockEventPacket_ = ClientboundBlockEventPacket;
    class MobEffectInstance implements Internal.IForgeMobEffectInstance, Internal.Comparable<Internal.MobEffectInstance> {
        constructor(arg0: Internal.MobEffect_, arg1: number)
        constructor(arg0: Internal.MobEffect_)
        constructor(arg0: Internal.MobEffect_, arg1: number, arg2: number, arg3: boolean, arg4: boolean, arg5: boolean, arg6: Internal.MobEffectInstance_)
        constructor(arg0: Internal.MobEffect_, arg1: number, arg2: number, arg3: boolean, arg4: boolean, arg5: boolean)
        constructor(arg0: Internal.MobEffect_, arg1: number, arg2: number)
        constructor(arg0: Internal.MobEffect_, arg1: number, arg2: number, arg3: boolean, arg4: boolean)
        constructor(arg0: Internal.MobEffectInstance_)
        applyEffect(arg0: Internal.LivingEntity_): void;
        addCurativeItem(arg0: Internal.ItemStack_): void;
        toString(): string;
        getCurativeItems(): Internal.List<Internal.ItemStack>;
        setNoCounter(arg0: boolean): void;
        isAmbient(): boolean;
        writeCurativeItems(arg0: Internal.CompoundTag_): void;
        save(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        compareTo(arg0: any): number;
        isNoCounter(): boolean;
        static load(arg0: Internal.CompoundTag_): Internal.MobEffectInstance;
        getAmplifier(): number;
        compareTo(arg0: Internal.MobEffectInstance_): number;
        getEffect(): Internal.MobEffect;
        hashCode(): number;
        setCurativeItems(arg0: Internal.List_<Internal.ItemStack_>): void;
        update(arg0: Internal.MobEffectInstance_): boolean;
        showIcon(): boolean;
        equals(arg0: any): boolean;
        isCurativeItem(arg0: Internal.ItemStack_): boolean;
        isVisible(): boolean;
        getDescriptionId(): string;
        tick(arg0: Internal.LivingEntity_, arg1: Internal.Runnable_): boolean;
        getDuration(): number;
        get curativeItems(): Internal.List<Internal.ItemStack>
        set noCounter(arg0: boolean)
        get ambient(): boolean
        get noCounter(): boolean
        get amplifier(): number
        get effect(): Internal.MobEffect
        set curativeItems(arg0: Internal.List_<Internal.ItemStack_>)
        get visible(): boolean
        get descriptionId(): string
        get duration(): number
    }
    type MobEffectInstance_ = MobEffectInstance;
    class SpringConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.FluidState_, arg1: boolean, arg2: number, arg3: number, arg4: Internal.HolderSet_<Internal.Block_>)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
        readonly "requiresBlockBelow": boolean;
        readonly "state": Internal.FluidState;
        readonly "validBlocks": Internal.HolderSet<Internal.Block>;
        readonly "rockCount": number;
        readonly "holeCount": number;
    }
    type SpringConfiguration_ = SpringConfiguration;
    class TropicalFish extends Internal.AbstractSchoolingFish {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static getPatternColor(arg0: number): Internal.DyeColor;
        getBucketItemStack(): Internal.ItemStack;
        getStepHeight(): number;
        setVariant(arg0: number): void;
        asKJS(): Internal.EntityJS;
        getVariant(): number;
        static getBaseVariant(arg0: number): number;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        getBaseVariant(): number;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getBaseColor(): number[];
        static getPredefinedName(arg0: number): string;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        static getBaseColor(arg0: number): Internal.DyeColor;
        isMaxGroupSizeReached(arg0: number): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static getFishTypeName(arg0: number): string;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        saveToBucketTag(arg0: Internal.ItemStack_): void;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        getBaseTextureLocation(): ResourceLocation;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getPatternTextureLocation(): ResourceLocation;
        getClassification(arg0: boolean): Internal.MobCategory;
        static checkTropicalFishSpawnRules(arg0: Internal.EntityType_<Internal.TropicalFish_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        getPatternColor(): number[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get bucketItemStack(): Internal.ItemStack
        get stepHeight(): number
        set variant(arg0: number)
        get variant(): number
        get multipartEntity(): boolean
        get baseVariant(): number
        get baseColor(): number[]
        get parts(): Internal.PartEntity<any>[]
        get baseTextureLocation(): ResourceLocation
        get patternTextureLocation(): ResourceLocation
        get patternColor(): number[]
        readonly static "BUCKET_VARIANT_TAG": "BucketVariantTag";
        readonly static "BASE_SMALL": 0;
        readonly static "BASE_LARGE": 1;
        readonly static "COMMON_VARIANTS": any;
    }
    type TropicalFish_ = TropicalFish;
    interface BlockPredicate {
        check(arg0: Internal.BlockContainerJS_): boolean;
    }
    type BlockPredicate_ = BlockPredicate;
    abstract class ChunkGenerator implements Internal.BiomeManager$NoiseBiomeSource {
        constructor(arg0: Internal.Registry_<Internal.StructureSet_>, arg1: Internal.Optional_<Internal.HolderSet_<Internal.StructureSet_>>, arg2: Internal.BiomeSource_)
        constructor(arg0: Internal.Registry_<Internal.StructureSet_>, arg1: Internal.Optional_<Internal.HolderSet_<Internal.StructureSet_>>, arg2: Internal.BiomeSource_, arg3: Internal.BiomeSource_, arg4: number)
        applyCarvers(arg0: Internal.WorldGenRegion_, arg1: number, arg2: Internal.BiomeManager_, arg3: Internal.StructureFeatureManager_, arg4: Internal.ChunkAccess_, arg5: CarvingGenerationStep_): void;
        hasFeatureChunkInRange(arg0: Internal.ResourceKey_<Internal.StructureSet_>, arg1: number, arg2: number, arg3: number, arg4: number): boolean;
        getSeaLevel(): number;
        ensureStructuresGenerated(): void;
        getTypeNameForDataFixer(): Internal.Optional<Internal.ResourceKey<Internal.Codec<any>>>;
        withSeed(arg0: number): this;
        getMobsAt(arg0: Internal.Holder_<Internal.Biome_>, arg1: Internal.StructureFeatureManager_, arg2: Internal.MobCategory_, arg3: BlockPos_): Internal.WeightedRandomList<Internal.MobSpawnSettings$SpawnerData>;
        getBiomeSource(): Internal.BiomeSource;
        getRingPositionsFor(arg0: Internal.ConcentricRingsStructurePlacement_): Internal.List<Internal.ChunkPos>;
        buildSurface(arg0: Internal.WorldGenRegion_, arg1: Internal.StructureFeatureManager_, arg2: Internal.ChunkAccess_): void;
        getBaseHeight(arg0: number, arg1: number, arg2: Internal.Heightmap$Types_, arg3: Internal.LevelHeightAccessor_): number;
        createReferences(arg0: Internal.WorldGenLevel_, arg1: Internal.StructureFeatureManager_, arg2: Internal.ChunkAccess_): void;
        addDebugScreenInfo(arg0: Internal.List_<string>, arg1: BlockPos_): void;
        spawnOriginalMobs(arg0: Internal.WorldGenRegion_): void;
        getMinY(): number;
        getNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        fillFromNoise(arg0: Internal.Executor_, arg1: Internal.Blender_, arg2: Internal.StructureFeatureManager_, arg3: Internal.ChunkAccess_): Internal.CompletableFuture<Internal.ChunkAccess>;
        climateSampler(): Internal.Climate$Sampler;
        getFirstOccupiedHeight(arg0: number, arg1: number, arg2: Internal.Heightmap$Types_, arg3: Internal.LevelHeightAccessor_): number;
        getBaseColumn(arg0: number, arg1: number, arg2: Internal.LevelHeightAccessor_): Internal.NoiseColumn;
        findNearestMapFeature(arg0: Internal.ServerLevel_, arg1: Internal.HolderSet_<Internal.ConfiguredStructureFeature_<any, any>>, arg2: BlockPos_, arg3: number, arg4: boolean): com.mojang.datafixers.util.Pair<BlockPos, Internal.Holder<Internal.ConfiguredStructureFeature<any, any>>>;
        getSpawnHeight(arg0: Internal.LevelHeightAccessor_): number;
        getGenDepth(): number;
        createStructures(arg0: Internal.RegistryAccess_, arg1: Internal.StructureFeatureManager_, arg2: Internal.ChunkAccess_, arg3: Internal.StructureManager_, arg4: number): void;
        createBiomes(arg0: Internal.Registry_<Internal.Biome_>, arg1: Internal.Executor_, arg2: Internal.Blender_, arg3: Internal.StructureFeatureManager_, arg4: Internal.ChunkAccess_): Internal.CompletableFuture<Internal.ChunkAccess>;
        static allConfigurations(arg0: Internal.Registry_<Internal.ConfiguredStructureFeature_<any, any>>, arg1: Internal.StructureFeature_<any>): Internal.Stream<Internal.ConfiguredStructureFeature<any, any>>;
        getFirstFreeHeight(arg0: number, arg1: number, arg2: Internal.Heightmap$Types_, arg3: Internal.LevelHeightAccessor_): number;
        applyBiomeDecoration(arg0: Internal.WorldGenLevel_, arg1: Internal.ChunkAccess_, arg2: Internal.StructureFeatureManager_): void;
        possibleStructureSets(): Internal.Stream<Internal.Holder<Internal.StructureSet>>;
        get seaLevel(): number
        get typeNameForDataFixer(): Internal.Optional<Internal.ResourceKey<Internal.Codec<any>>>
        get biomeSource(): Internal.BiomeSource
        get minY(): number
        get genDepth(): number
        readonly static "CODEC": any;
    }
    type ChunkGenerator_ = ChunkGenerator;
    class StructureTemplatePool$Projection extends Internal.Enum<Internal.StructureTemplatePool$Projection> implements Internal.StringRepresentable {
        static byName(arg0: string): Internal.StructureTemplatePool$Projection;
        static values(): Internal.StructureTemplatePool$Projection[];
        getSerializedName(): string;
        getName(): string;
        static valueOf(arg0: string): Internal.StructureTemplatePool$Projection;
        getProcessors(): Internal.ImmutableList<Internal.StructureProcessor>;
        get serializedName(): string
        get name(): string
        get processors(): Internal.ImmutableList<Internal.StructureProcessor>
        readonly static "TERRAIN_MATCHING": Internal.StructureTemplatePool$Projection;
        readonly static "RIGID": Internal.StructureTemplatePool$Projection;
        readonly static "CODEC": any;
    }
    type StructureTemplatePool$Projection_ = "terrain_matching" | StructureTemplatePool$Projection | "rigid";
    class ParsedCommandNode <S> {
        constructor(arg0: Internal.CommandNode_<S>, arg1: Internal.StringRange_)
        hashCode(): number;
        toString(): string;
        equals(arg0: any): boolean;
        getRange(): Internal.StringRange;
        getNode(): Internal.CommandNode<S>;
        get range(): Internal.StringRange
        get node(): Internal.CommandNode<S>
    }
    type ParsedCommandNode_<S> = ParsedCommandNode<S>;
    abstract class BaseContainerBlockEntity extends Internal.BlockEntity implements Internal.Container, Internal.Nameable, Internal.MenuProvider {
        stopOpen(arg0: Internal.Player_): void;
        getDisplayName(): Internal.Component;
        getCapability(arg0: Internal.Capability_<T>, arg1: Internal.Direction_): Internal.LazyOptional<T>;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        countItem(arg0: Internal.Item_): number;
        setCustomName(arg0: Internal.Component_): void;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        createMenu(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Player_): Internal.AbstractContainerMenu;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        load(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        invalidateCaps(): void;
        getName(): Internal.Component;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMaxStackSize(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        static canUnlock(arg0: Internal.Player_, arg1: Internal.LockCode_, arg2: Internal.Component_): boolean;
        canOpen(arg0: Internal.Player_): boolean;
        reviveCaps(): void;
        getRenderBoundingBox(): Internal.AABB;
        getCustomName(): Internal.Component;
        get displayName(): Internal.Component
        set customName(arg0: Internal.Component_)
        get name(): Internal.Component
        get modelData(): Internal.IModelData
        get maxStackSize(): number
        get renderBoundingBox(): Internal.AABB
        get customName(): Internal.Component
    }
    type BaseContainerBlockEntity_ = BaseContainerBlockEntity;
    class StoneButtonBlockBuilder extends Internal.ShapedBlockBuilder {
        constructor(i: ResourceLocation_)
        createObject(): Internal.Block;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
    }
    type StoneButtonBlockBuilder_ = StoneButtonBlockBuilder;
    interface Bucketable {
        saveToBucketTag(arg0: Internal.ItemStack_): void;
        saveDefaultDataToBucketTag(arg0: Internal.Mob_, arg1: Internal.ItemStack_): void;
        bucketMobPickup(arg0: Internal.Player_, arg1: Hand_, arg2: T): Internal.Optional<Internal.InteractionResult>;
        loadFromBucketTag(arg0: Internal.CompoundTag_): void;
        getBucketItemStack(): Internal.ItemStack;
        loadDefaultDataFromBucketTag(arg0: Internal.Mob_, arg1: Internal.CompoundTag_): void;
        setFromBucket(arg0: boolean): void;
        fromBucket(): boolean;
        getPickupSound(): Internal.SoundEvent;
        get bucketItemStack(): Internal.ItemStack
        set fromBucket(arg0: boolean)
        get pickupSound(): Internal.SoundEvent
    }
    type Bucketable_ = Bucketable;
    class BlockPositionSource implements Internal.PositionSource {
        constructor(arg0: BlockPos_)
        constructor(arg0: Internal.Optional_<BlockPos_>)
        getPosition(arg0: Internal.Level_): Internal.Optional<BlockPos>;
        getType(): Internal.PositionSourceType<any>;
        get type(): Internal.PositionSourceType<any>
        readonly static "CODEC": any;
    }
    type BlockPositionSource_ = BlockPositionSource;
    interface MessageSizeEstimator {
        newHandle(): Internal.MessageSizeEstimator$Handle;
    }
    type MessageSizeEstimator_ = MessageSizeEstimator;
    interface DynamicOps <T> {
        convertTo(arg0: Internal.DynamicOps_<U>, arg1: T): U;
        createNumeric(arg0: Internal.Number_): T;
        mergeToList(arg0: T, arg1: Internal.List_<T>): Internal.DataResult<T>;
        getMapEntries(arg0: T): Internal.DataResult<Internal.Consumer<Internal.BiConsumer<T, T>>>;
        mergeToList(arg0: T, arg1: T): Internal.DataResult<T>;
        getByteBuffer(arg0: T): Internal.DataResult<Internal.ByteBuffer>;
        listBuilder(): Internal.ListBuilder<T>;
        convertMap(arg0: Internal.DynamicOps_<U>, arg1: T): U;
        set(arg0: T, arg1: string, arg2: T): T;
        createInt(arg0: number): T;
        createFloat(arg0: number): T;
        createBoolean(arg0: boolean): T;
        getMap(arg0: T): Internal.DataResult<Internal.MapLike<T>>;
        withEncoder(arg0: Internal.Encoder_<E>): Internal.Function<E, Internal.DataResult<T>>;
        createIntList(arg0: Internal.IntStream_): T;
        updateGeneric(arg0: T, arg1: T, arg2: Internal.Function_<T, T>): T;
        createShort(arg0: number): T;
        convertList(arg0: Internal.DynamicOps_<U>, arg1: T): U;
        mapBuilder(): Internal.RecordBuilder<T>;
        update(arg0: T, arg1: string, arg2: Internal.Function_<T, T>): T;
        createMap(arg0: Internal.Map_<T, T>): T;
        createString(arg0: string): T;
        getIntStream(arg0: T): Internal.DataResult<Internal.IntStream>;
        emptyList(): T;
        compressMaps(): boolean;
        getLongStream(arg0: T): Internal.DataResult<Internal.LongStream>;
        createLong(arg0: number): T;
        mergeToPrimitive(arg0: T, arg1: T): Internal.DataResult<T>;
        empty(): T;
        getStream(arg0: T): Internal.DataResult<Internal.Stream<T>>;
        createByteList(arg0: Internal.ByteBuffer_): T;
        mergeToMap(arg0: T, arg1: T, arg2: T): Internal.DataResult<T>;
        getNumberValue(arg0: T): Internal.DataResult<Internal.Number>;
        withParser(arg0: Internal.Decoder_<E>): Internal.Function<T, Internal.DataResult<E>>;
        createList(arg0: Internal.Stream_<T>): T;
        emptyMap(): T;
        withDecoder(arg0: Internal.Decoder_<E>): Internal.Function<T, Internal.DataResult<com.mojang.datafixers.util.Pair<E, T>>>;
        getGeneric(arg0: T, arg1: T): Internal.DataResult<T>;
        createByte(arg0: number): T;
        createMap(arg0: Internal.Stream_<com.mojang.datafixers.util.Pair_<T, T>>): T;
        getBooleanValue(arg0: T): Internal.DataResult<boolean>;
        createLongList(arg0: Internal.LongStream_): T;
        getNumberValue(arg0: T, arg1: Internal.Number_): Internal.Number;
        createDouble(arg0: number): T;
        getMapValues(arg0: T): Internal.DataResult<Internal.Stream<com.mojang.datafixers.util.Pair<T, T>>>;
        get(arg0: T, arg1: string): Internal.DataResult<T>;
        mergeToMap(arg0: T, arg1: Internal.Map_<T, T>): Internal.DataResult<T>;
        getList(arg0: T): Internal.DataResult<Internal.Consumer<Internal.Consumer<T>>>;
        getStringValue(arg0: T): Internal.DataResult<string>;
        mergeToMap(arg0: T, arg1: Internal.MapLike_<T>): Internal.DataResult<T>;
        remove(arg0: T, arg1: string): T;
    }
    type DynamicOps_<T> = DynamicOps<T>;
    abstract class Struct extends Internal.Pointer$Default {
        free(): void;
        clear(): void;
        isNull(arg0: number): boolean;
        sizeof(): number;
    }
    type Struct_ = Struct;
    class ClientboundAddPlayerPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.Player_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getX(): number;
        getY(): number;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getZ(): number;
        getPlayerId(): Internal.UUID;
        getxRot(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getEntityId(): number;
        getyRot(): number;
        isSkippable(): boolean;
        get x(): number
        get y(): number
        get z(): number
        get playerId(): Internal.UUID
        get xRot(): number
        get entityId(): number
        get yRot(): number
        get skippable(): boolean
    }
    type ClientboundAddPlayerPacket_ = ClientboundAddPlayerPacket;
    class BiomeManager {
        constructor(arg0: Internal.BiomeManager$NoiseBiomeSource_, arg1: number)
        getBiome(arg0: BlockPos_): Internal.Holder<Internal.Biome>;
        withDifferentSource(arg0: Internal.BiomeManager$NoiseBiomeSource_): this;
        getNoiseBiomeAtQuart(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        getNoiseBiomeAtPosition(arg0: BlockPos_): Internal.Holder<Internal.Biome>;
        static obfuscateSeed(arg0: number): number;
        getNoiseBiomeAtPosition(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        readonly static "CHUNK_CENTER_QUART": 2;
    }
    type BiomeManager_ = BiomeManager;
    class SmithingMenu extends Internal.ItemCombinerMenu {
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: any_)
        constructor(arg0: number, arg1: Internal.Inventory_)
        canTakeItemForPickAll(arg0: Internal.ItemStack_, arg1: Internal.Slot_): boolean;
        createResult(): void;
    }
    type SmithingMenu_ = SmithingMenu;
    class ShulkerBoxColoring extends Internal.CustomRecipe {
        constructor(arg0: ResourceLocation_)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        getSerializer(): Internal.RecipeSerializer<any>;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        matches(arg0: Internal.CraftingContainer_, arg1: Internal.Level_): boolean;
        isIncomplete(): boolean;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        assemble(arg0: Internal.CraftingContainer_): Internal.ItemStack;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get serializer(): Internal.RecipeSerializer<any>
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get incomplete(): boolean
    }
    type ShulkerBoxColoring_ = ShulkerBoxColoring;
    class ClientPlayerNetworkEvent$RespawnEvent extends Internal.ClientPlayerNetworkEvent {
        constructor()
        constructor(arg0: Internal.MultiPlayerGameMode_, arg1: Internal.LocalPlayer_, arg2: Internal.LocalPlayer_, arg3: Internal.Connection_)
        getNewPlayer(): Internal.LocalPlayer;
        getListenerList(): Internal.ListenerList;
        getOldPlayer(): Internal.LocalPlayer;
        get newPlayer(): Internal.LocalPlayer
        get listenerList(): Internal.ListenerList
        get oldPlayer(): Internal.LocalPlayer
    }
    type ClientPlayerNetworkEvent$RespawnEvent_ = ClientPlayerNetworkEvent$RespawnEvent;
    class BasicBlockJS$Builder extends Internal.BlockBuilder {
        constructor(i: ResourceLocation_)
        createObject(): Internal.Block;
    }
    type BasicBlockJS$Builder_ = BasicBlockJS$Builder;
    class UUID implements Internal.Comparable<Internal.UUID>, Internal.Serializable {
        constructor(arg0: number, arg1: number)
        toString(): string;
        version(): number;
        node(): number;
        variant(): number;
        compareTo(arg0: any): number;
        getLeastSignificantBits(): number;
        clockSequence(): number;
        hashCode(): number;
        static randomUUID(): Internal.UUID;
        compareTo(arg0: Internal.UUID_): number;
        static nameUUIDFromBytes(arg0: number[]): Internal.UUID;
        timestamp(): number;
        equals(arg0: any): boolean;
        getMostSignificantBits(): number;
        static fromString(arg0: string): Internal.UUID;
        get leastSignificantBits(): number
        get mostSignificantBits(): number
    }
    type UUID_ = UUID;
    class CommandBlockEntity$Mode extends Internal.Enum<Internal.CommandBlockEntity$Mode> {
        static values(): Internal.CommandBlockEntity$Mode[];
        static valueOf(arg0: string): Internal.CommandBlockEntity$Mode;
        readonly static "AUTO": Internal.CommandBlockEntity$Mode;
        readonly static "REDSTONE": Internal.CommandBlockEntity$Mode;
        readonly static "SEQUENCE": Internal.CommandBlockEntity$Mode;
    }
    type CommandBlockEntity$Mode_ = "sequence" | "auto" | "redstone" | CommandBlockEntity$Mode;
    abstract class DynamicConstantDesc <T> implements Internal.ConstantDesc {
        constantName(): string;
        constantType(): Internal.ClassDesc;
        toString(): string;
        bootstrapArgsList(): Internal.List<Internal.ConstantDesc>;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup_): T;
        static ofCanonical(arg0: Internal.DirectMethodHandleDesc_, arg1: string, arg2: Internal.ClassDesc_, arg3: Internal.ConstantDesc_[]): Internal.ConstantDesc;
        bootstrapMethod(): Internal.DirectMethodHandleDesc;
        hashCode(): number;
        bootstrapArgs(): Internal.ConstantDesc[];
        static of(arg0: Internal.DirectMethodHandleDesc_): Internal.DynamicConstantDesc<T>;
        static ofNamed(arg0: Internal.DirectMethodHandleDesc_, arg1: string, arg2: Internal.ClassDesc_, ...arg3: Internal.ConstantDesc_[]): Internal.DynamicConstantDesc<T>;
        equals(arg0: any): boolean;
        static of(arg0: Internal.DirectMethodHandleDesc_, ...arg1: Internal.ConstantDesc_[]): Internal.DynamicConstantDesc<T>;
    }
    type DynamicConstantDesc_<T> = DynamicConstantDesc<T>;
    interface Double2LongFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleToLongFunction {
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Double2FloatFunction;
        getOrDefault(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Double2IntFunction;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Double2CharFunction;
        get(arg0: any): number;
        containsKey(arg0: any): boolean;
        getOrDefault(arg0: number, arg1: number): number;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2LongFunction;
        put(arg0: any, arg1: any): any;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2LongFunction;
        apply(arg0: number): number;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Double2ByteFunction;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2LongFunction;
        get(arg0: number): number;
        defaultReturnValue(): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeObject(arg0: Internal.Object2DoubleFunction_<any>): Internal.Object2LongFunction<T>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2LongFunction;
        andThenObject(arg0: Internal.Long2ObjectFunction_<any>): Internal.Double2ObjectFunction<T>;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Double2DoubleFunction;
        applyAsLong(arg0: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Double2ShortFunction;
        andThenLong(arg0: Internal.Long2LongFunction_): this;
        containsKey(arg0: number): boolean;
        size(): number;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2LongFunction;
        clear(): void;
        andThenReference(arg0: Internal.Long2ReferenceFunction_<any>): Internal.Double2ReferenceFunction<T>;
        composeDouble(arg0: Internal.Double2DoubleFunction_): this;
        remove(arg0: any): any;
        composeReference(arg0: Internal.Reference2DoubleFunction_<any>): Internal.Reference2LongFunction<T>;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2LongFunction;
        put(arg0: number, arg1: number): number;
        defaultReturnValue(arg0: number): void;
    }
    type Double2LongFunction_ = Double2LongFunction | ((arg0: number)=>number);
    abstract class AbstractFurnaceBlockEntity extends Internal.BaseContainerBlockEntity implements Internal.StackedContentsCompatible, Internal.RecipeHolder, Internal.WorldlyContainer {
        stopOpen(arg0: Internal.Player_): void;
        getCapability(arg0: Internal.Capability_<T>, arg1: Internal.Direction_): Internal.LazyOptional<T>;
        static serverTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.AbstractFurnaceBlockEntity_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        countItem(arg0: Internal.Item_): number;
        static isFuel(arg0: Internal.ItemStack_): boolean;
        isEmpty(): boolean;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        removeItem(arg0: number, arg1: number): Internal.ItemStack;
        load(arg0: Internal.CompoundTag_): void;
        canPlaceItemThroughFace(arg0: number, arg1: Internal.ItemStack_, arg2: Internal.Direction_): boolean;
        static getFuel(): Internal.Map<Internal.Item, number>;
        onLoad(): void;
        getContainerSize(): number;
        getSlotsForFace(arg0: Internal.Direction_): number[];
        setItem(arg0: number, arg1: Internal.ItemStack_): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        awardUsedRecipes(arg0: Internal.Player_): void;
        awardUsedRecipesAndPopExperience(arg0: Internal.ServerPlayer_): void;
        invalidateCaps(): void;
        setRecipeUsed(arg0: Internal.Level_, arg1: Internal.ServerPlayer_, arg2: Internal.Recipe_<any>): boolean;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMaxStackSize(): number;
        fillStackedContents(arg0: Internal.StackedContents_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        removeItemNoUpdate(arg0: number): Internal.ItemStack;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        stillValid(arg0: Internal.Player_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getRecipeUsed(): Internal.Recipe<any>;
        getItem(arg0: number): Internal.ItemStack;
        setRecipeUsed(arg0: Internal.Recipe_<any>): void;
        clearContent(): void;
        reviveCaps(): void;
        canTakeItemThroughFace(arg0: number, arg1: Internal.ItemStack_, arg2: Internal.Direction_): boolean;
        getRecipesToAwardAndPopExperience(arg0: Internal.ServerLevel_, arg1: Vec3_): Internal.List<Internal.Recipe<any>>;
        getRenderBoundingBox(): Internal.AABB;
        get empty(): boolean
        get fuel(): Internal.Map<Internal.Item, number>
        get containerSize(): number
        get modelData(): Internal.IModelData
        get maxStackSize(): number
        get recipeUsed(): Internal.Recipe<any>
        set recipeUsed(arg0: Internal.Recipe_<any>)
        get renderBoundingBox(): Internal.AABB
        readonly static "DATA_LIT_DURATION": 1;
        readonly static "DATA_COOKING_PROGRESS": 2;
        readonly static "NUM_DATA_VALUES": 4;
        readonly static "DATA_LIT_TIME": 0;
        readonly static "BURN_TIME_STANDARD": 200;
        readonly static "BURN_COOL_SPEED": 2;
        readonly static "DATA_COOKING_TOTAL_TIME": 3;
    }
    type AbstractFurnaceBlockEntity_ = AbstractFurnaceBlockEntity;
    class ScreenEvent$KeyboardCharTypedEvent$Pre extends Internal.ScreenEvent$KeyboardCharTypedEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: string, arg2: number)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$KeyboardCharTypedEvent$Pre_ = ScreenEvent$KeyboardCharTypedEvent$Pre;
    class EmptyPoolElement extends Internal.StructurePoolElement {
        getType(): Internal.StructurePoolElementType<any>;
        getSize(arg0: Internal.StructureManager_, arg1: Internal.Rotation_): Vec3i;
        toString(): string;
        place(arg0: Internal.StructureManager_, arg1: Internal.WorldGenLevel_, arg2: Internal.StructureFeatureManager_, arg3: Internal.ChunkGenerator_, arg4: BlockPos_, arg5: BlockPos_, arg6: Internal.Rotation_, arg7: Internal.BoundingBox_, arg8: Internal.Random_, arg9: boolean): boolean;
        getShuffledJigsawBlocks(arg0: Internal.StructureManager_, arg1: BlockPos_, arg2: Internal.Rotation_, arg3: Internal.Random_): Internal.List<Internal.StructureTemplate$StructureBlockInfo>;
        getBoundingBox(arg0: Internal.StructureManager_, arg1: BlockPos_, arg2: Internal.Rotation_): Internal.BoundingBox;
        get type(): Internal.StructurePoolElementType<any>
        readonly static "CODEC": any;
        readonly static "INSTANCE": Internal.EmptyPoolElement;
    }
    type EmptyPoolElement_ = EmptyPoolElement;
    interface IForgeCommandSourceStack {
        getRecipeManager(): Internal.RecipeManager;
        getAdvancement(arg0: ResourceLocation_): Internal.Advancement;
        getUnsidedLevel(): Internal.Level;
        getScoreboard(): Internal.Scoreboard;
        get recipeManager(): Internal.RecipeManager
        get unsidedLevel(): Internal.Level
        get scoreboard(): Internal.Scoreboard
    }
    type IForgeCommandSourceStack_ = IForgeCommandSourceStack;
    class SoundBufferLibrary {
        constructor(arg0: Internal.ResourceManager_)
        getStream(arg0: ResourceLocation_, arg1: boolean): Internal.CompletableFuture<Internal.AudioStream>;
        preload(arg0: Internal.Collection_<Internal.Sound_>): Internal.CompletableFuture<any>;
        clear(): void;
        getCompleteBuffer(arg0: ResourceLocation_): Internal.CompletableFuture<Internal.SoundBuffer>;
    }
    type SoundBufferLibrary_ = SoundBufferLibrary;
    class PlayerEnderChestContainer extends Internal.SimpleContainer {
        constructor()
        stillValid(arg0: Internal.Player_): boolean;
        stopOpen(arg0: Internal.Player_): void;
        createTag(): Internal.ListTag;
        isActiveChest(arg0: Internal.EnderChestBlockEntity_): boolean;
        getMaxStackSize(): number;
        countItem(arg0: Internal.Item_): number;
        fromTag(arg0: Internal.ListTag_): void;
        setActiveChest(arg0: Internal.EnderChestBlockEntity_): void;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        get maxStackSize(): number
        set activeChest(arg0: Internal.EnderChestBlockEntity_)
    }
    type PlayerEnderChestContainer_ = PlayerEnderChestContainer;
    interface HolderSet <T> extends Internal.Iterable<Internal.Holder<T>> {
        isValidInRegistry(arg0: Internal.Registry_<T>): boolean;
        unwrap(): Internal.Either<Internal.TagKey<T>, Internal.List<Internal.Holder<T>>>;
        direct(arg0: Internal.List_<any>): Internal.HolderSet$Direct<T>;
        forEach(arg0: Internal.Consumer_<any>): void;
        get(arg0: number): Internal.Holder<T>;
        spliterator(): Internal.Spliterator<Internal.Holder<T>>;
        stream(): Internal.Stream<Internal.Holder<T>>;
        getRandomElement(arg0: Internal.Random_): Internal.Optional<Internal.Holder<T>>;
        size(): number;
        contains(arg0: Internal.Holder_<T>): boolean;
        direct(arg0: Internal.Function_<E, Internal.Holder_<T>>, ...arg1: E[]): Internal.HolderSet$Direct<T>;
        direct(...arg0: Internal.Holder_<T>[]): Internal.HolderSet$Direct<T>;
        direct(arg0: Internal.Function_<E, Internal.Holder_<T>>, arg1: Internal.List_<E>): Internal.HolderSet$Direct<T>;
    }
    type HolderSet_<T> = HolderSet<T>;
    class TraderLlama extends Internal.Llama {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        isTraderLlama(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        setDespawnDelay(arg0: number): void;
        get traderLlama(): boolean
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        set despawnDelay(arg0: number)
    }
    type TraderLlama_ = TraderLlama;
    abstract class TypeToken <T> extends Internal.TypeCapture<T> implements Internal.Serializable {
        static of(arg0: Internal.Class_<T>): Internal.TypeToken<T>;
        where(arg0: Internal.TypeParameter_<X>, arg1: Internal.Class_<X>): this;
        isPrimitive(): boolean;
        static of(arg0: Internal.Type_): Internal.TypeToken<any>;
        method(arg0: Internal.Method_): Internal.Invokable<T, any>;
        getSubtype(arg0: Internal.Class_<any>): Internal.TypeToken<any>;
        toString(): string;
        getSupertype(arg0: Internal.Class_<any>): Internal.TypeToken<any>;
        getComponentType(): Internal.TypeToken<any>;
        getTypes(): Internal.TypeToken$TypeSet<>;
        getRawType(): Internal.Class<any>;
        where(arg0: Internal.TypeParameter_<X>, arg1: Internal.TypeToken_<X>): this;
        resolveType(arg0: Internal.Type_): Internal.TypeToken<any>;
        isSubtypeOf(arg0: Internal.TypeToken_<any>): boolean;
        isSupertypeOf(arg0: Internal.Type_): boolean;
        hashCode(): number;
        isArray(): boolean;
        wrap(): this;
        isSubtypeOf(arg0: Internal.Type_): boolean;
        unwrap(): this;
        equals(arg0: any): boolean;
        constructor(arg0: Internal.Constructor_<any>): Internal.Invokable<T, T>;
        getType(): Internal.Type;
        isSupertypeOf(arg0: Internal.TypeToken_<any>): boolean;
        get primitive(): boolean
        get componentType(): Internal.TypeToken<any>
        get types(): Internal.TypeToken$TypeSet<>
        get rawType(): Internal.Class<any>
        get array(): boolean
        get type(): Internal.Type
    }
    type TypeToken_<T> = TypeToken<T>;
    interface ICustomPacket <T> {
        getThis(): T;
        setData(arg0: Internal.FriendlyByteBuf_): void;
        getInternalData(): Internal.FriendlyByteBuf;
        getDirection(): Internal.NetworkDirection;
        getName(): ResourceLocation;
        getIndex(): number;
        setName(arg0: ResourceLocation_): void;
        setIndex(arg0: number): void;
        get this(): T
        set data(arg0: Internal.FriendlyByteBuf_)
        get internalData(): Internal.FriendlyByteBuf
        get direction(): Internal.NetworkDirection
        get name(): ResourceLocation
        get index(): number
        set name(arg0: ResourceLocation_)
        set index(arg0: number)
    }
    type ICustomPacket_<T> = ICustomPacket<T>;
    class BlockStateProviderType <P> extends Internal.ForgeRegistryEntry<Internal.BlockStateProviderType<any>> {
        constructor(arg0: Internal.Codec_<P>)
        codec(): Internal.Codec<P>;
        readonly static "WEIGHTED_STATE_PROVIDER": Internal.BlockStateProviderType<any>;
        readonly static "SIMPLE_STATE_PROVIDER": Internal.BlockStateProviderType<any>;
        readonly static "DUAL_NOISE_PROVIDER": Internal.BlockStateProviderType<any>;
        readonly static "NOISE_THRESHOLD_PROVIDER": Internal.BlockStateProviderType<any>;
        readonly static "ROTATED_BLOCK_PROVIDER": Internal.BlockStateProviderType<any>;
        readonly static "NOISE_PROVIDER": Internal.BlockStateProviderType<any>;
        readonly static "RANDOMIZED_INT_STATE_PROVIDER": Internal.BlockStateProviderType<any>;
    }
    type BlockStateProviderType_<P> = Special.BlockStateProviderType | BlockStateProviderType<P>;
    class MinecartFurnace extends Internal.AbstractMinecart {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        isPoweredCart(): boolean;
        getCurrentRailPosition(): BlockPos;
        getMaxCartSpeedOnRail(): number;
        interact(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        getSlopeAdjustment(): number;
        shouldDoRailFunctions(): boolean;
        canRiderInteract(): boolean;
        destroy(arg0: Internal.DamageSource_): void;
        isMultipartEntity(): boolean;
        canBeRidden(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getDefaultDisplayBlockState(): Internal.BlockState;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getCartItem(): Internal.ItemStack;
        tick(): void;
        getMinecartType(): Internal.AbstractMinecart$Type;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getComparatorLevel(): number;
        get poweredCart(): boolean
        get currentRailPosition(): BlockPos
        get maxCartSpeedOnRail(): number
        get stepHeight(): number
        get slopeAdjustment(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get defaultDisplayBlockState(): Internal.BlockState
        get cartItem(): Internal.ItemStack
        get minecartType(): Internal.AbstractMinecart$Type
        get comparatorLevel(): number
        "xPush": number;
        "zPush": number;
    }
    type MinecartFurnace_ = MinecartFurnace;
    abstract class ForwardingCollection <E> extends Internal.ForwardingObject implements Internal.Collection<E> {
        add(arg0: E): boolean;
        forEach(arg0: Internal.Consumer_<any>): void;
        toArray(arg0: T[]): T[];
        remove(arg0: any): boolean;
        parallelStream(): Internal.Stream<E>;
        isEmpty(): boolean;
        toArray(): any[];
        iterator(): Internal.Iterator<E>;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        size(): number;
        stream(): Internal.Stream<E>;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        clear(): void;
        addAll(arg0: Internal.Collection_<any>): boolean;
        spliterator(): Internal.Spliterator<E>;
        contains(arg0: any): boolean;
        get empty(): boolean
    }
    type ForwardingCollection_<E> = ForwardingCollection<E>;
    interface Hopper extends Internal.Container {
        stopOpen(arg0: Internal.Player_): void;
        getSuckShape(): Internal.VoxelShape;
        getMaxStackSize(): number;
        countItem(arg0: Internal.Item_): number;
        getLevelX(): number;
        getLevelY(): number;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        getLevelZ(): number;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        get suckShape(): Internal.VoxelShape
        get maxStackSize(): number
        get levelX(): number
        get levelY(): number
        get levelZ(): number
        readonly static "SUCK": any;
        readonly static "INSIDE": any;
        readonly static "ABOVE": any;
    }
    type Hopper_ = Hopper;
    class DeltaFeatureConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.BlockState_, arg1: Internal.BlockState_, arg2: Internal.IntProvider_, arg3: Internal.IntProvider_)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        rim(): Internal.BlockState;
        contents(): Internal.BlockState;
        rimSize(): Internal.IntProvider;
        size(): Internal.IntProvider;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
    }
    type DeltaFeatureConfiguration_ = DeltaFeatureConfiguration;
    interface GenericFutureListener <F> extends Internal.EventListener {
        operationComplete(arg0: F): void;
    }
    type GenericFutureListener_<F> = GenericFutureListener<F>;
    class Subject implements Internal.Serializable {
        constructor()
        constructor(arg0: boolean, arg1: Internal.Set_<any>, arg2: Internal.Set_<any>, arg3: Internal.Set_<any>)
        getPrivateCredentials(arg0: Internal.Class_<T>): Internal.Set<T>;
        getPublicCredentials(arg0: Internal.Class_<T>): Internal.Set<T>;
        getPrivateCredentials(): Internal.Set<any>;
        getPublicCredentials(): Internal.Set<any>;
        toString(): string;
        getPrincipals(arg0: Internal.Class_<T>): Internal.Set<T>;
        static getSubject(arg0: Internal.AccessControlContext_): Internal.Subject;
        static doAs(arg0: Internal.Subject_, arg1: Internal.PrivilegedExceptionAction_<T>): T;
        static doAsPrivileged(arg0: Internal.Subject_, arg1: Internal.PrivilegedAction_<T>, arg2: Internal.AccessControlContext_): T;
        hashCode(): number;
        setReadOnly(): void;
        static doAs(arg0: Internal.Subject_, arg1: Internal.PrivilegedAction_<T>): T;
        isReadOnly(): boolean;
        equals(arg0: any): boolean;
        static doAsPrivileged(arg0: Internal.Subject_, arg1: Internal.PrivilegedExceptionAction_<T>, arg2: Internal.AccessControlContext_): T;
        getPrincipals(): Internal.Set<Internal.Principal>;
        get privateCredentials(): Internal.Set<any>
        get publicCredentials(): Internal.Set<any>
        get readOnly(): boolean
        get principals(): Internal.Set<Internal.Principal>
    }
    type Subject_ = Subject;
    class JsonGenerator {
        constructor(c: Internal.ConsoleJS_, m: Internal.Map_<ResourceLocation_, Internal.JsonElement_>)
        json(id: ResourceLocation_, json: Internal.JsonElement_): void;
        getAllJsons(): Internal.Map<ResourceLocation, Internal.JsonElement>;
        get allJsons(): Internal.Map<ResourceLocation, Internal.JsonElement>
    }
    type JsonGenerator_ = JsonGenerator;
    class ServerGamePacketListenerImpl implements Internal.ServerPlayerConnection, Internal.ServerGamePacketListener {
        constructor(arg0: Internal.MinecraftServer_, arg1: Internal.Connection_, arg2: Internal.ServerPlayer_)
        teleport(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.Set_<Internal.ClientboundPlayerPositionPacket$RelativeArgument_>, arg6: boolean): void;
        handlePlayerAbilities(arg0: Internal.ServerboundPlayerAbilitiesPacket_): void;
        handlePlayerInput(arg0: Internal.ServerboundPlayerInputPacket_): void;
        handleClientCommand(arg0: Internal.ServerboundClientCommandPacket_): void;
        handleResourcePackResponse(arg0: Internal.ServerboundResourcePackPacket_): void;
        handleSetCarriedItem(arg0: Internal.ServerboundSetCarriedItemPacket_): void;
        handlePickItem(arg0: Internal.ServerboundPickItemPacket_): void;
        handleSetCreativeModeSlot(arg0: Internal.ServerboundSetCreativeModeSlotPacket_): void;
        handleSeenAdvancements(arg0: Internal.ServerboundSeenAdvancementsPacket_): void;
        getPlayer(): Internal.ServerPlayer;
        handleKeepAlive(arg0: Internal.ServerboundKeepAlivePacket_): void;
        handleUseItem(arg0: Internal.ServerboundUseItemPacket_): void;
        handlePaddleBoat(arg0: Internal.ServerboundPaddleBoatPacket_): void;
        handleSetStructureBlock(arg0: Internal.ServerboundSetStructureBlockPacket_): void;
        handleCustomPayload(arg0: Internal.ServerboundCustomPayloadPacket_): void;
        handleSelectTrade(arg0: Internal.ServerboundSelectTradePacket_): void;
        handleJigsawGenerate(arg0: Internal.ServerboundJigsawGeneratePacket_): void;
        getConnection(): Internal.Connection;
        onDisconnect(arg0: Internal.Component_): void;
        handleSetJigsawBlock(arg0: Internal.ServerboundSetJigsawBlockPacket_): void;
        handleSetCommandMinecart(arg0: Internal.ServerboundSetCommandMinecartPacket_): void;
        tick(): void;
        handleSetCommandBlock(arg0: Internal.ServerboundSetCommandBlockPacket_): void;
        handleRecipeBookSeenRecipePacket(arg0: Internal.ServerboundRecipeBookSeenRecipePacket_): void;
        handleBlockEntityTagQuery(arg0: Internal.ServerboundBlockEntityTagQuery_): void;
        handleContainerButtonClick(arg0: Internal.ServerboundContainerButtonClickPacket_): void;
        handlePong(arg0: Internal.ServerboundPongPacket_): void;
        teleport(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        handlePlaceRecipe(arg0: Internal.ServerboundPlaceRecipePacket_): void;
        handlePlayerCommand(arg0: Internal.ServerboundPlayerCommandPacket_): void;
        handleEditBook(arg0: Internal.ServerboundEditBookPacket_): void;
        handleInteract(arg0: Internal.ServerboundInteractPacket_): void;
        handleTeleportToEntityPacket(arg0: Internal.ServerboundTeleportToEntityPacket_): void;
        dismount(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        send(arg0: Internal.Packet_<any>, arg1: Internal.GenericFutureListener_<any>): void;
        handleContainerClose(arg0: Internal.ServerboundContainerClosePacket_): void;
        handleChangeDifficulty(arg0: Internal.ServerboundChangeDifficultyPacket_): void;
        handleClientInformation(arg0: Internal.ServerboundClientInformationPacket_): void;
        handleRecipeBookChangeSettingsPacket(arg0: Internal.ServerboundRecipeBookChangeSettingsPacket_): void;
        handleContainerClick(arg0: Internal.ServerboundContainerClickPacket_): void;
        handleCustomCommandSuggestions(arg0: Internal.ServerboundCommandSuggestionPacket_): void;
        handleAcceptTeleportPacket(arg0: Internal.ServerboundAcceptTeleportationPacket_): void;
        handleMovePlayer(arg0: Internal.ServerboundMovePlayerPacket_): void;
        disconnect(arg0: Internal.Component_): void;
        handlePlayerAction(arg0: Internal.ServerboundPlayerActionPacket_): void;
        resetPosition(): void;
        handleLockDifficulty(arg0: Internal.ServerboundLockDifficultyPacket_): void;
        handleAnimate(arg0: Internal.ServerboundSwingPacket_): void;
        handleRenameItem(arg0: Internal.ServerboundRenameItemPacket_): void;
        shouldPropagateHandlingExceptions(): boolean;
        handleEntityTagQuery(arg0: Internal.ServerboundEntityTagQuery_): void;
        handleSignUpdate(arg0: Internal.ServerboundSignUpdatePacket_): void;
        handleChat(arg0: Internal.ServerboundChatPacket_): void;
        handleSetBeaconPacket(arg0: Internal.ServerboundSetBeaconPacket_): void;
        teleport(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.Set_<Internal.ClientboundPlayerPositionPacket$RelativeArgument_>): void;
        handleUseItemOn(arg0: Internal.ServerboundUseItemOnPacket_): void;
        send(arg0: Internal.Packet_<any>): void;
        handleMoveVehicle(arg0: Internal.ServerboundMoveVehiclePacket_): void;
        get player(): Internal.ServerPlayer
        get connection(): Internal.Connection
        readonly "connection": Internal.Connection;
        "player": Internal.ServerPlayer;
    }
    type ServerGamePacketListenerImpl_ = ServerGamePacketListenerImpl;
    class LivingFallEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.LivingEntity_, arg1: number, arg2: number)
        getDamageMultiplier(): number;
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        getDistance(): number;
        setDamageMultiplier(arg0: number): void;
        setDistance(arg0: number): void;
        get damageMultiplier(): number
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
        get distance(): number
        set damageMultiplier(arg0: number)
        set distance(arg0: number)
    }
    type LivingFallEvent_ = LivingFallEvent;
    class CommandBlockEntity extends Internal.BlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getCommandBlock(): Internal.BaseCommandBlock;
        isAutomatic(): boolean;
        markConditionMet(): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        serializeNBT(): Internal.CompoundTag;
        wasConditionMet(): boolean;
        isConditional(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onlyOpCanSetNbt(): boolean;
        load(arg0: Internal.CompoundTag_): void;
        setAutomatic(arg0: boolean): void;
        onLoad(): void;
        getMode(): Internal.CommandBlockEntity$Mode;
        onModeSwitch(): void;
        setPowered(arg0: boolean): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        isPowered(): boolean;
        getRenderBoundingBox(): Internal.AABB;
        get modelData(): Internal.IModelData
        get commandBlock(): Internal.BaseCommandBlock
        get automatic(): boolean
        get conditional(): boolean
        set automatic(arg0: boolean)
        get mode(): Internal.CommandBlockEntity$Mode
        set powered(arg0: boolean)
        get powered(): boolean
        get renderBoundingBox(): Internal.AABB
    }
    type CommandBlockEntity_ = CommandBlockEntity;
    class RecordItemJS$Builder extends Internal.ItemBuilder {
        constructor(i: ResourceLocation_)
        createObject(): Internal.Item;
        analogOutput(o: number): this;
        song(s: ResourceLocation_): this;
    }
    type RecordItemJS$Builder_ = RecordItemJS$Builder;
    class StatsCounter {
        constructor()
        getValue(arg0: Internal.Stat_<any>): number;
        increment(arg0: Internal.Player_, arg1: Internal.Stat_<any>, arg2: number): void;
        getValue(arg0: Internal.StatType_<T>, arg1: T): number;
        setValue(arg0: Internal.Player_, arg1: Internal.Stat_<any>, arg2: number): void;
    }
    type StatsCounter_ = StatsCounter;
    abstract class SpellcasterIllager extends Internal.AbstractIllager {
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setIsCastingSpell(arg0: Internal.SpellcasterIllager$IllagerSpell_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        tick(): void;
        asKJS(): Internal.EntityJS;
        getArmPose(): Internal.AbstractIllager$IllagerArmPose;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        isCastingSpell(): boolean;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        set isCastingSpell(arg0: Internal.SpellcasterIllager$IllagerSpell_)
        get stepHeight(): number
        get armPose(): Internal.AbstractIllager$IllagerArmPose
        get castingSpell(): boolean
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type SpellcasterIllager_ = SpellcasterIllager;
    class Slime extends Internal.Mob implements Internal.Enemy {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        push(arg0: Internal.Entity_): void;
        playerTouch(arg0: Internal.Player_): void;
        remove(arg0: Internal.Entity$RemovalReason_): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        getSize(): number;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getDimensions(arg0: Internal.Pose_): Internal.EntityDimensions;
        refreshDimensions(): void;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getMaxHeadXRot(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        static checkSlimeSpawnRules(arg0: Internal.EntityType_<Internal.Slime_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        tick(): void;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        isTiny(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        getType(): Internal.EntityType<any>;
        get stepHeight(): number
        get size(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get maxHeadXRot(): number
        get tiny(): boolean
        get type(): Internal.EntityType<any>
        readonly static "MIN_SIZE": 1;
        "targetSquish": number;
        "squish": number;
        readonly static "MAX_SIZE": 127;
        "oSquish": number;
    }
    type Slime_ = Slime;
    class NoiseThresholdProvider extends Internal.NoiseBasedStateProvider {
        constructor(arg0: number, arg1: Internal.NormalNoise$NoiseParameters_, arg2: number, arg3: number, arg4: number, arg5: Internal.BlockState_, arg6: Internal.List_<Internal.BlockState_>, arg7: Internal.List_<Internal.BlockState_>)
        getState(arg0: Internal.Random_, arg1: BlockPos_): Internal.BlockState;
        readonly static "CODEC": any;
    }
    type NoiseThresholdProvider_ = NoiseThresholdProvider;
    class Sheep extends Internal.Animal implements Internal.Shearable, Internal.IForgeShearable {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        isShearable(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: BlockPos_): boolean;
        shear(arg0: Internal.SoundSource_): void;
        ate(): void;
        getHeadEatPositionScale(arg0: number): number;
        static getRandomSheepColor(arg0: Internal.Random_): Internal.DyeColor;
        getStepHeight(): number;
        getDefaultLootTable(): ResourceLocation;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        static getColorArray(arg0: Internal.DyeColor_): number[];
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        isSheared(): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getColor(): Internal.DyeColor;
        getHeadEatAngleScale(arg0: number): number;
        deserializeNBT(arg0: Internal.Tag_): void;
        readyForShearing(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        onSheared(arg0: Internal.Player_, arg1: Internal.ItemStack_, arg2: Internal.Level_, arg3: BlockPos_, arg4: number): Internal.List<Internal.ItemStack>;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): this;
        getClassification(arg0: boolean): Internal.MobCategory;
        setColor(arg0: Internal.DyeColor_): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        setSheared(arg0: boolean): void;
        get stepHeight(): number
        get defaultLootTable(): ResourceLocation
        get multipartEntity(): boolean
        get sheared(): boolean
        get parts(): Internal.PartEntity<any>[]
        get color(): Internal.DyeColor
        set color(arg0: Internal.DyeColor_)
        set sheared(arg0: boolean)
    }
    type Sheep_ = Sheep;
    class AttributeKey <T> extends Internal.AbstractConstant<Internal.AttributeKey<T>> {
        static valueOf(arg0: string): Internal.AttributeKey<T>;
        static newInstance(arg0: string): Internal.AttributeKey<T>;
        static valueOf(arg0: Internal.Class_<any>, arg1: string): Internal.AttributeKey<T>;
        static exists(arg0: string): boolean;
    }
    type AttributeKey_<T> = AttributeKey<T>;
    class TippedArrowRecipe extends Internal.CustomRecipe {
        constructor(arg0: ResourceLocation_)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        getSerializer(): Internal.RecipeSerializer<any>;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        matches(arg0: Internal.CraftingContainer_, arg1: Internal.Level_): boolean;
        isIncomplete(): boolean;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        assemble(arg0: Internal.CraftingContainer_): Internal.ItemStack;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get serializer(): Internal.RecipeSerializer<any>
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get incomplete(): boolean
    }
    type TippedArrowRecipe_ = TippedArrowRecipe;
    class BlockRotProcessor extends Internal.StructureProcessor {
        constructor(arg0: number)
        processBlock(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.StructureTemplate$StructureBlockInfo_, arg4: Internal.StructureTemplate$StructureBlockInfo_, arg5: Internal.StructurePlaceSettings_): Internal.StructureTemplate$StructureBlockInfo;
        readonly static "CODEC": any;
    }
    type BlockRotProcessor_ = BlockRotProcessor;
    class LootItemConditionType extends Internal.SerializerType<Internal.LootItemCondition> {
        constructor(arg0: Internal.Serializer_<any>)
    }
    type LootItemConditionType_ = Special.LootItemConditionType | LootItemConditionType;
    class TrapezoidFloat extends Internal.FloatProvider {
        getMinValue(): number;
        toString(): string;
        getMaxValue(): number;
        sample(arg0: Internal.Random_): number;
        getType(): Internal.FloatProviderType<any>;
        static of(arg0: number, arg1: number, arg2: number): Internal.TrapezoidFloat;
        get minValue(): number
        get maxValue(): number
        get type(): Internal.FloatProviderType<any>
        readonly static "CODEC": any;
    }
    type TrapezoidFloat_ = TrapezoidFloat;
    interface ClientGamePacketListener extends Internal.PacketListener {
        setActionBarText(arg0: Internal.ClientboundSetActionBarTextPacket_): void;
        handleContainerSetSlot(arg0: Internal.ClientboundContainerSetSlotPacket_): void;
        handleAddPlayer(arg0: Internal.ClientboundAddPlayerPacket_): void;
        handleSetScore(arg0: Internal.ClientboundSetScorePacket_): void;
        handleAnimate(arg0: Internal.ClientboundAnimatePacket_): void;
        handleResourcePack(arg0: Internal.ClientboundResourcePackPacket_): void;
        handleContainerContent(arg0: Internal.ClientboundContainerSetContentPacket_): void;
        handleOpenScreen(arg0: Internal.ClientboundOpenScreenPacket_): void;
        handleLogin(arg0: Internal.ClientboundLoginPacket_): void;
        handleTagQueryPacket(arg0: Internal.ClientboundTagQueryPacket_): void;
        handleUpdateAttributes(arg0: Internal.ClientboundUpdateAttributesPacket_): void;
        handleSetSpawn(arg0: Internal.ClientboundSetDefaultSpawnPositionPacket_): void;
        handleCustomPayload(arg0: Internal.ClientboundCustomPayloadPacket_): void;
        handleLookAt(arg0: Internal.ClientboundPlayerLookAtPacket_): void;
        handleParticleEvent(arg0: Internal.ClientboundLevelParticlesPacket_): void;
        handleTitlesClear(arg0: Internal.ClientboundClearTitlesPacket_): void;
        handleContainerClose(arg0: Internal.ClientboundContainerClosePacket_): void;
        handleRemoveEntities(arg0: Internal.ClientboundRemoveEntitiesPacket_): void;
        handleSetCamera(arg0: Internal.ClientboundSetCameraPacket_): void;
        handleTeleportEntity(arg0: Internal.ClientboundTeleportEntityPacket_): void;
        handlePlayerCombatEnter(arg0: Internal.ClientboundPlayerCombatEnterPacket_): void;
        handleForgetLevelChunk(arg0: Internal.ClientboundForgetLevelChunkPacket_): void;
        handleBlockEvent(arg0: Internal.ClientboundBlockEventPacket_): void;
        handleLightUpdatePacket(arg0: Internal.ClientboundLightUpdatePacket_): void;
        handleMoveVehicle(arg0: Internal.ClientboundMoveVehiclePacket_): void;
        handleCommands(arg0: Internal.ClientboundCommandsPacket_): void;
        handleSetBorderCenter(arg0: Internal.ClientboundSetBorderCenterPacket_): void;
        handleItemCooldown(arg0: Internal.ClientboundCooldownPacket_): void;
        setSubtitleText(arg0: Internal.ClientboundSetSubtitleTextPacket_): void;
        handleAddExperienceOrb(arg0: Internal.ClientboundAddExperienceOrbPacket_): void;
        handleRespawn(arg0: Internal.ClientboundRespawnPacket_): void;
        handleCommandSuggestions(arg0: Internal.ClientboundCommandSuggestionsPacket_): void;
        handleSetEquipment(arg0: Internal.ClientboundSetEquipmentPacket_): void;
        handleChunkBlocksUpdate(arg0: Internal.ClientboundSectionBlocksUpdatePacket_): void;
        handleExplosion(arg0: Internal.ClientboundExplodePacket_): void;
        handleUpdateMobEffect(arg0: Internal.ClientboundUpdateMobEffectPacket_): void;
        handleKeepAlive(arg0: Internal.ClientboundKeepAlivePacket_): void;
        handleUpdateRecipes(arg0: Internal.ClientboundUpdateRecipesPacket_): void;
        handleLevelChunkWithLight(arg0: Internal.ClientboundLevelChunkWithLightPacket_): void;
        handleOpenBook(arg0: Internal.ClientboundOpenBookPacket_): void;
        handleBlockEntityData(arg0: Internal.ClientboundBlockEntityDataPacket_): void;
        handleCustomSoundEvent(arg0: Internal.ClientboundCustomSoundPacket_): void;
        handlePlayerInfo(arg0: Internal.ClientboundPlayerInfoPacket_): void;
        handleUpdateAdvancementsPacket(arg0: Internal.ClientboundUpdateAdvancementsPacket_): void;
        handleSetChunkCacheRadius(arg0: Internal.ClientboundSetChunkCacheRadiusPacket_): void;
        handleAddVibrationSignal(arg0: Internal.ClientboundAddVibrationSignalPacket_): void;
        handleMapItemData(arg0: Internal.ClientboundMapItemDataPacket_): void;
        handleInitializeBorder(arg0: Internal.ClientboundInitializeBorderPacket_): void;
        handleSetPlayerTeamPacket(arg0: Internal.ClientboundSetPlayerTeamPacket_): void;
        handleBlockDestruction(arg0: Internal.ClientboundBlockDestructionPacket_): void;
        handleTakeItemEntity(arg0: Internal.ClientboundTakeItemEntityPacket_): void;
        handleEntityLinkPacket(arg0: Internal.ClientboundSetEntityLinkPacket_): void;
        handleSetBorderSize(arg0: Internal.ClientboundSetBorderSizePacket_): void;
        handleSetTime(arg0: Internal.ClientboundSetTimePacket_): void;
        handleSetCarriedItem(arg0: Internal.ClientboundSetCarriedItemPacket_): void;
        setTitlesAnimation(arg0: Internal.ClientboundSetTitlesAnimationPacket_): void;
        handleSetBorderLerpSize(arg0: Internal.ClientboundSetBorderLerpSizePacket_): void;
        handleSetExperience(arg0: Internal.ClientboundSetExperiencePacket_): void;
        handleSetDisplayObjective(arg0: Internal.ClientboundSetDisplayObjectivePacket_): void;
        handleAddPainting(arg0: Internal.ClientboundAddPaintingPacket_): void;
        handleDisconnect(arg0: Internal.ClientboundDisconnectPacket_): void;
        handleSetHealth(arg0: Internal.ClientboundSetHealthPacket_): void;
        handleTabListCustomisation(arg0: Internal.ClientboundTabListPacket_): void;
        handleAddObjective(arg0: Internal.ClientboundSetObjectivePacket_): void;
        handleUpdateTags(arg0: Internal.ClientboundUpdateTagsPacket_): void;
        handleMerchantOffers(arg0: Internal.ClientboundMerchantOffersPacket_): void;
        handleStopSoundEvent(arg0: Internal.ClientboundStopSoundPacket_): void;
        handleRemoveMobEffect(arg0: Internal.ClientboundRemoveMobEffectPacket_): void;
        handleSetSimulationDistance(arg0: Internal.ClientboundSetSimulationDistancePacket_): void;
        handleSetChunkCacheCenter(arg0: Internal.ClientboundSetChunkCacheCenterPacket_): void;
        handleChat(arg0: Internal.ClientboundChatPacket_): void;
        handlePing(arg0: Internal.ClientboundPingPacket_): void;
        handleBlockUpdate(arg0: Internal.ClientboundBlockUpdatePacket_): void;
        handleRotateMob(arg0: Internal.ClientboundRotateHeadPacket_): void;
        handleMovePlayer(arg0: Internal.ClientboundPlayerPositionPacket_): void;
        handleAddEntity(arg0: Internal.ClientboundAddEntityPacket_): void;
        handleSoundEntityEvent(arg0: Internal.ClientboundSoundEntityPacket_): void;
        handleHorseScreenOpen(arg0: Internal.ClientboundHorseScreenOpenPacket_): void;
        handleChangeDifficulty(arg0: Internal.ClientboundChangeDifficultyPacket_): void;
        handleEntityEvent(arg0: Internal.ClientboundEntityEventPacket_): void;
        handleSetBorderWarningDelay(arg0: Internal.ClientboundSetBorderWarningDelayPacket_): void;
        handleOpenSignEditor(arg0: Internal.ClientboundOpenSignEditorPacket_): void;
        setTitleText(arg0: Internal.ClientboundSetTitleTextPacket_): void;
        handleSetEntityData(arg0: Internal.ClientboundSetEntityDataPacket_): void;
        handleBossUpdate(arg0: Internal.ClientboundBossEventPacket_): void;
        handlePlaceRecipe(arg0: Internal.ClientboundPlaceGhostRecipePacket_): void;
        handleGameEvent(arg0: Internal.ClientboundGameEventPacket_): void;
        handleAddMob(arg0: Internal.ClientboundAddMobPacket_): void;
        handleSoundEvent(arg0: Internal.ClientboundSoundPacket_): void;
        handleSetEntityMotion(arg0: Internal.ClientboundSetEntityMotionPacket_): void;
        handleContainerSetData(arg0: Internal.ClientboundContainerSetDataPacket_): void;
        handlePlayerCombatEnd(arg0: Internal.ClientboundPlayerCombatEndPacket_): void;
        handleMoveEntity(arg0: Internal.ClientboundMoveEntityPacket_): void;
        handleLevelEvent(arg0: Internal.ClientboundLevelEventPacket_): void;
        handlePlayerAbilities(arg0: Internal.ClientboundPlayerAbilitiesPacket_): void;
        shouldPropagateHandlingExceptions(): boolean;
        handlePlayerCombatKill(arg0: Internal.ClientboundPlayerCombatKillPacket_): void;
        handleSetBorderWarningDistance(arg0: Internal.ClientboundSetBorderWarningDistancePacket_): void;
        handleBlockBreakAck(arg0: Internal.ClientboundBlockBreakAckPacket_): void;
        handleSetEntityPassengersPacket(arg0: Internal.ClientboundSetPassengersPacket_): void;
        handleAwardStats(arg0: Internal.ClientboundAwardStatsPacket_): void;
        handleSelectAdvancementsTab(arg0: Internal.ClientboundSelectAdvancementsTabPacket_): void;
        handleAddOrRemoveRecipes(arg0: Internal.ClientboundRecipePacket_): void;
        set actionBarText(arg0: Internal.ClientboundSetActionBarTextPacket_)
        set subtitleText(arg0: Internal.ClientboundSetSubtitleTextPacket_)
        set titlesAnimation(arg0: Internal.ClientboundSetTitlesAnimationPacket_)
        set titleText(arg0: Internal.ClientboundSetTitleTextPacket_)
    }
    type ClientGamePacketListener_ = ClientGamePacketListener;
    class EnchantmentCategory extends Internal.Enum<Internal.EnchantmentCategory> implements Internal.IExtensibleEnum {
        static valueOf(arg0: string): Internal.EnchantmentCategory;
        init(): void;
        static create(arg0: string, arg1: Internal.Predicate_<Internal.Item_>): Internal.EnchantmentCategory;
        canEnchant(arg0: Internal.Item_): boolean;
        static values(): Internal.EnchantmentCategory[];
        readonly static "ARMOR_CHEST": any;
        readonly static "BOW": any;
        readonly static "ARMOR": any;
        readonly static "ARMOR_FEET": any;
        readonly static "TRIDENT": any;
        readonly static "CROSSBOW": any;
        readonly static "BREAKABLE": any;
        readonly static "WEAPON": any;
        readonly static "ARMOR_HEAD": any;
        readonly static "ARMOR_LEGS": any;
        readonly static "WEARABLE": any;
        readonly static "DIGGER": any;
        readonly static "FISHING_ROD": any;
        readonly static "VANISHABLE": any;
    }
    type EnchantmentCategory_ = "armor_head" | "armor_legs" | "crossbow" | "vanishable" | "armor_chest" | "breakable" | "fishing_rod" | "trident" | "digger" | "wearable" | "weapon" | "armor" | "bow" | "armor_feet" | EnchantmentCategory;
    class ScriptPackInfo {
        constructor(n: string, p: string)
        readonly "displayName": Internal.Component;
        readonly "scripts": Internal.List<Internal.ScriptFileInfo>;
        readonly "pathStart": string;
        readonly "namespace": string;
    }
    type ScriptPackInfo_ = ScriptPackInfo;
    class ClientboundSetBorderWarningDelayPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.WorldBorder_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getWarningDelay(): number;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get warningDelay(): number
        get skippable(): boolean
    }
    type ClientboundSetBorderWarningDelayPacket_ = ClientboundSetBorderWarningDelayPacket;
    class PrintWriter extends Internal.Writer {
        constructor(arg0: Internal.File_)
        constructor(arg0: Internal.OutputStream_, arg1: boolean)
        constructor(arg0: Internal.OutputStream_)
        constructor(arg0: string, arg1: string)
        constructor(arg0: string, arg1: Internal.Charset_)
        constructor(arg0: Internal.File_, arg1: Internal.Charset_)
        constructor(arg0: Internal.Writer_, arg1: boolean)
        constructor(arg0: Internal.Writer_)
        constructor(arg0: Internal.OutputStream_, arg1: boolean, arg2: Internal.Charset_)
        constructor(arg0: string)
        constructor(arg0: Internal.File_, arg1: string)
        print(arg0: string): void;
        println(arg0: number): void;
        println(): void;
        format(arg0: Internal.Locale_, arg1: string, ...arg2: any[]): this;
        write(arg0: string[], arg1: number, arg2: number): void;
        println(arg0: number): void;
        print(arg0: number): void;
        println(arg0: string): void;
        flush(): void;
        write(arg0: number): void;
        print(arg0: number): void;
        write(arg0: string, arg1: number, arg2: number): void;
        printf(arg0: string, ...arg1: any[]): this;
        print(arg0: number): void;
        print(arg0: boolean): void;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): this;
        printf(arg0: Internal.Locale_, arg1: string, ...arg2: any[]): this;
        write(arg0: string): void;
        println(arg0: string): void;
        println(arg0: string[]): void;
        println(arg0: boolean): void;
        append(arg0: Internal.CharSequence_): this;
        println(arg0: number): void;
        checkError(): boolean;
        println(arg0: number): void;
        print(arg0: any): void;
        print(arg0: string[]): void;
        print(arg0: string): void;
        close(): void;
        write(arg0: string[]): void;
        format(arg0: string, ...arg1: any[]): this;
        print(arg0: number): void;
        println(arg0: any): void;
        append(arg0: string): this;
    }
    type PrintWriter_ = PrintWriter;
    class PredicateManager extends Internal.SimpleJsonResourceReloadListener {
        constructor()
        get(arg0: ResourceLocation_): Internal.LootItemCondition;
        getName(): string;
        getKeys(): Internal.Set<ResourceLocation>;
        get name(): string
        get keys(): Internal.Set<ResourceLocation>
    }
    type PredicateManager_ = PredicateManager;
    class ServerboundPaddleBoatPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: boolean, arg1: boolean)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getRight(): boolean;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        isSkippable(): boolean;
        getLeft(): boolean;
        get right(): boolean
        get skippable(): boolean
        get left(): boolean
    }
    type ServerboundPaddleBoatPacket_ = ServerboundPaddleBoatPacket;
    class ExperienceOrb extends Internal.Entity {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number, arg4: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        playerTouch(arg0: Internal.Player_): void;
        static getExperienceValue(arg0: number): number;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getAddEntityPacket(): Internal.Packet<any>;
        canRiderInteract(): boolean;
        getSoundSource(): Internal.SoundSource;
        getIcon(): number;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getValue(): number;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        static award(arg0: Internal.ServerLevel_, arg1: Vec3_, arg2: number): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        isAttackable(): boolean;
        get stepHeight(): number
        get addEntityPacket(): Internal.Packet<any>
        get soundSource(): Internal.SoundSource
        get icon(): number
        get multipartEntity(): boolean
        get value(): number
        get parts(): Internal.PartEntity<any>[]
        get attackable(): boolean
        "value": number;
    }
    type ExperienceOrb_ = ExperienceOrb;
    abstract class BlockEntity extends Internal.CapabilityProvider<Internal.BlockEntity> implements Internal.IForgeBlockEntity {
        constructor(arg0: Internal.BlockEntityType_<any>, arg1: BlockPos_, arg2: Internal.BlockState_)
        saveWithId(): Internal.CompoundTag;
        static getPosFromTag(arg0: Internal.CompoundTag_): BlockPos;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getUpdateTag(): Internal.CompoundTag;
        onChunkUnloaded(): void;
        saveToItem(arg0: Internal.ItemStack_): void;
        setLevel(arg0: Internal.Level_): void;
        static addEntityType(arg0: Internal.CompoundTag_, arg1: Internal.BlockEntityType_<any>): void;
        getLevel(): Internal.Level;
        getUpdatePacket(): Internal.Packet<Internal.ClientGamePacketListener>;
        setBlockState(arg0: Internal.BlockState_): void;
        getBlockPos(): BlockPos;
        isRemoved(): boolean;
        clearRemoved(): void;
        onlyOpCanSetNbt(): boolean;
        load(arg0: Internal.CompoundTag_): void;
        setChanged(): void;
        onLoad(): void;
        saveWithoutMetadata(): Internal.CompoundTag;
        fillCrashReportCategory(arg0: Internal.CrashReportCategory_): void;
        getTileData(): Internal.CompoundTag;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        saveWithFullMetadata(): Internal.CompoundTag;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        triggerEvent(arg0: number, arg1: number): boolean;
        getBlockState(): Internal.BlockState;
        hasLevel(): boolean;
        setRemoved(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        serializeNBT(): Internal.CompoundTag;
        getType(): Internal.BlockEntityType<any>;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        static loadStatic(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: Internal.CompoundTag_): Internal.BlockEntity;
        getRenderBoundingBox(): Internal.AABB;
        get updateTag(): Internal.CompoundTag
        set level(arg0: Internal.Level_)
        get level(): Internal.Level
        get updatePacket(): Internal.Packet<Internal.ClientGamePacketListener>
        set blockState(arg0: Internal.BlockState_)
        get blockPos(): BlockPos
        get removed(): boolean
        get tileData(): Internal.CompoundTag
        get modelData(): Internal.IModelData
        get blockState(): Internal.BlockState
        get type(): Internal.BlockEntityType<any>
        get renderBoundingBox(): Internal.AABB
    }
    type BlockEntity_ = BlockEntity;
    interface ObjectBidirectionalIterator <K> extends Internal.ObjectIterator<K>, Internal.BidirectionalIterator<K> {
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        skip(arg0: number): number;
        back(arg0: number): number;
    }
    type ObjectBidirectionalIterator_<K> = ObjectBidirectionalIterator<K>;
    class FireworksJS$Shape extends Internal.Enum<Internal.FireworksJS$Shape> {
        static values(): Internal.FireworksJS$Shape[];
        static valueOf(name: string): Internal.FireworksJS$Shape;
        static get(name: string): Internal.FireworksJS$Shape;
        readonly static "CREEPER": Internal.FireworksJS$Shape;
        readonly "type": number;
        readonly static "LARGE_BALL": Internal.FireworksJS$Shape;
        readonly static "VALUES": any;
        readonly static "BURST": Internal.FireworksJS$Shape;
        readonly static "STAR": Internal.FireworksJS$Shape;
        readonly static "SMALL_BALL": Internal.FireworksJS$Shape;
    }
    type FireworksJS$Shape_ = "star" | "burst" | FireworksJS$Shape | "large_ball" | "creeper" | "small_ball";
    class EntityJoinWorldEvent extends Internal.EntityEvent {
        constructor()
        constructor(arg0: Internal.Entity_, arg1: Internal.Level_, arg2: boolean)
        constructor(arg0: Internal.Entity_, arg1: Internal.Level_)
        getWorld(): Internal.Level;
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        loadedFromDisk(): boolean;
        get world(): Internal.Level
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type EntityJoinWorldEvent_ = EntityJoinWorldEvent;
    class ServerboundInteractPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        static createAttackPacket(arg0: Internal.Entity_, arg1: boolean): Internal.ServerboundInteractPacket;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        static createInteractionPacket(arg0: Internal.Entity_, arg1: boolean, arg2: Hand_): Internal.ServerboundInteractPacket;
        dispatch(arg0: Internal.ServerboundInteractPacket$Handler_): void;
        static createInteractionPacket(arg0: Internal.Entity_, arg1: boolean, arg2: Hand_, arg3: Vec3_): Internal.ServerboundInteractPacket;
        getTarget(arg0: Internal.ServerLevel_): Internal.Entity;
        isSkippable(): boolean;
        isUsingSecondaryAction(): boolean;
        get skippable(): boolean
        get usingSecondaryAction(): boolean
    }
    type ServerboundInteractPacket_ = ServerboundInteractPacket;
    interface EntityTargetKJS {
        getNameKJS(target: Internal.LootContext$EntityTarget_): string;
        getNameKJS(): string;
        get nameKJS(): string
    }
    type EntityTargetKJS_ = EntityTargetKJS;
    interface Guard {
        checkGuard(arg0: any): void;
    }
    type Guard_ = Guard;
    interface GameEventListener {
        handleGameEvent(arg0: Internal.Level_, arg1: Internal.GameEvent_, arg2: Internal.Entity_, arg3: BlockPos_): boolean;
        getListenerSource(): Internal.PositionSource;
        getListenerRadius(): number;
        get listenerSource(): Internal.PositionSource
        get listenerRadius(): number
    }
    type GameEventListener_ = GameEventListener;
    class ScreenEvent$KeyboardKeyReleasedEvent$Pre extends Internal.ScreenEvent$KeyboardKeyReleasedEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number, arg3: number)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$KeyboardKeyReleasedEvent$Pre_ = ScreenEvent$KeyboardKeyReleasedEvent$Pre;
    interface Double2ReferenceFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.DoubleFunction<V> {
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Double2ShortFunction;
        composeObject(arg0: Internal.Object2DoubleFunction_<any>): Internal.Object2ReferenceFunction<T, V>;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2ReferenceFunction<V>;
        andThenObject(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Double2ObjectFunction<T>;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2ReferenceFunction<V>;
        getOrDefault(arg0: any, arg1: V): V;
        composeReference(arg0: Internal.Reference2DoubleFunction_<any>): Internal.Reference2ReferenceFunction<T, V>;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Double2ByteFunction;
        remove(arg0: number): V;
        containsKey(arg0: any): boolean;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Double2DoubleFunction;
        put(arg0: number, arg1: V): V;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Double2LongFunction;
        get(arg0: any): V;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2ReferenceFunction<V>;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): V;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Double2IntFunction;
        apply(arg0: number): V;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
        apply(arg0: number): V;
        put(arg0: number, arg1: V): V;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2ReferenceFunction<V>;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2ReferenceFunction<V>;
        get(arg0: number): V;
        containsKey(arg0: number): boolean;
        getOrDefault(arg0: number, arg1: V): V;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        size(): number;
        andThenReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Double2ReferenceFunction<T>;
        clear(): void;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2ReferenceFunction<V>;
        composeDouble(arg0: Internal.Double2DoubleFunction_): this;
        defaultReturnValue(): V;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Double2CharFunction;
        defaultReturnValue(arg0: V): void;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Double2FloatFunction;
    }
    type Double2ReferenceFunction_<V> = ((arg0: number)=>V) | Double2ReferenceFunction<V>;
    interface Shearable {
        readyForShearing(): boolean;
        shear(arg0: Internal.SoundSource_): void;
    }
    type Shearable_ = Shearable;
    abstract class PlayerJS <P> extends Internal.LivingEntityJS implements Internal.WithAttachedData {
        constructor(data: Internal.PlayerDataJS_<any, any>, player: P)
        isMiningBlock(): boolean;
        getMouseItem(): Internal.ItemStackJS;
        setAirSupply(air: number): void;
        getInventory(): Internal.InventoryJS;
        getMaxAirSupply(): number;
        isFake(): boolean;
        getStats(): Internal.PlayerStatsJS;
        isCreativeMode(): boolean;
        getFoodLevel(): number;
        setXpLevel(l: number): void;
        closeInventory(): void;
        setFoodLevel(foodLevel: number): void;
        setSaturation(saturation: number): void;
        isSpectator(): boolean;
        addXPLevels(l: number): void;
        giveInHand(item: Internal.ItemStackJS_): void;
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void;
        addFood(f: number, m: number): void;
        getFoodData(): Internal.FoodData;
        getAirSupply(): number;
        sendInventoryUpdate(): void;
        getStages(): Internal.Stages;
        toString(): string;
        boostElytraFlight(): void;
        getPlayer(): Internal.PlayerJS<any>;
        addExhaustion(exhaustion: number): void;
        give(item: Internal.ItemStackJS_): void;
        isPlayer(): boolean;
        getXpLevel(): number;
        sendData(channel: string, data: Internal.CompoundTag_): void;
        addXP(xp: number): void;
        getData(): Internal.AttachedData;
        getSelectedSlot(): number;
        setSelectedSlot(index: number): void;
        getOpenInventory(): Internal.AbstractContainerMenu;
        setStatusMessage(message: Internal.Component_): void;
        getXp(): number;
        getProfile(): Internal.GameProfile;
        getSaturation(): number;
        paint(arg0: Internal.CompoundTag_): void;
        setMouseItem(item: Internal.ItemStackJS_): void;
        setXp(xp: number): void;
        spawn(): void;
        addItemCooldown(item: Internal.Item_, ticks: number): void;
        get miningBlock(): boolean
        get mouseItem(): Internal.ItemStackJS
        set airSupply(air: number)
        get inventory(): Internal.InventoryJS
        get maxAirSupply(): number
        get fake(): boolean
        get stats(): Internal.PlayerStatsJS
        get creativeMode(): boolean
        get foodLevel(): number
        set xpLevel(l: number)
        set foodLevel(foodLevel: number)
        set saturation(saturation: number)
        get spectator(): boolean
        get foodData(): Internal.FoodData
        get airSupply(): number
        get stages(): Internal.Stages
        get player(): Internal.PlayerJS<any>
        get player(): boolean
        get xpLevel(): number
        get data(): Internal.AttachedData
        get selectedSlot(): number
        set selectedSlot(index: number)
        get openInventory(): Internal.AbstractContainerMenu
        set statusMessage(message: Internal.Component_)
        get xp(): number
        get profile(): Internal.GameProfile
        get saturation(): number
        set mouseItem(item: Internal.ItemStackJS_)
        set xp(xp: number)
        readonly "minecraftPlayer": P;
    }
    type PlayerJS_<P> = PlayerJS<P>;
    interface ModuleReader extends Internal.Closeable {
        find(arg0: string): Internal.Optional<Internal.URI>;
        close(): void;
        list(): Internal.Stream<string>;
        release(arg0: Internal.ByteBuffer_): void;
        open(arg0: string): Internal.Optional<Internal.InputStream>;
        read(arg0: string): Internal.Optional<Internal.ByteBuffer>;
    }
    type ModuleReader_ = ModuleReader;
    interface TickAccess <T> {
        count(): number;
        schedule(arg0: Internal.ScheduledTick_<T>): void;
        hasScheduledTick(arg0: BlockPos_, arg1: T): boolean;
    }
    type TickAccess_<T> = TickAccess<T>;
    class TimerQueue <T> {
        constructor(arg0: any_<T>, arg1: Internal.Stream_<Internal.Dynamic_<Internal.Tag_>>)
        constructor(arg0: any_<T>)
        getEventsIds(): Internal.Set<string>;
        remove(arg0: string): number;
        schedule(arg0: string, arg1: number, arg2: Internal.TimerCallback_<T>): void;
        store(): Internal.ListTag;
        tick(arg0: T, arg1: number): void;
        get eventsIds(): Internal.Set<string>
    }
    type TimerQueue_<T> = TimerQueue<T>;
    interface EntityDataSerializer <T> {
        createAccessor(arg0: number): Internal.EntityDataAccessor<T>;
        copy(arg0: T): T;
        read(arg0: Internal.FriendlyByteBuf_): T;
        write(arg0: Internal.FriendlyByteBuf_, arg1: T): void;
    }
    type EntityDataSerializer_<T> = EntityDataSerializer<T>;
    interface SurfaceRules$SurfaceRule {
        tryApply(arg0: number, arg1: number, arg2: number): Internal.BlockState;
    }
    type SurfaceRules$SurfaceRule_ = SurfaceRules$SurfaceRule;
    class MatchingFluidsPredicate extends Internal.StateTestingPredicate {
        constructor(arg0: Vec3i_, arg1: Internal.HolderSet_<Internal.Fluid_>)
        type(): Internal.BlockPredicateType<any>;
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        negate(): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        readonly static "CODEC": Internal.Codec<Internal.MatchingFluidsPredicate>;
    }
    type MatchingFluidsPredicate_ = MatchingFluidsPredicate;
    class TextureManager implements Internal.Tickable, Internal.PreparableReloadListener, Internal.AutoCloseable {
        constructor(arg0: Internal.ResourceManager_)
        bindForSetup(arg0: ResourceLocation_): void;
        getTexture(arg0: ResourceLocation_, arg1: Internal.AbstractTexture_): Internal.AbstractTexture;
        getName(): string;
        close(): void;
        register(arg0: ResourceLocation_, arg1: Internal.AbstractTexture_): void;
        release(arg0: ResourceLocation_): void;
        getTexture(arg0: ResourceLocation_): Internal.AbstractTexture;
        register(arg0: string, arg1: Internal.DynamicTexture_): ResourceLocation;
        preload(arg0: ResourceLocation_, arg1: Internal.Executor_): Internal.CompletableFuture<void>;
        tick(): void;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        get name(): string
        readonly static "INTENTIONAL_MISSING_TEXTURE": ResourceLocation;
        readonly "byPath": Internal.Map<ResourceLocation, Internal.AbstractTexture>;
    }
    type TextureManager_ = TextureManager;
    interface ObjectSet <K> extends Internal.Set<K>, Internal.ObjectCollection<K> {
        of(): this;
        parallelStream(): Internal.Stream<K>;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        iterator(): Internal.Iterator<any>;
        spliterator(): Internal.Spliterator<any>;
        of(...arg0: K[]): this;
        forEach(arg0: Internal.Consumer_<any>): void;
        of(arg0: K): this;
        of(arg0: K, arg1: K, arg2: K): this;
        of(arg0: K, arg1: K): this;
        stream(): Internal.Stream<K>;
    }
    type ObjectSet_<K> = ObjectSet<K>;
    interface Double2IntFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleToIntFunction {
        put(arg0: number, arg1: number): number;
        get(arg0: number): number;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2IntFunction;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Double2DoubleFunction;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Double2FloatFunction;
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        defaultReturnValue(): number;
        andThenObject(arg0: Internal.Int2ObjectFunction_<any>): Internal.Double2ObjectFunction<T>;
        composeDouble(arg0: Internal.Double2DoubleFunction_): this;
        containsKey(arg0: any): boolean;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2IntFunction;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2IntFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        put(arg0: any, arg1: any): any;
        apply(arg0: number): number;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Double2LongFunction;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2IntFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Double2ByteFunction;
        getOrDefault(arg0: any, arg1: number): number;
        remove(arg0: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2IntFunction;
        containsKey(arg0: number): boolean;
        andThenReference(arg0: Internal.Int2ReferenceFunction_<any>): Internal.Double2ReferenceFunction<T>;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Double2ShortFunction;
        size(): number;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Double2CharFunction;
        composeReference(arg0: Internal.Reference2DoubleFunction_<any>): Internal.Reference2IntFunction<T>;
        defaultReturnValue(arg0: number): void;
        put(arg0: number, arg1: number): number;
        clear(): void;
        composeObject(arg0: Internal.Object2DoubleFunction_<any>): Internal.Object2IntFunction<T>;
        andThenInt(arg0: Internal.Int2IntFunction_): this;
        remove(arg0: any): any;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2IntFunction;
        applyAsInt(arg0: number): number;
    }
    type Double2IntFunction_ = Double2IntFunction | ((arg0: number)=>number);
    class RenderStateShard$TransparencyStateShard extends Internal.RenderStateShard {
        constructor(arg0: string, arg1: Internal.Runnable_, arg2: Internal.Runnable_)
    }
    type RenderStateShard$TransparencyStateShard_ = RenderStateShard$TransparencyStateShard;
    class MerchantOffers extends Internal.ArrayList<Internal.MerchantOffer> {
        constructor()
        constructor(arg0: Internal.CompoundTag_)
        writeToStream(arg0: Internal.FriendlyByteBuf_): void;
        getRecipeFor(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: number): Internal.MerchantOffer;
        parallelStream(): Internal.Stream<Internal.MerchantOffer>;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        createTag(): Internal.CompoundTag;
        static createFromStream(arg0: Internal.FriendlyByteBuf_): Internal.MerchantOffers;
        stream(): Internal.Stream<Internal.MerchantOffer>;
    }
    type MerchantOffers_ = MerchantOffers;
    class MinecartChest extends Internal.AbstractMinecartContainer {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        stopOpen(arg0: Internal.Player_): void;
        isPoweredCart(): boolean;
        getCurrentRailPosition(): BlockPos;
        getMaxCartSpeedOnRail(): number;
        countItem(arg0: Internal.Item_): number;
        createMenu(arg0: number, arg1: Internal.Inventory_): Internal.AbstractContainerMenu;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        getSlopeAdjustment(): number;
        getDefaultDisplayOffset(): number;
        shouldDoRailFunctions(): boolean;
        canRiderInteract(): boolean;
        destroy(arg0: Internal.DamageSource_): void;
        isMultipartEntity(): boolean;
        canBeRidden(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getContainerSize(): number;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getDefaultDisplayBlockState(): Internal.BlockState;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMaxStackSize(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getCartItem(): Internal.ItemStack;
        getMinecartType(): Internal.AbstractMinecart$Type;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getComparatorLevel(): number;
        get poweredCart(): boolean
        get currentRailPosition(): BlockPos
        get maxCartSpeedOnRail(): number
        get stepHeight(): number
        get slopeAdjustment(): number
        get defaultDisplayOffset(): number
        get multipartEntity(): boolean
        get containerSize(): number
        get parts(): Internal.PartEntity<any>[]
        get defaultDisplayBlockState(): Internal.BlockState
        get maxStackSize(): number
        get cartItem(): Internal.ItemStack
        get minecartType(): Internal.AbstractMinecart$Type
        get comparatorLevel(): number
    }
    type MinecartChest_ = MinecartChest;
    interface FeatureAccess {
        getAllReferences(): Internal.Map<Internal.ConfiguredStructureFeature<any, any>, Internal.LongSet>;
        getStartForFeature(arg0: Internal.ConfiguredStructureFeature_<any, any>): Internal.StructureStart;
        setStartForFeature(arg0: Internal.ConfiguredStructureFeature_<any, any>, arg1: Internal.StructureStart_): void;
        setAllReferences(arg0: Internal.Map_<Internal.ConfiguredStructureFeature_<any, any>, Internal.LongSet_>): void;
        getReferencesForFeature(arg0: Internal.ConfiguredStructureFeature_<any, any>): Internal.LongSet;
        addReferenceForFeature(arg0: Internal.ConfiguredStructureFeature_<any, any>, arg1: number): void;
        get allReferences(): Internal.Map<Internal.ConfiguredStructureFeature<any, any>, Internal.LongSet>
        set allReferences(arg0: Internal.Map_<Internal.ConfiguredStructureFeature_<any, any>, Internal.LongSet_>)
    }
    type FeatureAccess_ = FeatureAccess;
    interface FormattedText$StyledContentConsumer <T> {
        accept(arg0: Internal.Style_, arg1: string): Internal.Optional<T>;
    }
    type FormattedText$StyledContentConsumer_<T> = FormattedText$StyledContentConsumer<T>;
    interface AutoCloseable {
        close(): void;
    }
    type AutoCloseable_ = AutoCloseable;
    class ScreenEvent$MouseReleasedEvent$Pre extends Internal.ScreenEvent$MouseReleasedEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number, arg3: number)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$MouseReleasedEvent$Pre_ = ScreenEvent$MouseReleasedEvent$Pre;
    class MaterialColor {
        static getColorFromPackedId(arg0: number): number;
        calculateRGBColor(arg0: Internal.MaterialColor$Brightness_): number;
        static byId(arg0: number): Internal.MaterialColor;
        getPackedId(arg0: Internal.MaterialColor$Brightness_): number;
        readonly static "COLOR_PINK": Internal.MaterialColor;
        readonly static "COLOR_MAGENTA": Internal.MaterialColor;
        readonly static "TERRACOTTA_PURPLE": Internal.MaterialColor;
        readonly static "DEEPSLATE": Internal.MaterialColor;
        readonly static "TERRACOTTA_GRAY": Internal.MaterialColor;
        readonly static "WARPED_WART_BLOCK": Internal.MaterialColor;
        readonly static "RAW_IRON": Internal.MaterialColor;
        readonly static "QUARTZ": Internal.MaterialColor;
        readonly static "WOOD": Internal.MaterialColor;
        readonly static "COLOR_BLACK": Internal.MaterialColor;
        readonly static "COLOR_RED": Internal.MaterialColor;
        readonly static "PODZOL": Internal.MaterialColor;
        readonly "id": number;
        readonly static "CRIMSON_NYLIUM": Internal.MaterialColor;
        readonly static "GOLD": Internal.MaterialColor;
        readonly static "TERRACOTTA_BROWN": Internal.MaterialColor;
        readonly static "WATER": Internal.MaterialColor;
        readonly static "TERRACOTTA_LIGHT_BLUE": Internal.MaterialColor;
        readonly static "COLOR_PURPLE": Internal.MaterialColor;
        readonly static "TERRACOTTA_WHITE": Internal.MaterialColor;
        readonly static "TERRACOTTA_LIGHT_GREEN": Internal.MaterialColor;
        readonly static "CRIMSON_STEM": Internal.MaterialColor;
        readonly static "SNOW": Internal.MaterialColor;
        readonly static "WARPED_HYPHAE": Internal.MaterialColor;
        readonly static "FIRE": Internal.MaterialColor;
        readonly static "CLAY": Internal.MaterialColor;
        readonly static "TERRACOTTA_ORANGE": Internal.MaterialColor;
        readonly static "TERRACOTTA_RED": Internal.MaterialColor;
        readonly static "DIAMOND": Internal.MaterialColor;
        readonly static "NONE": Internal.MaterialColor;
        readonly static "ICE": Internal.MaterialColor;
        readonly static "LAPIS": Internal.MaterialColor;
        readonly static "TERRACOTTA_PINK": Internal.MaterialColor;
        readonly static "COLOR_LIGHT_BLUE": Internal.MaterialColor;
        readonly static "COLOR_BROWN": Internal.MaterialColor;
        readonly static "CRIMSON_HYPHAE": Internal.MaterialColor;
        readonly static "WARPED_NYLIUM": Internal.MaterialColor;
        readonly static "PLANT": Internal.MaterialColor;
        readonly static "TERRACOTTA_YELLOW": Internal.MaterialColor;
        readonly static "GRASS": Internal.MaterialColor;
        readonly static "TERRACOTTA_LIGHT_GRAY": Internal.MaterialColor;
        readonly static "TERRACOTTA_BLACK": Internal.MaterialColor;
        readonly static "SAND": Internal.MaterialColor;
        readonly static "COLOR_ORANGE": Internal.MaterialColor;
        readonly static "COLOR_BLUE": Internal.MaterialColor;
        readonly static "DIRT": Internal.MaterialColor;
        readonly static "STONE": Internal.MaterialColor;
        readonly static "COLOR_CYAN": Internal.MaterialColor;
        readonly static "TERRACOTTA_MAGENTA": Internal.MaterialColor;
        readonly static "WARPED_STEM": Internal.MaterialColor;
        readonly static "WOOL": Internal.MaterialColor;
        readonly static "TERRACOTTA_BLUE": Internal.MaterialColor;
        readonly static "COLOR_GRAY": Internal.MaterialColor;
        readonly static "COLOR_LIGHT_GREEN": Internal.MaterialColor;
        readonly static "TERRACOTTA_GREEN": Internal.MaterialColor;
        readonly static "GLOW_LICHEN": Internal.MaterialColor;
        readonly static "COLOR_LIGHT_GRAY": Internal.MaterialColor;
        readonly static "TERRACOTTA_CYAN": Internal.MaterialColor;
        readonly static "METAL": Internal.MaterialColor;
        readonly static "COLOR_YELLOW": Internal.MaterialColor;
        readonly static "COLOR_GREEN": Internal.MaterialColor;
        readonly static "EMERALD": Internal.MaterialColor;
        readonly static "NETHER": Internal.MaterialColor;
        readonly "col": number;
    }
    type MaterialColor_ = MaterialColor;
    abstract class ByteBuffer extends Internal.Buffer implements Internal.Comparable<Internal.ByteBuffer> {
        slice(arg0: number, arg1: number): this;
        alignedSlice(arg0: number): this;
        getDouble(arg0: number): number;
        mismatch(arg0: Internal.ByteBuffer_): number;
        putChar(arg0: number, arg1: string): this;
        isDirect(): boolean;
        static allocate(arg0: number): Internal.ByteBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): this;
        compareTo(arg0: any): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): this;
        putDouble(arg0: number, arg1: number): this;
        slice(): this;
        order(): Internal.ByteOrder;
        getFloat(arg0: number): number;
        put(arg0: number): this;
        putLong(arg0: number, arg1: number): this;
        asIntBuffer(): Internal.IntBuffer;
        getChar(arg0: number): string;
        asReadOnlyBuffer(): this;
        put(arg0: number, arg1: Internal.ByteBuffer_, arg2: number, arg3: number): this;
        asFloatBuffer(): Internal.FloatBuffer;
        put(arg0: number, arg1: number[]): this;
        getInt(): number;
        get(arg0: number, arg1: number[]): this;
        getChar(): string;
        put(arg0: Internal.ByteBuffer_): this;
        putFloat(arg0: number, arg1: number): this;
        putLong(arg0: number): this;
        get(arg0: number): number;
        getDouble(): number;
        putFloat(arg0: number): this;
        asLongBuffer(): Internal.LongBuffer;
        limit(arg0: number): Internal.Buffer;
        asShortBuffer(): Internal.ShortBuffer;
        static wrap(arg0: number[]): Internal.ByteBuffer;
        putChar(arg0: string): this;
        asCharBuffer(): Internal.CharBuffer;
        array(): number[];
        getLong(arg0: number): number;
        put(arg0: number[], arg1: number, arg2: number): this;
        putShort(arg0: number, arg1: number): this;
        compact(): this;
        static allocateDirect(arg0: number): Internal.ByteBuffer;
        arrayOffset(): number;
        putShort(arg0: number): this;
        getShort(arg0: number): number;
        order(arg0: Internal.ByteOrder_): this;
        get(arg0: number[], arg1: number, arg2: number): this;
        flip(): Internal.Buffer;
        getInt(arg0: number): number;
        getShort(): number;
        put(arg0: number[]): this;
        alignmentOffset(arg0: number, arg1: number): number;
        hasArray(): boolean;
        put(arg0: number, arg1: number): this;
        reset(): this;
        putDouble(arg0: number): this;
        compareTo(arg0: Internal.ByteBuffer_): number;
        toString(): string;
        get(arg0: number[]): this;
        rewind(): Internal.Buffer;
        position(arg0: number): this;
        clear(): this;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer;
        asDoubleBuffer(): Internal.DoubleBuffer;
        getLong(): number;
        mark(): Internal.Buffer;
        getFloat(): number;
        hashCode(): number;
        get(): number;
        duplicate(): this;
        putInt(arg0: number): this;
        equals(arg0: any): boolean;
        putInt(arg0: number, arg1: number): this;
        get direct(): boolean
        get int(): number
        get char(): string
        get double(): number
        get short(): number
        get long(): number
        get float(): number
    }
    type ByteBuffer_ = ByteBuffer;
    abstract class Registry <T> implements Internal.IdMap<T>, Internal.Keyable {
        elementsLifecycle(): Internal.Lifecycle;
        asHolderIdMap(): Internal.IdMap<Internal.Holder<T>>;
        getResourceKey(arg0: T): Internal.Optional<Internal.ResourceKey<T>>;
        get(arg0: Internal.ResourceKey_<T>): T;
        static registerMapping(arg0: Internal.Registry_<V>, arg1: number, arg2: string, arg3: T): T;
        getTagNames(): Internal.Stream<Internal.TagKey<T>>;
        keySet(): Internal.Set<ResourceLocation>;
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<T>;
        getOrCreateHolder(arg0: Internal.ResourceKey_<T>): Internal.Holder<T>;
        static checkRegistry(arg0: Internal.Registry_<T>): void;
        keys(arg0: Internal.DynamicOps_<U>): Internal.Stream<U>;
        get(arg0: ResourceLocation_): T;
        getHolder(arg0: Internal.ResourceKey_<T>): Internal.Optional<Internal.Holder<T>>;
        byIdOrThrow(arg0: number): T;
        containsKey(arg0: Internal.ResourceKey_<T>): boolean;
        bindTags(arg0: Internal.Map_<Internal.TagKey_<T>, Internal.List_<Internal.Holder_<T>>>): void;
        containsKey(arg0: ResourceLocation_): boolean;
        getTags(): Internal.Stream<com.mojang.datafixers.util.Pair<Internal.TagKey<T>, Internal.HolderSet$Named<T>>>;
        getHolder(arg0: number): Internal.Optional<Internal.Holder<T>>;
        getTagOrEmpty(arg0: Internal.TagKey_<T>): Internal.Iterable<Internal.Holder<T>>;
        freeze(): this;
        holderByNameCodec(): Internal.Codec<Internal.Holder<T>>;
        static freezeBuiltins(): void;
        static register(arg0: Internal.Registry_<V>, arg1: Internal.ResourceKey_<V>, arg2: T): T;
        static register(arg0: Internal.Registry_<any>, arg1: string, arg2: T): T;
        lifecycle(arg0: T): Internal.Lifecycle;
        createIntrusiveHolder(arg0: T): Internal.Holder$Reference<T>;
        toString(): string;
        getHolderOrThrow(arg0: Internal.ResourceKey_<T>): Internal.Holder<T>;
        stream(): Internal.Stream<T>;
        getOrCreateTag(arg0: Internal.TagKey_<T>): Internal.HolderSet$Named<T>;
        getOptional(arg0: Internal.ResourceKey_<T>): Internal.Optional<T>;
        getTag(arg0: Internal.TagKey_<T>): Internal.Optional<Internal.HolderSet$Named<T>>;
        getOptional(arg0: ResourceLocation_): Internal.Optional<T>;
        getId(arg0: T): number;
        lifecycle(): Internal.Lifecycle;
        isKnownTagName(arg0: Internal.TagKey_<T>): boolean;
        key(): Internal.ResourceKey<any>;
        entrySet(): Internal.Set<Internal.Map$Entry<Internal.ResourceKey<T>, T>>;
        resetTags(): void;
        static register(arg0: Internal.Registry_<V>, arg1: ResourceLocation_, arg2: T): T;
        getOrThrow(arg0: Internal.ResourceKey_<T>): T;
        getRandom(arg0: Internal.Random_): Internal.Optional<Internal.Holder<T>>;
        byNameCodec(): Internal.Codec<T>;
        getKey(arg0: T): ResourceLocation;
        holders(): Internal.Stream<Internal.Holder$Reference<T>>;
        get tagNames(): Internal.Stream<Internal.TagKey<T>>
        get tags(): Internal.Stream<com.mojang.datafixers.util.Pair<Internal.TagKey<T>, Internal.HolderSet$Named<T>>>
        readonly static "CONFIGURED_CARVER_REGISTRY": Internal.ResourceKey<any>;
        readonly static "MENU_REGISTRY": Internal.ResourceKey<any>;
        readonly static "CARVER_REGISTRY": Internal.ResourceKey<any>;
        readonly static "ENCHANTMENT_REGISTRY": Internal.ResourceKey<any>;
        readonly static "FLOAT_PROVIDER_TYPES": Internal.MappedRegistry<any>;
        readonly static "BLOCK_ENTITY_TYPE_REGISTRY": Internal.ResourceKey<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "ATTRIBUTE": any;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "STRUCTURE_FEATURE": any;
        readonly static "PLACEMENT_MODIFIER_REGISTRY": Internal.ResourceKey<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "PARTICLE_TYPE": any;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "RECIPE_SERIALIZER": any;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "ITEM": any;
        readonly static "VILLAGER_TYPE": Internal.DefaultedRegistry<any>;
        readonly static "FEATURE_SIZE_TYPES": Internal.MappedRegistry<any>;
        readonly static "DIMENSION_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "RULE_TEST_REGISTRY": Internal.ResourceKey<any>;
        readonly static "GAME_EVENT_REGISTRY": Internal.ResourceKey<any>;
        readonly static "TEMPLATE_POOL_REGISTRY": Internal.ResourceKey<any>;
        readonly static "STRUCTURE_PIECE": Internal.MappedRegistry<any>;
        readonly static "GAME_EVENT": Internal.DefaultedRegistry<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "BLOCKSTATE_PROVIDER_TYPES": any;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "SOUND_EVENT": any;
        readonly static "STRUCTURE_POOL_ELEMENT_REGISTRY": Internal.ResourceKey<any>;
        readonly static "LOOT_SCORE_PROVIDER_TYPE": Internal.MappedRegistry<any>;
        readonly static "DENSITY_FUNCTION_REGISTRY": Internal.ResourceKey<any>;
        readonly static "PARTICLE_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "BLOCK_REGISTRY": Internal.ResourceKey<any>;
        readonly static "ENTITY_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "ITEM_REGISTRY": Internal.ResourceKey<any>;
        readonly static "POS_RULE_TEST_REGISTRY": Internal.ResourceKey<any>;
        readonly static "TREE_DECORATOR_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "ATTRIBUTE_REGISTRY": Internal.ResourceKey<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "MENU": any;
        readonly static "STRUCTURE_FEATURE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "PLACED_FEATURE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "CHUNK_GENERATOR_REGISTRY": Internal.ResourceKey<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "POINT_OF_INTEREST_TYPE": any;
        readonly static "MOB_EFFECT_REGISTRY": Internal.ResourceKey<any>;
        readonly static "LOOT_POOL_ENTRY_TYPE": Internal.MappedRegistry<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "BLOCK_ENTITY_TYPE": any;
        readonly static "STRUCTURE_PROCESSOR": Internal.MappedRegistry<any>;
        readonly static "DENSITY_FUNCTION_TYPES": Internal.MappedRegistry<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "CHUNK_STATUS": any;
        readonly static "POSITION_SOURCE_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "POSITION_SOURCE_TYPE": Internal.MappedRegistry<any>;
        readonly static "FOLIAGE_PLACER_TYPE_REGISTRY": Internal.ResourceKey<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "TREE_DECORATOR_TYPES": any;
        readonly static "RULE_TEST": Internal.MappedRegistry<any>;
        readonly static "CONFIGURED_FEATURE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "RECIPE_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "RECIPE_SERIALIZER_REGISTRY": Internal.ResourceKey<any>;
        readonly static "MEMORY_MODULE_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "STRUCTURE_SET_REGISTRY": Internal.ResourceKey<any>;
        readonly static "MOTIVE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "CUSTOM_STAT_REGISTRY": Internal.ResourceKey<any>;
        readonly static "RECIPE_TYPE": Internal.MappedRegistry<any>;
        readonly static "CONDITION_REGISTRY": Internal.ResourceKey<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "ENCHANTMENT": any;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "MOTIVE": any;
        readonly static "POS_RULE_TEST": Internal.MappedRegistry<any>;
        readonly static "FLOAT_PROVIDER_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "DIMENSION_REGISTRY": Internal.ResourceKey<any>;
        readonly static "STRUCTURE_PLACEMENT_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "RULE": Internal.MappedRegistry<any>;
        readonly static "SOUND_EVENT_REGISTRY": Internal.ResourceKey<any>;
        readonly static "STRUCTURE_PLACEMENT_TYPE": Internal.MappedRegistry<any>;
        readonly static "LOOT_CONDITION_TYPE": Internal.MappedRegistry<any>;
        readonly static "SCHEDULE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "NOISE_GENERATOR_SETTINGS_REGISTRY": Internal.ResourceKey<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "ACTIVITY": any;
        readonly static "LEVEL_STEM_REGISTRY": Internal.ResourceKey<any>;
        readonly static "TRUNK_PLACER_TYPES": Internal.MappedRegistry<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "MEMORY_MODULE_TYPE": any;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "CARVER": any;
        readonly static "CHUNK_STATUS_REGISTRY": Internal.ResourceKey<any>;
        readonly static "BLOCK_STATE_PROVIDER_TYPE_REGISTRY": Internal.ResourceKey<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "SCHEDULE": any;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "MOB_EFFECT": any;
        readonly static "VILLAGER_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "SENSOR_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "TRUNK_PLACER_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "BLOCK_PREDICATE_TYPES": Internal.MappedRegistry<any>;
        readonly static "PLACEMENT_MODIFIERS": Internal.MappedRegistry<any>;
        readonly static "ACTIVITY_REGISTRY": Internal.ResourceKey<any>;
        readonly static "BIOME_SOURCE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "STAT_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "FEATURE_SIZE_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "INT_PROVIDER_TYPES": Internal.MappedRegistry<any>;
        readonly static "STRUCTURE_POOL_ELEMENT": Internal.MappedRegistry<any>;
        readonly static "STRUCTURE_PROCESSOR_REGISTRY": Internal.ResourceKey<any>;
        readonly static "CONFIGURED_STRUCTURE_FEATURE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "POINT_OF_INTEREST_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "CHUNK_GENERATOR": Internal.MappedRegistry<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "ENTITY_TYPE": any;
        readonly static "HEIGHT_PROVIDER_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "BIOME_SOURCE": Internal.MappedRegistry<any>;
        readonly static "ROOT_REGISTRY_NAME": ResourceLocation;
        readonly static "POTION_REGISTRY": Internal.ResourceKey<any>;
        readonly static "LOOT_ENTRY_REGISTRY": Internal.ResourceKey<any>;
        readonly static "STRUCTURE_PIECE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "LOOT_NUMBER_PROVIDER_TYPE": Internal.MappedRegistry<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "FEATURE": any;
        readonly static "REGISTRY": Internal.MappedRegistry<any>;
        readonly static "FEATURE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "HEIGHT_PROVIDER_TYPES": Internal.MappedRegistry<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "BLOCK": any;
        readonly static "CUSTOM_STAT": Internal.MappedRegistry<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "VILLAGER_PROFESSION": any;
        readonly static "PROCESSOR_LIST_REGISTRY": Internal.ResourceKey<any>;
        readonly static "NOISE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "CONDITION": Internal.MappedRegistry<any>;
        readonly static "LOOT_NUMBER_PROVIDER_REGISTRY": Internal.ResourceKey<any>;
        readonly static "LOOT_NBT_PROVIDER_REGISTRY": Internal.ResourceKey<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "FOLIAGE_PLACER_TYPES": any;
        readonly static "RULE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "LOOT_ITEM_REGISTRY": Internal.ResourceKey<any>;
        readonly static "INT_PROVIDER_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "VILLAGER_PROFESSION_REGISTRY": Internal.ResourceKey<any>;
        readonly static "LOOT_FUNCTION_REGISTRY": Internal.ResourceKey<any>;
        readonly static "LOOT_NBT_PROVIDER_TYPE": Internal.MappedRegistry<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "STAT_TYPE": any;
        readonly static "LOOT_FUNCTION_TYPE": Internal.MappedRegistry<any>;
        readonly static "FLUID_REGISTRY": Internal.ResourceKey<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "FLUID": any;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "POTION": any;
        readonly static "LOOT_SCORE_PROVIDER_REGISTRY": Internal.ResourceKey<any>;
        readonly static "BIOME_REGISTRY": Internal.ResourceKey<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "SENSOR_TYPE": any;
        readonly static "BLOCK_PREDICATE_TYPE_REGISTRY": Internal.ResourceKey<any>;
        readonly static "DENSITY_FUNCTION_TYPE_REGISTRY": Internal.ResourceKey<any>;
    }
    type Registry_<T> = Registry<T>;
    class ShulkerBoxBlockEntity extends Internal.RandomizableContainerBlockEntity implements Internal.WorldlyContainer {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        constructor(arg0: Internal.DyeColor_, arg1: BlockPos_, arg2: Internal.BlockState_)
        stopOpen(arg0: Internal.Player_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        countItem(arg0: Internal.Item_): number;
        isClosed(): boolean;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        static tick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.ShulkerBoxBlockEntity_): void;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        load(arg0: Internal.CompoundTag_): void;
        canPlaceItemThroughFace(arg0: number, arg1: Internal.ItemStack_, arg2: Internal.Direction_): boolean;
        getProgress(arg0: number): number;
        onLoad(): void;
        getBoundingBox(arg0: Internal.BlockState_): Internal.AABB;
        getContainerSize(): number;
        getSlotsForFace(arg0: Internal.Direction_): number[];
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getColor(): Internal.DyeColor;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        triggerEvent(arg0: number, arg1: number): boolean;
        getMaxStackSize(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        getAnimationStatus(): Internal.ShulkerBoxBlockEntity$AnimationStatus;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        loadFromTag(arg0: Internal.CompoundTag_): void;
        canTakeItemThroughFace(arg0: number, arg1: Internal.ItemStack_, arg2: Internal.Direction_): boolean;
        getRenderBoundingBox(): Internal.AABB;
        get closed(): boolean
        get containerSize(): number
        get color(): Internal.DyeColor
        get modelData(): Internal.IModelData
        get maxStackSize(): number
        get animationStatus(): Internal.ShulkerBoxBlockEntity$AnimationStatus
        get renderBoundingBox(): Internal.AABB
        readonly static "MAX_LID_ROTATION": 270.0;
        readonly static "CONTAINER_SIZE": 27;
        readonly static "ITEMS_TAG": "Items";
        readonly static "EVENT_SET_OPEN_COUNT": 1;
        readonly static "OPENING_TICK_LENGTH": 10;
        readonly static "COLUMNS": 9;
        readonly static "ROWS": 3;
        readonly static "MAX_LID_HEIGHT": 0.5;
    }
    type ShulkerBoxBlockEntity_ = ShulkerBoxBlockEntity;
    class ServerboundClientInformationPacket extends Internal.Record implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: string, arg1: number, arg2: Internal.ChatVisiblity_, arg3: boolean, arg4: number, arg5: Internal.HumanoidArm_, arg6: boolean, arg7: boolean)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        chatColors(): boolean;
        write(arg0: Internal.FriendlyByteBuf_): void;
        language(): string;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        toString(): string;
        mainHand(): Internal.HumanoidArm;
        chatVisibility(): Internal.ChatVisiblity;
        isSkippable(): boolean;
        allowsListing(): boolean;
        hashCode(): number;
        modelCustomisation(): number;
        viewDistance(): number;
        equals(arg0: any): boolean;
        textFilteringEnabled(): boolean;
        get skippable(): boolean
        readonly static "MAX_LANGUAGE_LENGTH": 16;
    }
    type ServerboundClientInformationPacket_ = ServerboundClientInformationPacket;
    interface Short2ByteFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntUnaryOperator {
        composeObject(arg0: Internal.Object2ShortFunction_<any>): Internal.Object2ByteFunction<T>;
        getOrDefault(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2ByteFunction;
        containsKey(arg0: any): boolean;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Short2DoubleFunction;
        get(arg0: number): number;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2ByteFunction;
        remove(arg0: number): number;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Short2LongFunction;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        applyAsInt(arg0: number): number;
        put(arg0: any, arg1: any): any;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2ByteFunction;
        defaultReturnValue(): number;
        getOrDefault(arg0: number, arg1: number): number;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2ByteFunction;
        get(arg0: any): number;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Short2ShortFunction;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Short2CharFunction;
        andThenReference(arg0: Internal.Byte2ReferenceFunction_<any>): Internal.Short2ReferenceFunction<T>;
        containsKey(arg0: number): boolean;
        apply(arg0: number): number;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2ByteFunction;
        getOrDefault(arg0: any, arg1: number): number;
        size(): number;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2ByteFunction;
        composeShort(arg0: Internal.Short2ShortFunction_): this;
        andThenByte(arg0: Internal.Byte2ByteFunction_): this;
        put(arg0: number, arg1: number): number;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Short2IntFunction;
        clear(): void;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Short2FloatFunction;
        remove(arg0: any): any;
        composeReference(arg0: Internal.Reference2ShortFunction_<any>): Internal.Reference2ByteFunction<T>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        andThenObject(arg0: Internal.Byte2ObjectFunction_<any>): Internal.Short2ObjectFunction<T>;
    }
    type Short2ByteFunction_ = Short2ByteFunction | ((arg0: number)=>number);
    interface MobFilter extends Internal.BiPredicate<Internal.MobCategory, Internal.MobSpawnSettings$SpawnerData> {
        test(arg0: Internal.MobCategory_, arg1: Internal.MobSpawnSettings$SpawnerData_): boolean;
        of(o: any): this;
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.MobCategory, Internal.MobSpawnSettings$SpawnerData>;
        idFilter(s: string): this;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.MobCategory, Internal.MobSpawnSettings$SpawnerData>;
        test(arg0: any, arg1: any): boolean;
        negate(): Internal.BiPredicate<Internal.MobCategory, Internal.MobSpawnSettings$SpawnerData>;
        readonly static "ALWAYS_FALSE": any;
        readonly static "ALWAYS_TRUE": any;
    }
    type MobFilter_ = MobFilter | ((arg0: Internal.MobCategory, arg1: Internal.MobSpawnSettings$SpawnerData)=>boolean);
    interface IntStream$Builder extends Internal.IntConsumer {
        add(arg0: number): this;
        build(): Internal.IntStream;
        accept(arg0: number): void;
        andThen(arg0: Internal.IntConsumer_): Internal.IntConsumer;
    }
    type IntStream$Builder_ = IntStream$Builder;
    class SpawnerBlockEntity extends Internal.BlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        triggerEvent(arg0: number, arg1: number): boolean;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getUpdateTag(): Internal.CompoundTag;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getSpawner(): Internal.BaseSpawner;
        serializeNBT(): Internal.CompoundTag;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onlyOpCanSetNbt(): boolean;
        load(arg0: Internal.CompoundTag_): void;
        getUpdatePacket(): Internal.Packet<any>;
        onLoad(): void;
        static serverTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.SpawnerBlockEntity_): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        static clientTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.SpawnerBlockEntity_): void;
        get modelData(): Internal.IModelData
        get updateTag(): Internal.CompoundTag
        get spawner(): Internal.BaseSpawner
        get updatePacket(): Internal.Packet<any>
        get renderBoundingBox(): Internal.AABB
    }
    type SpawnerBlockEntity_ = SpawnerBlockEntity;
    interface Short2ObjectFunction <V> extends Internal.IntFunction<V>, it.unimi.dsi.fastutil.Function<number, V> {
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2ObjectFunction<V>;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Short2ByteFunction;
        remove(arg0: number): V;
        getOrDefault(arg0: any, arg1: V): V;
        composeReference(arg0: Internal.Reference2ShortFunction_<any>): Internal.Reference2ObjectFunction<T, V>;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Short2LongFunction;
        andThenObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Short2ObjectFunction<T>;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Short2ShortFunction;
        getOrDefault(arg0: number, arg1: V): V;
        composeObject(arg0: Internal.Object2ShortFunction_<any>): Internal.Object2ObjectFunction<T, V>;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2ObjectFunction<V>;
        get(arg0: any): V;
        put(arg0: any, arg1: any): any;
        apply(arg0: number): V;
        remove(arg0: any): V;
        put(arg0: number, arg1: V): V;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Short2IntFunction;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Short2DoubleFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Short2FloatFunction;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2ObjectFunction<V>;
        containsKey(arg0: number): boolean;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Short2CharFunction;
        put(arg0: number, arg1: V): V;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        size(): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
        andThenReference(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Short2ReferenceFunction<T>;
        get(arg0: number): V;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        defaultReturnValue(): V;
        defaultReturnValue(arg0: V): void;
        composeShort(arg0: Internal.Short2ShortFunction_): this;
    }
    type Short2ObjectFunction_<V> = ((arg0: number)=>V) | Short2ObjectFunction<V>;
    class PortalForcer implements Internal.ITeleporter {
        constructor(arg0: Internal.ServerLevel_)
        findPortalAround(arg0: BlockPos_, arg1: boolean, arg2: Internal.WorldBorder_): Internal.Optional<Internal.BlockUtil$FoundRectangle>;
        isVanilla(): boolean;
        playTeleportSound(arg0: Internal.ServerPlayer_, arg1: Internal.ServerLevel_, arg2: Internal.ServerLevel_): boolean;
        getPortalInfo(arg0: Internal.Entity_, arg1: Internal.ServerLevel_, arg2: Internal.Function_<Internal.ServerLevel_, Internal.PortalInfo_>): Internal.PortalInfo;
        createPortal(arg0: BlockPos_, arg1: Internal.Direction$Axis_): Internal.Optional<Internal.BlockUtil$FoundRectangle>;
        placeEntity(arg0: Internal.Entity_, arg1: Internal.ServerLevel_, arg2: Internal.ServerLevel_, arg3: number, arg4: Internal.Function_<boolean, Internal.Entity_>): Internal.Entity;
        get vanilla(): boolean
    }
    type PortalForcer_ = PortalForcer;
    class ItemTooltipEventJS extends Internal.EventJS {
        constructor(m: Internal.Map_<Internal.Item_, Internal.List_<any_>>)
        addAdvanced(item: any, handler: Internal.ItemTooltipEventJS$StaticTooltipHandlerFromJS_): void;
        add(item: any, text: any): void;
        isShift(): boolean;
        addToAll(text: any): void;
        isAlt(): boolean;
        isCtrl(): boolean;
        addAdvancedToAll(handler: Internal.ItemTooltipEventJS$StaticTooltipHandlerFromJS_): void;
        get shift(): boolean
        get alt(): boolean
        get ctrl(): boolean
    }
    type ItemTooltipEventJS_ = ItemTooltipEventJS;
    class KeyboardHandler {
        constructor(arg0: Internal.Minecraft_)
        setClipboard(arg0: string): void;
        keyPress(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        setup(arg0: number): void;
        getClipboard(): string;
        setSendRepeatsToGui(arg0: boolean): void;
        tick(): void;
        set clipboard(arg0: string)
        set up(arg0: number)
        get clipboard(): string
        set sendRepeatsToGui(arg0: boolean)
        readonly static "DEBUG_CRASH_TIME": 10000;
    }
    type KeyboardHandler_ = KeyboardHandler;
    class RandomFeatureConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.List_<Internal.WeightedPlacedFeature_>, arg1: Internal.Holder_<Internal.PlacedFeature_>)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
        readonly "features": Internal.List<Internal.WeightedPlacedFeature>;
        readonly "defaultFeature": Internal.Holder<Internal.PlacedFeature>;
    }
    type RandomFeatureConfiguration_ = RandomFeatureConfiguration;
    interface Char2ShortFunction extends it.unimi.dsi.fastutil.Function<string, number>, Internal.IntUnaryOperator {
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Char2ByteFunction;
        apply(arg0: string): number;
        getOrDefault(arg0: any, arg1: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        containsKey(arg0: string): boolean;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2ShortFunction;
        containsKey(arg0: any): boolean;
        get(arg0: any): number;
        defaultReturnValue(): number;
        composeObject(arg0: Internal.Object2CharFunction_<any>): Internal.Object2ShortFunction<T>;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2ShortFunction;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        applyAsInt(arg0: number): number;
        put(arg0: any, arg1: any): any;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2ShortFunction;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Char2LongFunction;
        composeChar(arg0: Internal.Char2CharFunction_): this;
        composeReference(arg0: Internal.Reference2CharFunction_<any>): Internal.Reference2ShortFunction<T>;
        put(arg0: string, arg1: number): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): this;
        andThenObject(arg0: Internal.Short2ObjectFunction_<any>): Internal.Char2ObjectFunction<T>;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2ShortFunction;
        put(arg0: string, arg1: number): number;
        size(): number;
        remove(arg0: string): number;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2ShortFunction;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Char2DoubleFunction;
        clear(): void;
        get(arg0: string): number;
        getOrDefault(arg0: any, arg1: number): number;
        remove(arg0: any): any;
        getOrDefault(arg0: string, arg1: number): number;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Char2FloatFunction;
        andThenReference(arg0: Internal.Short2ReferenceFunction_<any>): Internal.Char2ReferenceFunction<T>;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2ShortFunction;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Char2IntFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<string, T>;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Char2CharFunction;
    }
    type Char2ShortFunction_ = Char2ShortFunction | ((arg0: string)=>number);
    class ClientboundUpdateMobEffectPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: Internal.MobEffectInstance_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getEffectDurationTicks(): number;
        isEffectVisible(): boolean;
        write(arg0: Internal.FriendlyByteBuf_): void;
        isEffectAmbient(): boolean;
        isSuperLongDuration(): boolean;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getEffectAmplifier(): number;
        getEntityId(): number;
        effectShowsIcon(): boolean;
        getEffectId(): number;
        isSkippable(): boolean;
        get effectDurationTicks(): number
        get effectVisible(): boolean
        get effectAmbient(): boolean
        get superLongDuration(): boolean
        get effectAmplifier(): number
        get entityId(): number
        get effectId(): number
        get skippable(): boolean
    }
    type ClientboundUpdateMobEffectPacket_ = ClientboundUpdateMobEffectPacket;
    class Axolotl$Variant extends Internal.Enum<Internal.Axolotl$Variant> {
        static valueOf(arg0: string): Internal.Axolotl$Variant;
        getName(): string;
        static getRareSpawnVariant(arg0: Internal.Random_): Internal.Axolotl$Variant;
        static values(): Internal.Axolotl$Variant[];
        static getCommonSpawnVariant(arg0: Internal.Random_): Internal.Axolotl$Variant;
        getId(): number;
        get name(): string
        get id(): number
        readonly static "GOLD": Internal.Axolotl$Variant;
        readonly static "CYAN": Internal.Axolotl$Variant;
        readonly static "BLUE": Internal.Axolotl$Variant;
        readonly static "LUCY": Internal.Axolotl$Variant;
        readonly static "WILD": Internal.Axolotl$Variant;
        readonly static "BY_ID": any;
    }
    type Axolotl$Variant_ = "gold" | "wild" | Axolotl$Variant | "blue" | "lucy" | "cyan";
    abstract class TypeCapture <T> {
    }
    type TypeCapture_<T> = TypeCapture<T>;
    class LevelLightEngine implements Internal.LightEventListener {
        constructor(arg0: Internal.LightChunkGetter_, arg1: boolean, arg2: boolean)
        checkBlock(arg0: BlockPos_): void;
        updateSectionStatus(arg0: BlockPos_, arg1: boolean): void;
        getDebugData(arg0: Internal.LightLayer_, arg1: Internal.SectionPos_): string;
        retainData(arg0: Internal.ChunkPos_, arg1: boolean): void;
        getLightSectionCount(): number;
        getLayerListener(arg0: Internal.LightLayer_): Internal.LayerLightEventListener;
        getMaxLightSection(): number;
        enableLightSources(arg0: Internal.ChunkPos_, arg1: boolean): void;
        onBlockEmissionIncrease(arg0: BlockPos_, arg1: number): void;
        runUpdates(arg0: number, arg1: boolean, arg2: boolean): number;
        queueSectionData(arg0: Internal.LightLayer_, arg1: Internal.SectionPos_, arg2: Internal.DataLayer_, arg3: boolean): void;
        getMinLightSection(): number;
        hasLightWork(): boolean;
        getRawBrightness(arg0: BlockPos_, arg1: number): number;
        updateSectionStatus(arg0: Internal.SectionPos_, arg1: boolean): void;
        get lightSectionCount(): number
        get maxLightSection(): number
        get minLightSection(): number
        readonly static "MAX_SOURCE_LEVEL": 15;
        readonly static "LIGHT_SECTION_PADDING": 1;
    }
    type LevelLightEngine_ = LevelLightEngine;
    abstract class ScreenEvent$MouseDragEvent extends Internal.ScreenEvent$MouseInputEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number)
        getListenerList(): Internal.ListenerList;
        getMouseButton(): number;
        getDragY(): number;
        getDragX(): number;
        get listenerList(): Internal.ListenerList
        get mouseButton(): number
        get dragY(): number
        get dragX(): number
    }
    type ScreenEvent$MouseDragEvent_ = ScreenEvent$MouseDragEvent;
    class ClientboundOpenSignEditorPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: BlockPos_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getPos(): BlockPos;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get pos(): BlockPos
        get skippable(): boolean
    }
    type ClientboundOpenSignEditorPacket_ = ClientboundOpenSignEditorPacket;
    class WriteBufferWaterMark {
        constructor(arg0: number, arg1: number)
        toString(): string;
        low(): number;
        high(): number;
        readonly static "DEFAULT": Internal.WriteBufferWaterMark;
    }
    type WriteBufferWaterMark_ = WriteBufferWaterMark;
    class ServerLifecycleEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.MinecraftServer_)
        getListenerList(): Internal.ListenerList;
        getServer(): Internal.MinecraftServer;
        get listenerList(): Internal.ListenerList
        get server(): Internal.MinecraftServer
    }
    type ServerLifecycleEvent_ = ServerLifecycleEvent;
    interface ServerLevelData extends Internal.WritableLevelData {
        setInitialized(arg0: boolean): void;
        setWanderingTraderSpawnDelay(arg0: number): void;
        setRainTime(arg0: number): void;
        getWanderingTraderSpawnChance(): number;
        setWorldBorder(arg0: Internal.WorldBorder$Settings_): void;
        fillCrashReportCategory(arg0: Internal.CrashReportCategory_, arg1: Internal.LevelHeightAccessor_): void;
        setWanderingTraderSpawnChance(arg0: number): void;
        getLevelName(): string;
        getThunderTime(): number;
        getWanderingTraderId(): Internal.UUID;
        isInitialized(): boolean;
        setClearWeatherTime(arg0: number): void;
        getAllowCommands(): boolean;
        setThundering(arg0: boolean): void;
        getScheduledEvents(): Internal.TimerQueue<Internal.MinecraftServer>;
        setWanderingTraderId(arg0: Internal.UUID_): void;
        setDayTime(arg0: number): void;
        getWanderingTraderSpawnDelay(): number;
        setThunderTime(arg0: number): void;
        getWorldBorder(): Internal.WorldBorder$Settings;
        getClearWeatherTime(): number;
        setGameType(arg0: Internal.GameType_): void;
        setSpawn(arg0: BlockPos_, arg1: number): void;
        getRainTime(): number;
        getGameType(): Internal.GameType;
        setGameTime(arg0: number): void;
        set initialized(arg0: boolean)
        set wanderingTraderSpawnDelay(arg0: number)
        set rainTime(arg0: number)
        get wanderingTraderSpawnChance(): number
        set worldBorder(arg0: Internal.WorldBorder$Settings_)
        set wanderingTraderSpawnChance(arg0: number)
        get levelName(): string
        get thunderTime(): number
        get wanderingTraderId(): Internal.UUID
        get initialized(): boolean
        set clearWeatherTime(arg0: number)
        get allowCommands(): boolean
        set thundering(arg0: boolean)
        get scheduledEvents(): Internal.TimerQueue<Internal.MinecraftServer>
        set wanderingTraderId(arg0: Internal.UUID_)
        set dayTime(arg0: number)
        get wanderingTraderSpawnDelay(): number
        set thunderTime(arg0: number)
        get worldBorder(): Internal.WorldBorder$Settings
        get clearWeatherTime(): number
        set gameType(arg0: Internal.GameType_)
        get rainTime(): number
        get gameType(): Internal.GameType
        set gameTime(arg0: number)
    }
    type ServerLevelData_ = ServerLevelData;
    class NetworkDirection extends Internal.Enum<Internal.NetworkDirection> {
        buildPacket(arg0: Internal.Pair_<Internal.FriendlyByteBuf_, number>, arg1: ResourceLocation_): Internal.ICustomPacket<T>;
        getOriginationSide(): Internal.LogicalSide;
        static valueOf(arg0: string): Internal.NetworkDirection;
        getReceptionSide(): Internal.LogicalSide;
        static directionFor(arg0: Internal.Class_<T>): Internal.NetworkDirection;
        reply(): this;
        getEvent(arg0: Internal.ICustomPacket_<any>, arg1: Internal.Supplier_<Internal.NetworkEvent$Context_>): Internal.NetworkEvent;
        static values(): Internal.NetworkDirection[];
        get originationSide(): Internal.LogicalSide
        get receptionSide(): Internal.LogicalSide
        readonly static "LOGIN_TO_SERVER": Internal.NetworkDirection;
        readonly static "LOGIN_TO_CLIENT": Internal.NetworkDirection;
        readonly static "PLAY_TO_SERVER": Internal.NetworkDirection;
        readonly static "PLAY_TO_CLIENT": Internal.NetworkDirection;
    }
    type NetworkDirection_ = "login_to_server" | "play_to_server" | "play_to_client" | "login_to_client" | NetworkDirection;
    interface ServerLevelAccessor extends Internal.LevelAccessor {
        getBlockTint(arg0: BlockPos_, arg1: Internal.ColorResolver_): number;
        getMinSection(): number;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_): Internal.Player;
        findFreePosition(arg0: Internal.Entity_, arg1: Internal.VoxelShape_, arg2: Vec3_, arg3: number, arg4: number, arg5: number): Internal.Optional<Vec3>;
        dayTime(): number;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        isUnobstructed(arg0: Internal.Entity_, arg1: Internal.VoxelShape_): boolean;
        getMaxSection(): number;
        gameEvent(arg0: Internal.GameEvent_, arg1: Internal.Entity_): void;
        getBrightness(arg0: Internal.LightLayer_, arg1: BlockPos_): number;
        getNearestPlayer(arg0: Internal.Entity_, arg1: number): Internal.Player;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getBlockStatesIfLoaded(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getSectionYFromSectionIndex(arg0: number): number;
        isEmptyBlock(arg0: BlockPos_): boolean;
        getMaxLocalRawBrightness(arg0: BlockPos_, arg1: number): number;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        getBlockCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        getRawBrightness(arg0: BlockPos_, arg1: number): number;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        getTimeOfDay(arg0: number): number;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getHeightmapPos(arg0: Internal.Heightmap$Types_, arg1: BlockPos_): BlockPos;
        blockUpdated(arg0: BlockPos_, arg1: Internal.Block_): void;
        getDifficulty(): Internal.Difficulty;
        canSeeSky(arg0: BlockPos_): boolean;
        getMoonPhase(): number;
        isUnobstructed(arg0: Internal.Entity_): boolean;
        getEntities(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.Entity>;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_): Internal.List<T>;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        addFreshEntityWithPassengers(arg0: Internal.Entity_): void;
        getBrightness(arg0: BlockPos_): number;
        getNearestEntity(arg0: Internal.List_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number): T;
        getPlayerByUUID(arg0: Internal.UUID_): Internal.Player;
        canSeeSkyFromBelowWater(arg0: BlockPos_): boolean;
        getSectionsCount(): number;
        getMinBuildHeight(): number;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Fluid_, arg2: number): void;
        getSectionIndexFromSectionY(arg0: number): number;
        getNearbyPlayers(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: Internal.AABB_): Internal.List<Internal.Player>;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): Internal.Player;
        setBlock(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: number): boolean;
        noCollision(arg0: Internal.Entity_): boolean;
        getChunk(arg0: number, arg1: number, arg2: Internal.ChunkStatus_): Internal.ChunkAccess;
        getLevel(): Internal.ServerLevel;
        hasChunkAt(arg0: number, arg1: number): boolean;
        getSectionIndex(arg0: number): number;
        hasChunk(arg0: number, arg1: number): boolean;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: number, arg2: number, arg3: number): Internal.Player;
        getMaxBuildHeight(): number;
        getNearbyEntities(arg0: Internal.Class_<T>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: Internal.AABB_): Internal.List<T>;
        hasChunksAt(arg0: BlockPos_, arg1: BlockPos_): boolean;
        destroyBlock(arg0: BlockPos_, arg1: boolean): boolean;
        getMoonBrightness(): number;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Block_, arg2: number): void;
        addFreshEntity(arg0: Internal.Entity_): boolean;
        noCollision(arg0: Internal.AABB_): boolean;
        getChunk(arg0: number, arg1: number): Internal.ChunkAccess;
        isWaterAt(arg0: BlockPos_): boolean;
        getDirectSignal(arg0: BlockPos_, arg1: Internal.Direction_): number;
        getCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        destroyBlock(arg0: BlockPos_, arg1: boolean, arg2: Internal.Entity_): boolean;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        getEntityCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.VoxelShape>;
        collidesWithSuffocatingBlock(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getHeight(): number;
        getNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        noCollision(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getChunk(arg0: BlockPos_): Internal.ChunkAccess;
        gameEvent(arg0: Internal.GameEvent_, arg1: BlockPos_): void;
        isOutsideBuildHeight(arg0: number): boolean;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Fluid_, arg2: number, arg3: Internal.TickPriority_): void;
        gameEvent(arg0: Internal.Entity_, arg1: Internal.GameEvent_, arg2: Internal.Entity_): void;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Predicate_<Internal.Entity_>): Internal.Player;
        getMaxLocalRawBrightness(arg0: BlockPos_): number;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getNearestEntity(arg0: Internal.Class_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number, arg6: Internal.AABB_): T;
        isUnobstructed(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.CollisionContext_): boolean;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_, arg2: Internal.Predicate_<any>): Internal.List<T>;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        hasChunkAt(arg0: BlockPos_): boolean;
        levelEvent(arg0: number, arg1: BlockPos_, arg2: number): void;
        getBiome(arg0: BlockPos_): Internal.Holder<Internal.Biome>;
        getChunkForCollisions(arg0: number, arg1: number): Internal.BlockGetter;
        containsAnyLiquid(arg0: Internal.AABB_): boolean;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Block_, arg2: number, arg3: Internal.TickPriority_): void;
        hasNearbyAlivePlayer(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getMaxLightLevel(): number;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: number, arg3: number, arg4: number): Internal.Player;
        get minSection(): number
        get maxSection(): number
        get difficulty(): Internal.Difficulty
        get moonPhase(): number
        get sectionsCount(): number
        get minBuildHeight(): number
        get level(): Internal.ServerLevel
        get maxBuildHeight(): number
        get moonBrightness(): number
        get height(): number
        get maxLightLevel(): number
    }
    type ServerLevelAccessor_ = ServerLevelAccessor;
    class ServerboundSetCommandMinecartPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: string, arg2: boolean)
        handle(arg0: Internal.PacketListener_): void;
        isTrackOutput(): boolean;
        getCommand(): string;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getCommandBlock(arg0: Internal.Level_): Internal.BaseCommandBlock;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        isSkippable(): boolean;
        get trackOutput(): boolean
        get command(): string
        get skippable(): boolean
    }
    type ServerboundSetCommandMinecartPacket_ = ServerboundSetCommandMinecartPacket;
    interface DoubleBinaryOperator {
        applyAsDouble(arg0: number, arg1: number): number;
    }
    type DoubleBinaryOperator_ = DoubleBinaryOperator | ((arg0: number, arg1: number)=>number);
    class TagManager implements Internal.PreparableReloadListener {
        constructor(arg0: Internal.RegistryAccess_)
        static getTagDir(arg0: Internal.ResourceKey_<any>): string;
        getName(): string;
        getResult(): Internal.List<Internal.TagManager$LoadResult<any>>;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        get name(): string
        get result(): Internal.List<Internal.TagManager$LoadResult<any>>
    }
    type TagManager_ = TagManager;
    class PostChain implements Internal.AutoCloseable {
        constructor(arg0: Internal.TextureManager_, arg1: Internal.ResourceManager_, arg2: Internal.RenderTarget_, arg3: ResourceLocation_)
        process(arg0: number): void;
        addPass(arg0: string, arg1: Internal.RenderTarget_, arg2: Internal.RenderTarget_): Internal.PostPass;
        getName(): string;
        close(): void;
        resize(arg0: number, arg1: number): void;
        addTempTarget(arg0: string, arg1: number, arg2: number): void;
        getTempTarget(arg0: string): Internal.RenderTarget;
        get name(): string
    }
    type PostChain_ = PostChain;
    class DragonHoverPhase extends Internal.AbstractDragonPhaseInstance {
        constructor(arg0: Internal.EnderDragon_)
        getPhase(): Internal.EnderDragonPhase<Internal.DragonHoverPhase>;
        isSitting(): boolean;
        getFlyTargetLocation(): Vec3;
        getFlySpeed(): number;
        begin(): void;
        doServerTick(): void;
        get phase(): Internal.EnderDragonPhase<Internal.DragonHoverPhase>
        get sitting(): boolean
        get flyTargetLocation(): Vec3
        get flySpeed(): number
    }
    type DragonHoverPhase_ = DragonHoverPhase;
    interface IBlockRenderProperties {
        addHitEffects(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: Internal.HitResult_, arg3: Internal.ParticleEngine_): boolean;
        getFogColor(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_, arg4: Internal.Vector3d_, arg5: number): Internal.Vector3d;
        addDestroyEffects(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.ParticleEngine_): boolean;
        readonly static "DUMMY": any;
    }
    type IBlockRenderProperties_ = IBlockRenderProperties;
    interface Boolean2DoubleFunction extends it.unimi.dsi.fastutil.Function<boolean, number> {
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Boolean2ShortFunction;
        put(arg0: boolean, arg1: number): number;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): this;
        getOrDefault(arg0: any, arg1: any): any;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2DoubleFunction;
        get(arg0: any): number;
        andThenObject(arg0: Internal.Double2ObjectFunction_<any>): Internal.Boolean2ObjectFunction<T>;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Boolean2ByteFunction;
        containsKey(arg0: any): boolean;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2DoubleFunction;
        remove(arg0: boolean): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Boolean2LongFunction;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2DoubleFunction;
        put(arg0: any, arg1: any): any;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2DoubleFunction;
        defaultReturnValue(arg0: number): void;
        composeObject(arg0: Internal.Object2BooleanFunction_<any>): Internal.Object2DoubleFunction<T>;
        remove(arg0: any): number;
        andThenReference(arg0: Internal.Double2ReferenceFunction_<any>): Internal.Boolean2ReferenceFunction<T>;
        getOrDefault(arg0: any, arg1: number): number;
        get(arg0: boolean): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        defaultReturnValue(): number;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Boolean2IntFunction;
        containsKey(arg0: boolean): boolean;
        getOrDefault(arg0: boolean, arg1: number): number;
        size(): number;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Boolean2FloatFunction;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2DoubleFunction;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2DoubleFunction;
        put(arg0: boolean, arg1: number): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<boolean, T>;
        apply(arg0: boolean): number;
        clear(): void;
        composeReference(arg0: Internal.Reference2BooleanFunction_<any>): Internal.Reference2DoubleFunction<T>;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Boolean2CharFunction;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2DoubleFunction;
    }
    type Boolean2DoubleFunction_ = ((arg0: boolean)=>number) | Boolean2DoubleFunction;
    class RecipeFunction extends Internal.BaseFunction implements Internal.WrappedJS {
        constructor(e: Internal.RecipeEventJS_, id: ResourceLocation_, t: Internal.RecipeTypeJS_)
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        toString(): string;
        call(cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args0: any[]): Internal.RecipeJS;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getAllIds(): any[];
        createRecipe(args0: any[]): Internal.RecipeJS;
        get allIds(): any[]
        readonly "typeID": ResourceLocation;
        readonly "type": Internal.RecipeTypeJS;
    }
    type RecipeFunction_ = RecipeFunction;
    class ScreenEvent$KeyboardKeyReleasedEvent$Post extends Internal.ScreenEvent$KeyboardKeyReleasedEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number, arg3: number)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$KeyboardKeyReleasedEvent$Post_ = ScreenEvent$KeyboardKeyReleasedEvent$Post;
    class ModuleDescriptor$Modifier extends Internal.Enum<Internal.ModuleDescriptor$Modifier> {
        static valueOf(arg0: string): Internal.ModuleDescriptor$Modifier;
        static values(): Internal.ModuleDescriptor$Modifier[];
        readonly static "AUTOMATIC": Internal.ModuleDescriptor$Modifier;
        readonly static "MANDATED": Internal.ModuleDescriptor$Modifier;
        readonly static "OPEN": Internal.ModuleDescriptor$Modifier;
        readonly static "SYNTHETIC": Internal.ModuleDescriptor$Modifier;
    }
    type ModuleDescriptor$Modifier_ = ModuleDescriptor$Modifier | "mandated" | "open" | "synthetic" | "automatic";
    class BlockUtil$FoundRectangle {
        constructor(arg0: BlockPos_, arg1: number, arg2: number)
        readonly "minCorner": BlockPos;
        readonly "axis2Size": number;
        readonly "axis1Size": number;
    }
    type BlockUtil$FoundRectangle_ = BlockUtil$FoundRectangle;
    interface EventExecutorGroup extends Internal.Iterable<Internal.EventExecutor>, Internal.ScheduledExecutorService {
        submit(arg0: Internal.Runnable_, arg1: T): io.netty.util.concurrent.Future<T>;
        scheduleWithFixedDelay(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        shutdownNow(): Internal.List<Internal.Runnable>;
        scheduleAtFixedRate(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        forEach(arg0: Internal.Consumer_<any>): void;
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.Future<any>;
        shutdownGracefully(): io.netty.util.concurrent.Future<any>;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        schedule(arg0: Internal.Callable_<V>, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<V>;
        shutdown(): void;
        terminationFuture(): io.netty.util.concurrent.Future<any>;
        iterator(): Internal.Iterator<Internal.EventExecutor>;
        next(): Internal.EventExecutor;
        schedule(arg0: Internal.Runnable_, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        submit(arg0: Internal.Runnable_): io.netty.util.concurrent.Future<any>;
        submit(arg0: Internal.Callable_<T>): io.netty.util.concurrent.Future<T>;
        isShuttingDown(): boolean;
        get shuttingDown(): boolean
    }
    type EventExecutorGroup_ = EventExecutorGroup;
    class BlockEvent$NeighborNotifyEvent extends Internal.BlockEvent {
        constructor()
        constructor(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.EnumSet_<Internal.Direction_>, arg4: boolean)
        isCancelable(): boolean;
        getForceRedstoneUpdate(): boolean;
        getListenerList(): Internal.ListenerList;
        getNotifiedSides(): Internal.EnumSet<Internal.Direction>;
        get cancelable(): boolean
        get forceRedstoneUpdate(): boolean
        get listenerList(): Internal.ListenerList
        get notifiedSides(): Internal.EnumSet<Internal.Direction>
    }
    type BlockEvent$NeighborNotifyEvent_ = BlockEvent$NeighborNotifyEvent;
    class Program$Type extends Internal.Enum<Internal.Program$Type> {
        getExtension(): string;
        getPrograms(): Internal.Map<string, Internal.Program>;
        static values(): Internal.Program$Type[];
        getName(): string;
        static valueOf(arg0: string): Internal.Program$Type;
        get extension(): string
        get programs(): Internal.Map<string, Internal.Program>
        get name(): string
        readonly static "FRAGMENT": Internal.Program$Type;
        readonly static "VERTEX": Internal.Program$Type;
    }
    type Program$Type_ = "vertex" | "fragment" | Program$Type;
    abstract class AxisCycle extends Internal.Enum<Internal.AxisCycle> {
        static values(): Internal.AxisCycle[];
        cycle(arg0: number, arg1: number, arg2: number, arg3: Internal.Direction$Axis_): number;
        inverse(): this;
        cycle(arg0: number, arg1: number, arg2: number, arg3: Internal.Direction$Axis_): number;
        static valueOf(arg0: string): Internal.AxisCycle;
        static between(arg0: Internal.Direction$Axis_, arg1: Internal.Direction$Axis_): Internal.AxisCycle;
        cycle(arg0: Internal.Direction$Axis_): Internal.Direction$Axis;
        readonly static "AXIS_VALUES": any;
        readonly static "NONE": any;
        readonly static "VALUES": any;
        readonly static "FORWARD": any;
        readonly static "BACKWARD": any;
    }
    type AxisCycle_ = "backward" | AxisCycle | "forward" | "none";
    class LootContext$Builder {
        constructor(arg0: Internal.LootContext_)
        constructor(arg0: Internal.ServerLevel_)
        create(arg0: Internal.LootContextParamSet_): Internal.LootContext;
        withOptionalRandomSeed(arg0: number, arg1: Internal.Random_): this;
        withOptionalRandomSeed(arg0: number): this;
        getOptionalParameter(arg0: Internal.LootContextParam_<T>): T;
        getLevel(): Internal.ServerLevel;
        getParameter(arg0: Internal.LootContextParam_<T>): T;
        withLuck(arg0: number): this;
        withOptionalParameter(arg0: Internal.LootContextParam_<T>, arg1: T): this;
        withParameter(arg0: Internal.LootContextParam_<T>, arg1: T): this;
        withDynamicDrop(arg0: ResourceLocation_, arg1: Internal.LootContext$DynamicDrop_): this;
        withRandom(arg0: Internal.Random_): this;
        get level(): Internal.ServerLevel
    }
    type LootContext$Builder_ = LootContext$Builder;
    class Biome$ClimateSettings {
        constructor(arg0: Internal.Biome$Precipitation_, arg1: number, arg2: Internal.Biome$TemperatureModifier_, arg3: number)
        "temperatureModifier": Internal.Biome$TemperatureModifier;
        "precipitation": Internal.Biome$Precipitation;
        "temperature": number;
        "downfall": number;
        readonly static "CODEC": any;
    }
    type Biome$ClimateSettings_ = Biome$ClimateSettings;
    class AudioFormat {
        constructor(arg0: Internal.AudioFormat$Encoding_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: boolean)
        constructor(arg0: Internal.AudioFormat$Encoding_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: boolean, arg7: Internal.Map_<string, any>)
        constructor(arg0: number, arg1: number, arg2: number, arg3: boolean, arg4: boolean)
        matches(arg0: Internal.AudioFormat_): boolean;
        properties(): Internal.Map<string, any>;
        toString(): string;
        getSampleRate(): number;
        getFrameSize(): number;
        getFrameRate(): number;
        getProperty(arg0: string): any;
        isBigEndian(): boolean;
        getEncoding(): Internal.AudioFormat$Encoding;
        getChannels(): number;
        getSampleSizeInBits(): number;
        get sampleRate(): number
        get frameSize(): number
        get frameRate(): number
        get bigEndian(): boolean
        get encoding(): Internal.AudioFormat$Encoding
        get channels(): number
        get sampleSizeInBits(): number
    }
    type AudioFormat_ = AudioFormat;
    class PlayerInteractEvent$RightClickItem extends Internal.PlayerInteractEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Hand_)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type PlayerInteractEvent$RightClickItem_ = PlayerInteractEvent$RightClickItem;
    interface Double2ByteFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleToIntFunction {
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Double2LongFunction;
        composeObject(arg0: Internal.Object2DoubleFunction_<any>): Internal.Object2ByteFunction<T>;
        andThenByte(arg0: Internal.Byte2ByteFunction_): this;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Double2DoubleFunction;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Double2IntFunction;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Double2FloatFunction;
        getOrDefault(arg0: any, arg1: any): any;
        remove(arg0: number): number;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2ByteFunction;
        put(arg0: number, arg1: number): number;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2ByteFunction;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Double2ShortFunction;
        containsKey(arg0: any): boolean;
        defaultReturnValue(arg0: number): void;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2ByteFunction;
        put(arg0: any, arg1: any): any;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Double2CharFunction;
        defaultReturnValue(): number;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2ByteFunction;
        put(arg0: number, arg1: number): number;
        get(arg0: any): number;
        getOrDefault(arg0: number, arg1: number): number;
        apply(arg0: number): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        get(arg0: number): number;
        containsKey(arg0: number): boolean;
        getOrDefault(arg0: any, arg1: number): number;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2ByteFunction;
        size(): number;
        composeReference(arg0: Internal.Reference2DoubleFunction_<any>): Internal.Reference2ByteFunction<T>;
        clear(): void;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2ByteFunction;
        andThenReference(arg0: Internal.Byte2ReferenceFunction_<any>): Internal.Double2ReferenceFunction<T>;
        andThenObject(arg0: Internal.Byte2ObjectFunction_<any>): Internal.Double2ObjectFunction<T>;
        remove(arg0: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        applyAsInt(arg0: number): number;
        composeDouble(arg0: Internal.Double2DoubleFunction_): this;
    }
    type Double2ByteFunction_ = ((arg0: number)=>number) | Double2ByteFunction;
    class ServerStatusPing {
        constructor()
        hashCode(): number;
        getFMLNetworkVersion(): number;
        toString(): string;
        isTruncated(): boolean;
        getRemoteChannels(): Internal.Map<ResourceLocation, Internal.Pair<string, boolean>>;
        getRemoteModData(): Internal.Map<string, string>;
        equals(arg0: any): boolean;
        get FMLNetworkVersion(): number
        get truncated(): boolean
        get remoteChannels(): Internal.Map<ResourceLocation, Internal.Pair<string, boolean>>
        get remoteModData(): Internal.Map<string, string>
    }
    type ServerStatusPing_ = ServerStatusPing;
    class EffectProgram extends Internal.Program {
        static compileShader(arg0: Internal.Program$Type_, arg1: string, arg2: Internal.InputStream_, arg3: string): Internal.EffectProgram;
        close(): void;
        attachToEffect(arg0: Internal.Effect_): void;
    }
    type EffectProgram_ = EffectProgram;
    interface Spliterator$OfLong extends Internal.Spliterator$OfPrimitive<number, Internal.LongConsumer, Internal.Spliterator$OfLong> {
        forEachRemaining(arg0: any): void;
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        getComparator(): Internal.Comparator<any>;
        getExactSizeIfKnown(): number;
        hasCharacteristics(arg0: number): boolean;
        tryAdvance(arg0: Internal.LongConsumer_): boolean;
        tryAdvance(arg0: Internal.Consumer_<any>): boolean;
        tryAdvance(arg0: any): boolean;
        forEachRemaining(arg0: Internal.LongConsumer_): void;
        get comparator(): Internal.Comparator<any>
        get exactSizeIfKnown(): number
    }
    type Spliterator$OfLong_ = Spliterator$OfLong;
    class RegisterCommandsEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.CommandDispatcher_<Internal.CommandSourceStack_>, arg1: Internal.Commands$CommandSelection_)
        getDispatcher(): Internal.CommandDispatcher<Internal.CommandSourceStack>;
        getListenerList(): Internal.ListenerList;
        getEnvironment(): Internal.Commands$CommandSelection;
        get dispatcher(): Internal.CommandDispatcher<Internal.CommandSourceStack>
        get listenerList(): Internal.ListenerList
        get environment(): Internal.Commands$CommandSelection
    }
    type RegisterCommandsEvent_ = RegisterCommandsEvent;
    class ZoneOffsetTransitionRule implements Internal.Serializable {
        getLocalTime(): Internal.LocalTime;
        getMonth(): Internal.Month;
        toString(): string;
        getOffsetAfter(): Internal.ZoneOffset;
        isMidnightEndOfDay(): boolean;
        getDayOfWeek(): Internal.DayOfWeek;
        createTransition(arg0: number): Internal.ZoneOffsetTransition;
        getStandardOffset(): Internal.ZoneOffset;
        getDayOfMonthIndicator(): number;
        hashCode(): number;
        getOffsetBefore(): Internal.ZoneOffset;
        static of(arg0: Internal.Month_, arg1: number, arg2: Internal.DayOfWeek_, arg3: Internal.LocalTime_, arg4: boolean, arg5: Internal.ZoneOffsetTransitionRule$TimeDefinition_, arg6: Internal.ZoneOffset_, arg7: Internal.ZoneOffset_, arg8: Internal.ZoneOffset_): Internal.ZoneOffsetTransitionRule;
        equals(arg0: any): boolean;
        getTimeDefinition(): Internal.ZoneOffsetTransitionRule$TimeDefinition;
        get localTime(): Internal.LocalTime
        get month(): Internal.Month
        get offsetAfter(): Internal.ZoneOffset
        get midnightEndOfDay(): boolean
        get dayOfWeek(): Internal.DayOfWeek
        get standardOffset(): Internal.ZoneOffset
        get dayOfMonthIndicator(): number
        get offsetBefore(): Internal.ZoneOffset
        get timeDefinition(): Internal.ZoneOffsetTransitionRule$TimeDefinition
    }
    type ZoneOffsetTransitionRule_ = ZoneOffsetTransitionRule;
    class ContinuationPending extends Internal.RuntimeException {
        setApplicationState(applicationState: any): void;
        getApplicationState(): any;
        setContinuation(continuation: Internal.NativeContinuation_): void;
        getContinuation(): any;
        set applicationState(applicationState: any)
        get applicationState(): any
        set continuation(continuation: Internal.NativeContinuation_)
        get continuation(): any
    }
    type ContinuationPending_ = ContinuationPending;
    class OreConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.RuleTest_, arg1: Internal.BlockState_, arg2: number, arg3: number)
        constructor(arg0: Internal.RuleTest_, arg1: Internal.BlockState_, arg2: number)
        constructor(arg0: Internal.List_<Internal.OreConfiguration$TargetBlockState_>, arg1: number, arg2: number)
        constructor(arg0: Internal.List_<Internal.OreConfiguration$TargetBlockState_>, arg1: number)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        static target(arg0: Internal.RuleTest_, arg1: Internal.BlockState_): Internal.OreConfiguration$TargetBlockState;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "discardChanceOnAirExposure": number;
        readonly "targetStates": Internal.List<Internal.OreConfiguration$TargetBlockState>;
        readonly static "CODEC": any;
        readonly "size": number;
    }
    type OreConfiguration_ = OreConfiguration;
    class AmbientMoodSettings {
        constructor(arg0: Internal.SoundEvent_, arg1: number, arg2: number, arg3: number)
        getTickDelay(): number;
        getBlockSearchExtent(): number;
        getSoundEvent(): Internal.SoundEvent;
        getSoundPositionOffset(): number;
        get tickDelay(): number
        get blockSearchExtent(): number
        get soundEvent(): Internal.SoundEvent
        get soundPositionOffset(): number
        readonly static "CODEC": any;
        readonly static "LEGACY_CAVE_SETTINGS": Internal.AmbientMoodSettings;
    }
    type AmbientMoodSettings_ = AmbientMoodSettings;
    class SerializationContext {
        constructor()
        serializeConditions(arg0: Internal.LootItemCondition_[]): Internal.JsonElement;
        readonly static "INSTANCE": Internal.SerializationContext;
    }
    type SerializationContext_ = SerializationContext;
    class LevelVersion {
        snapshot(): boolean;
        static parse(arg0: Internal.Dynamic_<any>): Internal.LevelVersion;
        levelDataVersion(): number;
        lastPlayed(): number;
        minecraftVersionName(): string;
        minecraftVersion(): Internal.DataVersion;
    }
    type LevelVersion_ = LevelVersion;
    class ThrownEnderpearl extends Internal.ThrowableItemProjectile {
        constructor(arg0: Internal.Level_, arg1: Internal.LivingEntity_)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        tick(): void;
        asKJS(): Internal.EntityJS;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type ThrownEnderpearl_ = ThrownEnderpearl;
    class BlockIgnoreProcessor extends Internal.StructureProcessor {
        constructor(arg0: Internal.List_<Internal.Block_>)
        processBlock(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.StructureTemplate$StructureBlockInfo_, arg4: Internal.StructureTemplate$StructureBlockInfo_, arg5: Internal.StructurePlaceSettings_): Internal.StructureTemplate$StructureBlockInfo;
        readonly static "AIR": Internal.BlockIgnoreProcessor;
        readonly static "STRUCTURE_BLOCK": Internal.BlockIgnoreProcessor;
        readonly static "CODEC": any;
        readonly static "STRUCTURE_AND_AIR": Internal.BlockIgnoreProcessor;
    }
    type BlockIgnoreProcessor_ = BlockIgnoreProcessor;
    class ServerboundKeepAlivePacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getId(): number;
        isSkippable(): boolean;
        get id(): number
        get skippable(): boolean
    }
    type ServerboundKeepAlivePacket_ = ServerboundKeepAlivePacket;
    class MapDecoration {
        constructor(arg0: Internal.MapDecoration$Type_, arg1: number, arg2: number, arg3: number, arg4: Internal.Component_)
        getX(): number;
        getRot(): number;
        hashCode(): number;
        getName(): Internal.Component;
        renderOnFrame(): boolean;
        getImage(): number;
        equals(arg0: any): boolean;
        getType(): Internal.MapDecoration$Type;
        render(arg0: number): boolean;
        getY(): number;
        get x(): number
        get rot(): number
        get name(): Internal.Component
        get image(): number
        get type(): Internal.MapDecoration$Type
        get y(): number
    }
    type MapDecoration_ = MapDecoration;
    class DimensionDataStorage {
        constructor(arg0: Internal.File_, arg1: Internal.DataFixer_)
        computeIfAbsent(arg0: Internal.Function_<Internal.CompoundTag_, T>, arg1: Internal.Supplier_<T>, arg2: string): T;
        get(arg0: Internal.Function_<Internal.CompoundTag_, T>, arg1: string): T;
        set(arg0: string, arg1: Internal.SavedData_): void;
        readTagFromDisk(arg0: string, arg1: number): Internal.CompoundTag;
        save(): void;
    }
    type DimensionDataStorage_ = DimensionDataStorage;
    interface Int2LongFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntToLongFunction {
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2LongFunction;
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: number, arg1: number): number;
        containsKey(arg0: number): boolean;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Int2FloatFunction;
        composeInt(arg0: Internal.Int2IntFunction_): this;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Int2DoubleFunction;
        apply(arg0: number): number;
        get(arg0: any): number;
        containsKey(arg0: any): boolean;
        andThenLong(arg0: Internal.Long2LongFunction_): this;
        composeReference(arg0: Internal.Reference2IntFunction_<any>): Internal.Reference2LongFunction<T>;
        put(arg0: any, arg1: any): any;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Int2ShortFunction;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2LongFunction;
        remove(arg0: number): number;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2LongFunction;
        defaultReturnValue(): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Int2CharFunction;
        put(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Int2IntFunction;
        composeObject(arg0: Internal.Object2IntFunction_<any>): Internal.Object2LongFunction<T>;
        andThenObject(arg0: Internal.Long2ObjectFunction_<any>): Internal.Int2ObjectFunction<T>;
        put(arg0: number, arg1: number): number;
        size(): number;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2LongFunction;
        andThenReference(arg0: Internal.Long2ReferenceFunction_<any>): Internal.Int2ReferenceFunction<T>;
        clear(): void;
        applyAsLong(arg0: number): number;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2LongFunction;
        remove(arg0: any): any;
        get(arg0: number): number;
        defaultReturnValue(arg0: number): void;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Int2ByteFunction;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2LongFunction;
    }
    type Int2LongFunction_ = Int2LongFunction | ((arg0: number)=>number);
    interface IWeatherParticleRenderHandler {
        render(arg0: number, arg1: Internal.ClientLevel_, arg2: Internal.Minecraft_, arg3: Internal.Camera_): void;
    }
    type IWeatherParticleRenderHandler_ = IWeatherParticleRenderHandler | ((arg0: number, arg1: Internal.ClientLevel, arg2: Internal.Minecraft, arg3: Internal.Camera)=>void);
    class DynamicCommandExceptionType implements Internal.CommandExceptionType {
        constructor(arg0: Internal.Function_<any, Internal.Message_>)
        createWithContext(arg0: Internal.ImmutableStringReader_, arg1: any): Internal.CommandSyntaxException;
        create(arg0: any): Internal.CommandSyntaxException;
    }
    type DynamicCommandExceptionType_ = DynamicCommandExceptionType;
    abstract class ClientboundMoveEntityPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        handle(arg0: Internal.PacketListener_): void;
        static entityToPacket(arg0: number): number;
        getxRot(): number;
        toString(): string;
        getyRot(): number;
        static packetToEntity(arg0: number, arg1: number, arg2: number): Vec3;
        getEntity(arg0: Internal.Level_): Internal.Entity;
        isSkippable(): boolean;
        hasPosition(): boolean;
        getXa(): number;
        updateEntityPosition(arg0: Vec3_): Vec3;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getZa(): number;
        static packetToEntity(arg0: number): number;
        getYa(): number;
        hasRotation(): boolean;
        isOnGround(): boolean;
        get xRot(): number
        get yRot(): number
        get skippable(): boolean
        get xa(): number
        get za(): number
        get ya(): number
        get onGround(): boolean
    }
    type ClientboundMoveEntityPacket_ = ClientboundMoveEntityPacket;
    interface BlockStateKJS {
        setRequiresToolKJS(arg0: boolean): void;
        setMaterialKJS(arg0: Internal.Material_): void;
        setDestroySpeedKJS(arg0: number): void;
        setLightEmissionKJS(arg0: number): void;
        set requiresToolKJS(arg0: boolean)
        set materialKJS(arg0: Internal.Material_)
        set destroySpeedKJS(arg0: number)
        set lightEmissionKJS(arg0: number)
    }
    type BlockStateKJS_ = BlockStateKJS;
    class Heightmap$Types extends Internal.Enum<Internal.Heightmap$Types> implements Internal.StringRepresentable {
        static values(): Internal.Heightmap$Types[];
        isOpaque(): Internal.Predicate<Internal.BlockState>;
        keepAfterWorldgen(): boolean;
        getSerializedName(): string;
        getSerializationKey(): string;
        static valueOf(arg0: string): Internal.Heightmap$Types;
        static getFromKey(arg0: string): Internal.Heightmap$Types;
        sendToClient(): boolean;
        get serializedName(): string
        get serializationKey(): string
        readonly static "OCEAN_FLOOR": Internal.Heightmap$Types;
        readonly static "MOTION_BLOCKING_NO_LEAVES": Internal.Heightmap$Types;
        readonly static "CODEC": any;
        readonly static "MOTION_BLOCKING": Internal.Heightmap$Types;
        readonly static "WORLD_SURFACE": Internal.Heightmap$Types;
        readonly static "WORLD_SURFACE_WG": Internal.Heightmap$Types;
        readonly static "OCEAN_FLOOR_WG": Internal.Heightmap$Types;
    }
    type Heightmap$Types_ = "motion_blocking_no_leaves" | "ocean_floor" | "motion_blocking" | "world_surface" | Heightmap$Types | "world_surface_wg" | "ocean_floor_wg";
    interface ServerFunctionManager$TraceCallbacks {
        onCommand(arg0: number, arg1: string): void;
        onReturn(arg0: number, arg1: string, arg2: number): void;
        onCall(arg0: number, arg1: ResourceLocation_, arg2: number): void;
        onError(arg0: number, arg1: string): void;
    }
    type ServerFunctionManager$TraceCallbacks_ = ServerFunctionManager$TraceCallbacks;
    class LevelChunk extends Internal.ChunkAccess implements Internal.ICapabilityProviderImpl<Internal.LevelChunk> {
        constructor(arg0: Internal.Level_, arg1: Internal.ChunkPos_)
        constructor(arg0: Internal.ServerLevel_, arg1: Internal.ProtoChunk_, arg2: any_)
        constructor(arg0: Internal.Level_, arg1: Internal.ChunkPos_, arg2: Internal.UpgradeData_, arg3: Internal.LevelChunkTicks_<Internal.Block_>, arg4: Internal.LevelChunkTicks_<Internal.Fluid_>, arg5: number, arg6: Internal.LevelChunkSection_[], arg7: any_, arg8: Internal.BlendingData_)
        clearAllBlockEntities(): void;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.LevelChunk_>): boolean;
        getMinSection(): number;
        getBlockState(arg0: BlockPos_): Internal.BlockState;
        setClientLightReady(arg0: boolean): void;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        getMaxSection(): number;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        setLoaded(arg0: boolean): void;
        getSectionYFromSectionIndex(arg0: number): number;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        registerAllBlockEntitiesAfterLevelLoad(): void;
        setBlockEntity(arg0: Internal.BlockEntity_): void;
        getFluidState(arg0: number, arg1: number, arg2: number): Internal.FluidState;
        invalidateCaps(): void;
        getEventDispatcher(arg0: number): Internal.GameEventDispatcher;
        addAndRegisterBlockEntity(arg0: Internal.BlockEntity_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        setBlockState(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: boolean): Internal.BlockState;
        setFullStatus(arg0: Internal.Supplier_<Internal.ChunkHolder$FullChunkStatus_>): void;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getBlockEntityNbtForSaving(arg0: BlockPos_): Internal.CompoundTag;
        removeBlockEntity(arg0: BlockPos_): void;
        replaceWithPacketData(arg0: Internal.FriendlyByteBuf_, arg1: Internal.CompoundTag_, arg2: Internal.Consumer_<Internal.ClientboundLevelChunkPacketData$BlockEntityTagOutput_>): void;
        unregisterTickContainerFromLevel(arg0: Internal.ServerLevel_): void;
        getSectionsCount(): number;
        getSectionIndexFromSectionY(arg0: number): number;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        getCapability(arg0: Internal.Capability_<T>, arg1: Internal.Direction_): Internal.LazyOptional<T>;
        getLights(): Internal.Stream<BlockPos>;
        getSectionIndex(arg0: number): number;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.LevelChunk$EntityCreationType_): Internal.BlockEntity;
        getTicksForSerialization(): Internal.ChunkAccess$TicksToSave;
        isEmpty(): boolean;
        getMaxBuildHeight(): number;
        getLevel(): Internal.Level;
        unpackTicks(arg0: number): void;
        getFluidTicks(): Internal.TickContainerAccess<Internal.Fluid>;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        runPostLoad(): void;
        postProcessGeneration(): void;
        getBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        readCapsFromNBT(arg0: Internal.CompoundTag_): void;
        isClientLightReady(): boolean;
        getBlockTicks(): Internal.TickContainerAccess<Internal.Block>;
        writeCapsToNBT(): Internal.CompoundTag;
        getWorldForge(): Internal.LevelAccessor;
        isOutsideBuildHeight(arg0: number): boolean;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getFluidState(arg0: BlockPos_): Internal.FluidState;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        registerTickContainerInLevel(arg0: Internal.ServerLevel_): void;
        addEntity(arg0: Internal.Entity_): void;
        getBlockEntities(): Internal.Map<BlockPos, Internal.BlockEntity>;
        getStatus(): Internal.ChunkStatus;
        getMaxLightLevel(): number;
        reviveCaps(): void;
        getFullStatus(): Internal.ChunkHolder$FullChunkStatus;
        get minSection(): number
        set clientLightReady(arg0: boolean)
        get maxSection(): number
        set loaded(arg0: boolean)
        set blockEntity(arg0: Internal.BlockEntity_)
        set fullStatus(arg0: Internal.Supplier_<Internal.ChunkHolder$FullChunkStatus_>)
        get sectionsCount(): number
        get lights(): Internal.Stream<BlockPos>
        get ticksForSerialization(): Internal.ChunkAccess$TicksToSave
        get empty(): boolean
        get maxBuildHeight(): number
        get level(): Internal.Level
        get fluidTicks(): Internal.TickContainerAccess<Internal.Fluid>
        get clientLightReady(): boolean
        get blockTicks(): Internal.TickContainerAccess<Internal.Block>
        get worldForge(): Internal.LevelAccessor
        get blockEntities(): Internal.Map<BlockPos, Internal.BlockEntity>
        get status(): Internal.ChunkStatus
        get maxLightLevel(): number
        get fullStatus(): Internal.ChunkHolder$FullChunkStatus
    }
    type LevelChunk_ = LevelChunk;
    class ClientGenerateAssetsEventJS extends Internal.EventJS {
        constructor(gen: Internal.AssetJsonGenerator_, langMap: Internal.Map_<string, string>)
        addMultipartBlockState(id: ResourceLocation_, consumer: Internal.Consumer_<Internal.MultipartBlockStateGenerator_>): void;
        add(location: ResourceLocation_, json: Internal.JsonElement_): void;
        getAllAssets(): Internal.Map<ResourceLocation, Internal.JsonElement>;
        addLang(key: string, value: string): void;
        addBlockState(id: ResourceLocation_, consumer: Internal.Consumer_<Internal.VariantBlockStateGenerator_>): void;
        addModel(type: string, id: ResourceLocation_, consumer: Internal.Consumer_<Internal.ModelGenerator_>): void;
        get allAssets(): Internal.Map<ResourceLocation, Internal.JsonElement>
        readonly "generator": Internal.AssetJsonGenerator;
    }
    type ClientGenerateAssetsEventJS_ = ClientGenerateAssetsEventJS;
    class Direction$Plane extends Internal.Enum<Internal.Direction$Plane> implements Internal.Predicate<Internal.Direction>, Internal.Iterable<Internal.Direction> {
        stream(): Internal.Stream<Internal.Direction>;
        spliterator(): Internal.Spliterator<Internal.Direction>;
        getRandomDirection(arg0: Internal.Random_): Internal.Direction;
        forEach(arg0: Internal.Consumer_<any>): void;
        static values(): Internal.Direction$Plane[];
        iterator(): Internal.Iterator<Internal.Direction>;
        test(arg0: any): boolean;
        or(arg0: Internal.Predicate_<any>): Internal.Predicate<Internal.Direction>;
        and(arg0: Internal.Predicate_<any>): Internal.Predicate<Internal.Direction>;
        getRandomAxis(arg0: Internal.Random_): Internal.Direction$Axis;
        test(arg0: Internal.Direction_): boolean;
        static valueOf(arg0: string): Internal.Direction$Plane;
        negate(): Internal.Predicate<Internal.Direction>;
        readonly static "HORIZONTAL": Internal.Direction$Plane;
        readonly static "VERTICAL": Internal.Direction$Plane;
    }
    type Direction$Plane_ = Direction$Plane | "vertical" | "horizontal";
    class User$Type extends Internal.Enum<Internal.User$Type> {
        getName(): string;
        static valueOf(arg0: string): Internal.User$Type;
        static byName(arg0: string): Internal.User$Type;
        static values(): Internal.User$Type[];
        get name(): string
        readonly static "LEGACY": Internal.User$Type;
        readonly static "MSA": Internal.User$Type;
        readonly static "MOJANG": Internal.User$Type;
    }
    type User$Type_ = User$Type | "mojang" | "msa" | "legacy";
    class EnchantmentTableBlockEntity extends Internal.BlockEntity implements Internal.Nameable {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        getDisplayName(): Internal.Component;
        getName(): Internal.Component;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        static bookAnimationTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.EnchantmentTableBlockEntity_): void;
        setCustomName(arg0: Internal.Component_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        load(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        getCustomName(): Internal.Component;
        get displayName(): Internal.Component
        get name(): Internal.Component
        get modelData(): Internal.IModelData
        set customName(arg0: Internal.Component_)
        get renderBoundingBox(): Internal.AABB
        get customName(): Internal.Component
        "rot": number;
        "tRot": number;
        "open": number;
        "flipT": number;
        "oOpen": number;
        "time": number;
        "oFlip": number;
        "oRot": number;
        "flipA": number;
        "flip": number;
    }
    type EnchantmentTableBlockEntity_ = EnchantmentTableBlockEntity;
    interface UserPrincipal extends Internal.Principal {
        implies(arg0: Internal.Subject_): boolean;
    }
    type UserPrincipal_ = UserPrincipal;
    class Gui extends Internal.GuiComponent {
        constructor(arg0: Internal.Minecraft_)
        setTimes(arg0: number, arg1: number, arg2: number): void;
        getBossOverlay(): Internal.BossHealthOverlay;
        getSpectatorGui(): Internal.SpectatorGui;
        renderSelectedItemName(arg0: Internal.PoseStack_): void;
        renderJumpMeter(arg0: Internal.PoseStack_, arg1: number): void;
        renderDemoOverlay(arg0: Internal.PoseStack_): void;
        render(arg0: Internal.PoseStack_, arg1: number): void;
        handleChat(arg0: Internal.ChatType_, arg1: Internal.Component_, arg2: Internal.UUID_): void;
        getGuiTicks(): number;
        getFont(): Internal.Font;
        setNowPlaying(arg0: Internal.Component_): void;
        setSubtitle(arg0: Internal.Component_): void;
        renderExperienceBar(arg0: Internal.PoseStack_, arg1: number): void;
        setOverlayMessage(arg0: Internal.Component_, arg1: boolean): void;
        setTitle(arg0: Internal.Component_): void;
        onDisconnected(): void;
        clear(): void;
        tick(arg0: boolean): void;
        getChat(): Internal.ChatComponent;
        clearCache(): void;
        resetTitleTimes(): void;
        guessChatUUID(arg0: Internal.Component_): Internal.UUID;
        getTabList(): Internal.PlayerTabOverlay;
        get bossOverlay(): Internal.BossHealthOverlay
        get spectatorGui(): Internal.SpectatorGui
        get guiTicks(): number
        get font(): Internal.Font
        set nowPlaying(arg0: Internal.Component_)
        set subtitle(arg0: Internal.Component_)
        set title(arg0: Internal.Component_)
        get chat(): Internal.ChatComponent
        get tabList(): Internal.PlayerTabOverlay
        "vignetteBrightness": number;
    }
    type Gui_ = Gui;
    interface LevelSimulatedReader {
        getHeightmapPos(arg0: Internal.Heightmap$Types_, arg1: BlockPos_): BlockPos;
        isFluidAtPosition(arg0: BlockPos_, arg1: Internal.Predicate_<Internal.FluidState_>): boolean;
        isStateAtPosition(arg0: BlockPos_, arg1: Internal.Predicate_<Internal.BlockState_>): boolean;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
    }
    type LevelSimulatedReader_ = LevelSimulatedReader;
    class Turtle extends Internal.Animal {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getMobType(): Internal.MobType;
        thunderHit(arg0: Internal.ServerLevel_, arg1: Internal.LightningBolt_): void;
        travel(arg0: Vec3_): void;
        getStepHeight(): number;
        getScale(): number;
        asKJS(): Internal.EntityJS;
        canFallInLove(): boolean;
        isFood(arg0: Internal.ItemStack_): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        isPushedByFluid(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        hasEgg(): boolean;
        static checkTurtleSpawnRules(arg0: Internal.EntityType_<Internal.Turtle_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        isLayingEgg(): boolean;
        getAmbientSoundInterval(): number;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canBeLeashed(arg0: Internal.Player_): boolean;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        setHomePos(arg0: BlockPos_): void;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        getWalkTargetValue(arg0: BlockPos_, arg1: Internal.LevelReader_): number;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        canBreatheUnderwater(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get mobType(): Internal.MobType
        get stepHeight(): number
        get scale(): number
        get multipartEntity(): boolean
        get pushedByFluid(): boolean
        get parts(): Internal.PartEntity<any>[]
        get layingEgg(): boolean
        get ambientSoundInterval(): number
        set homePos(arg0: BlockPos_)
        readonly static "BABY_ON_LAND_SELECTOR": any;
        readonly static "FOOD_ITEMS": Internal.Ingredient;
    }
    type Turtle_ = Turtle;
    interface SerializableTickContainer <T> {
        save(arg0: number, arg1: Internal.Function_<T, string>): Internal.Tag;
    }
    type SerializableTickContainer_<T> = SerializableTickContainer<T>;
    class LargeFireball extends Internal.Fireball {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        constructor(arg0: Internal.Level_, arg1: Internal.LivingEntity_, arg2: number, arg3: number, arg4: number, arg5: number)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type LargeFireball_ = LargeFireball;
    abstract class AbstractIntSet extends Internal.AbstractIntCollection implements Internal.Cloneable, Internal.IntSet {
        stream(): Internal.Stream<number>;
        iterator(): Internal.IntIterator;
        removeIf(arg0: Internal.IntPredicate_): boolean;
        remove(arg0: number): boolean;
        forEach(arg0: Internal.Consumer_<any>): void;
        add(arg0: number): boolean;
        parallelStream(): Internal.Stream<number>;
        remove(arg0: any): boolean;
        forEach(arg0: Internal.IntConsumer_): void;
        intSpliterator(): Internal.IntSpliterator;
        add(arg0: any): boolean;
        hashCode(): number;
        intStream(): Internal.IntStream;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        rem(arg0: number): boolean;
        intParallelStream(): Internal.IntStream;
        spliterator(): Internal.IntSpliterator;
        equals(arg0: any): boolean;
        intIterator(): Internal.IntIterator;
        contains(arg0: any): boolean;
    }
    type AbstractIntSet_ = AbstractIntSet;
    class SoundRegistryEventJS extends Internal.StartupEventJS {
        constructor(registry: Internal.Consumer_<ResourceLocation_>)
        register(r: ResourceLocation_): void;
    }
    type SoundRegistryEventJS_ = SoundRegistryEventJS;
    class EntityEvent$EntityConstructing extends Internal.EntityEvent {
        constructor()
        constructor(arg0: Internal.Entity_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type EntityEvent$EntityConstructing_ = EntityEvent$EntityConstructing;
    class LanguageManager implements Internal.ResourceManagerReloadListener {
        constructor(arg0: string)
        getLanguage(arg0: string): Internal.LanguageInfo;
        getLanguages(): Internal.SortedSet<Internal.LanguageInfo>;
        getName(): string;
        onResourceManagerReload(arg0: Internal.ResourceManager_): void;
        getSelected(): Internal.LanguageInfo;
        setSelected(arg0: Internal.LanguageInfo_): void;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        get languages(): Internal.SortedSet<Internal.LanguageInfo>
        get name(): string
        get selected(): Internal.LanguageInfo
        set selected(arg0: Internal.LanguageInfo_)
        readonly static "DEFAULT_LANGUAGE_CODE": "en_us";
    }
    type LanguageManager_ = LanguageManager;
    interface ShortList extends Internal.ShortCollection, Internal.Comparable<Internal.List<any>>, Internal.List<number> {
        sort(arg0: Internal.ShortComparator_): void;
        addAll(arg0: number, arg1: Internal.ShortCollection_): boolean;
        forEach(arg0: Internal.ShortConsumer_): void;
        add(arg0: number, arg1: any): void;
        intStream(): Internal.IntStream;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        stream(): Internal.Stream<number>;
        intParallelStream(): Internal.IntStream;
        replaceAll(arg0: Internal.ShortUnaryOperator_): void;
        intIterator(): Internal.IntIterator;
        listIterator(): Internal.ListIterator<any>;
        set(arg0: number, arg1: number): number;
        add(arg0: number, arg1: number): void;
        size(arg0: number): void;
        removeIf(arg0: Internal.IntPredicate_): boolean;
        of(arg0: number, arg1: number, arg2: number): this;
        addAll(arg0: number, arg1: Internal.ShortList_): boolean;
        indexOf(arg0: any): number;
        spliterator(): Internal.ShortSpliterator;
        removeShort(arg0: number): number;
        of(arg0: number): this;
        remove(arg0: any): boolean;
        sort(arg0: Internal.Comparator_<any>): void;
        getElements(arg0: number, arg1: number[], arg2: number, arg3: number): void;
        unstableSort(arg0: Internal.ShortComparator_): void;
        add(arg0: any): boolean;
        addElements(arg0: number, arg1: number[], arg2: number, arg3: number): void;
        addAll(arg0: Internal.ShortList_): boolean;
        indexOf(arg0: number): number;
        iterator(): Internal.ShortListIterator;
        addElements(arg0: number, arg1: number[]): void;
        unstableSort(arg0: Internal.Comparator_<any>): void;
        set(arg0: number, arg1: any): any;
        lastIndexOf(arg0: any): number;
        removeElements(arg0: number, arg1: number): void;
        add(arg0: number): boolean;
        remove(arg0: number): any;
        setElements(arg0: number, arg1: number[]): void;
        forEach(arg0: Internal.Consumer_<any>): void;
        forEach(arg0: Internal.IntConsumer_): void;
        getShort(arg0: number): number;
        setElements(arg0: number[]): void;
        listIterator(arg0: number): Internal.ListIterator<any>;
        lastIndexOf(arg0: number): number;
        add(arg0: number): boolean;
        add(arg0: number, arg1: number): void;
        of(arg0: number, arg1: number): this;
        contains(arg0: any): boolean;
        replaceAll(arg0: Internal.UnaryOperator_<number>): void;
        parallelStream(): Internal.Stream<number>;
        of(...arg0: number[]): this;
        removeIf(arg0: Internal.ShortPredicate_): boolean;
        replaceAll(arg0: Internal.IntUnaryOperator_): void;
        intSpliterator(): Internal.IntSpliterator;
        subList(arg0: number, arg1: number): Internal.List<any>;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        toShortArray(arg0: number[]): number[];
        of(): this;
        get(arg0: number): number;
        setElements(arg0: number, arg1: number[], arg2: number, arg3: number): void;
        set(arg0: number, arg1: number): number;
        set elements(arg0: number[])
    }
    type ShortList_ = ShortList;
    class GiantTrunkPlacer extends Internal.TrunkPlacer {
        constructor(arg0: number, arg1: number, arg2: number)
        placeTrunk(arg0: Internal.LevelSimulatedReader_, arg1: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>, arg2: Internal.Random_, arg3: number, arg4: BlockPos_, arg5: Internal.TreeConfiguration_): Internal.List<Internal.FoliagePlacer$FoliageAttachment>;
        readonly static "CODEC": any;
    }
    type GiantTrunkPlacer_ = GiantTrunkPlacer;
    interface IForgeAbstractMinecart {
        setCanUseRail(arg0: boolean): void;
        isPoweredCart(): boolean;
        setMaxSpeedAirLateral(arg0: number): void;
        getCurrentRailPosition(): BlockPos;
        getMaxCartSpeedOnRail(): number;
        getDragAir(): number;
        getMaxSpeedAirLateral(): number;
        setCurrentCartSpeedCapOnRail(arg0: number): void;
        getCartItem(): Internal.ItemStack;
        getCurrentCartSpeedCapOnRail(): number;
        setDragAir(arg0: number): void;
        getSlopeAdjustment(): number;
        setMaxSpeedAirVertical(arg0: number): void;
        shouldDoRailFunctions(): boolean;
        moveMinecartOnRail(arg0: BlockPos_): void;
        getMaxSpeedAirVertical(): number;
        canBeRidden(): boolean;
        getComparatorLevel(): number;
        getMaxSpeedWithRail(): number;
        canUseRail(): boolean;
        set canUseRail(arg0: boolean)
        get poweredCart(): boolean
        set maxSpeedAirLateral(arg0: number)
        get currentRailPosition(): BlockPos
        get maxCartSpeedOnRail(): number
        get dragAir(): number
        get maxSpeedAirLateral(): number
        set currentCartSpeedCapOnRail(arg0: number)
        get cartItem(): Internal.ItemStack
        get currentCartSpeedCapOnRail(): number
        set dragAir(arg0: number)
        get slopeAdjustment(): number
        set maxSpeedAirVertical(arg0: number)
        get maxSpeedAirVertical(): number
        get comparatorLevel(): number
        get maxSpeedWithRail(): number
        readonly static "DEFAULT_MAX_SPEED_AIR_VERTICAL": -1.0;
        readonly static "DEFAULT_MAX_SPEED_AIR_LATERAL": 0.4;
        readonly static "DEFAULT_AIR_DRAG": 0.949999988079071;
    }
    type IForgeAbstractMinecart_ = IForgeAbstractMinecart;
    class PlayerAdvancementEventJS extends Internal.PlayerEventJS {
        constructor(player: Internal.ServerPlayer_, advancement: Internal.Advancement_)
        getAdvancement(): Internal.AdvancementJS;
        getEntity(): Internal.EntityJS;
        canCancel(): boolean;
        get advancement(): Internal.AdvancementJS
        get entity(): Internal.EntityJS
    }
    type PlayerAdvancementEventJS_ = PlayerAdvancementEventJS;
    class Collector$Characteristics extends Internal.Enum<Internal.Collector$Characteristics> {
        static values(): Internal.Collector$Characteristics[];
        static valueOf(arg0: string): Internal.Collector$Characteristics;
        readonly static "CONCURRENT": Internal.Collector$Characteristics;
        readonly static "IDENTITY_FINISH": Internal.Collector$Characteristics;
        readonly static "UNORDERED": Internal.Collector$Characteristics;
    }
    type Collector$Characteristics_ = Collector$Characteristics | "identity_finish" | "unordered" | "concurrent";
    interface IForgeShearable {
        isShearable(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: BlockPos_): boolean;
        onSheared(arg0: Internal.Player_, arg1: Internal.ItemStack_, arg2: Internal.Level_, arg3: BlockPos_, arg4: number): Internal.List<Internal.ItemStack>;
    }
    type IForgeShearable_ = IForgeShearable;
    class Provider$Service {
        constructor(arg0: Internal.Provider_, arg1: string, arg2: string, arg3: string, arg4: Internal.List_<string>, arg5: Internal.Map_<string, string>)
        getAlgorithm(): string;
        newInstance(arg0: any): any;
        getAttribute(arg0: string): string;
        toString(): string;
        getType(): string;
        getClassName(): string;
        supportsParameter(arg0: any): boolean;
        getProvider(): Internal.Provider;
        get algorithm(): string
        get type(): string
        get className(): string
        get provider(): Internal.Provider
    }
    type Provider$Service_ = Provider$Service;
    class JsonNull extends Internal.JsonElement {
        constructor()
        hashCode(): number;
        deepCopy(): this;
        equals(arg0: any): boolean;
        readonly static "INSTANCE": Internal.JsonNull;
    }
    type JsonNull_ = JsonNull;
    class NoiseSettings extends Internal.Record {
        constructor(arg0: number, arg1: number, arg2: Internal.NoiseSamplingSettings_, arg3: Internal.NoiseSlider_, arg4: Internal.NoiseSlider_, arg5: number, arg6: number, arg7: Internal.TerrainShaper_)
        getCellHeight(): number;
        getCellCountY(): number;
        toString(): string;
        bottomSlideSettings(): Internal.NoiseSlider;
        noiseSizeVertical(): number;
        static create(arg0: number, arg1: number, arg2: Internal.NoiseSamplingSettings_, arg3: Internal.NoiseSlider_, arg4: Internal.NoiseSlider_, arg5: number, arg6: number, arg7: Internal.TerrainShaper_): Internal.NoiseSettings;
        height(): number;
        noiseSamplingSettings(): Internal.NoiseSamplingSettings;
        minY(): number;
        terrainShaper(): Internal.TerrainShaper;
        hashCode(): number;
        topSlideSettings(): Internal.NoiseSlider;
        noiseSizeHorizontal(): number;
        getCellWidth(): number;
        equals(arg0: any): boolean;
        getMinCellY(): number;
        get cellHeight(): number
        get cellCountY(): number
        get cellWidth(): number
        get minCellY(): number
        readonly static "CODEC": any;
    }
    type NoiseSettings_ = NoiseSettings;
    class RepairItemRecipe extends Internal.CustomRecipe {
        constructor(arg0: ResourceLocation_)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        getSerializer(): Internal.RecipeSerializer<any>;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        matches(arg0: Internal.CraftingContainer_, arg1: Internal.Level_): boolean;
        isIncomplete(): boolean;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        assemble(arg0: Internal.CraftingContainer_): Internal.ItemStack;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get serializer(): Internal.RecipeSerializer<any>
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get incomplete(): boolean
    }
    type RepairItemRecipe_ = RepairItemRecipe;
    interface AudioStream extends Internal.Closeable {
        read(arg0: number): Internal.ByteBuffer;
        getFormat(): Internal.AudioFormat;
        get format(): Internal.AudioFormat
    }
    type AudioStream_ = AudioStream;
    class LevelResource {
        constructor(arg0: string)
        toString(): string;
        getId(): string;
        get id(): string
        readonly static "PLAYER_OLD_DATA_DIR": Internal.LevelResource;
        readonly static "PLAYER_STATS_DIR": Internal.LevelResource;
        readonly static "ROOT": Internal.LevelResource;
        readonly static "MAP_RESOURCE_FILE": Internal.LevelResource;
        readonly static "GENERATED_DIR": Internal.LevelResource;
        readonly static "LEVEL_DATA_FILE": Internal.LevelResource;
        readonly static "PLAYER_ADVANCEMENTS_DIR": Internal.LevelResource;
        readonly static "PLAYER_DATA_DIR": Internal.LevelResource;
        readonly static "DATAPACK_DIR": Internal.LevelResource;
    }
    type LevelResource_ = LevelResource;
    class ClientChunkCache extends Internal.ChunkSource {
        constructor(arg0: Internal.ClientLevel_, arg1: number)
        gatherStats(): string;
        getLoadedChunksCount(): number;
        getLevel(): Internal.BlockGetter;
        updateViewCenter(arg0: number, arg1: number): void;
        drop(arg0: number, arg1: number): void;
        tick(arg0: Internal.BooleanSupplier_, arg1: boolean): void;
        getChunk(arg0: number, arg1: number, arg2: Internal.ChunkStatus_, arg3: boolean): Internal.ChunkAccess;
        getLightEngine(): Internal.LevelLightEngine;
        onLightUpdate(arg0: Internal.LightLayer_, arg1: Internal.SectionPos_): void;
        replaceWithPacketData(arg0: number, arg1: number, arg2: Internal.FriendlyByteBuf_, arg3: Internal.CompoundTag_, arg4: Internal.Consumer_<Internal.ClientboundLevelChunkPacketData$BlockEntityTagOutput_>): Internal.LevelChunk;
        updateViewRadius(arg0: number): void;
        get loadedChunksCount(): number
        get level(): Internal.BlockGetter
        get lightEngine(): Internal.LevelLightEngine
    }
    type ClientChunkCache_ = ClientChunkCache;
    class Shulker extends Internal.AbstractGolem implements Internal.Enemy {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        push(arg0: Internal.Entity_): void;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        static getProgressAabb(arg0: Internal.Direction_, arg1: number): Internal.AABB;
        setPos(arg0: number, arg1: number, arg2: number): void;
        getPickRadius(): number;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        startRiding(arg0: Internal.Entity_, arg1: boolean): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        stopRiding(): void;
        getSoundSource(): Internal.SoundSource;
        isMultipartEntity(): boolean;
        getMaxHeadYRot(): number;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getDeltaMovement(): Vec3;
        getMaxHeadXRot(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getColor(): Internal.DyeColor;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMyRidingOffset(): number;
        getAttachFace(): Internal.Direction;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        lerpTo(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: boolean): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canBeCollidedWith(): boolean;
        move(arg0: Internal.MoverType_, arg1: Vec3_): void;
        playAmbientSound(): void;
        setDeltaMovement(arg0: Vec3_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        getClientPeekAmount(arg0: number): number;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        getRenderPosition(arg0: number): Internal.Optional<Vec3>;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        recreateFromPacket(arg0: Internal.ClientboundAddMobPacket_): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        static getProgressDeltaAabb(arg0: Internal.Direction_, arg1: number, arg2: number): Internal.AABB;
        get pickRadius(): number
        get stepHeight(): number
        get soundSource(): Internal.SoundSource
        get multipartEntity(): boolean
        get maxHeadYRot(): number
        get parts(): Internal.PartEntity<any>[]
        get deltaMovement(): Vec3
        get maxHeadXRot(): number
        get color(): Internal.DyeColor
        get myRidingOffset(): number
        get attachFace(): Internal.Direction
        set deltaMovement(arg0: Vec3_)
    }
    type Shulker_ = Shulker;
    class SpikeConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: boolean, arg1: Internal.List_<Internal.SpikeFeature$EndSpike_>, arg2: BlockPos_)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        getCrystalBeamTarget(): BlockPos;
        getSpikes(): Internal.List<Internal.SpikeFeature$EndSpike>;
        isCrystalInvulnerable(): boolean;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        get crystalBeamTarget(): BlockPos
        get spikes(): Internal.List<Internal.SpikeFeature$EndSpike>
        get crystalInvulnerable(): boolean
        readonly static "CODEC": any;
    }
    type SpikeConfiguration_ = SpikeConfiguration;
    class ThrownExperienceBottle extends Internal.ThrowableItemProjectile {
        constructor(arg0: Internal.Level_, arg1: Internal.LivingEntity_)
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type ThrownExperienceBottle_ = ThrownExperienceBottle;
    class ClientboundPlaceGhostRecipePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: Internal.Recipe_<any>)
        getRecipe(): ResourceLocation;
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getContainerId(): number;
        isSkippable(): boolean;
        get recipe(): ResourceLocation
        get containerId(): number
        get skippable(): boolean
    }
    type ClientboundPlaceGhostRecipePacket_ = ClientboundPlaceGhostRecipePacket;
    interface AdvancementList$Listener {
        onAddAdvancementRoot(arg0: Internal.Advancement_): void;
        onRemoveAdvancementRoot(arg0: Internal.Advancement_): void;
        onRemoveAdvancementTask(arg0: Internal.Advancement_): void;
        onAddAdvancementTask(arg0: Internal.Advancement_): void;
        onAdvancementsCleared(): void;
    }
    type AdvancementList$Listener_ = AdvancementList$Listener;
    class LivingExperienceDropEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.LivingEntity_, arg1: Internal.Player_, arg2: number)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        setDroppedExperience(arg0: number): void;
        getOriginalExperience(): number;
        getDroppedExperience(): number;
        getAttackingPlayer(): Internal.Player;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
        set droppedExperience(arg0: number)
        get originalExperience(): number
        get droppedExperience(): number
        get attackingPlayer(): Internal.Player
    }
    type LivingExperienceDropEvent_ = LivingExperienceDropEvent;
    interface Tickable {
        tick(): void;
    }
    type Tickable_ = Tickable;
    class ClientboundMoveVehiclePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.Entity_)
        handle(arg0: Internal.PacketListener_): void;
        getX(): number;
        getY(): number;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getZ(): number;
        getYRot(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getXRot(): number;
        isSkippable(): boolean;
        get x(): number
        get y(): number
        get z(): number
        get YRot(): number
        get XRot(): number
        get skippable(): boolean
    }
    type ClientboundMoveVehiclePacket_ = ClientboundMoveVehiclePacket;
    class CanyonCarverConfiguration$CanyonShapeConfiguration {
        constructor(arg0: Internal.FloatProvider_, arg1: Internal.FloatProvider_, arg2: number, arg3: Internal.FloatProvider_, arg4: number, arg5: number)
        readonly "verticalRadiusCenterFactor": number;
        readonly "verticalRadiusDefaultFactor": number;
        readonly "distanceFactor": Internal.FloatProvider;
        readonly "widthSmoothness": number;
        readonly static "CODEC": any;
        readonly "thickness": Internal.FloatProvider;
        readonly "horizontalRadiusFactor": Internal.FloatProvider;
    }
    type CanyonCarverConfiguration$CanyonShapeConfiguration_ = CanyonCarverConfiguration$CanyonShapeConfiguration;
    class ClientboundSetPassengersPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.Entity_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getPassengers(): number[];
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getVehicle(): number;
        isSkippable(): boolean;
        get passengers(): number[]
        get vehicle(): number
        get skippable(): boolean
    }
    type ClientboundSetPassengersPacket_ = ClientboundSetPassengersPacket;
    interface BlockColor {
        getColor(arg0: Internal.BlockState_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_, arg3: number): number;
    }
    type BlockColor_ = BlockColor;
    interface LevelEntityGetter <T> {
        get(arg0: number): T;
        get(arg0: Internal.AABB_, arg1: Internal.Consumer_<T>): void;
        get(arg0: Internal.EntityTypeTest_<T, U>, arg1: Internal.AABB_, arg2: Internal.Consumer_<U>): void;
        getAll(): Internal.Iterable<T>;
        get(arg0: Internal.EntityTypeTest_<T, U>, arg1: Internal.Consumer_<U>): void;
        get(arg0: Internal.UUID_): T;
        get all(): Internal.Iterable<T>
    }
    type LevelEntityGetter_<T> = LevelEntityGetter<T>;
    class Stat <T> extends Internal.ObjectiveCriteria {
        hashCode(): number;
        toString(): string;
        getValue(): T;
        getType(): Internal.StatType<T>;
        equals(arg0: any): boolean;
        static buildName(arg0: Internal.StatType_<T>, arg1: T): string;
        format(arg0: number): string;
        get value(): T
        get type(): Internal.StatType<T>
    }
    type Stat_<T> = Stat<T>;
    interface Byte2ObjectFunction <V> extends Internal.IntFunction<V>, it.unimi.dsi.fastutil.Function<number, V> {
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Byte2ShortFunction;
        getOrDefault(arg0: any, arg1: V): V;
        put(arg0: number, arg1: V): V;
        composeObject(arg0: Internal.Object2ByteFunction_<any>): Internal.Object2ObjectFunction<T, V>;
        andThenReference(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Byte2ReferenceFunction<T>;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Byte2ByteFunction;
        containsKey(arg0: any): boolean;
        andThenObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Byte2ObjectFunction<T>;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Byte2FloatFunction;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Byte2LongFunction;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2ObjectFunction<V>;
        get(arg0: any): V;
        put(arg0: any, arg1: any): any;
        get(arg0: number): V;
        apply(arg0: number): V;
        remove(arg0: any): V;
        containsKey(arg0: number): boolean;
        remove(arg0: number): V;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Byte2CharFunction;
        composeByte(arg0: Internal.Byte2ByteFunction_): this;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Byte2DoubleFunction;
        apply(arg0: number): V;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2ObjectFunction<V>;
        put(arg0: number, arg1: V): V;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2ObjectFunction<V>;
        size(): number;
        composeReference(arg0: Internal.Reference2ByteFunction_<any>): Internal.Reference2ObjectFunction<T, V>;
        getOrDefault(arg0: number, arg1: V): V;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
        clear(): void;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Byte2IntFunction;
        defaultReturnValue(): V;
        defaultReturnValue(arg0: V): void;
    }
    type Byte2ObjectFunction_<V> = ((arg0: number)=>V) | Byte2ObjectFunction<V>;
    interface ChunkProgressListener {
        start(): void;
        stop(): void;
        onStatusChange(arg0: Internal.ChunkPos_, arg1: Internal.ChunkStatus_): void;
        updateSpawnPos(arg0: Internal.ChunkPos_): void;
    }
    type ChunkProgressListener_ = ChunkProgressListener;
    class StructureCheckResult extends Internal.Enum<Internal.StructureCheckResult> {
        static values(): Internal.StructureCheckResult[];
        static valueOf(arg0: string): Internal.StructureCheckResult;
        readonly static "START_NOT_PRESENT": Internal.StructureCheckResult;
        readonly static "CHUNK_LOAD_NEEDED": Internal.StructureCheckResult;
        readonly static "START_PRESENT": Internal.StructureCheckResult;
    }
    type StructureCheckResult_ = "start_present" | "chunk_load_needed" | StructureCheckResult | "start_not_present";
    interface IModelData {
        hasProperty(arg0: Internal.ModelProperty_<any>): boolean;
        setData(arg0: Internal.ModelProperty_<T>, arg1: T): T;
        getData(arg0: Internal.ModelProperty_<T>): T;
    }
    type IModelData_ = IModelData;
    class ServerboundClientCommandPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.ServerboundClientCommandPacket$Action_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getAction(): Internal.ServerboundClientCommandPacket$Action;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        isSkippable(): boolean;
        get action(): Internal.ServerboundClientCommandPacket$Action
        get skippable(): boolean
    }
    type ServerboundClientCommandPacket_ = ServerboundClientCommandPacket;
    interface Era extends Internal.TemporalAccessor, Internal.TemporalAdjuster {
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        get(arg0: Internal.TemporalField_): number;
        getLong(arg0: Internal.TemporalField_): number;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        getValue(): number;
        query(arg0: Internal.TemporalQuery_<R>): R;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        isSupported(arg0: Internal.TemporalField_): boolean;
        get value(): number
    }
    type Era_ = Era | (()=>number);
    class ClientboundSetDefaultSpawnPositionPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: BlockPos_, arg1: number)
        handle(arg0: Internal.PacketListener_): void;
        getPos(): BlockPos;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getAngle(): number;
        isSkippable(): boolean;
        get pos(): BlockPos
        get angle(): number
        get skippable(): boolean
    }
    type ClientboundSetDefaultSpawnPositionPacket_ = ClientboundSetDefaultSpawnPositionPacket;
    interface Key extends Internal.Serializable {
        getAlgorithm(): string;
        getFormat(): string;
        getEncoded(): number[];
        get algorithm(): string
        get format(): string
        get encoded(): number[]
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "serialVersionUID": 6603384152749567654;
    }
    type Key_ = Key;
    abstract class ForwardingSet <E> extends Internal.ForwardingCollection<E> implements Internal.Set<E> {
        hashCode(): number;
        stream(): Internal.Stream<E>;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<E>;
        parallelStream(): Internal.Stream<E>;
        equals(arg0: any): boolean;
    }
    type ForwardingSet_<E> = ForwardingSet<E>;
    interface Palette <T> {
        read(arg0: Internal.FriendlyByteBuf_): void;
        maybeHas(arg0: Internal.Predicate_<T>): boolean;
        write(arg0: Internal.FriendlyByteBuf_): void;
        valueFor(arg0: number): T;
        getSerializedSize(): number;
        getSize(): number;
        idFor(arg0: T): number;
        copy(): this;
        get serializedSize(): number
        get size(): number
    }
    type Palette_<T> = Palette<T>;
    class PlayerStatsJS {
        constructor(p: Internal.PlayerJS_<any>, s: Internal.StatsCounter_)
        getDeaths(): number;
        getAnimalsBred(): number;
        getPlayerKills(): number;
        getTimeSinceRest(): number;
        getWalkDistance(): number;
        getDamageDealt(): number;
        getItemsDropped(item: Internal.Item_): number;
        getSprintDistance(): number;
        getBlocksMined(block: Internal.Block_): number;
        set(id: ResourceLocation_, value: number): void;
        getPlayTime(): number;
        getMobKills(): number;
        add(id: ResourceLocation_, value: number): void;
        getCrouchDistance(): number;
        getTimeCrouchTime(): number;
        getPlayer(): Internal.PlayerJS<any>;
        getJumps(): number;
        getItemsCrafted(item: Internal.Item_): number;
        get(id: ResourceLocation_): number;
        getTimeSinceDeath(): number;
        getDamageAbsorbed(): number;
        getItemsUsed(item: Internal.Item_): number;
        getItemsPickedUp(item: Internal.Item_): number;
        getSwimDistance(): number;
        getDamageBlocked_by_shield(): number;
        getDamageResisted(): number;
        getItemsBroken(item: Internal.Item_): number;
        getFishCaught(): number;
        getDamageTaken(): number;
        getDamageDealt_resisted(): number;
        getKilled(entity: Internal.EntityType_<any>): number;
        getDamageDealt_absorbed(): number;
        getKilledBy(entity: Internal.EntityType_<any>): number;
        get deaths(): number
        get animalsBred(): number
        get playerKills(): number
        get timeSinceRest(): number
        get walkDistance(): number
        get damageDealt(): number
        get sprintDistance(): number
        get playTime(): number
        get mobKills(): number
        get crouchDistance(): number
        get timeCrouchTime(): number
        get player(): Internal.PlayerJS<any>
        get jumps(): number
        get timeSinceDeath(): number
        get damageAbsorbed(): number
        get swimDistance(): number
        get damageBlocked_by_shield(): number
        get damageResisted(): number
        get fishCaught(): number
        get damageTaken(): number
        get damageDealt_resisted(): number
        get damageDealt_absorbed(): number
    }
    type PlayerStatsJS_ = PlayerStatsJS;
    abstract class CollectionTag <T> extends Internal.AbstractList<T> implements Internal.Tag {
        constructor()
        remove(arg0: number): any;
        stream(): Internal.Stream<T>;
        forEach(arg0: Internal.Consumer_<any>): void;
        addTag(arg0: number, arg1: Internal.Tag_): boolean;
        spliterator(): Internal.Spliterator<T>;
        add(arg0: number, arg1: any): void;
        sort(arg0: Internal.Comparator_<any>): void;
        set(arg0: number, arg1: T): T;
        setTag(arg0: number, arg1: Internal.Tag_): boolean;
        getAsString(): string;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        replaceAll(arg0: Internal.UnaryOperator_<T>): void;
        add(arg0: number, arg1: T): void;
        parallelStream(): Internal.Stream<T>;
        set(arg0: number, arg1: any): any;
        getElementType(): number;
        get asString(): string
        get elementType(): number
    }
    type CollectionTag_<T> = CollectionTag<T>;
    class ServerboundSetStructureBlockPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: BlockPos_, arg1: Internal.StructureBlockEntity$UpdateType_, arg2: Internal.StructureMode_, arg3: string, arg4: BlockPos_, arg5: Vec3i_, arg6: Internal.Mirror_, arg7: Internal.Rotation_, arg8: string, arg9: boolean, arg10: boolean, arg11: boolean, arg12: number, arg13: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        isIgnoreEntities(): boolean;
        getData(): string;
        getSeed(): number;
        isSkippable(): boolean;
        getUpdateType(): Internal.StructureBlockEntity$UpdateType;
        getPos(): BlockPos;
        getSize(): Vec3i;
        isShowAir(): boolean;
        getRotation(): Internal.Rotation;
        isShowBoundingBox(): boolean;
        getMirror(): Internal.Mirror;
        getIntegrity(): number;
        getOffset(): BlockPos;
        getName(): string;
        getMode(): Internal.StructureMode;
        get ignoreEntities(): boolean
        get data(): string
        get seed(): number
        get skippable(): boolean
        get updateType(): Internal.StructureBlockEntity$UpdateType
        get pos(): BlockPos
        get size(): Vec3i
        get showAir(): boolean
        get rotation(): Internal.Rotation
        get showBoundingBox(): boolean
        get mirror(): Internal.Mirror
        get integrity(): number
        get offset(): BlockPos
        get name(): string
        get mode(): Internal.StructureMode
    }
    type ServerboundSetStructureBlockPacket_ = ServerboundSetStructureBlockPacket;
    interface Object2BooleanFunction <K> extends it.unimi.dsi.fastutil.Function<K, boolean>, Internal.Predicate<K> {
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2BooleanFunction;
        test(arg0: K): boolean;
        composeReference(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Reference2BooleanFunction<T>;
        getOrDefault(arg0: any, arg1: any): any;
        andThenObject(arg0: Internal.Boolean2ObjectFunction_<any>): Internal.Object2ObjectFunction<K, T>;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Object2IntFunction<K>;
        containsKey(arg0: any): boolean;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Object2CharFunction<K>;
        removeBoolean(arg0: any): boolean;
        andThenReference(arg0: Internal.Boolean2ReferenceFunction_<any>): Internal.Object2ReferenceFunction<K, T>;
        or(arg0: Internal.Predicate_<any>): Internal.Predicate<K>;
        put(arg0: any, arg1: any): any;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Object2FloatFunction<K>;
        composeObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Object2BooleanFunction<T>;
        apply(arg0: K): boolean;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Object2ByteFunction<K>;
        defaultReturnValue(): boolean;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Object2LongFunction<K>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2BooleanFunction;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Object2ShortFunction<K>;
        getOrDefault(arg0: any, arg1: boolean): boolean;
        remove(arg0: any): boolean;
        getOrDefault(arg0: any, arg1: boolean): boolean;
        put(arg0: K, arg1: boolean): boolean;
        put(arg0: K, arg1: boolean): boolean;
        getBoolean(arg0: any): boolean;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, boolean>;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2BooleanFunction;
        and(arg0: Internal.Predicate_<any>): Internal.Predicate<K>;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2BooleanFunction;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2BooleanFunction;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2BooleanFunction;
        size(): number;
        negate(): Internal.Predicate<K>;
        clear(): void;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        get(arg0: any): any;
        defaultReturnValue(arg0: boolean): void;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2BooleanFunction;
    }
    type Object2BooleanFunction_<K> = Object2BooleanFunction<K> | ((arg0: any)=>boolean);
    class Boat$Type extends Internal.Enum<Internal.Boat$Type> {
        static byName(arg0: string): Internal.Boat$Type;
        static values(): Internal.Boat$Type[];
        toString(): string;
        static byId(arg0: number): Internal.Boat$Type;
        getName(): string;
        getPlanks(): Internal.Block;
        static valueOf(arg0: string): Internal.Boat$Type;
        get name(): string
        get planks(): Internal.Block
        readonly static "DARK_OAK": Internal.Boat$Type;
        readonly static "SPRUCE": Internal.Boat$Type;
        readonly static "JUNGLE": Internal.Boat$Type;
        readonly static "OAK": Internal.Boat$Type;
        readonly static "BIRCH": Internal.Boat$Type;
        readonly static "ACACIA": Internal.Boat$Type;
    }
    type Boat$Type_ = "jungle" | Boat$Type | "oak" | "dark_oak" | "acacia" | "spruce" | "birch";
    interface TemporalUnit {
        between(arg0: Internal.Temporal_, arg1: Internal.Temporal_): number;
        isTimeBased(): boolean;
        addTo(arg0: R, arg1: number): R;
        toString(): string;
        getDuration(): Internal.Duration;
        isDurationEstimated(): boolean;
        isDateBased(): boolean;
        isSupportedBy(arg0: Internal.Temporal_): boolean;
        get timeBased(): boolean
        get duration(): Internal.Duration
        get durationEstimated(): boolean
        get dateBased(): boolean
    }
    type TemporalUnit_ = TemporalUnit;
    interface Spliterator$OfDouble extends Internal.Spliterator$OfPrimitive<number, Internal.DoubleConsumer, Internal.Spliterator$OfDouble> {
        forEachRemaining(arg0: any): void;
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        getComparator(): Internal.Comparator<any>;
        getExactSizeIfKnown(): number;
        forEachRemaining(arg0: Internal.DoubleConsumer_): void;
        hasCharacteristics(arg0: number): boolean;
        tryAdvance(arg0: Internal.Consumer_<any>): boolean;
        tryAdvance(arg0: any): boolean;
        tryAdvance(arg0: Internal.DoubleConsumer_): boolean;
        get comparator(): Internal.Comparator<any>
        get exactSizeIfKnown(): number
    }
    type Spliterator$OfDouble_ = Spliterator$OfDouble;
    abstract class AbstractContainerScreen <T> extends Internal.Screen implements Internal.MenuAccess<T> {
        constructor(arg0: T, arg1: Internal.Inventory_, arg2: Internal.Component_)
        charTyped(arg0: string, arg1: number): boolean;
        getGuiLeft(): number;
        mouseClicked(arg0: number, arg1: number, arg2: number): boolean;
        keyReleased(arg0: number, arg1: number, arg2: number): boolean;
        mouseScrolled(arg0: number, arg1: number, arg2: number): boolean;
        getSlotUnderMouse(): Internal.Slot;
        onClose(): void;
        static renderSlotHighlight(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number): void;
        mouseDragged(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): boolean;
        mouseMoved(arg0: number, arg1: number): void;
        getMenu(): T;
        magicalSpecialHackyFocus(arg0: Internal.GuiEventListener_): void;
        render(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        mouseReleased(arg0: number, arg1: number, arg2: number): boolean;
        changeFocus(arg0: boolean): boolean;
        tick(): void;
        keyPressed(arg0: number, arg1: number, arg2: number): boolean;
        isPauseScreen(): boolean;
        getXSize(): number;
        getGuiTop(): number;
        getYSize(): number;
        setInitialFocus(arg0: Internal.GuiEventListener_): void;
        removed(): void;
        getSlotColor(arg0: number): number;
        static renderSlotHighlight(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        getChildAt(arg0: number, arg1: number): Internal.Optional<Internal.GuiEventListener>;
        get guiLeft(): number
        get slotUnderMouse(): Internal.Slot
        get menu(): T
        get pauseScreen(): boolean
        get XSize(): number
        get guiTop(): number
        get YSize(): number
        set initialFocus(arg0: Internal.GuiEventListener_)
        readonly static "SLOT_ITEM_BLIT_OFFSET": 100;
        readonly static "INVENTORY_LOCATION": ResourceLocation;
    }
    type AbstractContainerScreen_<T> = AbstractContainerScreen<T>;
    interface Short2ShortFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntUnaryOperator {
        andThenReference(arg0: Internal.Short2ReferenceFunction_<any>): Internal.Short2ReferenceFunction<T>;
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: number, arg1: number): number;
        put(arg0: number, arg1: number): number;
        remove(arg0: any): number;
        composeShort(arg0: Internal.Short2ShortFunction_): this;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        composeReference(arg0: Internal.Reference2ShortFunction_<any>): Internal.Reference2ShortFunction<T>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Short2LongFunction;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Short2CharFunction;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2ShortFunction;
        containsKey(arg0: any): boolean;
        composeObject(arg0: Internal.Object2ShortFunction_<any>): Internal.Object2ShortFunction<T>;
        defaultReturnValue(): number;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Short2DoubleFunction;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        remove(arg0: number): number;
        applyAsInt(arg0: number): number;
        get(arg0: number): number;
        identity(): this;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2ShortFunction;
        put(arg0: any, arg1: any): any;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2ShortFunction;
        put(arg0: number, arg1: number): number;
        apply(arg0: number): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): this;
        containsKey(arg0: number): boolean;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2ShortFunction;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2ShortFunction;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Short2IntFunction;
        size(): number;
        defaultReturnValue(arg0: number): void;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Short2ByteFunction;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Short2FloatFunction;
        clear(): void;
        andThenObject(arg0: Internal.Short2ObjectFunction_<any>): Internal.Short2ObjectFunction<T>;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2ShortFunction;
        getOrDefault(arg0: any, arg1: number): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        get(arg0: any): any;
    }
    type Short2ShortFunction_ = Short2ShortFunction | ((arg0: number)=>number);
    interface Int2DoubleFunction extends Internal.IntToDoubleFunction, it.unimi.dsi.fastutil.Function<number, number> {
        applyAsDouble(arg0: number): number;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2DoubleFunction;
        composeObject(arg0: Internal.Object2IntFunction_<any>): Internal.Object2DoubleFunction<T>;
        getOrDefault(arg0: any, arg1: any): any;
        get(arg0: any): number;
        apply(arg0: number): number;
        containsKey(arg0: number): boolean;
        composeReference(arg0: Internal.Reference2IntFunction_<any>): Internal.Reference2DoubleFunction<T>;
        containsKey(arg0: any): boolean;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2DoubleFunction;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2DoubleFunction;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2DoubleFunction;
        put(arg0: any, arg1: any): any;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Int2IntFunction;
        defaultReturnValue(arg0: number): void;
        get(arg0: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        andThenObject(arg0: Internal.Double2ObjectFunction_<any>): Internal.Int2ObjectFunction<T>;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Int2CharFunction;
        getOrDefault(arg0: any, arg1: number): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2DoubleFunction;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Int2ByteFunction;
        composeInt(arg0: Internal.Int2IntFunction_): this;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Int2FloatFunction;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2DoubleFunction;
        defaultReturnValue(): number;
        size(): number;
        put(arg0: number, arg1: number): number;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): this;
        clear(): void;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Int2ShortFunction;
        put(arg0: number, arg1: number): number;
        remove(arg0: any): any;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Int2LongFunction;
        andThenReference(arg0: Internal.Double2ReferenceFunction_<any>): Internal.Int2ReferenceFunction<T>;
    }
    type Int2DoubleFunction_ = Int2DoubleFunction | ((arg0: number)=>number);
    interface BidirectionalIterator <K> extends Internal.Iterator<K> {
        hasPrevious(): boolean;
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        previous(): K;
    }
    type BidirectionalIterator_<K> = BidirectionalIterator<K>;
    interface Stream$Builder <T> extends Internal.Consumer<T> {
        andThen(arg0: Internal.Consumer_<any>): Internal.Consumer<T>;
        add(arg0: T): this;
        build(): Internal.Stream<T>;
        accept(arg0: T): void;
    }
    type Stream$Builder_<T> = Stream$Builder<T>;
    class AttributeModifier {
        constructor(arg0: Internal.UUID_, arg1: string, arg2: number, arg3: Internal.AttributeModifier$Operation_)
        constructor(arg0: string, arg1: number, arg2: Internal.AttributeModifier$Operation_)
        constructor(arg0: Internal.UUID_, arg1: Internal.Supplier_<string>, arg2: number, arg3: Internal.AttributeModifier$Operation_)
        save(): Internal.CompoundTag;
        hashCode(): number;
        toString(): string;
        getAmount(): number;
        getName(): string;
        getId(): Internal.UUID;
        static load(arg0: Internal.CompoundTag_): Internal.AttributeModifier;
        equals(arg0: any): boolean;
        getOperation(): Internal.AttributeModifier$Operation;
        get amount(): number
        get name(): string
        get id(): Internal.UUID
        get operation(): Internal.AttributeModifier$Operation
    }
    type AttributeModifier_ = AttributeModifier;
    abstract class CapabilityProvider <B> implements Internal.ICapabilityProviderImpl<B> {
        areCapsCompatible(arg0: Internal.CapabilityProvider_<B>): boolean;
        getCapability(arg0: Internal.Capability_<T>, arg1: Internal.Direction_): Internal.LazyOptional<T>;
        invalidateCaps(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        reviveCaps(): void;
    }
    type CapabilityProvider_<B> = CapabilityProvider<B>;
    class HumanoidModel <T> extends Internal.AgeableListModel<T> implements Internal.ArmedModel, Internal.HeadedModel {
        constructor(arg0: Internal.ModelPart_)
        constructor(arg0: Internal.ModelPart_, arg1: Internal.Function_<ResourceLocation_, Internal.RenderType_>)
        copyPropertiesTo(arg0: Internal.HumanoidModel_<T>): void;
        setupAnim(arg0: Internal.Entity_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        setupAnim(arg0: T, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        prepareMobModel(arg0: Internal.Entity_, arg1: number, arg2: number, arg3: number): void;
        setAllVisible(arg0: boolean): void;
        getHead(): Internal.ModelPart;
        translateToHand(arg0: Internal.HumanoidArm_, arg1: Internal.PoseStack_): void;
        prepareMobModel(arg0: T, arg1: number, arg2: number, arg3: number): void;
        static createMesh(arg0: Internal.CubeDeformation_, arg1: number): Internal.MeshDefinition;
        set allVisible(arg0: boolean)
        get head(): Internal.ModelPart
        "rightArmPose": Internal.HumanoidModel$ArmPose;
        readonly "body": Internal.ModelPart;
        readonly "head": Internal.ModelPart;
        readonly "leftArm": Internal.ModelPart;
        readonly "rightArm": Internal.ModelPart;
        readonly "leftLeg": Internal.ModelPart;
        "crouching": boolean;
        "leftArmPose": Internal.HumanoidModel$ArmPose;
        readonly "hat": Internal.ModelPart;
        "swimAmount": number;
        readonly static "HAT_OVERLAY_SCALE": 0.5;
        readonly "rightLeg": Internal.ModelPart;
        readonly static "OVERLAY_SCALE": 0.25;
    }
    type HumanoidModel_<T> = HumanoidModel<T>;
    interface Aquifer {
        create(arg0: Internal.NoiseChunk_, arg1: Internal.ChunkPos_, arg2: Internal.DensityFunction_, arg3: Internal.DensityFunction_, arg4: Internal.DensityFunction_, arg5: Internal.DensityFunction_, arg6: Internal.PositionalRandomFactory_, arg7: number, arg8: number, arg9: Internal.Aquifer$FluidPicker_): this;
        createDisabled(arg0: Internal.Aquifer$FluidPicker_): this;
        computeSubstance(arg0: Internal.DensityFunction$FunctionContext_, arg1: number): Internal.BlockState;
        shouldScheduleFluidUpdate(): boolean;
    }
    type Aquifer_ = Aquifer;
    class LootNbtProviderType extends Internal.SerializerType<any> {
        constructor(arg0: Internal.Serializer_<any>)
    }
    type LootNbtProviderType_ = Special.LootNbtProviderType | LootNbtProviderType;
    interface StringSplitter$LinePosConsumer {
        accept(arg0: Internal.Style_, arg1: number, arg2: number): void;
    }
    type StringSplitter$LinePosConsumer_ = ((arg0: Internal.Style, arg1: number, arg2: number)=>void) | StringSplitter$LinePosConsumer;
    class Period implements Internal.ChronoPeriod, Internal.Serializable {
        withDays(arg0: number): this;
        multipliedBy(arg0: number): Internal.ChronoPeriod;
        static ofDays(arg0: number): Internal.Period;
        isZero(): boolean;
        toTotalMonths(): number;
        static of(arg0: number, arg1: number, arg2: number): Internal.Period;
        getDays(): number;
        static from(arg0: Internal.TemporalAmount_): Internal.Period;
        withMonths(arg0: number): this;
        static ofWeeks(arg0: number): Internal.Period;
        getUnits(): Internal.List<Internal.TemporalUnit>;
        minusYears(arg0: number): this;
        get(arg0: Internal.TemporalUnit_): number;
        getChronology(): Internal.IsoChronology;
        isNegative(): boolean;
        plusDays(arg0: number): this;
        addTo(arg0: Internal.Temporal_): Internal.Temporal;
        minus(arg0: Internal.TemporalAmount_): this;
        toString(): string;
        static ofMonths(arg0: number): Internal.Period;
        getYears(): number;
        static parse(arg0: Internal.CharSequence_): Internal.Period;
        getMonths(): number;
        normalized(): Internal.ChronoPeriod;
        minusMonths(arg0: number): this;
        subtractFrom(arg0: Internal.Temporal_): Internal.Temporal;
        minusDays(arg0: number): this;
        hashCode(): number;
        plusYears(arg0: number): this;
        plus(arg0: Internal.TemporalAmount_): Internal.ChronoPeriod;
        static between(arg0: Internal.LocalDate_, arg1: Internal.LocalDate_): Internal.Period;
        negated(): this;
        static ofYears(arg0: number): Internal.Period;
        equals(arg0: any): boolean;
        withYears(arg0: number): this;
        plusMonths(arg0: number): this;
        get zero(): boolean
        get days(): number
        get units(): Internal.List<Internal.TemporalUnit>
        get chronology(): Internal.IsoChronology
        get negative(): boolean
        get years(): number
        get months(): number
        readonly static "ZERO": Internal.Period;
    }
    type Period_ = Period;
    interface DynamicFunction$Callback {
        call(arg0: any[]): any;
    }
    type DynamicFunction$Callback_ = ((arg0: any[])=>any) | DynamicFunction$Callback;
    class WorldBorder$Settings {
        getDamagePerBlock(): number;
        getWarningBlocks(): number;
        getSizeLerpTarget(): number;
        static read(arg0: Internal.DynamicLike_<any>, arg1: Internal.WorldBorder$Settings_): Internal.WorldBorder$Settings;
        getSafeZone(): number;
        getSizeLerpTime(): number;
        getSize(): number;
        getWarningTime(): number;
        write(arg0: Internal.CompoundTag_): void;
        getCenterZ(): number;
        getCenterX(): number;
        get damagePerBlock(): number
        get warningBlocks(): number
        get sizeLerpTarget(): number
        get safeZone(): number
        get sizeLerpTime(): number
        get size(): number
        get warningTime(): number
        get centerZ(): number
        get centerX(): number
    }
    type WorldBorder$Settings_ = WorldBorder$Settings;
    class ScreenEvent$KeyboardKeyPressedEvent$Pre extends Internal.ScreenEvent$KeyboardKeyPressedEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number, arg3: number)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$KeyboardKeyPressedEvent$Pre_ = ScreenEvent$KeyboardKeyPressedEvent$Pre;
    class PlayerInteractEvent$RightClickEmpty extends Internal.PlayerInteractEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Hand_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type PlayerInteractEvent$RightClickEmpty_ = PlayerInteractEvent$RightClickEmpty;
    class EntityArrayList extends Internal.ArrayList<Internal.EntityJS> implements Internal.MessageSender {
        constructor(l: Internal.LevelJS_, entities: Internal.Iterable_<any>)
        constructor(l: Internal.LevelJS_, size: number)
        parallelStream(): Internal.Stream<Internal.EntityJS>;
        getDisplayName(): Internal.Component;
        getName(): Internal.Component;
        runCommandSilent(command: string): number;
        playSound(id: Internal.SoundEvent_, volume: number, pitch: number): void;
        kill(): void;
        tell(message: Internal.Component_): void;
        sendData(channel: string, data: Internal.CompoundTag_): void;
        getLevel(): Internal.LevelJS;
        setStatusMessage(message: Internal.Component_): void;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        playSound(id: Internal.SoundEvent_): void;
        stream(): Internal.Stream<Internal.EntityJS>;
        filter(filter: Internal.Predicate_<Internal.EntityJS_>): this;
        getFirst(): Internal.EntityJS;
        runCommand(command: string): number;
        get displayName(): Internal.Component
        get name(): Internal.Component
        get level(): Internal.LevelJS
        set statusMessage(message: Internal.Component_)
        get first(): Internal.EntityJS
    }
    type EntityArrayList_ = EntityArrayList;
    class Vec2 {
        constructor(arg0: number, arg1: number)
        add(arg0: number): this;
        equals(arg0: Internal.Vec2_): boolean;
        lengthSquared(): number;
        length(): number;
        normalized(): this;
        distanceToSqr(arg0: Internal.Vec2_): number;
        scale(arg0: number): this;
        add(arg0: Internal.Vec2_): this;
        dot(arg0: Internal.Vec2_): number;
        negated(): this;
        readonly "y": number;
        readonly static "NEG_UNIT_X": Internal.Vec2;
        readonly static "MAX": Internal.Vec2;
        readonly "x": number;
        readonly static "MIN": Internal.Vec2;
        readonly static "ZERO": Internal.Vec2;
        readonly static "ONE": Internal.Vec2;
        readonly static "NEG_UNIT_Y": Internal.Vec2;
        readonly static "UNIT_Y": Internal.Vec2;
        readonly static "UNIT_X": Internal.Vec2;
    }
    type Vec2_ = Vec2;
    interface JsonSerializable {
        toJson(): Internal.JsonElement;
    }
    type JsonSerializable_ = JsonSerializable;
    class AxisAlignedLinearPosTest extends Internal.PosRuleTest {
        constructor(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Direction$Axis_)
        test(arg0: BlockPos_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.Random_): boolean;
        readonly static "CODEC": any;
    }
    type AxisAlignedLinearPosTest_ = AxisAlignedLinearPosTest;
    class ConstantFloat extends Internal.FloatProvider {
        getMinValue(): number;
        toString(): string;
        getMaxValue(): number;
        sample(arg0: Internal.Random_): number;
        static of(arg0: number): Internal.ConstantFloat;
        getType(): Internal.FloatProviderType<any>;
        getValue(): number;
        get minValue(): number
        get maxValue(): number
        get type(): Internal.FloatProviderType<any>
        get value(): number
        readonly static "ZERO": Internal.ConstantFloat;
        readonly static "CODEC": any;
    }
    type ConstantFloat_ = ConstantFloat;
    abstract class CompressorHolder implements Internal.Compressable {
        constructor()
        compressor(arg0: Internal.DynamicOps_<T>): Internal.KeyCompressor<T>;
    }
    type CompressorHolder_ = CompressorHolder;
    interface MetadataSectionSerializer <T> {
        getMetadataSectionName(): string;
        fromJson(arg0: Internal.JsonObject_): T;
        get metadataSectionName(): string
    }
    type MetadataSectionSerializer_<T> = MetadataSectionSerializer<T>;
    class AddReloadListenerEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.ReloadableServerResources_)
        getListeners(): Internal.List<Internal.PreparableReloadListener>;
        getServerResources(): Internal.ReloadableServerResources;
        getListenerList(): Internal.ListenerList;
        getConditionContext(): Internal.ICondition$IContext;
        addListener(arg0: Internal.PreparableReloadListener_): void;
        get listeners(): Internal.List<Internal.PreparableReloadListener>
        get serverResources(): Internal.ReloadableServerResources
        get listenerList(): Internal.ListenerList
        get conditionContext(): Internal.ICondition$IContext
    }
    type AddReloadListenerEvent_ = AddReloadListenerEvent;
    interface OpticFinder <FT> {
        type(): com.mojang.datafixers.types.Type<FT>;
        inField(arg0: string, arg1: com.mojang.datafixers.types.Type_<GT>): this;
        findType(arg0: com.mojang.datafixers.types.Type_<A>, arg1: com.mojang.datafixers.types.Type_<FR>, arg2: boolean): Internal.Either<Internal.TypedOptic<A, any, FT, FR>, Internal.Type$FieldNotFoundException>;
        findType(arg0: com.mojang.datafixers.types.Type_<A>, arg1: boolean): Internal.Either<Internal.TypedOptic<A, any, FT, FT>, Internal.Type$FieldNotFoundException>;
    }
    type OpticFinder_<FT> = OpticFinder<FT>;
    abstract class ForgeRegistryEntry$UncheckedRegistryEntry <V> extends Internal.ForgeRegistryEntry<V> {
        constructor()
        setRegistryName(arg0: ResourceLocation_): any;
        set registryName(arg0: ResourceLocation_)
    }
    type ForgeRegistryEntry$UncheckedRegistryEntry_<V> = ForgeRegistryEntry$UncheckedRegistryEntry<V>;
    class ClientboundPlayerInfoPacket$PlayerUpdate {
        constructor(arg0: Internal.GameProfile_, arg1: number, arg2: Internal.GameType_, arg3: Internal.Component_)
        getDisplayName(): Internal.Component;
        toString(): string;
        getGameMode(): Internal.GameType;
        getProfile(): Internal.GameProfile;
        getLatency(): number;
        get displayName(): Internal.Component
        get gameMode(): Internal.GameType
        get profile(): Internal.GameProfile
        get latency(): number
    }
    type ClientboundPlayerInfoPacket$PlayerUpdate_ = ClientboundPlayerInfoPacket$PlayerUpdate;
    interface ShortBidirectionalIterator extends Internal.ShortIterator, Internal.ObjectBidirectionalIterator<number> {
        previousShort(): number;
        forEachRemaining(arg0: Internal.ShortConsumer_): void;
        forEachRemaining(arg0: any): void;
        previous(): number;
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): any;
        skip(arg0: number): number;
        forEachRemaining(arg0: Internal.IntConsumer_): void;
        back(arg0: number): number;
    }
    type ShortBidirectionalIterator_ = ShortBidirectionalIterator;
    interface TypeDescriptor {
        descriptorString(): string;
    }
    type TypeDescriptor_ = TypeDescriptor;
    interface CustomProperty {
        get(): any;
    }
    type CustomProperty_ = CustomProperty;
    class ClientboundCommandsPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.RootCommandNode_<Internal.SharedSuggestionProvider_>)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getRoot(): Internal.RootCommandNode<Internal.SharedSuggestionProvider>;
        isSkippable(): boolean;
        get root(): Internal.RootCommandNode<Internal.SharedSuggestionProvider>
        get skippable(): boolean
    }
    type ClientboundCommandsPacket_ = ClientboundCommandsPacket;
    class PlatformWrapper$ModInfo {
        constructor(i: string)
        getName(): string;
        getVersion(): string;
        getId(): string;
        get name(): string
        get version(): string
        get id(): string
    }
    type PlatformWrapper$ModInfo_ = PlatformWrapper$ModInfo;
    interface ChronoLocalDateTime <D> extends Internal.Comparable<Internal.ChronoLocalDateTime<any>>, Internal.Temporal, Internal.TemporalAdjuster {
        plus(arg0: Internal.TemporalAmount_): this;
        toLocalTime(): Internal.LocalTime;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Temporal;
        compareTo(arg0: any): number;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Temporal;
        isSupported(arg0: Internal.TemporalField_): boolean;
        format(arg0: Internal.DateTimeFormatter_): string;
        getChronology(): Internal.Chronology;
        with(arg0: Internal.TemporalAdjuster_): this;
        isEqual(arg0: Internal.ChronoLocalDateTime_<any>): boolean;
        toString(): string;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        isBefore(arg0: Internal.ChronoLocalDateTime_<any>): boolean;
        query(arg0: Internal.TemporalQuery_<R>): R;
        toInstant(arg0: Internal.ZoneOffset_): Internal.Instant;
        with(arg0: Internal.TemporalField_, arg1: number): this;
        from(arg0: Internal.TemporalAccessor_): Internal.ChronoLocalDateTime<any>;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        hashCode(): number;
        get(arg0: Internal.TemporalField_): number;
        isAfter(arg0: Internal.ChronoLocalDateTime_<any>): boolean;
        atZone(arg0: Internal.ZoneId_): Internal.ChronoZonedDateTime<D>;
        toEpochSecond(arg0: Internal.ZoneOffset_): number;
        compareTo(arg0: Internal.ChronoLocalDateTime_<any>): number;
        toLocalDate(): D;
        equals(arg0: any): boolean;
        minus(arg0: Internal.TemporalAmount_): Internal.Temporal;
        timeLineOrder(): Internal.Comparator<Internal.ChronoLocalDateTime<any>>;
        get chronology(): Internal.Chronology
    }
    type ChronoLocalDateTime_<D> = ChronoLocalDateTime<D>;
    class RuinedPortalConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.RuinedPortalFeature$Type_)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
        readonly "portalType": Internal.RuinedPortalFeature$Type;
    }
    type RuinedPortalConfiguration_ = RuinedPortalConfiguration;
    class HugeMushroomFeatureConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.BlockStateProvider_, arg1: Internal.BlockStateProvider_, arg2: number)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "capProvider": Internal.BlockStateProvider;
        readonly static "CODEC": any;
        readonly "stemProvider": Internal.BlockStateProvider;
        readonly "foliageRadius": number;
    }
    type HugeMushroomFeatureConfiguration_ = HugeMushroomFeatureConfiguration;
    interface PerformanceMetrics {
        getMaxTime(): number;
        getAverageTime(): number;
        getMinTime(): number;
        getSampleCount(): number;
        get maxTime(): number
        get averageTime(): number
        get minTime(): number
        get sampleCount(): number
    }
    type PerformanceMetrics_ = PerformanceMetrics;
    class CubicSpline$Builder <C> {
        addPoint(arg0: number, arg1: number, arg2: number): this;
        addPoint(arg0: number, arg1: Internal.CubicSpline_<C>, arg2: number): this;
        build(): Internal.CubicSpline<C>;
    }
    type CubicSpline$Builder_<C> = CubicSpline$Builder<C>;
    class StairBlockBuilder extends Internal.ShapedBlockBuilder {
        constructor(i: ResourceLocation_)
        createObject(): Internal.Block;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
    }
    type StairBlockBuilder_ = StairBlockBuilder;
    class EnderDragonPhaseManager {
        constructor(arg0: Internal.EnderDragon_)
        getCurrentPhase(): Internal.DragonPhaseInstance;
        getPhase(arg0: Internal.EnderDragonPhase_<T>): T;
        setPhase(arg0: Internal.EnderDragonPhase_<any>): void;
        get currentPhase(): Internal.DragonPhaseInstance
        set phase(arg0: Internal.EnderDragonPhase_<any>)
    }
    type EnderDragonPhaseManager_ = EnderDragonPhaseManager;
    class MapDecoration$Type extends Internal.Enum<Internal.MapDecoration$Type> {
        isRenderedOnFrame(): boolean;
        getMapColor(): number;
        static values(): Internal.MapDecoration$Type[];
        hasMapColor(): boolean;
        shouldTrackCount(): boolean;
        static byIcon(arg0: number): Internal.MapDecoration$Type;
        getIcon(): number;
        static valueOf(arg0: string): Internal.MapDecoration$Type;
        get renderedOnFrame(): boolean
        get mapColor(): number
        get icon(): number
        readonly static "BANNER_GREEN": Internal.MapDecoration$Type;
        readonly static "BANNER_RED": Internal.MapDecoration$Type;
        readonly static "BANNER_GRAY": Internal.MapDecoration$Type;
        readonly static "MANSION": Internal.MapDecoration$Type;
        readonly static "BANNER_BLUE": Internal.MapDecoration$Type;
        readonly static "MONUMENT": Internal.MapDecoration$Type;
        readonly static "PLAYER_OFF_LIMITS": Internal.MapDecoration$Type;
        readonly static "TARGET_POINT": Internal.MapDecoration$Type;
        readonly static "BANNER_LIGHT_BLUE": Internal.MapDecoration$Type;
        readonly static "RED_X": Internal.MapDecoration$Type;
        readonly static "BANNER_MAGENTA": Internal.MapDecoration$Type;
        readonly static "BLUE_MARKER": Internal.MapDecoration$Type;
        readonly static "BANNER_WHITE": Internal.MapDecoration$Type;
        readonly static "PLAYER_OFF_MAP": Internal.MapDecoration$Type;
        readonly static "BANNER_LIGHT_GRAY": Internal.MapDecoration$Type;
        readonly static "BANNER_YELLOW": Internal.MapDecoration$Type;
        readonly static "TARGET_X": Internal.MapDecoration$Type;
        readonly static "RED_MARKER": Internal.MapDecoration$Type;
        readonly static "BANNER_ORANGE": Internal.MapDecoration$Type;
        readonly static "BANNER_BLACK": Internal.MapDecoration$Type;
        readonly static "BANNER_BROWN": Internal.MapDecoration$Type;
        readonly static "BANNER_PURPLE": Internal.MapDecoration$Type;
        readonly static "PLAYER": Internal.MapDecoration$Type;
        readonly static "BANNER_LIME": Internal.MapDecoration$Type;
        readonly static "BANNER_PINK": Internal.MapDecoration$Type;
        readonly static "FRAME": Internal.MapDecoration$Type;
        readonly static "BANNER_CYAN": Internal.MapDecoration$Type;
    }
    type MapDecoration$Type_ = "banner_blue" | "player" | "banner_black" | "banner_cyan" | MapDecoration$Type | "banner_gray" | "target_x" | "monument" | "banner_brown" | "banner_light_blue" | "banner_white" | "banner_purple" | "banner_lime" | "banner_yellow" | "banner_pink" | "red_x" | "frame" | "red_marker" | "player_off_limits" | "banner_magenta" | "player_off_map" | "blue_marker" | "banner_red" | "banner_orange" | "target_point" | "banner_light_gray" | "mansion" | "banner_green";
    class Schedule extends Internal.ForgeRegistryEntry<Internal.Schedule> {
        constructor()
        getActivityAt(arg0: number): Internal.Activity;
        readonly static "VILLAGER_DEFAULT": Internal.Schedule;
        readonly static "SIMPLE": Internal.Schedule;
        readonly static "EMPTY": Internal.Schedule;
        readonly static "WORK_START_TIME": 2000;
        readonly static "VILLAGER_BABY": Internal.Schedule;
        readonly static "TOTAL_WORK_TIME": 7000;
    }
    type Schedule_ = Schedule | Special.Schedule;
    class ServerPlayerDataJS extends Internal.PlayerDataJS<Internal.ServerPlayer, Internal.ServerPlayerJS> {
        constructor(s: Internal.ServerJS_, i: Internal.UUID_, n: string, h: boolean)
        getMinecraftPlayer(): Internal.Player;
        hasClientMod(): boolean;
        getProfile(): Internal.GameProfile;
        getOverworld(): Internal.LevelJS;
        getName(): string;
        getId(): Internal.UUID;
        getServer(): Internal.ServerJS;
        getPlayer(): Internal.ServerPlayerJS;
        get minecraftPlayer(): Internal.Player
        get profile(): Internal.GameProfile
        get overworld(): Internal.LevelJS
        get name(): string
        get id(): Internal.UUID
        get server(): Internal.ServerJS
        get player(): Internal.ServerPlayerJS
    }
    type ServerPlayerDataJS_ = ServerPlayerDataJS;
    class WrappedGoal extends Internal.Goal {
        constructor(arg0: number, arg1: Internal.Goal_)
        isRunning(): boolean;
        tick(): void;
        isInterruptable(): boolean;
        start(): void;
        hashCode(): number;
        getGoal(): Internal.Goal;
        canBeReplacedBy(arg0: Internal.WrappedGoal_): boolean;
        getPriority(): number;
        getFlags(): Internal.EnumSet<Internal.Goal$Flag>;
        setFlags(arg0: Internal.EnumSet_<Internal.Goal$Flag_>): void;
        stop(): void;
        canUse(): boolean;
        requiresUpdateEveryTick(): boolean;
        equals(arg0: any): boolean;
        canContinueToUse(): boolean;
        get running(): boolean
        get interruptable(): boolean
        get goal(): Internal.Goal
        get priority(): number
        get flags(): Internal.EnumSet<Internal.Goal$Flag>
        set flags(arg0: Internal.EnumSet_<Internal.Goal$Flag_>)
    }
    type WrappedGoal_ = WrappedGoal;
    interface IForgeMenuType <T> {
        create(arg0: number, arg1: Internal.Inventory_, arg2: Internal.FriendlyByteBuf_): T;
        create(arg0: Internal.IContainerFactory_<T>): Internal.MenuType<T>;
    }
    type IForgeMenuType_<T> = IForgeMenuType<T>;
    interface PalettedContainer$CountConsumer <T> {
        accept(arg0: T, arg1: number): void;
    }
    type PalettedContainer$CountConsumer_<T> = PalettedContainer$CountConsumer<T> | ((arg0: T, arg1: number)=>void);
    interface SingleRedirectModifier <S> {
        apply(arg0: Internal.CommandContext_<S>): S;
    }
    type SingleRedirectModifier_<S> = SingleRedirectModifier<S> | ((arg0: Internal.CommandContext<S>)=>S);
    class Ocelot extends Internal.Animal {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        customServerAiStep(): void;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        static checkOcelotSpawnRules(arg0: Internal.EntityType_<Internal.Ocelot_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        isSteppingCarefully(): boolean;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        isFood(arg0: Internal.ItemStack_): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        checkSpawnObstruction(arg0: Internal.LevelReader_): boolean;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        getAmbientSoundInterval(): number;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getLeashOffset(): Vec3;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getClassification(arg0: boolean): Internal.MobCategory;
        removeWhenFarAway(arg0: number): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get steppingCarefully(): boolean
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get ambientSoundInterval(): number
        get leashOffset(): Vec3
        readonly static "CROUCH_SPEED_MOD": 0.6;
        readonly static "SPRINT_SPEED_MOD": 1.33;
        readonly static "WALK_SPEED_MOD": 0.8;
    }
    type Ocelot_ = Ocelot;
    interface PositionSourceType <T> {
        register(arg0: string, arg1: S): S;
        toNetwork(arg0: T, arg1: Internal.FriendlyByteBuf_): void;
        codec(): Internal.Codec<T>;
        fromNetwork(arg0: Internal.FriendlyByteBuf_): Internal.PositionSource;
        write(arg0: Internal.FriendlyByteBuf_, arg1: T): void;
        read(arg0: Internal.FriendlyByteBuf_): T;
        readonly static "BLOCK": any;
        readonly static "ENTITY": any;
    }
    type PositionSourceType_<T> = PositionSourceType<T> | Special.PositionSourceType;
    class BrewingStandMenu extends Internal.AbstractContainerMenu {
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Container_, arg3: any_)
        constructor(arg0: number, arg1: Internal.Inventory_)
        stillValid(arg0: Internal.Player_): boolean;
        getBrewingTicks(): number;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        getFuel(): number;
        get brewingTicks(): number
        get fuel(): number
    }
    type BrewingStandMenu_ = BrewingStandMenu;
    interface TypeFamily {
        familyOptic(arg0: Internal.IntFunction_<Internal.OpticParts_<A, B>>): Internal.FamilyOptic<A, B>;
        apply(arg0: number): com.mojang.datafixers.types.Type<any>;
    }
    type TypeFamily_ = TypeFamily;
    interface DiscreteVoxelShape$IntLineConsumer {
        consume(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
    }
    type DiscreteVoxelShape$IntLineConsumer_ = DiscreteVoxelShape$IntLineConsumer;
    abstract class Minecraft$ChatStatus extends Internal.Enum<Internal.Minecraft$ChatStatus> {
        static valueOf(arg0: string): Internal.Minecraft$ChatStatus;
        getMessage(): Internal.Component;
        static values(): Internal.Minecraft$ChatStatus[];
        isChatAllowed(arg0: boolean): boolean;
        get message(): Internal.Component
        readonly static "DISABLED_BY_OPTIONS": any;
        readonly static "DISABLED_BY_LAUNCHER": any;
        readonly static "ENABLED": any;
        readonly static "DISABLED_BY_PROFILE": any;
    }
    type Minecraft$ChatStatus_ = Minecraft$ChatStatus | "enabled" | "disabled_by_profile" | "disabled_by_launcher" | "disabled_by_options";
    class MetricCategory extends Internal.Enum<Internal.MetricCategory> {
        static valueOf(arg0: string): Internal.MetricCategory;
        static values(): Internal.MetricCategory[];
        getDescription(): string;
        get description(): string
        readonly static "MAIL_BOXES": Internal.MetricCategory;
        readonly static "CHUNK_RENDERING_DISPATCHING": Internal.MetricCategory;
        readonly static "JVM": Internal.MetricCategory;
        readonly static "PATH_FINDING": Internal.MetricCategory;
        readonly static "EVENT_LOOPS": Internal.MetricCategory;
        readonly static "CHUNK_RENDERING": Internal.MetricCategory;
        readonly static "TICK_LOOP": Internal.MetricCategory;
        readonly static "CPU": Internal.MetricCategory;
    }
    type MetricCategory_ = "path_finding" | "cpu" | "jvm" | "chunk_rendering" | "mail_boxes" | "tick_loop" | "event_loops" | "chunk_rendering_dispatching" | MetricCategory;
    class CubeDeformation {
        constructor(arg0: number)
        constructor(arg0: number, arg1: number, arg2: number)
        extend(arg0: number, arg1: number, arg2: number): this;
        extend(arg0: number): this;
        readonly static "NONE": Internal.CubeDeformation;
    }
    type CubeDeformation_ = CubeDeformation;
    class Difficulty extends Internal.Enum<Internal.Difficulty> {
        static values(): Internal.Difficulty[];
        getDisplayName(): Internal.Component;
        static byId(arg0: number): Internal.Difficulty;
        static byName(arg0: string): Internal.Difficulty;
        getKey(): string;
        static valueOf(arg0: string): Internal.Difficulty;
        getId(): number;
        get displayName(): Internal.Component
        get key(): string
        get id(): number
        readonly static "NORMAL": Internal.Difficulty;
        readonly static "PEACEFUL": Internal.Difficulty;
        readonly static "HARD": Internal.Difficulty;
        readonly static "EASY": Internal.Difficulty;
    }
    type Difficulty_ = "normal" | "peaceful" | Difficulty | "hard" | "easy";
    class EntityLootEventJS extends Internal.LootEventJS {
        constructor(c: Internal.Map_<ResourceLocation_, Internal.JsonElement_>)
        addEntity(type: Internal.EntityType_<any>, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        modifyEntity(type: Internal.EntityType_<any>, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        getType(): string;
        getDirectory(): string;
        get type(): string
        get directory(): string
    }
    type EntityLootEventJS_ = EntityLootEventJS;
    class ItemTransforms {
        constructor(arg0: Internal.ItemTransform_, arg1: Internal.ItemTransform_, arg2: Internal.ItemTransform_, arg3: Internal.ItemTransform_, arg4: Internal.ItemTransform_, arg5: Internal.ItemTransform_, arg6: Internal.ItemTransform_, arg7: Internal.ItemTransform_, arg8: Internal.ImmutableMap_<Internal.ItemTransforms$TransformType_, Internal.ItemTransform_>)
        constructor(arg0: Internal.ItemTransform_, arg1: Internal.ItemTransform_, arg2: Internal.ItemTransform_, arg3: Internal.ItemTransform_, arg4: Internal.ItemTransform_, arg5: Internal.ItemTransform_, arg6: Internal.ItemTransform_, arg7: Internal.ItemTransform_)
        constructor(arg0: Internal.ItemTransforms_)
        getTransform(arg0: Internal.ItemTransforms$TransformType_): Internal.ItemTransform;
        hasTransform(arg0: Internal.ItemTransforms$TransformType_): boolean;
        readonly "fixed": Internal.ItemTransform;
        readonly "thirdPersonRightHand": Internal.ItemTransform;
        readonly static "NO_TRANSFORMS": Internal.ItemTransforms;
        readonly "thirdPersonLeftHand": Internal.ItemTransform;
        readonly "firstPersonLeftHand": Internal.ItemTransform;
        readonly "head": Internal.ItemTransform;
        readonly "ground": Internal.ItemTransform;
        readonly "firstPersonRightHand": Internal.ItemTransform;
        readonly "gui": Internal.ItemTransform;
        readonly "moddedTransforms": Internal.ImmutableMap<Internal.ItemTransforms$TransformType, Internal.ItemTransform>;
    }
    type ItemTransforms_ = ItemTransforms;
    abstract class ParticleType <T> extends Internal.ForgeRegistryEntry<Internal.ParticleType<any>> {
        constructor(arg0: boolean, arg1: Internal.ParticleOptions$Deserializer_<T>)
        getDeserializer(): Internal.ParticleOptions$Deserializer<T>;
        codec(): Internal.Codec<T>;
        getOverrideLimiter(): boolean;
        get deserializer(): Internal.ParticleOptions$Deserializer<T>
        get overrideLimiter(): boolean
    }
    type ParticleType_<T> = Special.ParticleType | ParticleType<T>;
    abstract class RenderType extends Internal.RenderStateShard {
        constructor(arg0: string, arg1: Internal.VertexFormat_, arg2: Internal.VertexFormat$Mode_, arg3: number, arg4: boolean, arg5: boolean, arg6: Internal.Runnable_, arg7: Internal.Runnable_)
        static cutout(): Internal.RenderType;
        static textIntensitySeeThrough(arg0: ResourceLocation_): Internal.RenderType;
        static beaconBeam(arg0: ResourceLocation_, arg1: boolean): Internal.RenderType;
        static entitySolid(arg0: ResourceLocation_): Internal.RenderType;
        affectsCrumbling(): boolean;
        outline(): Internal.Optional<Internal.RenderType>;
        static lines(): Internal.RenderType;
        static entityTranslucent(arg0: ResourceLocation_): Internal.RenderType;
        static entityCutout(arg0: ResourceLocation_): Internal.RenderType;
        static entityNoOutline(arg0: ResourceLocation_): Internal.RenderType;
        static entityShadow(arg0: ResourceLocation_): Internal.RenderType;
        static entityCutoutNoCull(arg0: ResourceLocation_): Internal.RenderType;
        static tripwire(): Internal.RenderType;
        static translucentNoCrumbling(): Internal.RenderType;
        static entityGlint(): Internal.RenderType;
        static energySwirl(arg0: ResourceLocation_, arg1: number, arg2: number): Internal.RenderType;
        static text(arg0: ResourceLocation_): Internal.RenderType;
        static outline(arg0: ResourceLocation_): Internal.RenderType;
        static endPortal(): Internal.RenderType;
        mode(): Internal.VertexFormat$Mode;
        static leash(): Internal.RenderType;
        static glintTranslucent(): Internal.RenderType;
        static entityCutoutNoCull(arg0: ResourceLocation_, arg1: boolean): Internal.RenderType;
        static create(arg0: string, arg1: Internal.VertexFormat_, arg2: Internal.VertexFormat$Mode_, arg3: number, arg4: Internal.RenderType$CompositeState_): Internal.RenderType$CompositeRenderType;
        static translucentMovingBlock(): Internal.RenderType;
        static itemEntityTranslucentCull(arg0: ResourceLocation_): Internal.RenderType;
        static armorCutoutNoCull(arg0: ResourceLocation_): Internal.RenderType;
        static armorGlint(): Internal.RenderType;
        isOutline(): boolean;
        static glintDirect(): Internal.RenderType;
        static entityGlintDirect(): Internal.RenderType;
        static eyes(arg0: ResourceLocation_): Internal.RenderType;
        static entityCutoutNoCullZOffset(arg0: ResourceLocation_, arg1: boolean): Internal.RenderType;
        bufferSize(): number;
        static entityTranslucent(arg0: ResourceLocation_, arg1: boolean): Internal.RenderType;
        static textSeeThrough(arg0: ResourceLocation_): Internal.RenderType;
        static create(arg0: string, arg1: Internal.VertexFormat_, arg2: Internal.VertexFormat$Mode_, arg3: number, arg4: boolean, arg5: boolean, arg6: Internal.RenderType$CompositeState_): Internal.RenderType$CompositeRenderType;
        static entitySmoothCutout(arg0: ResourceLocation_): Internal.RenderType;
        static solid(): Internal.RenderType;
        static dragonExplosionAlpha(arg0: ResourceLocation_): Internal.RenderType;
        end(arg0: Internal.BufferBuilder_, arg1: number, arg2: number, arg3: number): void;
        static endGateway(): Internal.RenderType;
        static textIntensity(arg0: ResourceLocation_): Internal.RenderType;
        static glint(): Internal.RenderType;
        format(): Internal.VertexFormat;
        static waterMask(): Internal.RenderType;
        static chunkBufferLayers(): Internal.List<Internal.RenderType>;
        static entityCutoutNoCullZOffset(arg0: ResourceLocation_): Internal.RenderType;
        static lineStrip(): Internal.RenderType;
        static textPolygonOffset(arg0: ResourceLocation_): Internal.RenderType;
        toString(): string;
        static crumbling(arg0: ResourceLocation_): Internal.RenderType;
        static entityDecal(arg0: ResourceLocation_): Internal.RenderType;
        static armorEntityGlint(): Internal.RenderType;
        static cutoutMipped(): Internal.RenderType;
        asOptional(): Internal.Optional<Internal.RenderType>;
        static lightning(): Internal.RenderType;
        static translucent(): Internal.RenderType;
        static entityTranslucentCull(arg0: ResourceLocation_): Internal.RenderType;
        static textIntensityPolygonOffset(arg0: ResourceLocation_): Internal.RenderType;
        get outline(): boolean
        readonly static "LINES": Internal.RenderType$CompositeRenderType;
        readonly static "TRANSIENT_BUFFER_SIZE": 256;
        readonly static "BIG_BUFFER_SIZE": 2097152;
        readonly static "SMALL_BUFFER_SIZE": 131072;
        readonly static "MEDIUM_BUFFER_SIZE": 262144;
        readonly static "LINE_STRIP": Internal.RenderType$CompositeRenderType;
    }
    type RenderType_ = RenderType;
    class ChunkBufferBuilderPack {
        constructor()
        discardAll(): void;
        clearAll(): void;
        builder(arg0: Internal.RenderType_): Internal.BufferBuilder;
    }
    type ChunkBufferBuilderPack_ = ChunkBufferBuilderPack;
    class ClientboundAddMobPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.LivingEntity_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getxRot(): number;
        getYd(): number;
        getZd(): number;
        getXd(): number;
        getyRot(): number;
        isSkippable(): boolean;
        getX(): number;
        getY(): number;
        getZ(): number;
        getType(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getUUID(): Internal.UUID;
        getyHeadRot(): number;
        getId(): number;
        get xRot(): number
        get yd(): number
        get zd(): number
        get xd(): number
        get yRot(): number
        get skippable(): boolean
        get x(): number
        get y(): number
        get z(): number
        get type(): number
        get UUID(): Internal.UUID
        get yHeadRot(): number
        get id(): number
    }
    type ClientboundAddMobPacket_ = ClientboundAddMobPacket;
    class VertexFormat$Mode extends Internal.Enum<Internal.VertexFormat$Mode> {
        static valueOf(arg0: string): Internal.VertexFormat$Mode;
        indexCount(arg0: number): number;
        static values(): Internal.VertexFormat$Mode[];
        readonly static "DEBUG_LINE_STRIP": Internal.VertexFormat$Mode;
        readonly static "TRIANGLE_STRIP": Internal.VertexFormat$Mode;
        readonly static "DEBUG_LINES": Internal.VertexFormat$Mode;
        readonly static "LINE_STRIP": Internal.VertexFormat$Mode;
        readonly static "TRIANGLE_FAN": Internal.VertexFormat$Mode;
        readonly static "LINES": Internal.VertexFormat$Mode;
        readonly static "TRIANGLES": Internal.VertexFormat$Mode;
        readonly static "QUADS": Internal.VertexFormat$Mode;
        readonly "asGLMode": number;
        readonly "primitiveLength": number;
        readonly "primitiveStride": number;
    }
    type VertexFormat$Mode_ = "triangles" | "triangle_fan" | "debug_line_strip" | "line_strip" | "triangle_strip" | "debug_lines" | VertexFormat$Mode | "quads" | "lines";
    class ClientboundOpenScreenPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: Internal.MenuType_<any>, arg2: Internal.Component_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getType(): Internal.MenuType<any>;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getTitle(): Internal.Component;
        getContainerId(): number;
        isSkippable(): boolean;
        get type(): Internal.MenuType<any>
        get title(): Internal.Component
        get containerId(): number
        get skippable(): boolean
    }
    type ClientboundOpenScreenPacket_ = ClientboundOpenScreenPacket;
    class TextureAtlas$Preparations {
        constructor(arg0: Internal.Set_<ResourceLocation_>, arg1: number, arg2: number, arg3: number, arg4: Internal.List_<Internal.TextureAtlasSprite_>)
    }
    type TextureAtlas$Preparations_ = TextureAtlas$Preparations;
    class ClientPlayerNetworkEvent$LoggedInEvent extends Internal.ClientPlayerNetworkEvent {
        constructor()
        constructor(arg0: Internal.MultiPlayerGameMode_, arg1: Internal.LocalPlayer_, arg2: Internal.Connection_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ClientPlayerNetworkEvent$LoggedInEvent_ = ClientPlayerNetworkEvent$LoggedInEvent;
    class PlacedFeature extends Internal.Record {
        constructor(arg0: Internal.Holder_<Internal.ConfiguredFeature_<any, any>>, arg1: Internal.List_<Internal.PlacementModifier_>)
        hashCode(): number;
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        toString(): string;
        place(arg0: Internal.WorldGenLevel_, arg1: Internal.ChunkGenerator_, arg2: Internal.Random_, arg3: BlockPos_): boolean;
        feature(): Internal.Holder<Internal.ConfiguredFeature<any, any>>;
        placeWithBiomeCheck(arg0: Internal.WorldGenLevel_, arg1: Internal.ChunkGenerator_, arg2: Internal.Random_, arg3: BlockPos_): boolean;
        equals(arg0: any): boolean;
        placement(): Internal.List<Internal.PlacementModifier>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "LIST_CODEC": any;
        readonly static "DIRECT_CODEC": any;
        readonly static "LIST_OF_LISTS_CODEC": any;
        readonly static "CODEC": any;
    }
    type PlacedFeature_ = Special.PlacedFeature | PlacedFeature;
    class ObjectiveCriteria$RenderType extends Internal.Enum<Internal.ObjectiveCriteria$RenderType> {
        static valueOf(arg0: string): Internal.ObjectiveCriteria$RenderType;
        static byId(arg0: string): Internal.ObjectiveCriteria$RenderType;
        getId(): string;
        static values(): Internal.ObjectiveCriteria$RenderType[];
        get id(): string
        readonly static "HEARTS": Internal.ObjectiveCriteria$RenderType;
        readonly static "INTEGER": Internal.ObjectiveCriteria$RenderType;
    }
    type ObjectiveCriteria$RenderType_ = ObjectiveCriteria$RenderType | "hearts" | "integer";
    interface TypeDescriptor$OfMethod <F, M> extends Internal.TypeDescriptor {
        changeParameterType(arg0: number, arg1: F): M;
        returnType(): F;
        parameterArray(): F[];
        parameterCount(): number;
        insertParameterTypes(arg0: number, ...arg1: F[]): M;
        parameterType(arg0: number): F;
        parameterList(): Internal.List<F>;
        changeReturnType(arg0: F): M;
        dropParameterTypes(arg0: number, arg1: number): M;
    }
    type TypeDescriptor$OfMethod_<F, M> = TypeDescriptor$OfMethod<F, M>;
    class PoiManager extends Internal.SectionStorage<any> {
        constructor(arg0: Internal.Path_, arg1: Internal.DataFixer_, arg2: boolean, arg3: Internal.LevelHeightAccessor_)
        take(arg0: Internal.Predicate_<Internal.PoiType_>, arg1: Internal.Predicate_<BlockPos_>, arg2: BlockPos_, arg3: number): Internal.Optional<BlockPos>;
        getCountInRange(arg0: Internal.Predicate_<Internal.PoiType_>, arg1: BlockPos_, arg2: number, arg3: Internal.PoiManager$Occupancy_): number;
        add(arg0: BlockPos_, arg1: Internal.PoiType_): void;
        checkConsistencyWithBlocks(arg0: Internal.ChunkPos_, arg1: Internal.LevelChunkSection_): void;
        getType(arg0: BlockPos_): Internal.Optional<Internal.PoiType>;
        getInChunk(arg0: Internal.Predicate_<Internal.PoiType_>, arg1: Internal.ChunkPos_, arg2: Internal.PoiManager$Occupancy_): Internal.Stream<Internal.PoiRecord>;
        findAllClosestFirst(arg0: Internal.Predicate_<Internal.PoiType_>, arg1: Internal.Predicate_<BlockPos_>, arg2: BlockPos_, arg3: number, arg4: Internal.PoiManager$Occupancy_): Internal.Stream<BlockPos>;
        findClosest(arg0: Internal.Predicate_<Internal.PoiType_>, arg1: BlockPos_, arg2: number, arg3: Internal.PoiManager$Occupancy_): Internal.Optional<BlockPos>;
        getRandom(arg0: Internal.Predicate_<Internal.PoiType_>, arg1: Internal.Predicate_<BlockPos_>, arg2: Internal.PoiManager$Occupancy_, arg3: BlockPos_, arg4: number, arg5: Internal.Random_): Internal.Optional<BlockPos>;
        sectionsToVillage(arg0: Internal.SectionPos_): number;
        find(arg0: Internal.Predicate_<Internal.PoiType_>, arg1: Internal.Predicate_<BlockPos_>, arg2: BlockPos_, arg3: number, arg4: Internal.PoiManager$Occupancy_): Internal.Optional<BlockPos>;
        getFreeTickets(arg0: BlockPos_): number;
        getInSquare(arg0: Internal.Predicate_<Internal.PoiType_>, arg1: BlockPos_, arg2: number, arg3: Internal.PoiManager$Occupancy_): Internal.Stream<Internal.PoiRecord>;
        findClosest(arg0: Internal.Predicate_<Internal.PoiType_>, arg1: Internal.Predicate_<BlockPos_>, arg2: BlockPos_, arg3: number, arg4: Internal.PoiManager$Occupancy_): Internal.Optional<BlockPos>;
        ensureLoadedAndValid(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: number): void;
        tick(arg0: Internal.BooleanSupplier_): void;
        exists(arg0: BlockPos_, arg1: Internal.Predicate_<Internal.PoiType_>): boolean;
        release(arg0: BlockPos_): boolean;
        existsAtPosition(arg0: Internal.PoiType_, arg1: BlockPos_): boolean;
        getInRange(arg0: Internal.Predicate_<Internal.PoiType_>, arg1: BlockPos_, arg2: number, arg3: Internal.PoiManager$Occupancy_): Internal.Stream<Internal.PoiRecord>;
        findAll(arg0: Internal.Predicate_<Internal.PoiType_>, arg1: Internal.Predicate_<BlockPos_>, arg2: BlockPos_, arg3: number, arg4: Internal.PoiManager$Occupancy_): Internal.Stream<BlockPos>;
        remove(arg0: BlockPos_): void;
        readonly static "MAX_VILLAGE_DISTANCE": 6;
        readonly static "VILLAGE_SECTION_SIZE": 1;
    }
    type PoiManager_ = PoiManager;
    interface Optic <Proof, S, T, A, B> {
        upCast(arg0: Internal.Set_<Internal.TypeToken_<any>>, arg1: Internal.TypeToken_<Proof2>): Internal.Optional<Internal.Optic<any, S, T, A, B>>;
        eval(arg0: Internal.App_<any, P>): Internal.Function<Internal.App2<P, A, B>, Internal.App2<P, S, T>>;
        compose(arg0: Internal.Optic_<any, A, B, A1, B1>): Internal.Optic<Proof2, S, T, A1, B1>;
        composeUnchecked(arg0: Internal.Optic_<any, A, B, A1, B1>): Internal.Optic<any, S, T, A1, B1>;
    }
    type Optic_<Proof, S, T, A, B> = Optic<Proof, S, T, A, B>;
    class ScriptFileInfo {
        constructor(p: Internal.ScriptPackInfo_, f: string)
        preload(source: Internal.ScriptSource_): Internal.Throwable;
        getPriority(): number;
        getPackMode(): string;
        getProperty(s: string, def: string): string;
        isIgnored(): boolean;
        get priority(): number
        get packMode(): string
        get ignored(): boolean
        readonly "location": string;
        readonly "pack": Internal.ScriptPackInfo;
        readonly "file": string;
        readonly "id": ResourceLocation;
    }
    type ScriptFileInfo_ = ScriptFileInfo;
    class AdvancementEvent extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.Advancement_)
        getAdvancement(): Internal.Advancement;
        getListenerList(): Internal.ListenerList;
        get advancement(): Internal.Advancement
        get listenerList(): Internal.ListenerList
    }
    type AdvancementEvent_ = AdvancementEvent;
    class PlayerInteractEvent$RightClickBlock extends Internal.PlayerInteractEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Hand_, arg2: BlockPos_, arg3: Internal.BlockHitResult_)
        setUseItem(arg0: Internal.Event$Result_): void;
        setCanceled(arg0: boolean): void;
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        getUseBlock(): Internal.Event$Result;
        setUseBlock(arg0: Internal.Event$Result_): void;
        getUseItem(): Internal.Event$Result;
        getHitVec(): Internal.BlockHitResult;
        set useItem(arg0: Internal.Event$Result_)
        set canceled(arg0: boolean)
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
        get useBlock(): Internal.Event$Result
        set useBlock(arg0: Internal.Event$Result_)
        get useItem(): Internal.Event$Result
        get hitVec(): Internal.BlockHitResult
    }
    type PlayerInteractEvent$RightClickBlock_ = PlayerInteractEvent$RightClickBlock;
    class RenderStateShard$LineStateShard extends Internal.RenderStateShard {
        constructor(arg0: Internal.OptionalDouble_)
        toString(): string;
    }
    type RenderStateShard$LineStateShard_ = RenderStateShard$LineStateShard;
    interface Float2FloatFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleUnaryOperator {
        compose(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        composeFloat(arg0: Internal.Float2FloatFunction_): this;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2FloatFunction;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2FloatFunction;
        getOrDefault(arg0: any, arg1: any): any;
        get(arg0: number): number;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2FloatFunction;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Float2CharFunction;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Float2LongFunction;
        composeObject(arg0: Internal.Object2FloatFunction_<any>): Internal.Object2FloatFunction<T>;
        defaultReturnValue(arg0: number): void;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2FloatFunction;
        containsKey(arg0: any): boolean;
        getOrDefault(arg0: number, arg1: number): number;
        andThenObject(arg0: Internal.Float2ObjectFunction_<any>): Internal.Float2ObjectFunction<T>;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2FloatFunction;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Float2IntFunction;
        put(arg0: any, arg1: any): any;
        containsKey(arg0: number): boolean;
        andThenReference(arg0: Internal.Float2ReferenceFunction_<any>): Internal.Float2ReferenceFunction<T>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        defaultReturnValue(): number;
        remove(arg0: any): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        identity(): this;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Float2ShortFunction;
        applyAsDouble(arg0: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        put(arg0: number, arg1: number): number;
        apply(arg0: number): number;
        composeReference(arg0: Internal.Reference2FloatFunction_<any>): Internal.Reference2FloatFunction<T>;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2FloatFunction;
        size(): number;
        andThen(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        remove(arg0: number): number;
        clear(): void;
        put(arg0: number, arg1: number): number;
        andThenFloat(arg0: Internal.Float2FloatFunction_): this;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Float2DoubleFunction;
        get(arg0: any): any;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Float2ByteFunction;
    }
    type Float2FloatFunction_ = Float2FloatFunction | ((arg0: number)=>number);
    class UnitTokenStream {
        constructor(context: Internal.UnitContext_, input: string)
        peekToken(): Internal.UnitToken;
        readFully(): Internal.UnitToken;
        nextToken(): Internal.UnitToken;
        toString(): string;
        getUnit(): Internal.Unit;
        ifNextToken(token: Internal.UnitToken_): boolean;
        readSingleToken(): Internal.UnitToken;
        get unit(): Internal.Unit
        readonly "context": Internal.UnitContext;
        readonly "input": string;
        readonly "charStream": Internal.CharStream;
        readonly "unit": Internal.Unit;
        readonly "inputStringPos": Internal.ArrayList<number>;
        readonly "infix": Internal.ArrayList<Internal.UnitToken>;
    }
    type UnitTokenStream_ = UnitTokenStream;
    abstract class FloatProvider {
        constructor()
        getMinValue(): number;
        getMaxValue(): number;
        sample(arg0: Internal.Random_): number;
        static codec(arg0: number, arg1: number): Internal.Codec<Internal.FloatProvider>;
        getType(): Internal.FloatProviderType<any>;
        get minValue(): number
        get maxValue(): number
        get type(): Internal.FloatProviderType<any>
        readonly static "CODEC": any;
    }
    type FloatProvider_ = FloatProvider;
    class Event {
        constructor()
        setCanceled(arg0: boolean): void;
        setResult(arg0: Internal.Event$Result_): void;
        hasResult(): boolean;
        getResult(): Internal.Event$Result;
        isCancelable(): boolean;
        setPhase(arg0: Internal.EventPriority_): void;
        getListenerList(): Internal.ListenerList;
        isCanceled(): boolean;
        getPhase(): Internal.EventPriority;
        set canceled(arg0: boolean)
        set result(arg0: Internal.Event$Result_)
        get result(): Internal.Event$Result
        get cancelable(): boolean
        set phase(arg0: Internal.EventPriority_)
        get listenerList(): Internal.ListenerList
        get canceled(): boolean
        get phase(): Internal.EventPriority
    }
    type Event_ = Event;
    class SmokerBlockEntity extends Internal.AbstractFurnaceBlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        stopOpen(arg0: Internal.Player_): void;
        setRecipeUsed(arg0: Internal.Level_, arg1: Internal.ServerPlayer_, arg2: Internal.Recipe_<any>): boolean;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getMaxStackSize(): number;
        countItem(arg0: Internal.Item_): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        startOpen(arg0: Internal.Player_): void;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get modelData(): Internal.IModelData
        get maxStackSize(): number
        get renderBoundingBox(): Internal.AABB
    }
    type SmokerBlockEntity_ = SmokerBlockEntity;
    class MerchantMenu extends Internal.AbstractContainerMenu {
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Merchant_)
        constructor(arg0: number, arg1: Internal.Inventory_)
        canTakeItemForPickAll(arg0: Internal.ItemStack_, arg1: Internal.Slot_): boolean;
        slotsChanged(arg0: Internal.Container_): void;
        getTraderXp(): number;
        setMerchantLevel(arg0: number): void;
        canRestock(): boolean;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        getOffers(): Internal.MerchantOffers;
        tryMoveItems(arg0: number): void;
        stillValid(arg0: Internal.Player_): boolean;
        setSelectionHint(arg0: number): void;
        getTraderLevel(): number;
        setCanRestock(arg0: boolean): void;
        showProgressBar(): boolean;
        setShowProgressBar(arg0: boolean): void;
        setXp(arg0: number): void;
        setOffers(arg0: Internal.MerchantOffers_): void;
        getFutureTraderXp(): number;
        removed(arg0: Internal.Player_): void;
        get traderXp(): number
        set merchantLevel(arg0: number)
        get offers(): Internal.MerchantOffers
        set selectionHint(arg0: number)
        get traderLevel(): number
        set canRestock(arg0: boolean)
        set showProgressBar(arg0: boolean)
        set xp(arg0: number)
        set offers(arg0: Internal.MerchantOffers_)
        get futureTraderXp(): number
    }
    type MerchantMenu_ = MerchantMenu;
    class ServerboundEntityTagQuery implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: number, arg1: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getEntityId(): number;
        getTransactionId(): number;
        isSkippable(): boolean;
        get entityId(): number
        get transactionId(): number
        get skippable(): boolean
    }
    type ServerboundEntityTagQuery_ = ServerboundEntityTagQuery;
    class ModelPart {
        constructor(arg0: Internal.List_<Internal.ModelPart$Cube_>, arg1: Internal.Map_<string, Internal.ModelPart_>)
        render(arg0: Internal.PoseStack_, arg1: Internal.VertexConsumer_, arg2: number, arg3: number): void;
        copyFrom(arg0: Internal.ModelPart_): void;
        render(arg0: Internal.PoseStack_, arg1: Internal.VertexConsumer_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        loadPose(arg0: Internal.PartPose_): void;
        isEmpty(): boolean;
        setPos(arg0: number, arg1: number, arg2: number): void;
        visit(arg0: Internal.PoseStack_, arg1: Internal.ModelPart$Visitor_): void;
        getAllParts(): Internal.Stream<Internal.ModelPart>;
        getRandomCube(arg0: Internal.Random_): Internal.ModelPart$Cube;
        getChild(arg0: string): this;
        setRotation(arg0: number, arg1: number, arg2: number): void;
        translateAndRotate(arg0: Internal.PoseStack_): void;
        storePose(): Internal.PartPose;
        get empty(): boolean
        get allParts(): Internal.Stream<Internal.ModelPart>
        "zRot": number;
        "visible": boolean;
        "z": number;
        "y": number;
        "x": number;
        "yRot": number;
        "xRot": number;
    }
    type ModelPart_ = ModelPart;
    class FenceGateBlockBuilder extends Internal.ShapedBlockBuilder {
        constructor(i: ResourceLocation_)
        createObject(): Internal.Block;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
    }
    type FenceGateBlockBuilder_ = FenceGateBlockBuilder;
    class AdvancementProgress implements Internal.Comparable<Internal.AdvancementProgress> {
        constructor()
        toString(): string;
        grantProgress(arg0: string): boolean;
        getCriterion(arg0: string): Internal.CriterionProgress;
        isDone(): boolean;
        getCompletedCriteria(): Internal.Iterable<string>;
        hasProgress(): boolean;
        compareTo(arg0: any): number;
        update(arg0: Internal.Map_<string, Internal.Criterion_>, arg1: string[][]): void;
        getPercent(): number;
        static fromNetwork(arg0: Internal.FriendlyByteBuf_): Internal.AdvancementProgress;
        revokeProgress(arg0: string): boolean;
        getFirstProgressDate(): Internal.Date;
        getRemainingCriteria(): Internal.Iterable<string>;
        getProgressText(): string;
        compareTo(arg0: Internal.AdvancementProgress_): number;
        serializeToNetwork(arg0: Internal.FriendlyByteBuf_): void;
        get done(): boolean
        get completedCriteria(): Internal.Iterable<string>
        get percent(): number
        get firstProgressDate(): Internal.Date
        get remainingCriteria(): Internal.Iterable<string>
        get progressText(): string
    }
    type AdvancementProgress_ = AdvancementProgress;
    class ItemPickupEventJS extends Internal.PlayerEventJS {
        constructor(player: Internal.Player_, entity: Internal.ItemEntity_, stack: Internal.ItemStack_)
        getEntity(): Internal.EntityJS;
        canCancel(): boolean;
        getItemEntity(): Internal.EntityJS;
        getItem(): Internal.ItemStackJS;
        get entity(): Internal.EntityJS
        get itemEntity(): Internal.EntityJS
        get item(): Internal.ItemStackJS
    }
    type ItemPickupEventJS_ = ItemPickupEventJS;
    class DataVersion {
        constructor(arg0: number, arg1: string)
        constructor(arg0: number)
        isSideSeries(): boolean;
        getSeries(): string;
        isCompatible(arg0: Internal.DataVersion_): boolean;
        getVersion(): number;
        get sideSeries(): boolean
        get series(): string
        get version(): number
        static "MAIN_SERIES": "main";
    }
    type DataVersion_ = DataVersion;
    class PlayerFlyableFallEvent extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: number, arg2: number)
        getMultiplier(): number;
        getListenerList(): Internal.ListenerList;
        setMultiplier(arg0: number): void;
        getDistance(): number;
        setDistance(arg0: number): void;
        get multiplier(): number
        get listenerList(): Internal.ListenerList
        set multiplier(arg0: number)
        get distance(): number
        set distance(arg0: number)
    }
    type PlayerFlyableFallEvent_ = PlayerFlyableFallEvent;
    abstract class ImmutableMap <K, V> implements Internal.Map<K, V>, Internal.Serializable {
        replace(arg0: K, arg1: V): V;
        static of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): Internal.ImmutableMap<K, V>;
        static of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): Internal.ImmutableMap<K, V>;
        static of(arg0: K, arg1: V): Internal.ImmutableMap<K, V>;
        containsValue(arg0: any): boolean;
        static of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): Internal.ImmutableMap<K, V>;
        static ofEntries(...arg0: Internal.Map$Entry_<any, any>[]): Internal.ImmutableMap<K, V>;
        getOrDefault(arg0: any, arg1: V): V;
        static toImmutableMap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Collector<T, any, Internal.ImmutableMap<K, V>>;
        putAll(arg0: Internal.Map_<any, any>): void;
        static of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): Internal.ImmutableMap<K, V>;
        isEmpty(): boolean;
        containsKey(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        replaceAll(arg0: Internal.BiFunction_<any, any, any>): void;
        static of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): Internal.ImmutableMap<K, V>;
        static of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): Internal.ImmutableMap<K, V>;
        static of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): Internal.ImmutableMap<K, V>;
        static of(arg0: K, arg1: V, arg2: K, arg3: V): Internal.ImmutableMap<K, V>;
        get(arg0: any): V;
        static of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): Internal.ImmutableMap<K, V>;
        remove(arg0: any): V;
        compute(arg0: K, arg1: Internal.BiFunction_<any, any, any>): V;
        static toImmutableMap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>, arg2: Internal.BinaryOperator_<V>): Internal.Collector<T, any, Internal.ImmutableMap<K, V>>;
        merge(arg0: K, arg1: V, arg2: Internal.BiFunction_<any, any, any>): V;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<any, any, any>): V;
        asMultimap(): Internal.ImmutableSetMultimap<K, V>;
        values(): Internal.Collection<any>;
        putIfAbsent(arg0: K, arg1: V): V;
        entrySet(): Internal.Set<any>;
        static builderWithExpectedSize(arg0: number): Internal.ImmutableMap$Builder<K, V>;
        toString(): string;
        remove(arg0: any, arg1: any): boolean;
        static copyOf(arg0: Internal.Iterable_<any>): Internal.ImmutableMap<K, V>;
        computeIfAbsent(arg0: K, arg1: Internal.Function_<any, any>): V;
        static of(): Internal.ImmutableMap<K, V>;
        hashCode(): number;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        static copyOf(arg0: Internal.Map_<any, any>): Internal.ImmutableMap<K, V>;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        clear(): void;
        static builder(): Internal.ImmutableMap$Builder<K, V>;
        keySet(): Internal.ImmutableSet<K>;
        equals(arg0: any): boolean;
        get empty(): boolean
    }
    type ImmutableMap_<K, V> = ImmutableMap<K, V>;
    class RemoveSpawnsProperties {
        constructor()
        "mobs": Internal.MobFilter;
        "biomes": Internal.BiomeFilter;
    }
    type RemoveSpawnsProperties_ = RemoveSpawnsProperties;
    class ClientboundSetPlayerTeamPacket$Action extends Internal.Enum<Internal.ClientboundSetPlayerTeamPacket$Action> {
        static values(): Internal.ClientboundSetPlayerTeamPacket$Action[];
        static valueOf(arg0: string): Internal.ClientboundSetPlayerTeamPacket$Action;
        readonly static "REMOVE": Internal.ClientboundSetPlayerTeamPacket$Action;
        readonly static "ADD": Internal.ClientboundSetPlayerTeamPacket$Action;
    }
    type ClientboundSetPlayerTeamPacket$Action_ = "remove" | ClientboundSetPlayerTeamPacket$Action | "add";
    interface Int2ObjectFunction <V> extends Internal.IntFunction<V>, it.unimi.dsi.fastutil.Function<number, V> {
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Int2CharFunction;
        put(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        containsKey(arg0: number): boolean;
        get(arg0: number): V;
        containsKey(arg0: any): boolean;
        put(arg0: number, arg1: V): V;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Int2ByteFunction;
        get(arg0: any): V;
        apply(arg0: number): V;
        put(arg0: any, arg1: any): any;
        apply(arg0: number): V;
        remove(arg0: any): V;
        andThenObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Int2ObjectFunction<T>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
        composeInt(arg0: Internal.Int2IntFunction_): this;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2ObjectFunction<V>;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Int2DoubleFunction;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Int2IntFunction;
        remove(arg0: number): V;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Int2ShortFunction;
        getOrDefault(arg0: number, arg1: V): V;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2ObjectFunction<V>;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Int2FloatFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Int2LongFunction;
        size(): number;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2ObjectFunction<V>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2ObjectFunction<V>;
        clear(): void;
        defaultReturnValue(): V;
        composeObject(arg0: Internal.Object2IntFunction_<any>): Internal.Object2ObjectFunction<T, V>;
        andThenReference(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Int2ReferenceFunction<T>;
        defaultReturnValue(arg0: V): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2ObjectFunction<V>;
        composeReference(arg0: Internal.Reference2IntFunction_<any>): Internal.Reference2ObjectFunction<T, V>;
    }
    type Int2ObjectFunction_<V> = ((arg0: number)=>V) | Int2ObjectFunction<V>;
    class RenderType$OutlineProperty extends Internal.Enum<Internal.RenderType$OutlineProperty> {
        static values(): Internal.RenderType$OutlineProperty[];
        toString(): string;
        static valueOf(arg0: string): Internal.RenderType$OutlineProperty;
        readonly static "NONE": Internal.RenderType$OutlineProperty;
        readonly static "AFFECTS_OUTLINE": Internal.RenderType$OutlineProperty;
        readonly static "IS_OUTLINE": Internal.RenderType$OutlineProperty;
    }
    type RenderType$OutlineProperty_ = RenderType$OutlineProperty | "is_outline" | "affects_outline" | "none";
    abstract class EffectRenderer {
        constructor()
        renderHUDEffect(arg0: Internal.MobEffectInstance_, arg1: Internal.GuiComponent_, arg2: Internal.PoseStack_, arg3: number, arg4: number, arg5: number, arg6: number): void;
        shouldRenderHUD(arg0: Internal.MobEffectInstance_): boolean;
        shouldRender(arg0: Internal.MobEffectInstance_): boolean;
        renderInventoryEffect(arg0: Internal.MobEffectInstance_, arg1: Internal.EffectRenderingInventoryScreen_<any>, arg2: Internal.PoseStack_, arg3: number, arg4: number, arg5: number): void;
        shouldRenderInvText(arg0: Internal.MobEffectInstance_): boolean;
        readonly static "DUMMY": any;
    }
    type EffectRenderer_ = EffectRenderer;
    class SimplePlayerEventJS extends Internal.PlayerEventJS {
        constructor(p: Internal.Player_)
        getEntity(): Internal.EntityJS;
        get entity(): Internal.EntityJS
    }
    type SimplePlayerEventJS_ = SimplePlayerEventJS;
    class ClientboundBlockEntityDataPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getPos(): BlockPos;
        write(arg0: Internal.FriendlyByteBuf_): void;
        static create(arg0: Internal.BlockEntity_, arg1: Internal.Function_<Internal.BlockEntity_, Internal.CompoundTag_>): Internal.ClientboundBlockEntityDataPacket;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getTag(): Internal.CompoundTag;
        isSkippable(): boolean;
        static create(arg0: Internal.BlockEntity_): Internal.ClientboundBlockEntityDataPacket;
        getType(): Internal.BlockEntityType<any>;
        get pos(): BlockPos
        get tag(): Internal.CompoundTag
        get skippable(): boolean
        get type(): Internal.BlockEntityType<any>
    }
    type ClientboundBlockEntityDataPacket_ = ClientboundBlockEntityDataPacket;
    interface App <F, A> {
    }
    type App_<F, A> = App<F, A>;
    class LootTableLoadEvent extends Internal.Event {
        constructor()
        constructor(arg0: ResourceLocation_, arg1: Internal.LootTable_, arg2: Internal.LootTables_)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        getName(): ResourceLocation;
        getLootTableManager(): Internal.LootTables;
        setTable(arg0: Internal.LootTable_): void;
        getTable(): Internal.LootTable;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
        get name(): ResourceLocation
        get lootTableManager(): Internal.LootTables
        set table(arg0: Internal.LootTable_)
        get table(): Internal.LootTable
    }
    type LootTableLoadEvent_ = LootTableLoadEvent;
    class Bee extends Internal.Animal implements Internal.FlyingAnimal, Internal.NeutralMob {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        playerDied(arg0: Internal.Player_): void;
        getTravellingTicks(): number;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        isAngry(): boolean;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): this;
        getStepHeight(): number;
        startPersistentAngerTimer(): void;
        getBlacklistedHives(): Internal.List<BlockPos>;
        hasSavedFlowerPos(): boolean;
        getSavedFlowerPos(): BlockPos;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setRemainingPersistentAngerTime(arg0: number): void;
        setStayOutOfHiveCountdown(arg0: number): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        hasNectar(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        hasHive(): boolean;
        tick(): void;
        getWalkTargetValue(arg0: BlockPos_, arg1: Internal.LevelReader_): number;
        readPersistentAngerSaveData(arg0: Internal.Level_, arg1: Internal.CompoundTag_): void;
        stopBeingAngry(): void;
        alwaysAccepts(): boolean;
        setPersistentAngerTarget(arg0: Internal.UUID_): void;
        getLeashOffset(): Vec3;
        getGoalSelector(): Internal.GoalSelector;
        isFlapping(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        isFlying(): boolean;
        getMobType(): Internal.MobType;
        forgetCurrentTargetAndRefreshUniversalAnger(): void;
        asKJS(): Internal.EntityJS;
        isFood(arg0: Internal.ItemStack_): boolean;
        canRiderInteract(): boolean;
        addPersistentAngerSaveData(arg0: Internal.CompoundTag_): void;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        isAngryAt(arg0: Internal.LivingEntity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getRemainingPersistentAngerTime(): number;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        getPersistentAngerTarget(): Internal.UUID;
        setSavedFlowerPos(arg0: BlockPos_): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        aiStep(): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        dropOffNectar(): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getHivePos(): BlockPos;
        getRollAmount(arg0: number): number;
        updatePersistentAnger(arg0: Internal.ServerLevel_, arg1: boolean): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        isAngryAtAllPlayers(arg0: Internal.Level_): boolean;
        hasStung(): boolean;
        resetTicksWithoutNectarSinceExitingHive(): void;
        get travellingTicks(): number
        get angry(): boolean
        get stepHeight(): number
        get blacklistedHives(): Internal.List<BlockPos>
        get savedFlowerPos(): BlockPos
        set remainingPersistentAngerTime(arg0: number)
        set stayOutOfHiveCountdown(arg0: number)
        set persistentAngerTarget(arg0: Internal.UUID_)
        get leashOffset(): Vec3
        get goalSelector(): Internal.GoalSelector
        get flapping(): boolean
        get flying(): boolean
        get mobType(): Internal.MobType
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get remainingPersistentAngerTime(): number
        get persistentAngerTarget(): Internal.UUID
        set savedFlowerPos(arg0: BlockPos_)
        get hivePos(): BlockPos
        readonly static "TAG_TICKS_SINCE_POLLINATION": "TicksSincePollination";
        readonly static "TAG_HAS_NECTAR": "HasNectar";
        readonly static "TAG_CANNOT_ENTER_HIVE_TICKS": "CannotEnterHiveTicks";
        readonly static "TICKS_PER_FLAP": 2;
        readonly static "TAG_FLOWER_POS": "FlowerPos";
        readonly static "FLAP_DEGREES_PER_TICK": 120.32113;
        readonly static "TAG_HIVE_POS": "HivePos";
        readonly static "TAG_HAS_STUNG": "HasStung";
        readonly static "TAG_CROPS_GROWN_SINCE_POLLINATION": "CropsGrownSincePollination";
    }
    type Bee_ = Bee;
    interface ClientAdvancements$Listener extends Internal.AdvancementList$Listener {
        onSelectedTabChanged(arg0: Internal.Advancement_): void;
        onUpdateAdvancementProgress(arg0: Internal.Advancement_, arg1: Internal.AdvancementProgress_): void;
    }
    type ClientAdvancements$Listener_ = ClientAdvancements$Listener;
    class ParsePosition {
        constructor(arg0: number)
        hashCode(): number;
        toString(): string;
        setErrorIndex(arg0: number): void;
        getErrorIndex(): number;
        getIndex(): number;
        equals(arg0: any): boolean;
        setIndex(arg0: number): void;
        set errorIndex(arg0: number)
        get errorIndex(): number
        get index(): number
        set index(arg0: number)
    }
    type ParsePosition_ = ParsePosition;
    class ServerStartingEvent extends Internal.ServerLifecycleEvent {
        constructor()
        constructor(arg0: Internal.MinecraftServer_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ServerStartingEvent_ = ServerStartingEvent;
    class SoundEvent$SoundSourceEvent extends net.minecraftforge.client.event.sound.SoundEvent {
        constructor()
        constructor(arg0: Internal.SoundEngine_, arg1: Internal.SoundInstance_, arg2: com.mojang.blaze3d.audio.Channel_)
        getChannel(): com.mojang.blaze3d.audio.Channel;
        getSound(): Internal.SoundInstance;
        getName(): string;
        getListenerList(): Internal.ListenerList;
        get channel(): com.mojang.blaze3d.audio.Channel
        get sound(): Internal.SoundInstance
        get name(): string
        get listenerList(): Internal.ListenerList
    }
    type SoundEvent$SoundSourceEvent_ = SoundEvent$SoundSourceEvent;
    class FrameType extends Internal.Enum<Internal.FrameType> {
        getDisplayName(): Internal.Component;
        static valueOf(arg0: string): Internal.FrameType;
        getName(): string;
        static byName(arg0: string): Internal.FrameType;
        getTexture(): number;
        static values(): Internal.FrameType[];
        getChatColor(): Internal.ChatFormatting;
        get displayName(): Internal.Component
        get name(): string
        get texture(): number
        get chatColor(): Internal.ChatFormatting
        readonly static "TASK": Internal.FrameType;
        readonly static "CHALLENGE": Internal.FrameType;
        readonly static "GOAL": Internal.FrameType;
    }
    type FrameType_ = "challenge" | FrameType | "goal" | "task";
    class BlackstoneReplaceProcessor extends Internal.StructureProcessor {
        processBlock(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.StructureTemplate$StructureBlockInfo_, arg4: Internal.StructureTemplate$StructureBlockInfo_, arg5: Internal.StructurePlaceSettings_): Internal.StructureTemplate$StructureBlockInfo;
        readonly static "INSTANCE": Internal.BlackstoneReplaceProcessor;
        readonly static "CODEC": any;
    }
    type BlackstoneReplaceProcessor_ = BlackstoneReplaceProcessor;
    interface IEventHandler {
        onEvent(arg0: Internal.EventJS_): void;
    }
    type IEventHandler_ = ((arg0: Internal.EventJS)=>void) | IEventHandler;
    class ImmutableMultiset$Builder <E> extends Internal.ImmutableCollection$Builder<E> {
        constructor()
        add(arg0: any[]): Internal.ImmutableCollection$Builder<any>;
        addAll(arg0: Internal.Iterator_<any>): Internal.ImmutableCollection$Builder<any>;
        addCopies(arg0: E, arg1: number): this;
        setCount(arg0: E, arg1: number): this;
        addAll(arg0: Internal.Iterable_<any>): Internal.ImmutableCollection$Builder<any>;
        build(): Internal.ImmutableCollection<any>;
        add(arg0: any): Internal.ImmutableCollection$Builder<any>;
    }
    type ImmutableMultiset$Builder_<E> = ImmutableMultiset$Builder<E>;
    class PlayerInteractEvent$EntityInteractSpecific extends Internal.PlayerInteractEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Hand_, arg2: Internal.Entity_, arg3: Vec3_)
        getLocalPos(): Vec3;
        getTarget(): Internal.Entity;
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get localPos(): Vec3
        get target(): Internal.Entity
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type PlayerInteractEvent$EntityInteractSpecific_ = PlayerInteractEvent$EntityInteractSpecific;
    class ShapelessRecipe implements Internal.CraftingRecipe {
        constructor(arg0: ResourceLocation_, arg1: string, arg2: Internal.ItemStack_, arg3: Internal.NonNullList_<Internal.Ingredient_>)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        isSpecial(): boolean;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        matches(arg0: Internal.CraftingContainer_, arg1: Internal.Level_): boolean;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        getSerializer(): Internal.RecipeSerializer<any>;
        getId(): ResourceLocation;
        isIncomplete(): boolean;
        assemble(arg0: Internal.CraftingContainer_): Internal.ItemStack;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getResultItem(): Internal.ItemStack;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get special(): boolean
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get serializer(): Internal.RecipeSerializer<any>
        get id(): ResourceLocation
        get incomplete(): boolean
        get resultItem(): Internal.ItemStack
        readonly "ingredients": Internal.NonNullList<Internal.Ingredient>;
        readonly "result": Internal.ItemStack;
        readonly "group": string;
    }
    type ShapelessRecipe_ = ShapelessRecipe;
    class LootContextParam <T> {
        constructor(arg0: ResourceLocation_)
        toString(): string;
        getName(): ResourceLocation;
        get name(): ResourceLocation
    }
    type LootContextParam_<T> = LootContextParam<T>;
    abstract class ClientboundPlayerInfoPacket$Action extends Internal.Enum<Internal.ClientboundPlayerInfoPacket$Action> {
        static values(): Internal.ClientboundPlayerInfoPacket$Action[];
        static valueOf(arg0: string): Internal.ClientboundPlayerInfoPacket$Action;
        readonly static "REMOVE_PLAYER": any;
        readonly static "UPDATE_DISPLAY_NAME": any;
        readonly static "UPDATE_LATENCY": any;
        readonly static "UPDATE_GAME_MODE": any;
        readonly static "ADD_PLAYER": any;
    }
    type ClientboundPlayerInfoPacket$Action_ = "update_game_mode" | "update_display_name" | "update_latency" | ClientboundPlayerInfoPacket$Action | "remove_player" | "add_player";
    abstract class PalettedContainer$Strategy {
        size(): number;
        getConfiguration(arg0: Internal.IdMap_<A>, arg1: number): Internal.PalettedContainer$Configuration<A>;
        getIndex(arg0: number, arg1: number, arg2: number): number;
        readonly static "HASHMAP_PALETTE_FACTORY": any;
        readonly static "LINEAR_PALETTE_FACTORY": any;
        readonly static "SINGLE_VALUE_PALETTE_FACTORY": any;
        readonly static "SECTION_BIOMES": any;
        readonly static "SECTION_STATES": any;
    }
    type PalettedContainer$Strategy_ = PalettedContainer$Strategy;
    abstract class StateTestingPredicate implements net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate {
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: any, arg1: any): boolean;
        negate(): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: Internal.WorldGenLevel_, arg1: BlockPos_): boolean;
    }
    type StateTestingPredicate_ = StateTestingPredicate;
    class PlayerRenderer extends Internal.LivingEntityRenderer<Internal.AbstractClientPlayer, any> {
        constructor(arg0: any_, arg1: boolean)
        renderLeftHand(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource_, arg2: number, arg3: Internal.AbstractClientPlayer_): void;
        render(arg0: Internal.LivingEntity_, arg1: number, arg2: number, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number): void;
        render(arg0: Internal.AbstractClientPlayer_, arg1: number, arg2: number, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number): void;
        render(arg0: Internal.Entity_, arg1: number, arg2: number, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number): void;
        getTextureLocation(arg0: Internal.Entity_): ResourceLocation;
        renderRightHand(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource_, arg2: number, arg3: Internal.AbstractClientPlayer_): void;
        getTextureLocation(arg0: Internal.AbstractClientPlayer_): ResourceLocation;
        getRenderOffset(arg0: Internal.AbstractClientPlayer_, arg1: number): Vec3;
        getRenderOffset(arg0: Internal.Entity_, arg1: number): Vec3;
    }
    type PlayerRenderer_ = PlayerRenderer;
    class GameRules$Type <T> {
        callVisitor(arg0: Internal.GameRules$GameRuleTypeVisitor_, arg1: Internal.GameRules$Key_<T>): void;
        createRule(): T;
        createArgument(arg0: string): Internal.RequiredArgumentBuilder<Internal.CommandSourceStack, any>;
    }
    type GameRules$Type_<T> = GameRules$Type<T>;
    class Material {
        constructor(arg0: Internal.MaterialColor_, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean, arg7: Internal.PushReaction_)
        isReplaceable(): boolean;
        isSolid(): boolean;
        isSolidBlocking(): boolean;
        blocksMotion(): boolean;
        isLiquid(): boolean;
        getColor(): Internal.MaterialColor;
        isFlammable(): boolean;
        getPushReaction(): Internal.PushReaction;
        get replaceable(): boolean
        get solid(): boolean
        get solidBlocking(): boolean
        get liquid(): boolean
        get color(): Internal.MaterialColor
        get flammable(): boolean
        get pushReaction(): Internal.PushReaction
        readonly static "SCULK": Internal.Material;
        readonly static "HEAVY_METAL": Internal.Material;
        readonly static "PLANT": Internal.Material;
        readonly static "SPONGE": Internal.Material;
        readonly static "WATER_PLANT": Internal.Material;
        readonly static "WOOL": Internal.Material;
        readonly static "REPLACEABLE_PLANT": Internal.Material;
        readonly static "ICE_SOLID": Internal.Material;
        readonly static "BUBBLE_COLUMN": Internal.Material;
        readonly static "WOOD": Internal.Material;
        readonly static "STONE": Internal.Material;
        readonly static "STRUCTURAL_AIR": Internal.Material;
        readonly static "REPLACEABLE_FIREPROOF_PLANT": Internal.Material;
        readonly static "LAVA": Internal.Material;
        readonly static "AMETHYST": Internal.Material;
        readonly static "NETHER_WOOD": Internal.Material;
        readonly static "DECORATION": Internal.Material;
        readonly static "BAMBOO_SAPLING": Internal.Material;
        readonly static "EXPLOSIVE": Internal.Material;
        readonly static "CACTUS": Internal.Material;
        readonly static "DIRT": Internal.Material;
        readonly static "LEAVES": Internal.Material;
        readonly static "BAMBOO": Internal.Material;
        readonly static "SAND": Internal.Material;
        readonly static "AIR": Internal.Material;
        readonly static "CLOTH_DECORATION": Internal.Material;
        readonly static "GRASS": Internal.Material;
        readonly static "SHULKER_SHELL": Internal.Material;
        readonly static "WEB": Internal.Material;
        readonly static "TOP_SNOW": Internal.Material;
        readonly static "PISTON": Internal.Material;
        readonly static "EGG": Internal.Material;
        readonly static "REPLACEABLE_WATER_PLANT": Internal.Material;
        readonly static "PORTAL": Internal.Material;
        readonly static "MOSS": Internal.Material;
        readonly static "ICE": Internal.Material;
        readonly static "BARRIER": Internal.Material;
        readonly static "GLASS": Internal.Material;
        readonly static "FIRE": Internal.Material;
        readonly static "WATER": Internal.Material;
        readonly static "VEGETABLE": Internal.Material;
        readonly static "POWDER_SNOW": Internal.Material;
        readonly static "CLAY": Internal.Material;
        readonly static "CAKE": Internal.Material;
        readonly static "BUILDABLE_GLASS": Internal.Material;
        readonly static "SNOW": Internal.Material;
        readonly static "METAL": Internal.Material;
    }
    type Material_ = Material;
    interface ChannelFuture extends io.netty.util.concurrent.Future<void> {
        channel(): io.netty.channel.Channel;
        removeListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        isVoid(): boolean;
        await(): this;
        addListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        removeListener(arg0: Internal.GenericFutureListener_<any>): this;
        syncUninterruptibly(): this;
        addListener(arg0: Internal.GenericFutureListener_<any>): this;
        sync(): this;
        awaitUninterruptibly(): this;
        get void(): boolean
    }
    type ChannelFuture_ = ChannelFuture;
    class BeeDebugRenderer implements Internal.DebugRenderer$SimpleDebugRenderer {
        constructor(arg0: Internal.Minecraft_)
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource_, arg2: number, arg3: number, arg4: number): void;
        removeBeeInfo(arg0: number): void;
        addOrUpdateHiveInfo(arg0: Internal.BeeDebugRenderer$HiveInfo_): void;
        clear(): void;
        addOrUpdateBeeInfo(arg0: Internal.BeeDebugRenderer$BeeInfo_): void;
    }
    type BeeDebugRenderer_ = BeeDebugRenderer;
    abstract class HitResult {
        distanceTo(arg0: Internal.Entity_): number;
        getLocation(): Vec3;
        getType(): Internal.HitResult$Type;
        get location(): Vec3
        get type(): Internal.HitResult$Type
    }
    type HitResult_ = HitResult;
    interface Float2ObjectFunction <V> extends Internal.DoubleFunction<V>, it.unimi.dsi.fastutil.Function<number, V> {
        andThenReference(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Float2ReferenceFunction<T>;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Float2FloatFunction;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2ObjectFunction<V>;
        getOrDefault(arg0: any, arg1: V): V;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2ObjectFunction<V>;
        andThenObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Float2ObjectFunction<T>;
        composeObject(arg0: Internal.Object2FloatFunction_<any>): Internal.Object2ObjectFunction<T, V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Float2CharFunction;
        getOrDefault(arg0: number, arg1: V): V;
        put(arg0: number, arg1: V): V;
        composeReference(arg0: Internal.Reference2FloatFunction_<any>): Internal.Reference2ObjectFunction<T, V>;
        containsKey(arg0: any): boolean;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Float2ByteFunction;
        get(arg0: any): V;
        put(arg0: any, arg1: any): any;
        remove(arg0: number): V;
        remove(arg0: any): V;
        composeFloat(arg0: Internal.Float2FloatFunction_): this;
        get(arg0: number): V;
        containsKey(arg0: number): boolean;
        apply(arg0: number): V;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
        apply(arg0: number): V;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Float2IntFunction;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Float2LongFunction;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Float2ShortFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Float2DoubleFunction;
        size(): number;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2ObjectFunction<V>;
        clear(): void;
        defaultReturnValue(): V;
        put(arg0: number, arg1: V): V;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2ObjectFunction<V>;
        defaultReturnValue(arg0: V): void;
    }
    type Float2ObjectFunction_<V> = ((arg0: number)=>V) | Float2ObjectFunction<V>;
    class DateFormatSymbols implements Internal.Cloneable, Internal.Serializable {
        constructor()
        constructor(arg0: Internal.Locale_)
        clone(): any;
        getShortWeekdays(): string[];
        getLocalPatternChars(): string;
        getShortMonths(): string[];
        static getInstance(arg0: Internal.Locale_): Internal.DateFormatSymbols;
        setEras(arg0: string[]): void;
        setMonths(arg0: string[]): void;
        setShortMonths(arg0: string[]): void;
        getWeekdays(): string[];
        getAmPmStrings(): string[];
        setLocalPatternChars(arg0: string): void;
        static getAvailableLocales(): Internal.Locale[];
        setAmPmStrings(arg0: string[]): void;
        setWeekdays(arg0: string[]): void;
        setZoneStrings(arg0: string[][]): void;
        hashCode(): number;
        getEras(): string[];
        setShortWeekdays(arg0: string[]): void;
        equals(arg0: any): boolean;
        getZoneStrings(): string[][];
        static getInstance(): Internal.DateFormatSymbols;
        getMonths(): string[];
        get shortWeekdays(): string[]
        get localPatternChars(): string
        get shortMonths(): string[]
        set eras(arg0: string[])
        set months(arg0: string[])
        set shortMonths(arg0: string[])
        get weekdays(): string[]
        get amPmStrings(): string[]
        set localPatternChars(arg0: string)
        get availableLocales(): Internal.Locale[]
        set amPmStrings(arg0: string[])
        set weekdays(arg0: string[])
        set zoneStrings(arg0: string[][])
        get eras(): string[]
        set shortWeekdays(arg0: string[])
        get zoneStrings(): string[][]
        get instance(): Internal.DateFormatSymbols
        get months(): string[]
    }
    type DateFormatSymbols_ = DateFormatSymbols;
    class LivingEvent$LivingUpdateEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.LivingEntity_)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type LivingEvent$LivingUpdateEvent_ = LivingEvent$LivingUpdateEvent;
    class EntryGroup$Builder extends Internal.LootPoolEntryContainer$Builder<Internal.EntryGroup$Builder> {
        constructor(...arg0: Internal.LootPoolEntryContainer$Builder_<any>[])
        build(): Internal.LootPoolEntryContainer;
        append(arg0: Internal.LootPoolEntryContainer$Builder_<any>): this;
    }
    type EntryGroup$Builder_ = EntryGroup$Builder;
    interface VillagerDataHolder {
        setVillagerData(arg0: Internal.VillagerData_): void;
        getVillagerData(): Internal.VillagerData;
        set villagerData(arg0: Internal.VillagerData_)
        get villagerData(): Internal.VillagerData
    }
    type VillagerDataHolder_ = VillagerDataHolder;
    interface Byte2BooleanFunction extends it.unimi.dsi.fastutil.Function<number, boolean>, Internal.IntPredicate {
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Byte2ShortFunction;
        getOrDefault(arg0: any, arg1: any): any;
        or(arg0: Internal.IntPredicate_): Internal.IntPredicate;
        negate(): Internal.IntPredicate;
        composeByte(arg0: Internal.Byte2ByteFunction_): this;
        remove(arg0: number): boolean;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2BooleanFunction;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Byte2ByteFunction;
        containsKey(arg0: any): boolean;
        get(arg0: any): boolean;
        andThenReference(arg0: Internal.Boolean2ReferenceFunction_<any>): Internal.Byte2ReferenceFunction<T>;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2BooleanFunction;
        put(arg0: number, arg1: boolean): boolean;
        put(arg0: any, arg1: any): any;
        containsKey(arg0: number): boolean;
        put(arg0: number, arg1: boolean): boolean;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Byte2IntFunction;
        defaultReturnValue(): boolean;
        andThenObject(arg0: Internal.Boolean2ObjectFunction_<any>): Internal.Byte2ObjectFunction<T>;
        and(arg0: Internal.IntPredicate_): Internal.IntPredicate;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Byte2DoubleFunction;
        get(arg0: number): boolean;
        getOrDefault(arg0: any, arg1: boolean): boolean;
        composeReference(arg0: Internal.Reference2ByteFunction_<any>): Internal.Reference2BooleanFunction<T>;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Byte2CharFunction;
        test(arg0: number): boolean;
        composeObject(arg0: Internal.Object2ByteFunction_<any>): Internal.Object2BooleanFunction<T>;
        getOrDefault(arg0: number, arg1: boolean): boolean;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2BooleanFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, boolean>;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Byte2FloatFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        size(): number;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2BooleanFunction;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Byte2LongFunction;
        clear(): void;
        apply(arg0: number): boolean;
        remove(arg0: any): any;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2BooleanFunction;
        defaultReturnValue(arg0: boolean): void;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2BooleanFunction;
    }
    type Byte2BooleanFunction_ = ((arg0: number)=>boolean) | Byte2BooleanFunction;
    class ZonedDateTime implements Internal.ChronoZonedDateTime<Internal.LocalDate>, Internal.Temporal, Internal.Serializable {
        getHour(): number;
        getMonth(): Internal.Month;
        toLocalTime(): Internal.LocalTime;
        isAfter(arg0: Internal.ChronoZonedDateTime_<any>): boolean;
        minus(arg0: number, arg1: Internal.TemporalUnit_): this;
        withDayOfMonth(arg0: number): this;
        toInstant(): Internal.Instant;
        withLaterOffsetAtOverlap(): this;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Temporal;
        getDayOfWeek(): Internal.DayOfWeek;
        static ofLocal(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneId_, arg2: Internal.ZoneOffset_): Internal.ZonedDateTime;
        compareTo(arg0: any): number;
        withMonth(arg0: number): this;
        withZoneSameLocal(arg0: Internal.ZoneId_): Internal.ChronoZonedDateTime<any>;
        withMinute(arg0: number): this;
        getMinute(): number;
        withFixedOffsetZone(): this;
        minusWeeks(arg0: number): this;
        getDayOfMonth(): number;
        withDayOfYear(arg0: number): this;
        plusSeconds(arg0: number): this;
        plusYears(arg0: number): this;
        plusMinutes(arg0: number): this;
        with(arg0: Internal.TemporalAdjuster_): Internal.Temporal;
        plusDays(arg0: number): this;
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneId_): Internal.ZonedDateTime;
        minusDays(arg0: number): this;
        static ofStrict(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneOffset_, arg2: Internal.ZoneId_): Internal.ZonedDateTime;
        withYear(arg0: number): this;
        compareTo(arg0: Internal.ChronoZonedDateTime_<any>): number;
        isSupported(arg0: Internal.TemporalField_): boolean;
        format(arg0: Internal.DateTimeFormatter_): string;
        getChronology(): Internal.Chronology;
        minusSeconds(arg0: number): this;
        getYear(): number;
        isBefore(arg0: Internal.ChronoZonedDateTime_<any>): boolean;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        get(arg0: Internal.TemporalField_): number;
        static parse(arg0: Internal.CharSequence_, arg1: Internal.DateTimeFormatter_): Internal.ZonedDateTime;
        static now(arg0: Internal.ZoneId_): Internal.ZonedDateTime;
        minusMonths(arg0: number): this;
        toEpochSecond(): number;
        withSecond(arg0: number): this;
        static ofInstant(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.ZonedDateTime;
        getMonthValue(): number;
        static from(arg0: Internal.TemporalAccessor_): Internal.ZonedDateTime;
        static of(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneId_): Internal.ZonedDateTime;
        toLocalDate(): Internal.LocalDate;
        plusMonths(arg0: number): this;
        minusNanos(arg0: number): this;
        static now(): Internal.ZonedDateTime;
        plusNanos(arg0: number): this;
        getZone(): Internal.ZoneId;
        static ofInstant(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneOffset_, arg2: Internal.ZoneId_): Internal.ZonedDateTime;
        with(arg0: Internal.TemporalField_, arg1: number): this;
        getLong(arg0: Internal.TemporalField_): number;
        withHour(arg0: number): this;
        withEarlierOffsetAtOverlap(): Internal.ChronoZonedDateTime<any>;
        minusHours(arg0: number): this;
        withNano(arg0: number): this;
        getOffset(): Internal.ZoneOffset;
        toString(): string;
        isEqual(arg0: Internal.ChronoZonedDateTime_<any>): boolean;
        getDayOfYear(): number;
        query(arg0: Internal.TemporalQuery_<R>): R;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        static of(arg0: Internal.LocalDate_, arg1: Internal.LocalTime_, arg2: Internal.ZoneId_): Internal.ZonedDateTime;
        getNano(): number;
        minusMinutes(arg0: number): this;
        getSecond(): number;
        toLocalDateTime(): Internal.ChronoLocalDateTime<any>;
        plusHours(arg0: number): this;
        plus(arg0: Internal.TemporalAmount_): Internal.Temporal;
        static parse(arg0: Internal.CharSequence_): Internal.ZonedDateTime;
        hashCode(): number;
        minusYears(arg0: number): this;
        truncatedTo(arg0: Internal.TemporalUnit_): this;
        static now(arg0: Internal.Clock_): Internal.ZonedDateTime;
        plusWeeks(arg0: number): this;
        toOffsetDateTime(): Internal.OffsetDateTime;
        equals(arg0: any): boolean;
        minus(arg0: Internal.TemporalAmount_): Internal.Temporal;
        withZoneSameInstant(arg0: Internal.ZoneId_): Internal.ChronoZonedDateTime<any>;
        get hour(): number
        get month(): Internal.Month
        get dayOfWeek(): Internal.DayOfWeek
        get minute(): number
        get dayOfMonth(): number
        get chronology(): Internal.Chronology
        get year(): number
        get monthValue(): number
        get zone(): Internal.ZoneId
        get offset(): Internal.ZoneOffset
        get dayOfYear(): number
        get nano(): number
        get second(): number
    }
    type ZonedDateTime_ = ZonedDateTime;
    abstract class Record {
        hashCode(): number;
        toString(): string;
        equals(arg0: any): boolean;
    }
    type Record_ = Record;
    abstract class AbstractEventExecutorGroup implements Internal.EventExecutorGroup {
        constructor()
        scheduleAtFixedRate(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        scheduleWithFixedDelay(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        shutdownNow(): Internal.List<Internal.Runnable>;
        invokeAny(arg0: Internal.Collection_<any>, arg1: number, arg2: Internal.TimeUnit_): T;
        forEach(arg0: Internal.Consumer_<any>): void;
        submit(arg0: Internal.Runnable_, arg1: any): Internal.Future<any>;
        schedule(arg0: Internal.Runnable_, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        shutdownGracefully(): io.netty.util.concurrent.Future<any>;
        invokeAll(arg0: Internal.Collection_<any>, arg1: number, arg2: Internal.TimeUnit_): Internal.List<Internal.Future<T>>;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        invokeAll(arg0: Internal.Collection_<any>): Internal.List<Internal.Future<T>>;
        shutdown(): void;
        submit(arg0: Internal.Callable_<any>): Internal.Future<any>;
        submit(arg0: Internal.Runnable_): Internal.Future<any>;
        execute(arg0: Internal.Runnable_): void;
        invokeAny(arg0: Internal.Collection_<any>): T;
        schedule(arg0: Internal.Callable_<any>, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
    }
    type AbstractEventExecutorGroup_ = AbstractEventExecutorGroup;
    interface Boolean2ShortFunction extends it.unimi.dsi.fastutil.Function<boolean, number> {
        composeReference(arg0: Internal.Reference2BooleanFunction_<any>): Internal.Reference2ShortFunction<T>;
        getOrDefault(arg0: any, arg1: any): any;
        remove(arg0: any): number;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Boolean2ByteFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2ShortFunction;
        andThenObject(arg0: Internal.Short2ObjectFunction_<any>): Internal.Boolean2ObjectFunction<T>;
        put(arg0: boolean, arg1: number): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): this;
        containsKey(arg0: any): boolean;
        get(arg0: any): number;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Boolean2DoubleFunction;
        apply(arg0: boolean): number;
        defaultReturnValue(): number;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Boolean2IntFunction;
        get(arg0: boolean): number;
        put(arg0: any, arg1: any): any;
        remove(arg0: boolean): number;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Boolean2LongFunction;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2ShortFunction;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2ShortFunction;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Boolean2FloatFunction;
        andThenReference(arg0: Internal.Short2ReferenceFunction_<any>): Internal.Boolean2ReferenceFunction<T>;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2ShortFunction;
        composeObject(arg0: Internal.Object2BooleanFunction_<any>): Internal.Object2ShortFunction<T>;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2ShortFunction;
        put(arg0: boolean, arg1: number): number;
        getOrDefault(arg0: boolean, arg1: number): number;
        containsKey(arg0: boolean): boolean;
        size(): number;
        defaultReturnValue(arg0: number): void;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<boolean, T>;
        clear(): void;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2ShortFunction;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2ShortFunction;
        getOrDefault(arg0: any, arg1: number): number;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Boolean2CharFunction;
    }
    type Boolean2ShortFunction_ = Boolean2ShortFunction | ((arg0: boolean)=>number);
    interface DensityFunction$ContextProvider {
        forIndex(arg0: number): Internal.DensityFunction$FunctionContext;
        fillAllDirectly(arg0: number[], arg1: Internal.DensityFunction_): void;
    }
    type DensityFunction$ContextProvider_ = DensityFunction$ContextProvider;
    abstract class BanListEntry <T> extends Internal.StoredUserEntry<T> {
        constructor(arg0: T, arg1: Internal.Date_, arg2: string, arg3: Internal.Date_, arg4: string)
        getDisplayName(): Internal.Component;
        getExpires(): Internal.Date;
        getSource(): string;
        getCreated(): Internal.Date;
        getReason(): string;
        get displayName(): Internal.Component
        get expires(): Internal.Date
        get source(): string
        get created(): Internal.Date
        get reason(): string
        readonly static "EXPIRES_NEVER": "forever";
        readonly static "DATE_FORMAT": Internal.SimpleDateFormat;
    }
    type BanListEntry_<T> = BanListEntry<T>;
    class MathContext implements Internal.Serializable {
        constructor(arg0: number)
        constructor(arg0: number, arg1: Internal.RoundingMode_)
        constructor(arg0: string)
        hashCode(): number;
        getPrecision(): number;
        toString(): string;
        equals(arg0: any): boolean;
        getRoundingMode(): Internal.RoundingMode;
        get precision(): number
        get roundingMode(): Internal.RoundingMode
        readonly static "DECIMAL128": Internal.MathContext;
        readonly static "UNLIMITED": Internal.MathContext;
        readonly static "DECIMAL32": Internal.MathContext;
        readonly static "DECIMAL64": Internal.MathContext;
    }
    type MathContext_ = MathContext;
    class EntityDataAccessor <T> {
        constructor(arg0: number, arg1: Internal.EntityDataSerializer_<T>)
        hashCode(): number;
        toString(): string;
        equals(arg0: any): boolean;
        getId(): number;
        getSerializer(): Internal.EntityDataSerializer<T>;
        get id(): number
        get serializer(): Internal.EntityDataSerializer<T>
    }
    type EntityDataAccessor_<T> = EntityDataAccessor<T>;
    class Potion extends Internal.ForgeRegistryEntry<Internal.Potion> {
        constructor(arg0: string, ...arg1: Internal.MobEffectInstance_[])
        constructor(...arg0: Internal.MobEffectInstance_[])
        getEffects(): Internal.List<Internal.MobEffectInstance>;
        hasInstantEffects(): boolean;
        static byName(arg0: string): Internal.Potion;
        getName(arg0: string): string;
        get effects(): Internal.List<Internal.MobEffectInstance>
    }
    type Potion_ = Potion | Special.Potion;
    interface ContextFactory$Listener {
        contextCreated(arg0: Internal.Context_): void;
        contextReleased(arg0: Internal.Context_): void;
    }
    type ContextFactory$Listener_ = ContextFactory$Listener;
    abstract class ZoneId implements Internal.Serializable {
        static of(arg0: string): Internal.ZoneId;
        toString(): string;
        static ofOffset(arg0: string, arg1: Internal.ZoneOffset_): Internal.ZoneId;
        getId(): string;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        static from(arg0: Internal.TemporalAccessor_): Internal.ZoneId;
        static systemDefault(): Internal.ZoneId;
        hashCode(): number;
        getRules(): Internal.ZoneRules;
        static getAvailableZoneIds(): Internal.Set<string>;
        static of(arg0: string, arg1: Internal.Map_<string, string>): Internal.ZoneId;
        equals(arg0: any): boolean;
        normalized(): this;
        get id(): string
        get rules(): Internal.ZoneRules
        get availableZoneIds(): Internal.Set<string>
        readonly static "SHORT_IDS": {"PNT": "America/Phoenix", "EST": "-05:00", "EAT": "Africa/Addis_Ababa", "ECT": "Europe/Paris", "PRT": "America/Puerto_Rico", "CTT": "Asia/Shanghai", "SST": "Pacific/Guadalcanal", "MST": "-07:00", "AST": "America/Anchorage", "NST": "Pacific/Auckland", "HST": "-10:00", "ACT": "Australia/Darwin", "BST": "Asia/Dhaka", "AET": "Australia/Sydney", "IST": "Asia/Kolkata", "CST": "America/Chicago", "NET": "Asia/Yerevan", "AGT": "America/Argentina/Buenos_Aires", "CAT": "Africa/Harare", "MIT": "Pacific/Apia", "BET": "America/Sao_Paulo", "PST": "America/Los_Angeles", "ART": "Africa/Cairo", "JST": "Asia/Tokyo", "VST": "Asia/Ho_Chi_Minh", "IET": "America/Indiana/Indianapolis", "CNT": "America/St_Johns", "PLT": "Asia/Karachi"};
    }
    type ZoneId_ = ZoneId;
    class DoubleBlockHalf extends Internal.Enum<Internal.DoubleBlockHalf> implements Internal.StringRepresentable {
        static values(): Internal.DoubleBlockHalf[];
        toString(): string;
        static valueOf(arg0: string): Internal.DoubleBlockHalf;
        getSerializedName(): string;
        get serializedName(): string
        readonly static "UPPER": Internal.DoubleBlockHalf;
        readonly static "LOWER": Internal.DoubleBlockHalf;
    }
    type DoubleBlockHalf_ = "lower" | DoubleBlockHalf | "upper";
    class PlayerTabOverlay extends Internal.GuiComponent {
        constructor(arg0: Internal.Minecraft_, arg1: Internal.Gui_)
        setFooter(arg0: Internal.Component_): void;
        setHeader(arg0: Internal.Component_): void;
        getNameForDisplay(arg0: Internal.PlayerInfo_): Internal.Component;
        render(arg0: Internal.PoseStack_, arg1: number, arg2: Internal.Scoreboard_, arg3: Internal.Objective_): void;
        reset(): void;
        setVisible(arg0: boolean): void;
        set footer(arg0: Internal.Component_)
        set header(arg0: Internal.Component_)
        set visible(arg0: boolean)
        readonly static "HEART_GOLDEN_FULL": 160;
        readonly static "HEART_EMPTY_CONTAINER": 16;
        readonly static "HEART_GHOST_HALF_FULL": 79;
        readonly static "MAX_ROWS_PER_COL": 20;
        readonly static "HEART_GHOST_FULL": 70;
        readonly static "HEART_GOLDEN_HALF_FULL": 169;
        readonly static "HEART_EMPTY_CONTAINER_BLINKING": 25;
        readonly static "HEART_HALF_FULL": 61;
        readonly static "HEART_FULL": 52;
    }
    type PlayerTabOverlay_ = PlayerTabOverlay;
    class GolemSensor extends Internal.Sensor<Internal.LivingEntity> {
        constructor()
        constructor(arg0: number)
        static golemDetected(arg0: Internal.LivingEntity_): void;
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
        static checkForNearbyGolem(arg0: Internal.LivingEntity_): void;
    }
    type GolemSensor_ = GolemSensor;
    class ItemEntityInteractEventJS extends Internal.PlayerEventJS {
        constructor(player: Internal.Player_, entity: Internal.Entity_, hand: Hand_)
        getEntity(): Internal.EntityJS;
        canCancel(): boolean;
        getHand(): Hand;
        getItem(): Internal.ItemStackJS;
        getTarget(): Internal.EntityJS;
        get entity(): Internal.EntityJS
        get hand(): Hand
        get item(): Internal.ItemStackJS
        get target(): Internal.EntityJS
    }
    type ItemEntityInteractEventJS_ = ItemEntityInteractEventJS;
    abstract class Permission implements Internal.Guard, Internal.Serializable {
        constructor(arg0: string)
        hashCode(): number;
        toString(): string;
        getName(): string;
        getActions(): string;
        newPermissionCollection(): Internal.PermissionCollection;
        implies(arg0: Internal.Permission_): boolean;
        checkGuard(arg0: any): void;
        equals(arg0: any): boolean;
        get name(): string
        get actions(): string
    }
    type Permission_ = Permission;
    class ItemTooltipEvent extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.List_<Internal.Component_>, arg3: Internal.TooltipFlag_)
        getFlags(): Internal.TooltipFlag;
        getListenerList(): Internal.ListenerList;
        getPlayer(): Internal.Player;
        getToolTip(): Internal.List<Internal.Component>;
        getItemStack(): Internal.ItemStack;
        get flags(): Internal.TooltipFlag
        get listenerList(): Internal.ListenerList
        get player(): Internal.Player
        get toolTip(): Internal.List<Internal.Component>
        get itemStack(): Internal.ItemStack
    }
    type ItemTooltipEvent_ = ItemTooltipEvent;
    interface EntityInLevelCallback {
        onMove(): void;
        onRemove(arg0: Internal.Entity$RemovalReason_): void;
        readonly static "NULL": any;
    }
    type EntityInLevelCallback_ = EntityInLevelCallback;
    class Registries {
        static getId(object: T, fallback: Internal.Registry_<T>): ResourceLocation;
        get(key: Internal.ResourceKey_<Internal.Registry_<T>>): Internal.Registrar<T>;
        static getRegistryName(object: T): ResourceLocation;
        get(registry: Internal.Registry_<T>): Internal.Registrar<T>;
        forRegistry(key: Internal.ResourceKey_<Internal.Registry_<T>>, callback: Internal.Consumer_<Internal.Registrar_<T>>): void;
        getModId(): string;
        static getId(object: T, fallback: Internal.ResourceKey_<Internal.Registry_<T>>): ResourceLocation;
        static get(modId: string): Internal.Registries;
        builder(registryId: ResourceLocation_, ...typeGetter: T[]): Internal.RegistrarBuilder<T>;
        get modId(): string
    }
    type Registries_ = Registries;
    interface Packet <T> {
        write(arg0: Internal.FriendlyByteBuf_): void;
        isSkippable(): boolean;
        handle(arg0: T): void;
        get skippable(): boolean
    }
    type Packet_<T> = Packet<T>;
    class ClientboundForgetLevelChunkPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getX(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getZ(): number;
        isSkippable(): boolean;
        get x(): number
        get z(): number
        get skippable(): boolean
    }
    type ClientboundForgetLevelChunkPacket_ = ClientboundForgetLevelChunkPacket;
    class StringBuilder extends Internal.AbstractStringBuilder implements Internal.CharSequence, Internal.Comparable<Internal.StringBuilder>, Internal.Serializable {
        constructor()
        constructor(arg0: Internal.CharSequence_)
        constructor(arg0: number)
        constructor(arg0: string)
        insert(arg0: number, arg1: number): this;
        append(arg0: string): Internal.AbstractStringBuilder;
        codePointAt(arg0: number): number;
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder;
        append(arg0: number): Internal.AbstractStringBuilder;
        append(arg0: boolean): Internal.AbstractStringBuilder;
        lastIndexOf(arg0: string): number;
        append(arg0: number): Internal.AbstractStringBuilder;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.StringBuilder_): number;
        indexOf(arg0: string): number;
        getChars(arg0: number, arg1: number, arg2: string[], arg3: number): void;
        lastIndexOf(arg0: string, arg1: number): number;
        append(arg0: number): Internal.AbstractStringBuilder;
        charAt(arg0: number): string;
        insert(arg0: number, arg1: string): this;
        length(): number;
        replace(arg0: number, arg1: number, arg2: string): Internal.AbstractStringBuilder;
        trimToSize(): void;
        append(arg0: string): Internal.AbstractStringBuilder;
        delete(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        indexOf(arg0: string, arg1: number): number;
        ensureCapacity(arg0: number): void;
        insert(arg0: number, arg1: boolean): this;
        chars(): Internal.IntStream;
        insert(arg0: number, arg1: any): Internal.AbstractStringBuilder;
        append(arg0: number): Internal.AbstractStringBuilder;
        capacity(): number;
        codePointCount(arg0: number, arg1: number): number;
        append(arg0: string[]): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: Internal.CharSequence_): this;
        substring(arg0: number): string;
        setCharAt(arg0: number, arg1: string): void;
        setLength(arg0: number): void;
        isEmpty(): boolean;
        codePointBefore(arg0: number): number;
        append(arg0: string[], arg1: number, arg2: number): Internal.AbstractStringBuilder;
        deleteCharAt(arg0: number): Internal.AbstractStringBuilder;
        subSequence(arg0: number, arg1: number): Internal.CharSequence;
        append(arg0: Internal.StringBuffer_): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: Internal.CharSequence_, arg2: number, arg3: number): this;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): Internal.AbstractStringBuilder;
        substring(arg0: number, arg1: number): string;
        insert(arg0: number, arg1: string[]): this;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        reverse(): this;
        toString(): string;
        appendCodePoint(arg0: number): this;
        insert(arg0: number, arg1: number): this;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.AbstractStringBuilder;
        offsetByCodePoints(arg0: number, arg1: number): number;
        append(arg0: any): Internal.AbstractStringBuilder;
        append(arg0: Internal.CharSequence_): Internal.AbstractStringBuilder;
        codePoints(): Internal.IntStream;
        set length(arg0: number)
        get empty(): boolean
    }
    type StringBuilder_ = StringBuilder;
    class ClientboundLevelChunkWithLightPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.LevelChunk_, arg1: Internal.LevelLightEngine_, arg2: Internal.BitSet_, arg3: Internal.BitSet_, arg4: boolean)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getX(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getZ(): number;
        getChunkData(): Internal.ClientboundLevelChunkPacketData;
        getLightData(): Internal.ClientboundLightUpdatePacketData;
        isSkippable(): boolean;
        get x(): number
        get z(): number
        get chunkData(): Internal.ClientboundLevelChunkPacketData
        get lightData(): Internal.ClientboundLightUpdatePacketData
        get skippable(): boolean
    }
    type ClientboundLevelChunkWithLightPacket_ = ClientboundLevelChunkWithLightPacket;
    abstract class BaseCommandBlock implements Internal.CommandSource {
        constructor()
        isTrackOutput(): boolean;
        getCommand(): string;
        getPosition(): Vec3;
        getName(): Internal.Component;
        getLevel(): Internal.ServerLevel;
        usedBy(arg0: Internal.Player_): Internal.InteractionResult;
        createCommandSourceStack(): Internal.CommandSourceStack;
        save(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        getLastOutput(): Internal.Component;
        shouldInformAdmins(): boolean;
        acceptsFailure(): boolean;
        alwaysAccepts(): boolean;
        load(arg0: Internal.CompoundTag_): void;
        setCommand(arg0: string): void;
        setName(arg0: Internal.Component_): void;
        sendMessage(arg0: Internal.Component_, arg1: Internal.UUID_): void;
        setSuccessCount(arg0: number): void;
        setLastOutput(arg0: Internal.Component_): void;
        setTrackOutput(arg0: boolean): void;
        acceptsSuccess(): boolean;
        onUpdated(): void;
        getSuccessCount(): number;
        performCommand(arg0: Internal.Level_): boolean;
        get trackOutput(): boolean
        get command(): string
        get position(): Vec3
        get name(): Internal.Component
        get level(): Internal.ServerLevel
        get lastOutput(): Internal.Component
        set command(arg0: string)
        set name(arg0: Internal.Component_)
        set successCount(arg0: number)
        set lastOutput(arg0: Internal.Component_)
        set trackOutput(arg0: boolean)
        get successCount(): number
    }
    type BaseCommandBlock_ = BaseCommandBlock;
    interface Byte2IntFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: number, arg1: number): number;
        composeReference(arg0: Internal.Reference2ByteFunction_<any>): Internal.Reference2IntFunction<T>;
        composeByte(arg0: Internal.Byte2ByteFunction_): this;
        andThenInt(arg0: Internal.Int2IntFunction_): this;
        get(arg0: number): number;
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        defaultReturnValue(): number;
        apply(arg0: number): number;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2IntFunction;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2IntFunction;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        andThenReference(arg0: Internal.Int2ReferenceFunction_<any>): Internal.Byte2ReferenceFunction<T>;
        andThenObject(arg0: Internal.Int2ObjectFunction_<any>): Internal.Byte2ObjectFunction<T>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2IntFunction;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Byte2ShortFunction;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Byte2DoubleFunction;
        containsKey(arg0: any): boolean;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Byte2LongFunction;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        applyAsInt(arg0: number): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        containsKey(arg0: number): boolean;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Byte2FloatFunction;
        composeObject(arg0: Internal.Object2ByteFunction_<any>): Internal.Object2IntFunction<T>;
        remove(arg0: number): number;
        put(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        size(): number;
        defaultReturnValue(arg0: number): void;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2IntFunction;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Byte2ByteFunction;
        clear(): void;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2IntFunction;
        remove(arg0: any): any;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Byte2CharFunction;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2IntFunction;
    }
    type Byte2IntFunction_ = Byte2IntFunction | ((arg0: number)=>number);
    class MutableArmorTier implements Internal.ArmorMaterial {
        constructor(id: string, p: Internal.ArmorMaterial_)
        setRepairIngredient(in_: Internal.IngredientJS_): void;
        getVanillaRepairIngredient(): Internal.Ingredient;
        getKnockbackResistance(): number;
        getEnchantmentValue(): number;
        setToughness(f: number): void;
        setEnchantmentValue(i: number): void;
        setSlotProtections(p: number[]): void;
        setEquipSound(e: Internal.SoundEvent_): void;
        setKnockbackResistance(f: number): void;
        setName(name: string): void;
        getToughness(): number;
        getDefenseForSlot(equipmentSlot: EquipmentSlot_): number;
        setDurabilityMultiplier(m: number): void;
        getName(): string;
        getDurabilityForSlot(equipmentSlot: EquipmentSlot_): number;
        getEquipSound(): Internal.SoundEvent;
        set repairIngredient(in_: Internal.IngredientJS_)
        get vanillaRepairIngredient(): Internal.Ingredient
        get knockbackResistance(): number
        get enchantmentValue(): number
        set toughness(f: number)
        set enchantmentValue(i: number)
        set slotProtections(p: number[])
        set equipSound(e: Internal.SoundEvent_)
        set knockbackResistance(f: number)
        set name(name: string)
        get toughness(): number
        set durabilityMultiplier(m: number)
        get name(): string
        get equipSound(): Internal.SoundEvent
        readonly "parent": Internal.ArmorMaterial;
    }
    type MutableArmorTier_ = MutableArmorTier;
    interface StreamTagVisitor {
        visitEntry(arg0: Internal.TagType_<any>, arg1: string): Internal.StreamTagVisitor$EntryResult;
        visit(arg0: number): Internal.StreamTagVisitor$ValueResult;
        visit(arg0: string): Internal.StreamTagVisitor$ValueResult;
        visit(arg0: number): Internal.StreamTagVisitor$ValueResult;
        visitContainerEnd(): Internal.StreamTagVisitor$ValueResult;
        visit(arg0: number): Internal.StreamTagVisitor$ValueResult;
        visitElement(arg0: Internal.TagType_<any>, arg1: number): Internal.StreamTagVisitor$EntryResult;
        visit(arg0: number): Internal.StreamTagVisitor$ValueResult;
        visit(arg0: number[]): Internal.StreamTagVisitor$ValueResult;
        visit(arg0: number): Internal.StreamTagVisitor$ValueResult;
        visitEnd(): Internal.StreamTagVisitor$ValueResult;
        visit(arg0: number): Internal.StreamTagVisitor$ValueResult;
        visitRootEntry(arg0: Internal.TagType_<any>): Internal.StreamTagVisitor$ValueResult;
        visit(arg0: number[]): Internal.StreamTagVisitor$ValueResult;
        visit(arg0: number[]): Internal.StreamTagVisitor$ValueResult;
        visitList(arg0: Internal.TagType_<any>, arg1: number): Internal.StreamTagVisitor$ValueResult;
        visitEntry(arg0: Internal.TagType_<any>): Internal.StreamTagVisitor$EntryResult;
    }
    type StreamTagVisitor_ = StreamTagVisitor;
    class ServerboundSetCarriedItemPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getSlot(): number;
        isSkippable(): boolean;
        get slot(): number
        get skippable(): boolean
    }
    type ServerboundSetCarriedItemPacket_ = ServerboundSetCarriedItemPacket;
    abstract class CombiningPredicate implements net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate {
        static codec(arg0: Internal.Function_<Internal.List_<net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_>, T>): Internal.Codec<T>;
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        negate(): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
    }
    type CombiningPredicate_ = CombiningPredicate;
    class BambooLeaves extends Internal.Enum<Internal.BambooLeaves> implements Internal.StringRepresentable {
        static valueOf(arg0: string): Internal.BambooLeaves;
        toString(): string;
        getSerializedName(): string;
        static values(): Internal.BambooLeaves[];
        get serializedName(): string
        readonly static "SMALL": Internal.BambooLeaves;
        readonly static "NONE": Internal.BambooLeaves;
        readonly static "LARGE": Internal.BambooLeaves;
    }
    type BambooLeaves_ = "large" | "small" | "none" | BambooLeaves;
    class SimpleMapCodec <K, V> extends Internal.MapCodec<Internal.Map<K, V>> implements Internal.BaseMapCodec<K, V> {
        constructor(arg0: Internal.Codec_<K>, arg1: Internal.Codec_<V>, arg2: Internal.Keyable_)
        keyCodec(): Internal.Codec<K>;
        toString(): string;
        ap(arg0: Internal.MapDecoder_<Internal.Function_<any, any>>): Internal.MapDecoder<E>;
        keys(arg0: Internal.DynamicOps_<T>): Internal.Stream<T>;
        encode(arg0: any, arg1: Internal.DynamicOps_<any>, arg2: Internal.RecordBuilder_<any>): Internal.RecordBuilder<any>;
        decode(arg0: Internal.DynamicOps_<T>, arg1: Internal.MapLike_<T>): Internal.DataResult<Internal.Map<K, V>>;
        hashCode(): number;
        flatMap(arg0: Internal.Function_<any, any>): Internal.MapDecoder<B>;
        elementCodec(): Internal.Codec<V>;
        encode(arg0: Internal.Map_<K, V>, arg1: Internal.DynamicOps_<T>, arg2: Internal.RecordBuilder_<T>): Internal.RecordBuilder<T>;
        compressedBuilder(arg0: Internal.DynamicOps_<T>): Internal.RecordBuilder<T>;
        decoder(): Internal.Decoder<Internal.Map<K, V>>;
        comap(arg0: Internal.Function_<any, any>): Internal.MapEncoder<B>;
        map(arg0: Internal.Function_<any, any>): Internal.MapDecoder<B>;
        encoder(): Internal.Encoder<Internal.Map<K, V>>;
        flatComap(arg0: Internal.Function_<any, any>): Internal.MapEncoder<B>;
        compressedDecode(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<Internal.Map<K, V>>;
        equals(arg0: any): boolean;
    }
    type SimpleMapCodec_<K, V> = SimpleMapCodec<K, V>;
    interface Blender$DistanceGetter {
        getDistance(arg0: number, arg1: number, arg2: number): number;
    }
    type Blender$DistanceGetter_ = Blender$DistanceGetter;
    class CameraType extends Internal.Enum<Internal.CameraType> {
        isMirrored(): boolean;
        static values(): Internal.CameraType[];
        isFirstPerson(): boolean;
        static valueOf(arg0: string): Internal.CameraType;
        cycle(): this;
        get mirrored(): boolean
        get firstPerson(): boolean
        readonly static "THIRD_PERSON_BACK": Internal.CameraType;
        readonly static "THIRD_PERSON_FRONT": Internal.CameraType;
        readonly static "FIRST_PERSON": Internal.CameraType;
    }
    type CameraType_ = "first_person" | "third_person_back" | "third_person_front" | CameraType;
    class ClientboundSetBorderSizePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.WorldBorder_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getSize(): number;
        isSkippable(): boolean;
        get size(): number
        get skippable(): boolean
    }
    type ClientboundSetBorderSizePacket_ = ClientboundSetBorderSizePacket;
    interface Short2LongFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntToLongFunction {
        apply(arg0: number): number;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2LongFunction;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Short2CharFunction;
        getOrDefault(arg0: any, arg1: any): any;
        remove(arg0: number): number;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2LongFunction;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2LongFunction;
        get(arg0: any): number;
        containsKey(arg0: any): boolean;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Short2DoubleFunction;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Short2FloatFunction;
        put(arg0: number, arg1: number): number;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2LongFunction;
        put(arg0: any, arg1: any): any;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Short2ShortFunction;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Short2IntFunction;
        defaultReturnValue(): number;
        andThenLong(arg0: Internal.Long2LongFunction_): this;
        composeObject(arg0: Internal.Object2ShortFunction_<any>): Internal.Object2LongFunction<T>;
        containsKey(arg0: number): boolean;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Short2ByteFunction;
        andThenObject(arg0: Internal.Long2ObjectFunction_<any>): Internal.Short2ObjectFunction<T>;
        getOrDefault(arg0: any, arg1: number): number;
        get(arg0: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        composeReference(arg0: Internal.Reference2ShortFunction_<any>): Internal.Reference2LongFunction<T>;
        size(): number;
        andThenReference(arg0: Internal.Long2ReferenceFunction_<any>): Internal.Short2ReferenceFunction<T>;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2LongFunction;
        composeShort(arg0: Internal.Short2ShortFunction_): this;
        clear(): void;
        applyAsLong(arg0: number): number;
        put(arg0: number, arg1: number): number;
        remove(arg0: any): any;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2LongFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        defaultReturnValue(arg0: number): void;
    }
    type Short2LongFunction_ = ((arg0: number)=>number) | Short2LongFunction;
    interface Copyable {
        copy(): this;
    }
    type Copyable_ = Copyable;
    class RecursiveTypeFamily implements Internal.TypeFamily {
        constructor(arg0: string, arg1: Internal.TypeTemplate_)
        static viewUnchecked(arg0: com.mojang.datafixers.types.Type_<any>, arg1: com.mojang.datafixers.types.Type_<any>, arg2: Internal.PointFree_<Internal.Function_<A, B>>): Internal.View<A, B>;
        name(): string;
        size(): number;
        hashCode(): number;
        toString(): string;
        fold(arg0: Internal.Algebra_): Internal.IntFunction<Internal.RewriteResult<any, any>>;
        apply(arg0: number): Internal.RecursivePoint$RecursivePointType<any>;
        everywhere(arg0: number, arg1: Internal.TypeRewriteRule_, arg2: Internal.PointFreeRule_): Internal.Optional<Internal.RewriteResult<any, any>>;
        buildMuType(arg0: com.mojang.datafixers.types.Type_<A>, arg1: Internal.RecursiveTypeFamily_): Internal.RecursivePoint$RecursivePointType<A>;
        findType(arg0: number, arg1: com.mojang.datafixers.types.Type_<A>, arg2: com.mojang.datafixers.types.Type_<B>, arg3: Internal.Type$TypeMatcher_<A, B>, arg4: boolean): Internal.Either<Internal.TypedOptic<any, any, A, B>, Internal.Type$FieldNotFoundException>;
        equals(arg0: any): boolean;
        template(): Internal.TypeTemplate;
    }
    type RecursiveTypeFamily_ = RecursiveTypeFamily;
    interface DirectMethodHandleDesc extends Internal.MethodHandleDesc {
        asType(arg0: Internal.MethodTypeDesc_): Internal.MethodHandleDesc;
        isOwnerInterface(): boolean;
        lookupDescriptor(): string;
        refKind(): number;
        methodName(): string;
        kind(): Internal.DirectMethodHandleDesc$Kind;
        owner(): Internal.ClassDesc;
        get ownerInterface(): boolean
    }
    type DirectMethodHandleDesc_ = DirectMethodHandleDesc;
    class TextureAtlasSprite implements Internal.AutoCloseable {
        wrap(arg0: Internal.VertexConsumer_): Internal.VertexConsumer;
        getX(): number;
        toString(): string;
        getWidth(): number;
        getY(): number;
        getName(): ResourceLocation;
        getPixelRGBA(arg0: number, arg1: number, arg2: number): number;
        atlas(): Internal.TextureAtlas;
        getUOffset(arg0: number): number;
        getAnimationTicker(): Internal.Tickable;
        uvShrinkRatio(): number;
        uploadFirstFrame(): void;
        getFrameCount(): number;
        close(): void;
        getUniqueFrames(): Internal.IntStream;
        getU(arg0: number): number;
        getHeight(): number;
        getVOffset(arg0: number): number;
        getV1(): number;
        getV(arg0: number): number;
        getU1(): number;
        getU0(): number;
        getV0(): number;
        isTransparent(arg0: number, arg1: number, arg2: number): boolean;
        get x(): number
        get width(): number
        get y(): number
        get name(): ResourceLocation
        get animationTicker(): Internal.Tickable
        get frameCount(): number
        get uniqueFrames(): Internal.IntStream
        get height(): number
        get v1(): number
        get u1(): number
        get u0(): number
        get v0(): number
    }
    type TextureAtlasSprite_ = TextureAtlasSprite;
    class StackedContents {
        constructor()
        accountStack(arg0: Internal.ItemStack_): void;
        canCraft(arg0: Internal.Recipe_<any>, arg1: Internal.IntList_): boolean;
        canCraft(arg0: Internal.Recipe_<any>, arg1: Internal.IntList_, arg2: number): boolean;
        accountStack(arg0: Internal.ItemStack_, arg1: number): void;
        clear(): void;
        static fromStackingIndex(arg0: number): Internal.ItemStack;
        accountSimpleStack(arg0: Internal.ItemStack_): void;
        static getStackingIndex(arg0: Internal.ItemStack_): number;
        getBiggestCraftableStack(arg0: Internal.Recipe_<any>, arg1: Internal.IntList_): number;
        getBiggestCraftableStack(arg0: Internal.Recipe_<any>, arg1: number, arg2: Internal.IntList_): number;
        readonly "contents": Internal.Int2IntMap;
    }
    type StackedContents_ = StackedContents;
    abstract class WorldCarver <C> extends Internal.ForgeRegistryEntry<Internal.WorldCarver<any>> {
        constructor(arg0: Internal.Codec_<C>)
        isStartChunk(arg0: C, arg1: Internal.Random_): boolean;
        configured(arg0: C): Internal.ConfiguredWorldCarver<C>;
        configuredCodec(): Internal.Codec<Internal.ConfiguredWorldCarver<C>>;
        getRange(): number;
        carve(arg0: Internal.CarvingContext_, arg1: C, arg2: Internal.ChunkAccess_, arg3: Internal.Function_<BlockPos_, Internal.Holder_<Internal.Biome_>>, arg4: Internal.Random_, arg5: Internal.Aquifer_, arg6: Internal.ChunkPos_, arg7: Internal.CarvingMask_): boolean;
        get range(): number
        readonly static "CANYON": any;
        readonly static "NETHER_CAVE": any;
        readonly static "CAVE": any;
    }
    type WorldCarver_<C> = WorldCarver<C> | Special.WorldCarver;
    abstract class Sensor <E> {
        constructor()
        constructor(arg0: number)
        static isEntityTargetable(arg0: Internal.LivingEntity_, arg1: Internal.LivingEntity_): boolean;
        static isEntityAttackable(arg0: Internal.LivingEntity_, arg1: Internal.LivingEntity_): boolean;
        static isEntityAttackableIgnoringLineOfSight(arg0: Internal.LivingEntity_, arg1: Internal.LivingEntity_): boolean;
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
        tick(arg0: Internal.ServerLevel_, arg1: E): void;
    }
    type Sensor_<E> = Sensor<E>;
    class ServerboundPongPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        isSkippable(): boolean;
        getId(): number;
        get skippable(): boolean
        get id(): number
    }
    type ServerboundPongPacket_ = ServerboundPongPacket;
    class Options {
        constructor(arg0: Internal.Minecraft_, arg1: Internal.File_)
        setServerRenderDistance(arg0: number): void;
        getBackgroundOpacity(arg0: number): number;
        broadcastOptions(): void;
        setCameraType(arg0: Internal.CameraType_): void;
        toggleModelPart(arg0: Internal.PlayerModelPart_, arg1: boolean): void;
        isModelPartEnabled(arg0: Internal.PlayerModelPart_): boolean;
        useNativeTransport(): boolean;
        getCameraType(): Internal.CameraType;
        save(): void;
        getCloudsType(): Internal.CloudStatus;
        getSoundSourceVolume(arg0: Internal.SoundSource_): number;
        setSoundCategoryVolume(arg0: Internal.SoundSource_, arg1: number): void;
        getFile(): Internal.File;
        getBackgroundColor(arg0: number): number;
        loadSelectedResourcePacks(arg0: Internal.PackRepository_): void;
        getEffectiveRenderDistance(): number;
        load(): void;
        dumpOptionsForReport(): string;
        getBackgroundColor(arg0: number): number;
        setKey(arg0: Internal.KeyMapping_, arg1: Internal.InputConstants$Key_): void;
        set serverRenderDistance(arg0: number)
        set cameraType(arg0: Internal.CameraType_)
        get cameraType(): Internal.CameraType
        get cloudsType(): Internal.CloudStatus
        get file(): Internal.File
        get effectiveRenderDistance(): number
        "realmsNotifications": boolean;
        "chatHeightFocused": number;
        readonly static "RENDER_DISTANCE_NORMAL": 8;
        "chatScale": number;
        "hideBundleTutorial": boolean;
        readonly "keyUp": Internal.KeyMapping;
        readonly static "RENDER_DISTANCE_EXTREME": 32;
        "graphicsMode": Internal.GraphicsStatus;
        "attackIndicator": Internal.AttackIndicatorStatus;
        "biomeBlendRadius": number;
        "pauseOnLostFocus": boolean;
        "chatWidth": number;
        readonly "keyRight": Internal.KeyMapping;
        "sensitivity": number;
        "enableVsync": boolean;
        "touchscreen": boolean;
        "smoothCamera": boolean;
        readonly "keyCommand": Internal.KeyMapping;
        "fovEffectScale": number;
        "joinedFirstServer": boolean;
        "particles": Internal.ParticleStatus;
        "incompatibleResourcePacks": Internal.List<string>;
        readonly "keyFullscreen": Internal.KeyMapping;
        "toggleCrouch": boolean;
        "hideMatchedNames": boolean;
        readonly "keyTogglePerspective": Internal.KeyMapping;
        "framerateLimit": number;
        "entityShadows": boolean;
        "bobView": boolean;
        readonly "keySmoothCamera": Internal.KeyMapping;
        "difficulty": Internal.Difficulty;
        "autoSuggestions": boolean;
        "mipmapLevels": number;
        "lastMpIp": string;
        "backgroundForChatOnly": boolean;
        readonly "keyLeft": Internal.KeyMapping;
        readonly "keyUse": Internal.KeyMapping;
        "simulationDistance": number;
        "chatVisibility": Internal.ChatVisiblity;
        readonly "keySocialInteractions": Internal.KeyMapping;
        readonly "keySpectatorOutlines": Internal.KeyMapping;
        readonly "keyLoadHotbarActivator": Internal.KeyMapping;
        "showAutosaveIndicator": boolean;
        "ambientOcclusion": Internal.AmbientOcclusionStatus;
        "syncWrites": boolean;
        "tutorialStep": Internal.TutorialSteps;
        "keyMappings": Internal.KeyMapping[];
        "mouseWheelSensitivity": number;
        "forceUnicodeFont": boolean;
        readonly "keySwapOffhand": Internal.KeyMapping;
        "hideLightningFlashes": boolean;
        "showSubtitles": boolean;
        readonly "keyDown": Internal.KeyMapping;
        readonly static "RENDER_DISTANCE_FAR": 12;
        "mainHand": Internal.HumanoidArm;
        "autoJump": boolean;
        "skipMultiplayerWarning": boolean;
        readonly "keyShift": Internal.KeyMapping;
        "fullscreen": boolean;
        "hideGui": boolean;
        "allowServerListing": boolean;
        readonly "keyScreenshot": Internal.KeyMapping;
        "chatDelay": number;
        "languageCode": string;
        readonly "keyPlayerList": Internal.KeyMapping;
        "fov": number;
        readonly "keyAttack": Internal.KeyMapping;
        "rawMouseInput": boolean;
        "renderFpsChart": boolean;
        "darkMojangStudiosBackground": boolean;
        readonly "keyChat": Internal.KeyMapping;
        "gamma": number;
        readonly "keyPickItem": Internal.KeyMapping;
        "chatLineSpacing": number;
        "invertYMouse": boolean;
        "chatHeightUnfocused": number;
        "chatOpacity": number;
        readonly static "RENDER_DISTANCE_TINY": 2;
        "chatLinks": boolean;
        "skipRealms32bitWarning": boolean;
        "fullscreenVideoModeString": string;
        "discreteMouseScroll": boolean;
        "useNativeTransport": boolean;
        "textBackgroundOpacity": number;
        "glDebugVerbosity": number;
        readonly static "RENDER_DISTANCE_REALLY_FAR": 16;
        "reducedDebugInfo": boolean;
        "guiScale": number;
        "overrideWidth": number;
        "chatColors": boolean;
        "renderDistance": number;
        readonly "keySaveHotbarActivator": Internal.KeyMapping;
        readonly static "RENDER_DISTANCE_SHORT": 4;
        "overrideHeight": number;
        "renderDebug": boolean;
        "chatLinksPrompt": boolean;
        readonly "keyAdvancements": Internal.KeyMapping;
        readonly "keyJump": Internal.KeyMapping;
        "screenEffectScale": number;
        "renderClouds": Internal.CloudStatus;
        readonly "keyDrop": Internal.KeyMapping;
        "resourcePacks": Internal.List<string>;
        readonly "keySprint": Internal.KeyMapping;
        "heldItemTooltips": boolean;
        readonly "keyInventory": Internal.KeyMapping;
        "advancedItemTooltips": boolean;
        "soundDevice": string;
        "renderDebugCharts": boolean;
        "toggleSprint": boolean;
        readonly "keyHotbarSlots": Internal.KeyMapping[];
        "entityDistanceScaling": number;
        "hideServerAddress": boolean;
        "narratorStatus": Internal.NarratorStatus;
        "prioritizeChunkUpdates": Internal.PrioritizeChunkUpdates;
        readonly static "DEFAULT_SOUND_DEVICE": "";
    }
    type Options_ = Options;
    interface Weighted <T> {
        getSound(): T;
        getWeight(): number;
        preloadIfRequired(arg0: Internal.SoundEngine_): void;
        get sound(): T
        get weight(): number
    }
    type Weighted_<T> = Weighted<T>;
    class Heightmap {
        constructor(arg0: Internal.ChunkAccess_, arg1: Internal.Heightmap$Types_)
        getHighestTaken(arg0: number, arg1: number): number;
        static primeHeightmaps(arg0: Internal.ChunkAccess_, arg1: Internal.Set_<Internal.Heightmap$Types_>): void;
        getFirstAvailable(arg0: number, arg1: number): number;
        getRawData(): number[];
        update(arg0: number, arg1: number, arg2: number, arg3: Internal.BlockState_): boolean;
        setRawData(arg0: Internal.ChunkAccess_, arg1: Internal.Heightmap$Types_, arg2: number[]): void;
        get rawData(): number[]
    }
    type Heightmap_ = Heightmap;
    class EntityEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.Entity_)
        getEntity(): Internal.Entity;
        getListenerList(): Internal.ListenerList;
        get entity(): Internal.Entity
        get listenerList(): Internal.ListenerList
    }
    type EntityEvent_ = EntityEvent;
    class InteractionResultHolder <T> {
        constructor(arg0: Internal.InteractionResult_, arg1: T)
        getResult(): Internal.InteractionResult;
        static fail(arg0: T): Internal.InteractionResultHolder<T>;
        static consume(arg0: T): Internal.InteractionResultHolder<T>;
        getObject(): T;
        static success(arg0: T): Internal.InteractionResultHolder<T>;
        static pass(arg0: T): Internal.InteractionResultHolder<T>;
        static sidedSuccess(arg0: T, arg1: boolean): Internal.InteractionResultHolder<T>;
        get result(): Internal.InteractionResult
        get object(): T
    }
    type InteractionResultHolder_<T> = InteractionResultHolder<T>;
    class ScreenEvent$InitScreenEvent extends Internal.ScreenEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: Internal.List_<Internal.GuiEventListener_>, arg2: Internal.Consumer_<Internal.GuiEventListener_>, arg3: Internal.Consumer_<Internal.GuiEventListener_>)
        getListenersList(): Internal.List<Internal.GuiEventListener>;
        removeListener(arg0: Internal.GuiEventListener_): void;
        getListenerList(): Internal.ListenerList;
        addListener(arg0: Internal.GuiEventListener_): void;
        get listenersList(): Internal.List<Internal.GuiEventListener>
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$InitScreenEvent_ = ScreenEvent$InitScreenEvent;
    class StoringChunkProgressListener implements Internal.ChunkProgressListener {
        constructor(arg0: number)
        getProgress(): number;
        getFullDiameter(): number;
        start(): void;
        getStatus(arg0: number, arg1: number): Internal.ChunkStatus;
        getDiameter(): number;
        stop(): void;
        onStatusChange(arg0: Internal.ChunkPos_, arg1: Internal.ChunkStatus_): void;
        updateSpawnPos(arg0: Internal.ChunkPos_): void;
        get progress(): number
        get fullDiameter(): number
        get diameter(): number
    }
    type StoringChunkProgressListener_ = StoringChunkProgressListener;
    class ServerboundSignUpdatePacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: BlockPos_, arg1: string, arg2: string, arg3: string, arg4: string)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getPos(): BlockPos;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getLines(): string[];
        isSkippable(): boolean;
        get pos(): BlockPos
        get lines(): string[]
        get skippable(): boolean
    }
    type ServerboundSignUpdatePacket_ = ServerboundSignUpdatePacket;
    class BlockContainerJS implements Internal.SpecialEquality {
        constructor(w: Internal.Level_, p: BlockPos_)
        getTags(): Internal.Collection<ResourceLocation>;
        getInventory(): Internal.InventoryJS;
        getWest(): this;
        getY(): number;
        getItem(): Internal.ItemStackJS;
        getNorth(): this;
        getBlockLight(): number;
        spawnFireworks(fireworks: Internal.FireworksJS_): void;
        getPos(): BlockPos;
        spawnLightning(effectOnly: boolean, player: Internal.EntityJS_): void;
        getDown(): this;
        getLight(): number;
        getSouth(): this;
        getSkyLight(): number;
        mergeEntityData(tag: Internal.CompoundTag_): void;
        getCanSeeSky(): boolean;
        getDimension(): ResourceLocation;
        getBlockState(): Internal.BlockState;
        specialEquals(o: any, shallow: boolean): boolean;
        hasTag(tag: ResourceLocation_): boolean;
        getLevel(): Internal.LevelJS;
        getTypeData(): Internal.CompoundTag;
        getDrops(entity: Internal.EntityJS_, heldItem: Internal.ItemStack_): Internal.List<Internal.ItemStackJS>;
        offset(x: number, y: number, z: number): this;
        offset(f: Internal.Direction_): this;
        createEntity(id: ResourceLocation_): Internal.EntityJS;
        offset(f: Internal.Direction_, d: number): this;
        getEast(): this;
        getEntityId(): string;
        getX(): number;
        set(id: ResourceLocation_, properties: Internal.Map_<any, any>): void;
        popItem(item: Internal.ItemStack_): void;
        set(id: ResourceLocation_, properties: Internal.Map_<any, any>, flags: number): void;
        getInventory(facing: Internal.Direction_): Internal.InventoryJS;
        setBlockState(state: Internal.BlockState_, flags: number): void;
        popItemFromFace(item: Internal.ItemStack_, dir: Internal.Direction_): void;
        getEntity(): Internal.BlockEntity;
        getPlayersInRadius(radius: number): Internal.EntityArrayList;
        clearCache(): void;
        getUp(): this;
        getZ(): number;
        getEntityData(): Internal.CompoundTag;
        spawnLightning(effectOnly: boolean): void;
        toString(): string;
        getDrops(): Internal.List<Internal.ItemStackJS>;
        getMaterial(): Internal.MaterialJS;
        getId(): string;
        canSeeSkyFromBelowWater(): boolean;
        getProperties(): Internal.Map<string, string>;
        createExplosion(): Internal.ExplosionJS;
        setEntityData(tag: Internal.CompoundTag_): void;
        set(id: ResourceLocation_): void;
        getPlayersInRadius(): Internal.EntityArrayList;
        equals(obj: any): boolean;
        getBiomeId(): ResourceLocation;
        get tags(): Internal.Collection<ResourceLocation>
        get inventory(): Internal.InventoryJS
        get west(): Internal.BlockContainerJS
        get y(): number
        get item(): Internal.ItemStackJS
        get north(): Internal.BlockContainerJS
        get blockLight(): number
        get pos(): BlockPos
        get down(): Internal.BlockContainerJS
        get light(): number
        get south(): Internal.BlockContainerJS
        get skyLight(): number
        get canSeeSky(): boolean
        get dimension(): ResourceLocation
        get blockState(): Internal.BlockState
        get level(): Internal.LevelJS
        get typeData(): Internal.CompoundTag
        get east(): Internal.BlockContainerJS
        get entityId(): string
        get x(): number
        get entity(): Internal.BlockEntity
        get up(): Internal.BlockContainerJS
        get z(): number
        get entityData(): Internal.CompoundTag
        get drops(): Internal.List<Internal.ItemStackJS>
        get material(): Internal.MaterialJS
        get id(): string
        get properties(): Internal.Map<string, string>
        set entityData(tag: Internal.CompoundTag_)
        get playersInRadius(): Internal.EntityArrayList
        get biomeId(): ResourceLocation
        readonly "minecraftLevel": Internal.Level;
    }
    type BlockContainerJS_ = BlockContainerJS;
    class AmbientParticleSettings {
        constructor(arg0: Internal.ParticleOptions_, arg1: number)
        getOptions(): Internal.ParticleOptions;
        canSpawn(arg0: Internal.Random_): boolean;
        get options(): Internal.ParticleOptions
        readonly static "CODEC": any;
    }
    type AmbientParticleSettings_ = AmbientParticleSettings;
    class EnderDragon extends Internal.Mob implements Internal.Enemy {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getHeadLookVector(arg0: number): Vec3;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        addEffect(arg0: Internal.MobEffectInstance_, arg1: Internal.Entity_): boolean;
        kill(): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        canAttack(arg0: Internal.LivingEntity_): boolean;
        getLatencyPos(arg0: number, arg1: number): number[];
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        getSoundSource(): Internal.SoundSource;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        setId(arg0: number): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        onCrystalDestroyed(arg0: Internal.EndCrystal_, arg1: BlockPos_, arg2: Internal.DamageSource_): void;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        hurt(arg0: Internal.EnderDragonPart_, arg1: Internal.DamageSource_, arg2: number): boolean;
        findPath(arg0: number, arg1: number, arg2: Internal.Node_): net.minecraft.world.level.pathfinder.Path;
        getPhaseManager(): Internal.EnderDragonPhaseManager;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        checkDespawn(): void;
        isPickable(): boolean;
        findClosestNode(arg0: number, arg1: number, arg2: number): number;
        canChangeDimensions(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        getDragonFight(): Internal.EndDragonFight;
        isFlapping(): boolean;
        getSubEntities(): Internal.EnderDragonPart[];
        getClassification(arg0: boolean): Internal.MobCategory;
        recreateFromPacket(arg0: Internal.ClientboundAddMobPacket_): void;
        getHeadPartYOffset(arg0: number, arg1: number[], arg2: number[]): number;
        foodEatenKJS(is: Internal.ItemStack_): void;
        findClosestNode(): number;
        onFlap(): void;
        get stepHeight(): number
        get soundSource(): Internal.SoundSource
        get multipartEntity(): boolean
        set id(arg0: number)
        get parts(): Internal.PartEntity<any>[]
        get phaseManager(): Internal.EnderDragonPhaseManager
        get pickable(): boolean
        get dragonFight(): Internal.EndDragonFight
        get flapping(): boolean
        get subEntities(): Internal.EnderDragonPart[]
        "oFlapTime": number;
        "nearestCrystal": Internal.EndCrystal;
        "flapTime": number;
        readonly static "DATA_PHASE": Internal.EntityDataAccessor<any>;
        "yRotA": number;
        readonly "head": Internal.EnderDragonPart;
        "dragonDeathTime": number;
        readonly "positions": number[][];
        "posPointer": number;
        "inWall": boolean;
    }
    type EnderDragon_ = EnderDragon;
    interface Delayed extends Internal.Comparable<Internal.Delayed> {
        getDelay(arg0: Internal.TimeUnit_): number;
    }
    type Delayed_ = Delayed;
    class OceanRuinFeature$Type extends Internal.Enum<Internal.OceanRuinFeature$Type> implements Internal.StringRepresentable {
        static byName(arg0: string): Internal.OceanRuinFeature$Type;
        static valueOf(arg0: string): Internal.OceanRuinFeature$Type;
        getSerializedName(): string;
        getName(): string;
        static values(): Internal.OceanRuinFeature$Type[];
        get serializedName(): string
        get name(): string
        readonly static "CODEC": any;
        readonly static "WARM": Internal.OceanRuinFeature$Type;
        readonly static "COLD": Internal.OceanRuinFeature$Type;
    }
    type OceanRuinFeature$Type_ = OceanRuinFeature$Type | "warm" | "cold";
    class PlayerEvent$TabListNameFormat extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_)
        getDisplayName(): Internal.Component;
        setDisplayName(arg0: Internal.Component_): void;
        getListenerList(): Internal.ListenerList;
        get displayName(): Internal.Component
        set displayName(arg0: Internal.Component_)
        get listenerList(): Internal.ListenerList
    }
    type PlayerEvent$TabListNameFormat_ = PlayerEvent$TabListNameFormat;
    interface Double2FloatFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleUnaryOperator {
        compose(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2FloatFunction;
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Double2ShortFunction;
        remove(arg0: number): number;
        put(arg0: number, arg1: number): number;
        defaultReturnValue(arg0: number): void;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2FloatFunction;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2FloatFunction;
        put(arg0: number, arg1: number): number;
        containsKey(arg0: any): boolean;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Double2LongFunction;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Double2DoubleFunction;
        andThenFloat(arg0: Internal.Float2FloatFunction_): this;
        andThenReference(arg0: Internal.Float2ReferenceFunction_<any>): Internal.Double2ReferenceFunction<T>;
        composeDouble(arg0: Internal.Double2DoubleFunction_): this;
        put(arg0: any, arg1: any): any;
        apply(arg0: number): number;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2FloatFunction;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Double2CharFunction;
        get(arg0: number): number;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2FloatFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        defaultReturnValue(): number;
        composeReference(arg0: Internal.Reference2DoubleFunction_<any>): Internal.Reference2FloatFunction<T>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        applyAsDouble(arg0: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Double2IntFunction;
        containsKey(arg0: number): boolean;
        composeObject(arg0: Internal.Object2DoubleFunction_<any>): Internal.Object2FloatFunction<T>;
        size(): number;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Double2ByteFunction;
        andThen(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2FloatFunction;
        clear(): void;
        andThenObject(arg0: Internal.Float2ObjectFunction_<any>): Internal.Double2ObjectFunction<T>;
        remove(arg0: any): any;
        getOrDefault(arg0: number, arg1: number): number;
    }
    type Double2FloatFunction_ = Double2FloatFunction | ((arg0: number)=>number);
    class PackMetadataSectionSerializer implements Internal.MetadataSectionSerializer<Internal.PackMetadataSection> {
        constructor()
        getMetadataSectionName(): string;
        fromJson(arg0: Internal.JsonObject_): any;
        get metadataSectionName(): string
    }
    type PackMetadataSectionSerializer_ = PackMetadataSectionSerializer;
    interface DomainCombiner {
        combine(arg0: Internal.ProtectionDomain_[], arg1: Internal.ProtectionDomain_[]): Internal.ProtectionDomain[];
    }
    type DomainCombiner_ = DomainCombiner;
    class Hotbar extends Internal.ForwardingList<Internal.ItemStack> {
        constructor()
        parallelStream(): Internal.Stream<Internal.ItemStack>;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        createTag(): Internal.ListTag;
        replaceAll(arg0: Internal.UnaryOperator_<Internal.ItemStack_>): void;
        forEach(arg0: Internal.Consumer_<any>): void;
        stream(): Internal.Stream<Internal.ItemStack>;
        fromTag(arg0: Internal.ListTag_): void;
        isEmpty(): boolean;
        sort(arg0: Internal.Comparator_<any>): void;
        spliterator(): Internal.Spliterator<Internal.ItemStack>;
        get empty(): boolean
    }
    type Hotbar_ = Hotbar;
    class GameRules {
        constructor()
        constructor(arg0: Internal.DynamicLike_<any>)
        getBoolean(arg0: Internal.GameRules$Key_<Internal.GameRules$BooleanValue_>): boolean;
        static visitGameRuleTypes(arg0: Internal.GameRules$GameRuleTypeVisitor_): void;
        assignFrom(arg0: Internal.GameRules_, arg1: Internal.MinecraftServer_): void;
        createTag(): Internal.CompoundTag;
        getRule(arg0: Internal.GameRules$Key_<T>): T;
        getInt(arg0: Internal.GameRules$Key_<Internal.GameRules$IntegerValue_>): number;
        copy(): this;
        static register(arg0: string, arg1: Internal.GameRules$Category_, arg2: Internal.GameRules$Type_<T>): Internal.GameRules$Key<T>;
        readonly static "RULE_MAX_COMMAND_CHAIN_LENGTH": Internal.GameRules$Key<any>;
        readonly static "RULE_MOBGRIEFING": Internal.GameRules$Key<any>;
        readonly static "RULE_DISABLE_ELYTRA_MOVEMENT_CHECK": Internal.GameRules$Key<any>;
        readonly static "RULE_FREEZE_DAMAGE": Internal.GameRules$Key<any>;
        readonly static "RULE_DOINSOMNIA": Internal.GameRules$Key<any>;
        readonly static "RULE_DAYLIGHT": Internal.GameRules$Key<any>;
        readonly static "RULE_DO_TRADER_SPAWNING": Internal.GameRules$Key<any>;
        readonly static "RULE_REDUCEDDEBUGINFO": Internal.GameRules$Key<any>;
        readonly static "RULE_DO_IMMEDIATE_RESPAWN": Internal.GameRules$Key<any>;
        readonly static "RULE_DOMOBSPAWNING": Internal.GameRules$Key<any>;
        readonly static "RULE_DOBLOCKDROPS": Internal.GameRules$Key<any>;
        readonly static "RULE_COMMANDBLOCKOUTPUT": Internal.GameRules$Key<any>;
        readonly static "RULE_WEATHER_CYCLE": Internal.GameRules$Key<any>;
        readonly static "RULE_NATURAL_REGENERATION": Internal.GameRules$Key<any>;
        readonly static "RULE_FIRE_DAMAGE": Internal.GameRules$Key<any>;
        readonly static "RULE_FORGIVE_DEAD_PLAYERS": Internal.GameRules$Key<any>;
        readonly static "RULE_SHOWDEATHMESSAGES": Internal.GameRules$Key<any>;
        readonly static "RULE_PLAYERS_SLEEPING_PERCENTAGE": Internal.GameRules$Key<any>;
        readonly static "RULE_FALL_DAMAGE": Internal.GameRules$Key<any>;
        readonly static "RULE_DISABLE_RAIDS": Internal.GameRules$Key<any>;
        readonly static "RULE_LOGADMINCOMMANDS": Internal.GameRules$Key<any>;
        readonly static "RULE_SPAWN_RADIUS": Internal.GameRules$Key<any>;
        readonly static "RULE_SENDCOMMANDFEEDBACK": Internal.GameRules$Key<any>;
        readonly static "RULE_ANNOUNCE_ADVANCEMENTS": Internal.GameRules$Key<any>;
        readonly static "RULE_DOENTITYDROPS": Internal.GameRules$Key<any>;
        readonly static "RULE_DO_PATROL_SPAWNING": Internal.GameRules$Key<any>;
        readonly static "DEFAULT_RANDOM_TICK_SPEED": 3;
        readonly static "RULE_DOFIRETICK": Internal.GameRules$Key<any>;
        readonly static "RULE_LIMITED_CRAFTING": Internal.GameRules$Key<any>;
        readonly static "RULE_SPECTATORSGENERATECHUNKS": Internal.GameRules$Key<any>;
        readonly static "RULE_MAX_ENTITY_CRAMMING": Internal.GameRules$Key<any>;
        readonly static "RULE_DROWNING_DAMAGE": Internal.GameRules$Key<any>;
        readonly static "RULE_UNIVERSAL_ANGER": Internal.GameRules$Key<any>;
        readonly static "RULE_KEEPINVENTORY": Internal.GameRules$Key<any>;
        readonly static "RULE_DOMOBLOOT": Internal.GameRules$Key<any>;
        readonly static "RULE_RANDOMTICKING": Internal.GameRules$Key<any>;
    }
    type GameRules_ = GameRules;
    class Instant implements Internal.Comparable<Internal.Instant>, Internal.Temporal, Internal.TemporalAdjuster, Internal.Serializable {
        minusSeconds(arg0: number): this;
        plus(arg0: number, arg1: Internal.TemporalUnit_): this;
        static parse(arg0: Internal.CharSequence_): Internal.Instant;
        isBefore(arg0: Internal.Instant_): boolean;
        static ofEpochSecond(arg0: number, arg1: number): Internal.Instant;
        compareTo(arg0: any): number;
        static ofEpochSecond(arg0: number): Internal.Instant;
        minus(arg0: Internal.TemporalAmount_): this;
        plusSeconds(arg0: number): this;
        getLong(arg0: Internal.TemporalField_): number;
        static now(): Internal.Instant;
        isSupported(arg0: Internal.TemporalField_): boolean;
        static from(arg0: Internal.TemporalAccessor_): Internal.Instant;
        minusNanos(arg0: number): this;
        with(arg0: Internal.TemporalField_, arg1: number): this;
        truncatedTo(arg0: Internal.TemporalUnit_): this;
        toString(): string;
        static now(arg0: Internal.Clock_): Internal.Instant;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        with(arg0: Internal.TemporalAdjuster_): this;
        query(arg0: Internal.TemporalQuery_<R>): R;
        minus(arg0: number, arg1: Internal.TemporalUnit_): this;
        atOffset(arg0: Internal.ZoneOffset_): Internal.OffsetDateTime;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        getNano(): number;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        plus(arg0: Internal.TemporalAmount_): Internal.Temporal;
        getEpochSecond(): number;
        plusMillis(arg0: number): this;
        hashCode(): number;
        toEpochMilli(): number;
        isAfter(arg0: Internal.Instant_): boolean;
        get(arg0: Internal.TemporalField_): number;
        atZone(arg0: Internal.ZoneId_): Internal.ZonedDateTime;
        compareTo(arg0: Internal.Instant_): number;
        plusNanos(arg0: number): this;
        static ofEpochMilli(arg0: number): Internal.Instant;
        equals(arg0: any): boolean;
        minusMillis(arg0: number): this;
        get nano(): number
        get epochSecond(): number
        readonly static "EPOCH": Internal.Instant;
        readonly static "MAX": Internal.Instant;
        readonly static "MIN": Internal.Instant;
    }
    type Instant_ = Instant;
    interface ImmutableStringReader {
        getTotalLength(): number;
        getCursor(): number;
        peek(): string;
        getRead(): string;
        canRead(): boolean;
        getRemainingLength(): number;
        getRemaining(): string;
        canRead(arg0: number): boolean;
        peek(arg0: number): string;
        getString(): string;
        get totalLength(): number
        get cursor(): number
        get read(): string
        get remainingLength(): number
        get remaining(): string
        get string(): string
    }
    type ImmutableStringReader_ = ImmutableStringReader;
    interface SeekableByteChannel extends Internal.ByteChannel {
        write(arg0: Internal.ByteBuffer_): number;
        read(arg0: Internal.ByteBuffer_): number;
        position(): number;
        truncate(arg0: number): this;
        position(arg0: number): this;
        size(): number;
    }
    type SeekableByteChannel_ = SeekableByteChannel;
    abstract class AbstractTexture implements Internal.AutoCloseable {
        constructor()
        setBlurMipmap(arg0: boolean, arg1: boolean): void;
        bind(): void;
        restoreLastBlurMipmap(): void;
        load(arg0: Internal.ResourceManager_): void;
        close(): void;
        releaseId(): void;
        setFilter(arg0: boolean, arg1: boolean): void;
        reset(arg0: Internal.TextureManager_, arg1: Internal.ResourceManager_, arg2: ResourceLocation_, arg3: Internal.Executor_): void;
        getId(): number;
        get id(): number
        readonly static "NOT_ASSIGNED": -1;
    }
    type AbstractTexture_ = AbstractTexture;
    interface ShortSpliterator extends Internal.Spliterator$OfPrimitive<number, Internal.ShortConsumer, Internal.ShortSpliterator> {
        forEachRemaining(arg0: Internal.ShortConsumer_): void;
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        getComparator(): Internal.Comparator<any>;
        getExactSizeIfKnown(): number;
        hasCharacteristics(arg0: number): boolean;
        tryAdvance(arg0: Internal.Consumer_<any>): boolean;
        skip(arg0: number): number;
        get comparator(): Internal.Comparator<any>
        get exactSizeIfKnown(): number
    }
    type ShortSpliterator_ = ShortSpliterator;
    class RenderGameOverlayEvent$Pre extends Internal.RenderGameOverlayEvent {
        constructor()
        constructor(arg0: Internal.PoseStack_, arg1: Internal.RenderGameOverlayEvent_, arg2: Internal.RenderGameOverlayEvent$ElementType_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type RenderGameOverlayEvent$Pre_ = RenderGameOverlayEvent$Pre;
    class CountingMap {
        constructor()
        add(key: any, value: number): number;
        set(key: any, value: number): number;
        getValues(): Internal.Collection<number>;
        forEach(forEach: Internal.Consumer_<Internal.Object2LongEntry_>): void;
        getSize(): number;
        get(key: any): number;
        clear(): void;
        getTotalCount(): number;
        getEntries(): Internal.List<Internal.Object2LongEntry>;
        getKeys(): Internal.Set<any>;
        get values(): Internal.Collection<number>
        get size(): number
        get totalCount(): number
        get entries(): Internal.List<Internal.Object2LongEntry>
        get keys(): Internal.Set<any>
    }
    type CountingMap_ = CountingMap;
    class AmbientOcclusionStatus extends Internal.Enum<Internal.AmbientOcclusionStatus> {
        static valueOf(arg0: string): Internal.AmbientOcclusionStatus;
        getKey(): string;
        static values(): Internal.AmbientOcclusionStatus[];
        static byId(arg0: number): Internal.AmbientOcclusionStatus;
        getId(): number;
        get key(): string
        get id(): number
        readonly static "OFF": Internal.AmbientOcclusionStatus;
        readonly static "MIN": Internal.AmbientOcclusionStatus;
        readonly static "MAX": Internal.AmbientOcclusionStatus;
    }
    type AmbientOcclusionStatus_ = "min" | "max" | "off" | AmbientOcclusionStatus;
    interface BucketPickup extends Internal.IForgeBucketPickup {
        getPickupSound(arg0: Internal.BlockState_): Internal.Optional<Internal.SoundEvent>;
        pickupBlock(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: Internal.BlockState_): Internal.ItemStack;
        getPickupSound(): Internal.Optional<Internal.SoundEvent>;
        get pickupSound(): Internal.Optional<Internal.SoundEvent>
    }
    type BucketPickup_ = BucketPickup;
    class PlaySoundEvent extends net.minecraftforge.client.event.sound.SoundEvent {
        constructor()
        constructor(arg0: Internal.SoundEngine_, arg1: Internal.SoundInstance_)
        setSound(arg0: Internal.SoundInstance_): void;
        getSound(): Internal.SoundInstance;
        getName(): string;
        getListenerList(): Internal.ListenerList;
        getOriginalSound(): Internal.SoundInstance;
        set sound(arg0: Internal.SoundInstance_)
        get sound(): Internal.SoundInstance
        get name(): string
        get listenerList(): Internal.ListenerList
        get originalSound(): Internal.SoundInstance
    }
    type PlaySoundEvent_ = PlaySoundEvent;
    interface BiomeSpecialEffects$GrassColorModifier$ColorModifier {
        modifyGrassColor(arg0: number, arg1: number, arg2: number): number;
    }
    type BiomeSpecialEffects$GrassColorModifier$ColorModifier_ = BiomeSpecialEffects$GrassColorModifier$ColorModifier | ((arg0: number, arg1: number, arg2: number)=>number);
    class Proxy$Type extends Internal.Enum<Internal.Proxy$Type> {
        static valueOf(arg0: string): Internal.Proxy$Type;
        static values(): Internal.Proxy$Type[];
        readonly static "SOCKS": Internal.Proxy$Type;
        readonly static "HTTP": Internal.Proxy$Type;
        readonly static "DIRECT": Internal.Proxy$Type;
    }
    type Proxy$Type_ = Proxy$Type | "http" | "socks" | "direct";
    interface K1 {
    }
    type K1_ = K1;
    class ShulkerBoxMenu extends Internal.AbstractContainerMenu {
        constructor(arg0: number, arg1: Internal.Inventory_)
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Container_)
        stillValid(arg0: Internal.Player_): boolean;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        removed(arg0: Internal.Player_): void;
    }
    type ShulkerBoxMenu_ = ShulkerBoxMenu;
    class MobCategory extends Internal.Enum<Internal.MobCategory> implements Internal.IExtensibleEnum, Internal.StringRepresentable {
        getDespawnDistance(): number;
        static values(): Internal.MobCategory[];
        init(): void;
        getSerializedName(): string;
        static byName(arg0: string): Internal.MobCategory;
        getName(): string;
        isFriendly(): boolean;
        isPersistent(): boolean;
        static valueOf(arg0: string): Internal.MobCategory;
        static create(arg0: string, arg1: string, arg2: number, arg3: boolean, arg4: boolean, arg5: number): Internal.MobCategory;
        getNoDespawnDistance(): number;
        getMaxInstancesPerChunk(): number;
        get despawnDistance(): number
        get serializedName(): string
        get name(): string
        get friendly(): boolean
        get persistent(): boolean
        get noDespawnDistance(): number
        get maxInstancesPerChunk(): number
        readonly static "AMBIENT": Internal.MobCategory;
        readonly static "CREATURE": Internal.MobCategory;
        readonly static "MISC": Internal.MobCategory;
        readonly static "MONSTER": Internal.MobCategory;
        readonly static "WATER_AMBIENT": Internal.MobCategory;
        readonly static "CODEC": any;
        readonly static "AXOLOTLS": Internal.MobCategory;
        readonly static "WATER_CREATURE": Internal.MobCategory;
        readonly static "UNDERGROUND_WATER_CREATURE": Internal.MobCategory;
    }
    type MobCategory_ = "monster" | "underground_water_creature" | "misc" | "creature" | "water_ambient" | "axolotls" | "ambient" | MobCategory | "water_creature";
    class BaseFunction extends Internal.IdScriptableObject implements dev.latvian.mods.rhino.Function {
        constructor()
        constructor(scope: Internal.Scriptable_, prototype: Internal.Scriptable_)
        constructor(isGenerator: boolean)
        getArity(): number;
        setImmunePrototypeProperty(value: any): void;
        call(cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        toString(): string;
        hasInstance(instance: Internal.Scriptable_): boolean;
        getClassName(): string;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getAllIds(): any[];
        getLength(): number;
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getFunctionName(): string;
        createObject(cx: Internal.Context_, scope: Internal.Scriptable_): Internal.Scriptable;
        execIdCall(f: Internal.IdFunctionObject_, cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        getTypeOf(): Internal.MemberType;
        construct(cx: Internal.Context_, scope: Internal.Scriptable_, args: any[]): Internal.Scriptable;
        get arity(): number
        set immunePrototypeProperty(value: any)
        get className(): string
        get allIds(): any[]
        get length(): number
        get functionName(): string
        get typeOf(): Internal.MemberType
    }
    type BaseFunction_ = BaseFunction;
    class DirectMethodHandleDesc$Kind extends Internal.Enum<Internal.DirectMethodHandleDesc$Kind> {
        static values(): Internal.DirectMethodHandleDesc$Kind[];
        static valueOf(arg0: string): Internal.DirectMethodHandleDesc$Kind;
        static valueOf(arg0: number, arg1: boolean): Internal.DirectMethodHandleDesc$Kind;
        static valueOf(arg0: number): Internal.DirectMethodHandleDesc$Kind;
        readonly static "INTERFACE_SPECIAL": Internal.DirectMethodHandleDesc$Kind;
        readonly "isInterface": boolean;
        readonly static "STATIC_SETTER": Internal.DirectMethodHandleDesc$Kind;
        readonly static "CONSTRUCTOR": Internal.DirectMethodHandleDesc$Kind;
        readonly static "SPECIAL": Internal.DirectMethodHandleDesc$Kind;
        readonly static "STATIC": Internal.DirectMethodHandleDesc$Kind;
        readonly static "SETTER": Internal.DirectMethodHandleDesc$Kind;
        readonly static "INTERFACE_VIRTUAL": Internal.DirectMethodHandleDesc$Kind;
        readonly static "GETTER": Internal.DirectMethodHandleDesc$Kind;
        readonly static "VIRTUAL": Internal.DirectMethodHandleDesc$Kind;
        readonly "refKind": number;
        readonly static "INTERFACE_STATIC": Internal.DirectMethodHandleDesc$Kind;
        readonly static "STATIC_GETTER": Internal.DirectMethodHandleDesc$Kind;
    }
    type DirectMethodHandleDesc$Kind_ = "static" | "constructor" | "interface_special" | "static_getter" | "setter" | "virtual" | DirectMethodHandleDesc$Kind | "getter" | "interface_static" | "special" | "static_setter" | "interface_virtual";
    class ModuleDescriptor$Provides implements Internal.Comparable<Internal.ModuleDescriptor$Provides> {
        hashCode(): number;
        toString(): string;
        equals(arg0: any): boolean;
        service(): string;
        compareTo(arg0: Internal.ModuleDescriptor$Provides_): number;
        providers(): Internal.List<string>;
        compareTo(arg0: any): number;
    }
    type ModuleDescriptor$Provides_ = ModuleDescriptor$Provides;
    interface Byte2ShortFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntUnaryOperator {
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Byte2ByteFunction;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2ShortFunction;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Byte2LongFunction;
        getOrDefault(arg0: any, arg1: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2ShortFunction;
        containsKey(arg0: any): boolean;
        get(arg0: any): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): this;
        composeByte(arg0: Internal.Byte2ByteFunction_): this;
        defaultReturnValue(): number;
        put(arg0: number, arg1: number): number;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Byte2DoubleFunction;
        applyAsInt(arg0: number): number;
        put(arg0: any, arg1: any): any;
        andThenReference(arg0: Internal.Short2ReferenceFunction_<any>): Internal.Byte2ReferenceFunction<T>;
        containsKey(arg0: number): boolean;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2ShortFunction;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Byte2FloatFunction;
        getOrDefault(arg0: number, arg1: number): number;
        andThenObject(arg0: Internal.Short2ObjectFunction_<any>): Internal.Byte2ObjectFunction<T>;
        remove(arg0: number): number;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2ShortFunction;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Byte2IntFunction;
        composeReference(arg0: Internal.Reference2ByteFunction_<any>): Internal.Reference2ShortFunction<T>;
        composeObject(arg0: Internal.Object2ByteFunction_<any>): Internal.Object2ShortFunction<T>;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2ShortFunction;
        put(arg0: number, arg1: number): number;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Byte2CharFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        size(): number;
        defaultReturnValue(arg0: number): void;
        get(arg0: number): number;
        apply(arg0: number): number;
        clear(): void;
        getOrDefault(arg0: any, arg1: number): number;
        remove(arg0: any): any;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2ShortFunction;
    }
    type Byte2ShortFunction_ = ((arg0: number)=>number) | Byte2ShortFunction;
    interface Appendable {
        append(arg0: Internal.CharSequence_): this;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): this;
        append(arg0: string): this;
    }
    type Appendable_ = Appendable;
    class BlockPredicateFilter extends Internal.PlacementFilter {
        type(): Internal.PlacementModifierType<any>;
        static forPredicate(arg0: net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_): Internal.BlockPredicateFilter;
        readonly static "CODEC": any;
    }
    type BlockPredicateFilter_ = BlockPredicateFilter;
    class StreamTagVisitor$EntryResult extends Internal.Enum<Internal.StreamTagVisitor$EntryResult> {
        static valueOf(arg0: string): Internal.StreamTagVisitor$EntryResult;
        static values(): Internal.StreamTagVisitor$EntryResult[];
        readonly static "BREAK": Internal.StreamTagVisitor$EntryResult;
        readonly static "SKIP": Internal.StreamTagVisitor$EntryResult;
        readonly static "ENTER": Internal.StreamTagVisitor$EntryResult;
        readonly static "HALT": Internal.StreamTagVisitor$EntryResult;
    }
    type StreamTagVisitor$EntryResult_ = StreamTagVisitor$EntryResult | "break" | "halt" | "skip" | "enter";
    class FogShape extends Internal.Enum<Internal.FogShape> {
        static valueOf(arg0: string): Internal.FogShape;
        static values(): Internal.FogShape[];
        getIndex(): number;
        get index(): number
        readonly static "CYLINDER": Internal.FogShape;
        readonly static "SPHERE": Internal.FogShape;
    }
    type FogShape_ = FogShape | "cylinder" | "sphere";
    class ClientboundSetCarriedItemPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getSlot(): number;
        isSkippable(): boolean;
        get slot(): number
        get skippable(): boolean
    }
    type ClientboundSetCarriedItemPacket_ = ClientboundSetCarriedItemPacket;
    class CampfireBlockEntity extends Internal.BlockEntity implements Internal.Clearable {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        static particleTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.CampfireBlockEntity_): void;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getUpdateTag(): Internal.CompoundTag;
        getItems(): Internal.NonNullList<Internal.ItemStack>;
        getCookableRecipe(arg0: Internal.ItemStack_): Internal.Optional<Internal.CampfireCookingRecipe>;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getUpdatePacket(): Internal.ClientboundBlockEntityDataPacket;
        serializeNBT(): Internal.CompoundTag;
        placeFood(arg0: Internal.ItemStack_, arg1: number): boolean;
        static cooldownTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.CampfireBlockEntity_): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        load(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        static cookTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.CampfireBlockEntity_): void;
        dowse(): void;
        clearContent(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get modelData(): Internal.IModelData
        get updateTag(): Internal.CompoundTag
        get items(): Internal.NonNullList<Internal.ItemStack>
        get updatePacket(): Internal.ClientboundBlockEntityDataPacket
        get renderBoundingBox(): Internal.AABB
    }
    type CampfireBlockEntity_ = CampfireBlockEntity;
    class PlayerXpEvent$XpChange extends Internal.PlayerXpEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: number)
        isCancelable(): boolean;
        setAmount(arg0: number): void;
        getListenerList(): Internal.ListenerList;
        getAmount(): number;
        get cancelable(): boolean
        set amount(arg0: number)
        get listenerList(): Internal.ListenerList
        get amount(): number
    }
    type PlayerXpEvent$XpChange_ = PlayerXpEvent$XpChange;
    interface TagVisitor {
        visitFloat(arg0: Internal.FloatTag_): void;
        visitByte(arg0: Internal.ByteTag_): void;
        visitLongArray(arg0: Internal.LongArrayTag_): void;
        visitList(arg0: Internal.ListTag_): void;
        visitShort(arg0: Internal.ShortTag_): void;
        visitEnd(arg0: Internal.EndTag_): void;
        visitIntArray(arg0: Internal.IntArrayTag_): void;
        visitInt(arg0: Internal.IntTag_): void;
        visitByteArray(arg0: Internal.ByteArrayTag_): void;
        visitString(arg0: Internal.StringTag_): void;
        visitCompound(arg0: Internal.CompoundTag_): void;
        visitDouble(arg0: Internal.DoubleTag_): void;
        visitLong(arg0: Internal.LongTag_): void;
    }
    type TagVisitor_ = TagVisitor;
    class GeodeLayerSettings {
        constructor(arg0: number, arg1: number, arg2: number, arg3: number)
        readonly "innerLayer": number;
        readonly "middleLayer": number;
        readonly static "CODEC": any;
        readonly "outerLayer": number;
        readonly "filling": number;
    }
    type GeodeLayerSettings_ = GeodeLayerSettings;
    interface DoublePredicate {
        or(arg0: Internal.DoublePredicate_): this;
        test(arg0: number): boolean;
        and(arg0: Internal.DoublePredicate_): this;
        negate(): this;
    }
    type DoublePredicate_ = DoublePredicate | ((arg0: number)=>boolean);
    interface RegistrySupplier <T> extends Internal.Supplier<T> {
        ifPresentOrElse(action: Internal.Consumer_<any>, emptyAction: Internal.Runnable_): void;
        stream(): Internal.Stream<T>;
        getRegistries(): Internal.Registries;
        getRegistryKey(): Internal.ResourceKey<Internal.Registry<T>>;
        getRegistrar(): Internal.Registrar<T>;
        getOrNull(): T;
        orElse(other: T): T;
        isPresent(): boolean;
        getId(): ResourceLocation;
        ifPresent(action: Internal.Consumer_<any>): void;
        orElseGet(supplier: Internal.Supplier_<any>): T;
        getRegistryId(): ResourceLocation;
        listen(callback: Internal.Consumer_<T>): void;
        toOptional(): Internal.Optional<T>;
        get registries(): Internal.Registries
        get registryKey(): Internal.ResourceKey<Internal.Registry<T>>
        get registrar(): Internal.Registrar<T>
        get orNull(): T
        get present(): boolean
        get id(): ResourceLocation
        get registryId(): ResourceLocation
    }
    type RegistrySupplier_<T> = RegistrySupplier<T>;
    class MetricSampler$MetricSamplerBuilder <T> {
        constructor(arg0: string, arg1: Internal.MetricCategory_, arg2: Internal.ToDoubleFunction_<T>, arg3: T)
        withBeforeTick(arg0: Internal.Consumer_<T>): this;
        withThresholdAlert(arg0: Internal.MetricSampler$ThresholdTest_): this;
        build(): Internal.MetricSampler;
    }
    type MetricSampler$MetricSamplerBuilder_<T> = MetricSampler$MetricSamplerBuilder<T>;
    interface ResultConsumer <S> {
        onCommandComplete(arg0: Internal.CommandContext_<S>, arg1: boolean, arg2: number): void;
    }
    type ResultConsumer_<S> = ((arg0: Internal.CommandContext<S>, arg1: boolean, arg2: number)=>void) | ResultConsumer<S>;
    class PlayerEvent$PlayerRespawnEvent extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: boolean)
        getListenerList(): Internal.ListenerList;
        isEndConquered(): boolean;
        get listenerList(): Internal.ListenerList
        get endConquered(): boolean
    }
    type PlayerEvent$PlayerRespawnEvent_ = PlayerEvent$PlayerRespawnEvent;
    class ModuleDescriptor$Exports$Modifier extends Internal.Enum<Internal.ModuleDescriptor$Exports$Modifier> {
        static values(): Internal.ModuleDescriptor$Exports$Modifier[];
        static valueOf(arg0: string): Internal.ModuleDescriptor$Exports$Modifier;
        readonly static "SYNTHETIC": Internal.ModuleDescriptor$Exports$Modifier;
        readonly static "MANDATED": Internal.ModuleDescriptor$Exports$Modifier;
    }
    type ModuleDescriptor$Exports$Modifier_ = "mandated" | "synthetic" | ModuleDescriptor$Exports$Modifier;
    class Item extends Internal.ForgeRegistryEntry<Internal.Item> implements Internal.ItemLike, Internal.IForgeItem, Internal.ItemKJS, Internal.InjectedItemExtension {
        constructor(arg0: Internal.Item$Properties_)
        getShareTag(arg0: Internal.ItemStack_): Internal.CompoundTag;
        getDrinkingSound(): Internal.SoundEvent;
        isEnderMask(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.EnderMan_): boolean;
        initializeClient(arg0: Internal.Consumer_<Internal.IItemRenderProperties_>): void;
        getBurnTime(arg0: Internal.ItemStack_, arg1: Internal.RecipeType_<any>): number;
        getDestroySpeed(arg0: Internal.ItemStack_, arg1: Internal.BlockState_): number;
        onDestroyed(arg0: Internal.ItemEntity_): void;
        isFireResistant(): boolean;
        onItemUseFirst(arg0: Internal.ItemStack_, arg1: Internal.UseOnContext_): Internal.InteractionResult;
        onUsingTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): void;
        isComplex(): boolean;
        onCraftedBy(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Player_): void;
        setMaxStackSizeKJS(arg0: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack_): boolean;
        isCorrectToolForDrops(arg0: Internal.ItemStack_, arg1: Internal.BlockState_): boolean;
        getItemStackLimit(arg0: Internal.ItemStack_): number;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_, arg3: Internal.LivingEntity_): boolean;
        getItemBuilderKJS(): Internal.ItemBuilder;
        appendHoverText(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.List_<Internal.Component_>, arg3: Internal.TooltipFlag_): void;
        onUseTick(arg0: Internal.Level_, arg1: Internal.LivingEntity_, arg2: Internal.ItemStack_, arg3: number): void;
        getFoodProperties(): Internal.FoodProperties;
        canBeHurtBy(arg0: Internal.DamageSource_): boolean;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_, arg1: Internal.Enchantment_): boolean;
        getUseAnimation(arg0: Internal.ItemStack_): Internal.UseAnim;
        getDescriptionId(): string;
        isValidRepairItem(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getXpRepairRatio(arg0: Internal.ItemStack_): number;
        isBookEnchantable(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        initCapabilities(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): Internal.ICapabilityProvider;
        onDroppedByPlayer(arg0: Internal.ItemStack_, arg1: Internal.Player_): boolean;
        asItem(): this;
        getTypeData(): Internal.CompoundTag;
        getDefaultInstance(): Internal.ItemStack;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack_): number;
        getCreatorModId(arg0: Internal.ItemStack_): string;
        canContinueUsing(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        setBurnTime(i: number): void;
        setItemBuilderKJS(b: Internal.ItemBuilder_): void;
        getFoodProperties(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): Internal.FoodProperties;
        getBarWidth(arg0: Internal.ItemStack_): number;
        getBarColor(arg0: Internal.ItemStack_): number;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        onLeftClickEntity(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getMaxDamage(): number;
        getDescription(): Internal.Component;
        hasCraftingRemainingItem(): boolean;
        canPerformAction(arg0: Internal.ItemStack_, arg1: Internal.ToolAction_): boolean;
        static byId(arg0: number): Internal.Item;
        onEntityItemUpdate(arg0: Internal.ItemStack_, arg1: Internal.ItemEntity_): boolean;
        getRenderPropertiesInternal(): any;
        interactLivingEntity(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.LivingEntity_, arg3: Hand_): Internal.InteractionResult;
        onArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Player_): void;
        useOn(arg0: Internal.UseOnContext_): Internal.InteractionResult;
        getRarity(arg0: Internal.ItemStack_): Rarity;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        setFireResistantKJS(arg0: boolean): void;
        getItemCategory(): Internal.CreativeModeTab;
        damageItem(arg0: Internal.ItemStack_, arg1: number, arg2: T, arg3: Internal.Consumer_<T>): number;
        fillItemCategory(arg0: Internal.CreativeModeTab_, arg1: Internal.NonNullList_<Internal.ItemStack_>): void;
        getTooltipImage(arg0: Internal.ItemStack_): Internal.Optional<Internal.TooltipComponent>;
        isEdible(): boolean;
        arch$holder(): Internal.Holder<Internal.Item>;
        getArmorTexture(arg0: Internal.ItemStack_, arg1: Internal.Entity_, arg2: EquipmentSlot_, arg3: string): string;
        use(arg0: Internal.Level_, arg1: Internal.Player_, arg2: Hand_): Internal.InteractionResultHolder<Internal.ItemStack>;
        toString(): string;
        getEnchantmentValue(): number;
        getId(): string;
        isEnchantable(arg0: Internal.ItemStack_): boolean;
        getSweepHitBox(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): Internal.AABB;
        overrideStackedOnOther(arg0: Internal.ItemStack_, arg1: Internal.Slot_, arg2: Internal.ClickAction_, arg3: Internal.Player_): boolean;
        onBlockStartBreak(arg0: Internal.ItemStack_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        getMaxDamage(arg0: Internal.ItemStack_): number;
        elytraFlightTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        isFoil(arg0: Internal.ItemStack_): boolean;
        isRepairable(arg0: Internal.ItemStack_): boolean;
        isDamageable(arg0: Internal.ItemStack_): boolean;
        useOnRelease(arg0: Internal.ItemStack_): boolean;
        canAttackBlock(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        getDescriptionId(arg0: Internal.ItemStack_): string;
        setMaxDamageKJS(arg0: number): void;
        releaseUsing(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.LivingEntity_, arg3: number): void;
        isBarVisible(arg0: Internal.ItemStack_): boolean;
        canWalkOnPowderedSnow(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getUseDuration(arg0: Internal.ItemStack_): number;
        hasContainerItem(arg0: Internal.ItemStack_): boolean;
        getEquipSound(): Internal.SoundEvent;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        getMaxStackSize(): number;
        static byBlock(arg0: Internal.Block_): Internal.Item;
        setCraftingRemainderKJS(arg0: Internal.Item_): void;
        isDamaged(arg0: Internal.ItemStack_): boolean;
        canFitInsideContainerItems(): boolean;
        getHighlightTip(arg0: Internal.ItemStack_, arg1: Internal.Component_): Internal.Component;
        isCorrectToolForDrops(arg0: Internal.BlockState_): boolean;
        verifyTagAfterLoad(arg0: Internal.CompoundTag_): void;
        canEquip(arg0: Internal.ItemStack_, arg1: EquipmentSlot_, arg2: Internal.Entity_): boolean;
        finishUsingItem(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.LivingEntity_): Internal.ItemStack;
        getItemEnchantability(arg0: Internal.ItemStack_): number;
        getEatingSound(): Internal.SoundEvent;
        hasCustomEntity(arg0: Internal.ItemStack_): boolean;
        canBeDepleted(): boolean;
        getDamage(arg0: Internal.ItemStack_): number;
        mineBlock(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.BlockState_, arg3: BlockPos_, arg4: Internal.LivingEntity_): boolean;
        readShareTag(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): void;
        getEquipmentSlot(arg0: Internal.ItemStack_): EquipmentSlot;
        getName(arg0: Internal.ItemStack_): Internal.Component;
        getDefaultAttributeModifiers(arg0: EquipmentSlot_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        arch$registryName(): ResourceLocation;
        setRarityKJS(arg0: Rarity_): void;
        getAttributeModifiers(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        canElytraFly(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        builtInRegistryHolder(): Internal.Holder$Reference<Internal.Item>;
        createEntity(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.ItemStack_): Internal.Entity;
        setFoodPropertiesKJS(arg0: Internal.FoodProperties_): void;
        onEntitySwing(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getEntityLifespan(arg0: Internal.ItemStack_, arg1: Internal.Level_): number;
        inventoryTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Entity_, arg3: number, arg4: boolean): void;
        setDamage(arg0: Internal.ItemStack_, arg1: number): void;
        hurtEnemy(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: Internal.LivingEntity_): boolean;
        getCraftingRemainingItem(): this;
        shouldOverrideMultiplayerNbt(): boolean;
        static getId(arg0: Internal.Item_): number;
        overrideOtherStackedOnMe(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.Slot_, arg3: Internal.ClickAction_, arg4: Internal.Player_, arg5: Internal.SlotAccess_): boolean;
        doesSneakBypassUse(arg0: Internal.ItemStack_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: boolean): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Mob_): void;
        getContainerItem(arg0: Internal.ItemStack_): Internal.ItemStack;
        get drinkingSound(): Internal.SoundEvent
        get fireResistant(): boolean
        get complex(): boolean
        set maxStackSizeKJS(arg0: number)
        get itemBuilderKJS(): Internal.ItemBuilder
        get foodProperties(): Internal.FoodProperties
        get descriptionId(): string
        get typeData(): Internal.CompoundTag
        get defaultInstance(): Internal.ItemStack
        set burnTime(i: number)
        set itemBuilderKJS(b: Internal.ItemBuilder_)
        get maxDamage(): number
        get description(): Internal.Component
        get renderPropertiesInternal(): any
        set fireResistantKJS(arg0: boolean)
        get itemCategory(): Internal.CreativeModeTab
        get edible(): boolean
        get enchantmentValue(): number
        get id(): string
        set maxDamageKJS(arg0: number)
        get equipSound(): Internal.SoundEvent
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>
        get maxStackSize(): number
        set craftingRemainderKJS(arg0: Internal.Item_)
        get eatingSound(): Internal.SoundEvent
        set rarityKJS(arg0: Rarity_)
        set foodPropertiesKJS(arg0: Internal.FoodProperties_)
        get craftingRemainingItem(): Internal.Item
        readonly static "BY_BLOCK": {[key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any, [key: any]: any, [key: any]: any, [key: Internal.Block]: any};
        readonly static "EAT_DURATION": 32;
        readonly static "MAX_STACK_SIZE": 64;
        /**
         * @org.spongepowered.asm.mixin.Final()
        */
        readonly static "MAX_BAR_WIDTH": 13;
    }
    type Item_ = Item | Special.Item;
    interface ItemSupplier {
        getItem(): Internal.ItemStack;
        get item(): Internal.ItemStack
    }
    type ItemSupplier_ = ItemSupplier;
    interface Boolean2ObjectFunction <V> extends it.unimi.dsi.fastutil.Function<boolean, V> {
        put(arg0: boolean, arg1: V): V;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Boolean2ShortFunction;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2ObjectFunction<V>;
        composeObject(arg0: Internal.Object2BooleanFunction_<any>): Internal.Object2ObjectFunction<T, V>;
        getOrDefault(arg0: any, arg1: V): V;
        composeReference(arg0: Internal.Reference2BooleanFunction_<any>): Internal.Reference2ObjectFunction<T, V>;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Boolean2DoubleFunction;
        containsKey(arg0: any): boolean;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Boolean2FloatFunction;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Boolean2IntFunction;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2ObjectFunction<V>;
        andThenReference(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Boolean2ReferenceFunction<T>;
        put(arg0: boolean, arg1: V): V;
        get(arg0: any): V;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Boolean2LongFunction;
        apply(arg0: boolean): V;
        get(arg0: boolean): V;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Boolean2ByteFunction;
        andThenObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Boolean2ObjectFunction<T>;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2ObjectFunction<V>;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2ObjectFunction<V>;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2ObjectFunction<V>;
        containsKey(arg0: boolean): boolean;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<boolean, V>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        remove(arg0: boolean): V;
        size(): number;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2ObjectFunction<V>;
        clear(): void;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2ObjectFunction<V>;
        defaultReturnValue(): V;
        getOrDefault(arg0: boolean, arg1: V): V;
        defaultReturnValue(arg0: V): void;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Boolean2CharFunction;
    }
    type Boolean2ObjectFunction_<V> = ((arg0: boolean)=>V) | Boolean2ObjectFunction<V>;
    class MapBanner {
        constructor(arg0: BlockPos_, arg1: Internal.DyeColor_, arg2: Internal.Component_)
        getPos(): BlockPos;
        save(): Internal.CompoundTag;
        getColor(): Internal.DyeColor;
        hashCode(): number;
        getName(): Internal.Component;
        static load(arg0: Internal.CompoundTag_): Internal.MapBanner;
        static fromWorld(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.MapBanner;
        getId(): string;
        equals(arg0: any): boolean;
        getDecoration(): Internal.MapDecoration$Type;
        get pos(): BlockPos
        get color(): Internal.DyeColor
        get name(): Internal.Component
        get id(): string
        get decoration(): Internal.MapDecoration$Type
    }
    type MapBanner_ = MapBanner;
    class HoeItemBuilder extends Internal.HandheldItemBuilder {
        constructor(i: ResourceLocation_)
        createObject(): Internal.Item;
    }
    type HoeItemBuilder_ = HoeItemBuilder;
    class ServerAdvancementManager extends Internal.SimpleJsonResourceReloadListener {
        constructor(arg0: Internal.PredicateManager_)
        constructor(arg0: Internal.PredicateManager_, arg1: Internal.ICondition$IContext_)
        getAllAdvancements(): Internal.Collection<Internal.Advancement>;
        getAdvancement(arg0: ResourceLocation_): Internal.Advancement;
        getName(): string;
        get allAdvancements(): Internal.Collection<Internal.Advancement>
        get name(): string
    }
    type ServerAdvancementManager_ = ServerAdvancementManager;
    class HoverEvent$Action <T> {
        constructor(arg0: string, arg1: boolean, arg2: Internal.Function_<Internal.JsonElement_, T>, arg3: Internal.Function_<T, Internal.JsonElement_>, arg4: Internal.Function_<Internal.Component_, T>)
        static getByName(arg0: string): Internal.HoverEvent$Action<any>;
        isAllowedFromServer(): boolean;
        toString(): string;
        deserializeFromLegacy(arg0: Internal.Component_): Internal.HoverEvent;
        getName(): string;
        serializeArg(arg0: any): Internal.JsonElement;
        deserialize(arg0: Internal.JsonElement_): Internal.HoverEvent;
        get allowedFromServer(): boolean
        get name(): string
        readonly static "SHOW_ENTITY": Internal.HoverEvent$Action<any>;
        readonly static "SHOW_TEXT": Internal.HoverEvent$Action<any>;
        readonly static "SHOW_ITEM": Internal.HoverEvent$Action<any>;
    }
    type HoverEvent$Action_<T> = HoverEvent$Action<T>;
    abstract class HangingEntity extends Internal.Entity {
        mirror(arg0: Internal.Mirror_): number;
        thunderHit(arg0: Internal.ServerLevel_, arg1: Internal.LightningBolt_): void;
        push(arg0: number, arg1: number, arg2: number): void;
        setPos(arg0: number, arg1: number, arg2: number): void;
        playPlacementSound(): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        getPos(): BlockPos;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        rotate(arg0: Internal.Rotation_): number;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        refreshDimensions(): void;
        shouldRiderSit(): boolean;
        getHeight(): number;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getWidth(): number;
        dropItem(arg0: Internal.Entity_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        survives(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        move(arg0: Internal.MoverType_, arg1: Vec3_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isPickable(): boolean;
        tick(): void;
        spawnAtLocation(arg0: Internal.ItemStack_, arg1: number): Internal.ItemEntity;
        skipAttackInteraction(arg0: Internal.Entity_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getDirection(): Internal.Direction;
        get stepHeight(): number
        get pos(): BlockPos
        get multipartEntity(): boolean
        get height(): number
        get parts(): Internal.PartEntity<any>[]
        get width(): number
        get pickable(): boolean
        get direction(): Internal.Direction
    }
    type HangingEntity_ = HangingEntity;
    class GoalSelectorDebugRenderer$DebugGoal {
        constructor(arg0: BlockPos_, arg1: number, arg2: string, arg3: boolean)
        readonly "name": string;
        readonly "priority": number;
        readonly "isRunning": boolean;
        readonly "pos": BlockPos;
    }
    type GoalSelectorDebugRenderer$DebugGoal_ = GoalSelectorDebugRenderer$DebugGoal;
    class SoundType {
        constructor(arg0: number, arg1: number, arg2: Internal.SoundEvent_, arg3: Internal.SoundEvent_, arg4: Internal.SoundEvent_, arg5: Internal.SoundEvent_, arg6: Internal.SoundEvent_)
        getVolume(): number;
        getPitch(): number;
        getHitSound(): Internal.SoundEvent;
        getStepSound(): Internal.SoundEvent;
        getBreakSound(): Internal.SoundEvent;
        getFallSound(): Internal.SoundEvent;
        getPlaceSound(): Internal.SoundEvent;
        get volume(): number
        get pitch(): number
        get hitSound(): Internal.SoundEvent
        get stepSound(): Internal.SoundEvent
        get breakSound(): Internal.SoundEvent
        get fallSound(): Internal.SoundEvent
        get placeSound(): Internal.SoundEvent
        readonly static "HONEY_BLOCK": Internal.SoundType;
        readonly static "SAND": Internal.SoundType;
        readonly static "NETHER_BRICKS": Internal.SoundType;
        readonly static "TUFF": Internal.SoundType;
        readonly static "GRAVEL": Internal.SoundType;
        readonly static "SHROOMLIGHT": Internal.SoundType;
        readonly static "GILDED_BLACKSTONE": Internal.SoundType;
        readonly static "HARD_CROP": Internal.SoundType;
        readonly static "DEEPSLATE_TILES": Internal.SoundType;
        readonly static "MOSS": Internal.SoundType;
        readonly "pitch": number;
        readonly static "GRASS": Internal.SoundType;
        readonly static "SOUL_SOIL": Internal.SoundType;
        readonly static "VINE": Internal.SoundType;
        readonly static "WEEPING_VINES": Internal.SoundType;
        readonly static "ANCIENT_DEBRIS": Internal.SoundType;
        readonly static "SCULK_SENSOR": Internal.SoundType;
        readonly static "BAMBOO": Internal.SoundType;
        readonly static "GLASS": Internal.SoundType;
        readonly static "DRIPSTONE_BLOCK": Internal.SoundType;
        readonly static "POINTED_DRIPSTONE": Internal.SoundType;
        readonly static "ROOTED_DIRT": Internal.SoundType;
        readonly static "NETHER_ORE": Internal.SoundType;
        readonly static "COPPER": Internal.SoundType;
        readonly static "LANTERN": Internal.SoundType;
        readonly static "CALCITE": Internal.SoundType;
        readonly static "STEM": Internal.SoundType;
        readonly static "BONE_BLOCK": Internal.SoundType;
        readonly static "SOUL_SAND": Internal.SoundType;
        readonly static "SNOW": Internal.SoundType;
        readonly static "BIG_DRIPLEAF": Internal.SoundType;
        readonly static "TWISTING_VINES": Internal.SoundType;
        readonly static "NETHERRACK": Internal.SoundType;
        readonly static "AMETHYST_CLUSTER": Internal.SoundType;
        readonly static "POLISHED_DEEPSLATE": Internal.SoundType;
        readonly static "SLIME_BLOCK": Internal.SoundType;
        readonly static "NYLIUM": Internal.SoundType;
        readonly static "DEEPSLATE": Internal.SoundType;
        readonly static "CHAIN": Internal.SoundType;
        readonly static "SPORE_BLOSSOM": Internal.SoundType;
        readonly static "WOOD": Internal.SoundType;
        readonly static "BASALT": Internal.SoundType;
        readonly static "AZALEA": Internal.SoundType;
        readonly static "NETHER_GOLD_ORE": Internal.SoundType;
        readonly static "SMALL_AMETHYST_BUD": Internal.SoundType;
        readonly static "CANDLE": Internal.SoundType;
        readonly static "FLOWERING_AZALEA": Internal.SoundType;
        readonly static "ANVIL": Internal.SoundType;
        readonly static "SCAFFOLDING": Internal.SoundType;
        readonly static "AMETHYST": Internal.SoundType;
        readonly static "CAVE_VINES": Internal.SoundType;
        readonly static "DEEPSLATE_BRICKS": Internal.SoundType;
        readonly static "LODESTONE": Internal.SoundType;
        readonly "volume": number;
        readonly static "FUNGUS": Internal.SoundType;
        readonly static "CORAL_BLOCK": Internal.SoundType;
        readonly static "SMALL_DRIPLEAF": Internal.SoundType;
        readonly static "HANGING_ROOTS": Internal.SoundType;
        readonly static "BAMBOO_SAPLING": Internal.SoundType;
        readonly static "SWEET_BERRY_BUSH": Internal.SoundType;
        readonly static "LILY_PAD": Internal.SoundType;
        readonly static "NETHER_WART": Internal.SoundType;
        readonly static "STONE": Internal.SoundType;
        readonly static "MOSS_CARPET": Internal.SoundType;
        readonly static "LADDER": Internal.SoundType;
        readonly static "WET_GRASS": Internal.SoundType;
        readonly static "NETHERITE_BLOCK": Internal.SoundType;
        readonly static "LARGE_AMETHYST_BUD": Internal.SoundType;
        readonly static "GLOW_LICHEN": Internal.SoundType;
        readonly static "MEDIUM_AMETHYST_BUD": Internal.SoundType;
        readonly static "WOOL": Internal.SoundType;
        readonly static "CROP": Internal.SoundType;
        readonly static "ROOTS": Internal.SoundType;
        readonly static "WART_BLOCK": Internal.SoundType;
        readonly static "NETHER_SPROUTS": Internal.SoundType;
        readonly static "AZALEA_LEAVES": Internal.SoundType;
        readonly static "POWDER_SNOW": Internal.SoundType;
        readonly static "METAL": Internal.SoundType;
    }
    type SoundType_ = SoundType;
    class GiftLootEventJS extends Internal.LootEventJS {
        constructor(c: Internal.Map_<ResourceLocation_, Internal.JsonElement_>)
        getType(): string;
        addGift(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        getDirectory(): string;
        get type(): string
        get directory(): string
    }
    type GiftLootEventJS_ = GiftLootEventJS;
    class ForgeIngameGui extends Internal.Gui {
        constructor(arg0: Internal.Minecraft_)
        renderFood(arg0: number, arg1: number, arg2: Internal.PoseStack_): void;
        setupOverlayRenderState(arg0: boolean, arg1: boolean): void;
        shouldDrawSurvivalElements(): boolean;
        setupOverlayRenderState(arg0: boolean, arg1: boolean, arg2: ResourceLocation_): void;
        renderHealth(arg0: number, arg1: number, arg2: Internal.PoseStack_): void;
        renderJumpMeter(arg0: Internal.PoseStack_, arg1: number): void;
        render(arg0: Internal.PoseStack_, arg1: number): void;
        readonly static "CHAT_PANEL_ELEMENT": any;
        readonly static "PLAYER_HEALTH_ELEMENT": any;
        static "rayTraceDistance": 20.0;
        readonly static "PORTAL_ELEMENT": any;
        readonly static "RECORD_OVERLAY_ELEMENT": any;
        readonly static "HUD_TEXT_ELEMENT": any;
        "left_height": number;
        readonly static "VIGNETTE_ELEMENT": any;
        readonly static "FOOD_LEVEL_ELEMENT": any;
        readonly static "FPS_GRAPH_ELEMENT": any;
        readonly static "FROSTBITE_ELEMENT": any;
        readonly static "CROSSHAIR_ELEMENT": any;
        "right_height": number;
        readonly static "SCOREBOARD_ELEMENT": any;
        readonly static "ARMOR_LEVEL_ELEMENT": any;
        readonly static "SUBTITLES_ELEMENT": any;
        readonly static "BOSS_HEALTH_ELEMENT": any;
        readonly static "HOTBAR_ELEMENT": any;
        readonly static "POTION_ICONS_ELEMENT": any;
        readonly static "SPYGLASS_ELEMENT": any;
        readonly static "MOUNT_HEALTH_ELEMENT": any;
        readonly static "ITEM_NAME_ELEMENT": any;
        readonly static "PLAYER_LIST_ELEMENT": any;
        readonly static "HELMET_ELEMENT": any;
        readonly static "EXPERIENCE_BAR_ELEMENT": any;
        readonly static "AIR_LEVEL_ELEMENT": any;
        readonly static "JUMP_BAR_ELEMENT": any;
        readonly static "SLEEP_FADE_ELEMENT": any;
        readonly static "TITLE_TEXT_ELEMENT": any;
    }
    type ForgeIngameGui_ = ForgeIngameGui;
    class VertexFormatElement$Type extends Internal.Enum<Internal.VertexFormatElement$Type> {
        getSize(): number;
        static valueOf(arg0: string): Internal.VertexFormatElement$Type;
        getName(): string;
        getGlType(): number;
        static values(): Internal.VertexFormatElement$Type[];
        get size(): number
        get name(): string
        get glType(): number
        readonly static "USHORT": Internal.VertexFormatElement$Type;
        readonly static "SHORT": Internal.VertexFormatElement$Type;
        readonly static "BYTE": Internal.VertexFormatElement$Type;
        readonly static "UINT": Internal.VertexFormatElement$Type;
        readonly static "INT": Internal.VertexFormatElement$Type;
        readonly static "FLOAT": Internal.VertexFormatElement$Type;
        readonly static "UBYTE": Internal.VertexFormatElement$Type;
    }
    type VertexFormatElement$Type_ = "float" | "uint" | "ushort" | "int" | "short" | "byte" | VertexFormatElement$Type | "ubyte";
    class TagEventJS$TagWrapper {
        remove(...ids: string[]): this;
        getObjectIds(): Internal.Collection<ResourceLocation>;
        toString(): string;
        setPriorityList(o: any): void;
        sort(): boolean;
        removeAll(): this;
        add(...ids: string[]): this;
        get objectIds(): Internal.Collection<ResourceLocation>
        set priorityList(o: any)
    }
    type TagEventJS$TagWrapper_ = TagEventJS$TagWrapper;
    class SequentialEntry$Builder extends Internal.LootPoolEntryContainer$Builder<Internal.SequentialEntry$Builder> {
        constructor(...arg0: Internal.LootPoolEntryContainer$Builder_<any>[])
        build(): Internal.LootPoolEntryContainer;
        then(arg0: Internal.LootPoolEntryContainer$Builder_<any>): this;
    }
    type SequentialEntry$Builder_ = SequentialEntry$Builder;
    class ServerEventJS extends Internal.EventJS {
        constructor()
        getServer(): Internal.ServerJS;
        get server(): Internal.ServerJS
    }
    type ServerEventJS_ = ServerEventJS;
    interface LerpingModel {
        getModelRotationValues(): Internal.Map<string, Internal.Vector3f>;
        get modelRotationValues(): Internal.Map<string, Internal.Vector3f>
    }
    type LerpingModel_ = LerpingModel;
    class RegisterClientCommandsEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.CommandDispatcher_<Internal.CommandSourceStack_>)
        getDispatcher(): Internal.CommandDispatcher<Internal.CommandSourceStack>;
        getListenerList(): Internal.ListenerList;
        get dispatcher(): Internal.CommandDispatcher<Internal.CommandSourceStack>
        get listenerList(): Internal.ListenerList
    }
    type RegisterClientCommandsEvent_ = RegisterClientCommandsEvent;
    class ClientboundAddVibrationSignalPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.VibrationPath_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getVibrationPath(): Internal.VibrationPath;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get vibrationPath(): Internal.VibrationPath
        get skippable(): boolean
    }
    type ClientboundAddVibrationSignalPacket_ = ClientboundAddVibrationSignalPacket;
    class ResolverStyle extends Internal.Enum<Internal.ResolverStyle> {
        static valueOf(arg0: string): Internal.ResolverStyle;
        static values(): Internal.ResolverStyle[];
        readonly static "LENIENT": Internal.ResolverStyle;
        readonly static "SMART": Internal.ResolverStyle;
        readonly static "STRICT": Internal.ResolverStyle;
    }
    type ResolverStyle_ = "smart" | ResolverStyle | "strict" | "lenient";
    class FishingHook extends Internal.Projectile {
        constructor(arg0: Internal.Player_, arg1: Internal.Level_, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        remove(arg0: Internal.Entity$RemovalReason_): void;
        getHookedIn(): Internal.Entity;
        getStepHeight(): number;
        retrieve(arg0: Internal.ItemStack_): number;
        asKJS(): Internal.EntityJS;
        setOwner(arg0: Internal.Entity_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getAddEntityPacket(): Internal.Packet<any>;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRenderAtSqrDistance(arg0: number): boolean;
        shouldRiderSit(): boolean;
        handleEntityEvent(arg0: number): void;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        recreateFromPacket(arg0: Internal.ClientboundAddEntityPacket_): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        lerpTo(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: boolean): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getPlayerOwner(): Internal.Player;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        canChangeDimensions(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        onClientRemoval(): void;
        isOpenWaterFishing(): boolean;
        get hookedIn(): Internal.Entity
        get stepHeight(): number
        set owner(arg0: Internal.Entity_)
        get addEntityPacket(): Internal.Packet<any>
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get playerOwner(): Internal.Player
        get openWaterFishing(): boolean
    }
    type FishingHook_ = FishingHook;
    class KubeJSRegistries {
        constructor()
        static fluids(): Internal.Registrar<Internal.Fluid>;
        static recipeSerializers(): Internal.Registrar<Internal.RecipeSerializer<any>>;
        static enchantments(): Internal.Registrar<Internal.Enchantment>;
        static chunkGenerators(): Internal.Registrar<Internal.Codec<any>>;
        static blockEntities(): Internal.Registrar<Internal.BlockEntityType<any>>;
        static blocks(): Internal.Registrar<Internal.Block>;
        static attributes(): Internal.Registrar<Internal.Attribute>;
        static registries(): Internal.Registrar<Internal.Registry<any>>;
        static potions(): Internal.Registrar<Internal.Potion>;
        static blockEntityTypes(): Internal.Registrar<Internal.BlockEntityType<any>>;
        static items(): Internal.Registrar<Internal.Item>;
        static biomes(): Internal.Registrar<Internal.Biome>;
        static mobEffects(): Internal.Registrar<Internal.MobEffect>;
        static byId(id: ResourceLocation_): Internal.Registrar<T>;
        static entityTypes(): Internal.Registrar<Internal.EntityType<any>>;
        static soundEvents(): Internal.Registrar<Internal.SoundEvent>;
    }
    type KubeJSRegistries_ = KubeJSRegistries;
    interface ObjIntConsumer <T> {
        accept(arg0: T, arg1: number): void;
    }
    type ObjIntConsumer_<T> = ((arg0: T, arg1: number)=>void) | ObjIntConsumer<T>;
    class ScriptPack {
        constructor(m: Internal.ScriptManager_, i: Internal.ScriptPackInfo_)
        "scope": Internal.Scriptable;
        "context": Internal.Context;
        readonly "info": Internal.ScriptPackInfo;
        readonly "scripts": Internal.List<Internal.ScriptFile>;
        readonly "manager": Internal.ScriptManager;
    }
    type ScriptPack_ = ScriptPack;
    class BellAttachType extends Internal.Enum<Internal.BellAttachType> implements Internal.StringRepresentable {
        getSerializedName(): string;
        static valueOf(arg0: string): Internal.BellAttachType;
        static values(): Internal.BellAttachType[];
        get serializedName(): string
        readonly static "DOUBLE_WALL": Internal.BellAttachType;
        readonly static "CEILING": Internal.BellAttachType;
        readonly static "SINGLE_WALL": Internal.BellAttachType;
        readonly static "FLOOR": Internal.BellAttachType;
    }
    type BellAttachType_ = "floor" | "ceiling" | "single_wall" | BellAttachType | "double_wall";
    abstract class FluidStackJS implements Internal.Copyable, Internal.WrappedJS {
        constructor()
        getTags(): Internal.Collection<ResourceLocation>;
        copy(): this;
        removeChance(): void;
        isEmpty(): boolean;
        toJson(): Internal.JsonObject;
        setNbt(arg0: Internal.CompoundTag_): void;
        toNBT(): Internal.CompoundTag;
        getAmount(): number;
        getFluidStack(): dev.architectury.fluid.FluidStack;
        getNbt(): Internal.CompoundTag;
        static of(o: any, amount: number, nbt: Internal.CompoundTag_): Internal.FluidStackJS;
        toString(): string;
        getChance(): number;
        hasTag(tag: ResourceLocation_): boolean;
        static of(o: any): Internal.FluidStackJS;
        setAmount(arg0: number): void;
        getId(): string;
        withAmount(amount: number): this;
        strongEquals(o: any): boolean;
        withNBT(nbt: Internal.CompoundTag_): this;
        hashCode(): number;
        static fromJson(e: Internal.JsonElement_): Internal.FluidStackJS;
        setChance(c: number): void;
        getFluid(): Internal.Fluid;
        hasChance(): boolean;
        equals(o: any): boolean;
        withChance(c: number): this;
        get tags(): Internal.Collection<ResourceLocation>
        get empty(): boolean
        set nbt(arg0: Internal.CompoundTag_)
        get amount(): number
        get fluidStack(): dev.architectury.fluid.FluidStack
        get nbt(): Internal.CompoundTag
        get chance(): number
        set amount(arg0: number)
        get id(): string
        set chance(c: number)
        get fluid(): Internal.Fluid
    }
    type FluidStackJS_ = FluidStackJS;
    class LootTableEntry implements Internal.FunctionContainer, Internal.ConditionContainer {
        constructor(o: Internal.JsonObject_)
        enchantWithLevels(levels: Internal.NumberProvider_, treasure: boolean): Internal.FunctionContainer;
        weight(weight: number): this;
        addFunction(arg0: Internal.JsonObject_): Internal.FunctionContainer;
        enchantRandomly(enchantments: ResourceLocation_[]): Internal.FunctionContainer;
        furnaceSmelt(): Internal.FunctionContainer;
        entityProperties(entity: Internal.LootContext$EntityTarget_, properties: Internal.JsonObject_): Internal.ConditionContainer;
        lootingEnchant(count: Internal.NumberProvider_, limit: number): Internal.FunctionContainer;
        addCondition(o: Internal.JsonObject_): this;
        addConditionalFunction(func: Internal.Consumer_<Internal.ConditionalFunction_>): Internal.FunctionContainer;
        randomChance(chance: number): Internal.ConditionContainer;
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer;
        name(name: Internal.Component_, entity: Internal.LootContext$EntityTarget_): Internal.FunctionContainer;
        killedByPlayer(): Internal.ConditionContainer;
        damage(damage: Internal.NumberProvider_): Internal.FunctionContainer;
        nbt(tag: Internal.CompoundTag_): Internal.FunctionContainer;
        entityScores(entity: Internal.LootContext$EntityTarget_, scores: Internal.Map_<string, any>): Internal.ConditionContainer;
        survivesExplosion(): Internal.ConditionContainer;
        count(count: Internal.NumberProvider_): Internal.FunctionContainer;
        quality(quality: number): this;
        copyName(source: Internal.CopyNameFunction$NameSource_): Internal.FunctionContainer;
        lootTable(table: ResourceLocation_, seed: number): Internal.FunctionContainer;
        name(name: Internal.Component_): Internal.FunctionContainer;
        readonly "json": Internal.JsonObject;
    }
    type LootTableEntry_ = LootTableEntry;
    interface LootItemCondition$Builder {
        build(): Internal.LootItemCondition;
        or(arg0: Internal.LootItemCondition$Builder_): Internal.AlternativeLootItemCondition$Builder;
        invert(): this;
    }
    type LootItemCondition$Builder_ = LootItemCondition$Builder | (()=>Internal.LootItemCondition_);
    interface BakedModel extends Internal.IForgeBakedModel {
        isLayered(): boolean;
        isCustomRenderer(): boolean;
        getLayerModels(arg0: Internal.ItemStack_, arg1: boolean): Internal.List<com.mojang.datafixers.util.Pair<Internal.BakedModel, Internal.RenderType>>;
        getQuads(arg0: Internal.BlockState_, arg1: Internal.Direction_, arg2: Internal.Random_): Internal.List<Internal.BakedQuad>;
        useAmbientOcclusion(arg0: Internal.BlockState_): boolean;
        getOverrides(): Internal.ItemOverrides;
        getQuads(arg0: Internal.BlockState_, arg1: Internal.Direction_, arg2: Internal.Random_, arg3: Internal.IModelData_): Internal.List<Internal.BakedQuad>;
        useAmbientOcclusion(): boolean;
        getModelData(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.IModelData_): Internal.IModelData;
        isGui3d(): boolean;
        usesBlockLight(): boolean;
        getParticleIcon(): Internal.TextureAtlasSprite;
        handlePerspective(arg0: Internal.ItemTransforms$TransformType_, arg1: Internal.PoseStack_): this;
        doesHandlePerspectives(): boolean;
        getTransforms(): Internal.ItemTransforms;
        getParticleIcon(arg0: Internal.IModelData_): Internal.TextureAtlasSprite;
        get layered(): boolean
        get customRenderer(): boolean
        get overrides(): Internal.ItemOverrides
        get gui3d(): boolean
        get particleIcon(): Internal.TextureAtlasSprite
        get transforms(): Internal.ItemTransforms
    }
    type BakedModel_ = BakedModel;
    interface MutableSearchTree <T> extends Internal.SearchTree<T> {
        clear(): void;
        refresh(): void;
        add(arg0: T): void;
    }
    type MutableSearchTree_<T> = MutableSearchTree<T>;
    class ParticleTypeBuilder extends Internal.BuilderBase<Internal.ParticleType<any>> {
        constructor(i: ResourceLocation_)
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.ParticleType<any>>;
        deserializer(d: Internal.ParticleOptions$Deserializer_<any>): this;
        createObject(): any;
        overrideLimiter(o: boolean): this;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.ParticleType<any>>
    }
    type ParticleTypeBuilder_ = ParticleTypeBuilder;
    interface PacketListener {
        getConnection(): Internal.Connection;
        onDisconnect(arg0: Internal.Component_): void;
        shouldPropagateHandlingExceptions(): boolean;
        get connection(): Internal.Connection
    }
    type PacketListener_ = PacketListener;
    class DefaultEventLoopGroup extends Internal.MultithreadEventLoopGroup {
        constructor(arg0: any_)
        constructor()
        constructor(arg0: number, arg1: Internal.Executor_)
        constructor(arg0: number)
        constructor(arg0: number, arg1: any_)
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
    }
    type DefaultEventLoopGroup_ = DefaultEventLoopGroup;
    interface Byte2CharFunction extends Internal.IntUnaryOperator, it.unimi.dsi.fastutil.Function<number, string> {
        getOrDefault(arg0: number, arg1: string): string;
        get(arg0: number): string;
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: any, arg1: any): any;
        defaultReturnValue(): string;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Byte2LongFunction;
        composeObject(arg0: Internal.Object2ByteFunction_<any>): Internal.Object2CharFunction<T>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Byte2FloatFunction;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2CharFunction;
        containsKey(arg0: any): boolean;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Byte2ByteFunction;
        composeByte(arg0: Internal.Byte2ByteFunction_): this;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        defaultReturnValue(arg0: string): void;
        applyAsInt(arg0: number): number;
        get(arg0: any): string;
        put(arg0: any, arg1: any): any;
        containsKey(arg0: number): boolean;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Byte2IntFunction;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2CharFunction;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Byte2DoubleFunction;
        andThenObject(arg0: Internal.Char2ObjectFunction_<any>): Internal.Byte2ObjectFunction<T>;
        remove(arg0: number): string;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2CharFunction;
        composeReference(arg0: Internal.Reference2ByteFunction_<any>): Internal.Reference2CharFunction<T>;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2CharFunction;
        andThenChar(arg0: Internal.Char2CharFunction_): this;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        size(): number;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2CharFunction;
        put(arg0: number, arg1: string): string;
        apply(arg0: number): string;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2CharFunction;
        put(arg0: number, arg1: string): string;
        remove(arg0: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, string>;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Byte2ShortFunction;
        andThenReference(arg0: Internal.Char2ReferenceFunction_<any>): Internal.Byte2ReferenceFunction<T>;
    }
    type Byte2CharFunction_ = Byte2CharFunction | ((arg0: number)=>string);
    class Guardian extends Internal.Monster {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getActiveAttackTarget(): Internal.LivingEntity;
        isMoving(): boolean;
        getMobType(): Internal.MobType;
        travel(arg0: Vec3_): void;
        getStepHeight(): number;
        getAttackDuration(): number;
        getAttackAnimationScale(arg0: number): number;
        asKJS(): Internal.EntityJS;
        hasActiveAttackTarget(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        checkSpawnObstruction(arg0: Internal.LevelReader_): boolean;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getTailAnimation(arg0: number): number;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getMaxHeadXRot(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getAmbientSoundInterval(): number;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        getSpikesAnimation(arg0: number): number;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getWalkTargetValue(arg0: BlockPos_, arg1: Internal.LevelReader_): number;
        static checkGuardianSpawnRules(arg0: Internal.EntityType_<any>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        canBreatheUnderwater(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get activeAttackTarget(): Internal.LivingEntity
        get moving(): boolean
        get mobType(): Internal.MobType
        get stepHeight(): number
        get attackDuration(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get maxHeadXRot(): number
        get ambientSoundInterval(): number
    }
    type Guardian_ = Guardian;
    class SoundInstance$Attenuation extends Internal.Enum<Internal.SoundInstance$Attenuation> {
        static values(): Internal.SoundInstance$Attenuation[];
        static valueOf(arg0: string): Internal.SoundInstance$Attenuation;
        readonly static "LINEAR": Internal.SoundInstance$Attenuation;
        readonly static "NONE": Internal.SoundInstance$Attenuation;
    }
    type SoundInstance$Attenuation_ = "linear" | SoundInstance$Attenuation | "none";
    class Brain <E> {
        constructor(arg0: Internal.Collection_<any>, arg1: Internal.Collection_<any>, arg2: Internal.ImmutableList_<any_<any>>, arg3: Internal.Supplier_<Internal.Codec_<Internal.Brain_<E>>>)
        serializeStart(arg0: Internal.DynamicOps_<T>): Internal.DataResult<T>;
        eraseMemory(arg0: Internal.MemoryModuleType_<U>): void;
        addActivityWithConditions(arg0: Internal.Activity_, arg1: Internal.ImmutableList_<any>, arg2: Internal.Set_<com.mojang.datafixers.util.Pair_<Internal.MemoryModuleType_<any>, Internal.MemoryStatus_>>): void;
        addActivity(arg0: Internal.Activity_, arg1: Internal.ImmutableList_<any>): void;
        setCoreActivities(arg0: Internal.Set_<Internal.Activity_>): void;
        addActivityAndRemoveMemoryWhenStopped(arg0: Internal.Activity_, arg1: number, arg2: Internal.ImmutableList_<any>, arg3: Internal.MemoryModuleType_<any>): void;
        static codec(arg0: Internal.Collection_<any>, arg1: Internal.Collection_<any>): Internal.Codec<Internal.Brain<E>>;
        useDefaultActivity(): void;
        getActiveActivities(): Internal.Set<Internal.Activity>;
        static provider(arg0: Internal.Collection_<any>, arg1: Internal.Collection_<any>): Internal.Brain$Provider<E>;
        setDefaultActivity(arg0: Internal.Activity_): void;
        setActiveActivityIfPossible(arg0: Internal.Activity_): void;
        updateActivityFromSchedule(arg0: number, arg1: number): void;
        getSchedule(): Internal.Schedule;
        setSchedule(arg0: Internal.Schedule_): void;
        isMemoryValue(arg0: Internal.MemoryModuleType_<U>, arg1: U): boolean;
        getTimeUntilExpiry(arg0: Internal.MemoryModuleType_<U>): number;
        removeAllBehaviors(): void;
        setMemory(arg0: Internal.MemoryModuleType_<U>, arg1: Internal.Optional_<any>): void;
        setMemory(arg0: Internal.MemoryModuleType_<U>, arg1: U): void;
        copyWithoutBehaviors(): this;
        addActivity(arg0: Internal.Activity_, arg1: number, arg2: Internal.ImmutableList_<any>): void;
        getRunningBehaviors(): Internal.List<Internal.Behavior<any>>;
        getActiveNonCoreActivity(): Internal.Optional<Internal.Activity>;
        checkMemory(arg0: Internal.MemoryModuleType_<any>, arg1: Internal.MemoryStatus_): boolean;
        stopAll(arg0: Internal.ServerLevel_, arg1: E): void;
        addActivityAndRemoveMemoriesWhenStopped(arg0: Internal.Activity_, arg1: Internal.ImmutableList_<any>, arg2: Internal.Set_<com.mojang.datafixers.util.Pair_<Internal.MemoryModuleType_<any>, Internal.MemoryStatus_>>, arg3: Internal.Set_<Internal.MemoryModuleType_<any>>): void;
        setMemoryWithExpiry(arg0: Internal.MemoryModuleType_<U>, arg1: U, arg2: number): void;
        getMemories(): Internal.Map<Internal.MemoryModuleType<any>, Internal.Optional<any>>;
        hasMemoryValue(arg0: Internal.MemoryModuleType_<any>): boolean;
        isActive(arg0: Internal.Activity_): boolean;
        getMemory(arg0: Internal.MemoryModuleType_<U>): Internal.Optional<U>;
        setActiveActivityToFirstValid(arg0: Internal.List_<Internal.Activity_>): void;
        tick(arg0: Internal.ServerLevel_, arg1: E): void;
        set coreActivities(arg0: Internal.Set_<Internal.Activity_>)
        get activeActivities(): Internal.Set<Internal.Activity>
        set defaultActivity(arg0: Internal.Activity_)
        set activeActivityIfPossible(arg0: Internal.Activity_)
        get schedule(): Internal.Schedule
        set schedule(arg0: Internal.Schedule_)
        get runningBehaviors(): Internal.List<Internal.Behavior<any>>
        get activeNonCoreActivity(): Internal.Optional<Internal.Activity>
        get memories(): Internal.Map<Internal.MemoryModuleType<any>, Internal.Optional<any>>
        set activeActivityToFirstValid(arg0: Internal.List_<Internal.Activity_>)
    }
    type Brain_<E> = Brain<E>;
    class LevelStem {
        constructor(arg0: Internal.Holder_<Internal.DimensionType_>, arg1: Internal.ChunkGenerator_)
        constructor(arg0: Internal.Holder_<Internal.DimensionType_>, arg1: Internal.ChunkGenerator_, arg2: boolean)
        generator(): Internal.ChunkGenerator;
        static stable(arg0: number, arg1: Internal.Registry_<Internal.LevelStem_>): boolean;
        typeHolder(): Internal.Holder<Internal.DimensionType>;
        useServerSeed(): boolean;
        static sortMap(arg0: Internal.Registry_<Internal.LevelStem_>): Internal.Registry<Internal.LevelStem>;
        readonly static "OVERWORLD": Internal.ResourceKey<any>;
        readonly static "END": Internal.ResourceKey<any>;
        readonly static "CODEC": any;
        readonly static "NETHER": Internal.ResourceKey<any>;
    }
    type LevelStem_ = LevelStem;
    class ListTag extends Internal.CollectionTag<Internal.Tag> {
        constructor()
        getDouble(arg0: number): number;
        get(arg0: number): Internal.Tag;
        set(arg0: number, arg1: Internal.Tag_): Internal.Tag;
        forEach(arg0: Internal.Consumer_<any>): void;
        addTag(arg0: number, arg1: Internal.Tag_): boolean;
        getCompound(arg0: number): Internal.CompoundTag;
        isEmpty(): boolean;
        getShort(arg0: number): number;
        add(arg0: number, arg1: any): void;
        setTag(arg0: number, arg1: Internal.Tag_): boolean;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        getFloat(arg0: number): number;
        getLongArray(arg0: number): number[];
        getIntArray(arg0: number): number[];
        getInt(arg0: number): number;
        getList(arg0: number): this;
        write(arg0: Internal.DataOutput_): void;
        stream(): Internal.Stream<Internal.Tag>;
        getString(arg0: number): string;
        getId(): number;
        spliterator(): Internal.Spliterator<Internal.Tag>;
        replaceAll(arg0: Internal.UnaryOperator_<Internal.Tag_>): void;
        getType(): Internal.TagType<Internal.ListTag>;
        toString(): string;
        remove(arg0: number): Internal.Tag;
        accept(arg0: Internal.TagVisitor_): void;
        add(arg0: number, arg1: Internal.Tag_): void;
        sort(arg0: Internal.Comparator_<any>): void;
        parallelStream(): Internal.Stream<Internal.Tag>;
        getAsString(): string;
        size(): number;
        hashCode(): number;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        copy(): Internal.Tag;
        clear(): void;
        equals(arg0: any): boolean;
        accept(arg0: Internal.StreamTagVisitor_): Internal.StreamTagVisitor$ValueResult;
        set(arg0: number, arg1: any): any;
        getElementType(): number;
        get empty(): boolean
        get id(): number
        get type(): Internal.TagType<Internal.ListTag>
        get asString(): string
        get elementType(): number
        readonly static "TYPE": any;
    }
    type ListTag_ = ListTag;
    class GlowSquid extends Internal.Squid {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getDarkTicksRemaining(): number;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        static checkGlowSquideSpawnRules(arg0: Internal.EntityType_<any>, arg1: Internal.ServerLevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get darkTicksRemaining(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type GlowSquid_ = GlowSquid;
    class URL implements Internal.Serializable {
        constructor(arg0: Internal.URL_, arg1: string, arg2: Internal.URLStreamHandler_)
        constructor(arg0: Internal.URL_, arg1: string)
        constructor(arg0: string, arg1: string, arg2: string)
        constructor(arg0: string, arg1: string, arg2: number, arg3: string)
        constructor(arg0: string, arg1: string, arg2: number, arg3: string, arg4: Internal.URLStreamHandler_)
        constructor(arg0: string)
        getContent(): any;
        getQuery(): string;
        toString(): string;
        sameFile(arg0: Internal.URL_): boolean;
        openConnection(): Internal.URLConnection;
        openConnection(arg0: Internal.Proxy_): Internal.URLConnection;
        getFile(): string;
        getPort(): number;
        getAuthority(): string;
        getUserInfo(): string;
        getRef(): string;
        getProtocol(): string;
        hashCode(): number;
        toExternalForm(): string;
        static setURLStreamHandlerFactory(arg0: Internal.URLStreamHandlerFactory_): void;
        openStream(): Internal.InputStream;
        toURI(): Internal.URI;
        getContent(arg0: Internal.Class_<any>[]): any;
        getPath(): string;
        equals(arg0: any): boolean;
        getHost(): string;
        getDefaultPort(): number;
        get content(): any
        get query(): string
        get file(): string
        get port(): number
        get authority(): string
        get userInfo(): string
        get ref(): string
        get protocol(): string
        set URLStreamHandlerFactory(arg0: Internal.URLStreamHandlerFactory_)
        get path(): string
        get host(): string
        get defaultPort(): number
    }
    type URL_ = URL;
    interface MatchResult {
        start(): number;
        end(): number;
        groupCount(): number;
        end(arg0: number): number;
        group(): string;
        group(arg0: number): string;
        start(arg0: number): number;
    }
    type MatchResult_ = MatchResult;
    class Score {
        constructor(arg0: Internal.Scoreboard_, arg1: Internal.Objective_, arg2: string)
        isLocked(): boolean;
        getOwner(): string;
        setScore(arg0: number): void;
        getObjective(): Internal.Objective;
        getScore(): number;
        add(arg0: number): void;
        increment(): void;
        reset(): void;
        setLocked(arg0: boolean): void;
        getScoreboard(): Internal.Scoreboard;
        get locked(): boolean
        get owner(): string
        set score(arg0: number)
        get objective(): Internal.Objective
        get score(): number
        set locked(arg0: boolean)
        get scoreboard(): Internal.Scoreboard
        readonly static "SCORE_COMPARATOR": any;
    }
    type Score_ = Score;
    interface ClassShutter {
        visibleToScripts(arg0: string, arg1: number): boolean;
        readonly static "TYPE_EXCEPTION": 3;
        readonly static "TYPE_CLASS_IN_PACKAGE": 2;
        readonly static "TYPE_UNKNOWN": 0;
        readonly static "TYPE_MEMBER": 1;
    }
    type ClassShutter_ = ClassShutter;
    class AnyOfPredicate extends Internal.CombiningPredicate {
        constructor(arg0: Internal.List_<net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_>)
        type(): Internal.BlockPredicateType<any>;
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: any, arg1: any): boolean;
        negate(): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: Internal.WorldGenLevel_, arg1: BlockPos_): boolean;
        readonly static "CODEC": Internal.Codec<Internal.AnyOfPredicate>;
    }
    type AnyOfPredicate_ = AnyOfPredicate;
    abstract class Enum <E> implements Internal.Constable, Internal.Serializable, Internal.Comparable<E> {
        static valueOf(arg0: Internal.Class_<T>, arg1: string): T;
        name(): string;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<E>>;
        hashCode(): number;
        toString(): string;
        compareTo(arg0: E): number;
        getDeclaringClass(): Internal.Class<E>;
        ordinal(): number;
        equals(arg0: any): boolean;
        compareTo(arg0: any): number;
        get declaringClass(): Internal.Class<E>
    }
    type Enum_<E> = Enum<E>;
    class NoiseGeneratorSettings extends Internal.Record {
        constructor(arg0: Internal.NoiseSettings_, arg1: Internal.BlockState_, arg2: Internal.BlockState_, arg3: Internal.NoiseRouterWithOnlyNoises_, arg4: Internal.SurfaceRules$RuleSource_, arg5: number, arg6: boolean, arg7: boolean, arg8: boolean, arg9: boolean)
        disableMobGeneration(): boolean;
        defaultBlock(): Internal.BlockState;
        toString(): string;
        noiseRouter(): Internal.NoiseRouterWithOnlyNoises;
        aquifersEnabled(): boolean;
        static register(arg0: Internal.ResourceKey_<Internal.NoiseGeneratorSettings_>, arg1: Internal.NoiseGeneratorSettings_): void;
        getRandomSource(): Internal.WorldgenRandom$Algorithm;
        static nether(): Internal.NoiseGeneratorSettings;
        surfaceRule(): Internal.SurfaceRules$RuleSource;
        isAquifersEnabled(): boolean;
        oreVeinsEnabled(): boolean;
        defaultFluid(): Internal.BlockState;
        static m_64474_(arg0: Internal.RecordCodecBuilder$Instance_<any>): Internal.App<any, any>;
        createNoiseRouter(arg0: Internal.Registry_<Internal.NormalNoise$NoiseParameters_>, arg1: number): Internal.NoiseRouter;
        hashCode(): number;
        seaLevel(): number;
        static bootstrap(): Internal.Holder<Internal.NoiseGeneratorSettings>;
        static overworld(arg0: boolean, arg1: boolean): Internal.NoiseGeneratorSettings;
        noiseSettings(): Internal.NoiseSettings;
        static caves(): Internal.NoiseGeneratorSettings;
        useLegacyRandomSource(): boolean;
        static floatingIslands(): Internal.NoiseGeneratorSettings;
        static end(): Internal.NoiseGeneratorSettings;
        equals(arg0: any): boolean;
        get randomSource(): Internal.WorldgenRandom$Algorithm
        get aquifersEnabled(): boolean
        readonly static "OVERWORLD": Internal.ResourceKey<any>;
        readonly static "END": Internal.ResourceKey<any>;
        readonly static "DIRECT_CODEC": any;
        readonly static "NETHER": Internal.ResourceKey<any>;
        readonly static "CAVES": Internal.ResourceKey<any>;
        readonly static "FLOATING_ISLANDS": Internal.ResourceKey<any>;
        readonly static "CODEC": any;
        readonly static "LARGE_BIOMES": Internal.ResourceKey<any>;
        readonly static "AMPLIFIED": Internal.ResourceKey<any>;
    }
    type NoiseGeneratorSettings_ = Special.NoiseGeneratorSettings | NoiseGeneratorSettings;
    interface PathMatcher {
        matches(arg0: Internal.Path_): boolean;
    }
    type PathMatcher_ = PathMatcher | ((arg0: Internal.Path)=>boolean);
    interface BitStorage {
        getAll(arg0: Internal.IntConsumer_): void;
        getAndSet(arg0: number, arg1: number): number;
        getSize(): number;
        copy(): this;
        set(arg0: number, arg1: number): void;
        get(arg0: number): number;
        getBits(): number;
        unpack(arg0: number[]): void;
        getRaw(): number[];
        get size(): number
        get bits(): number
        get raw(): number[]
    }
    type BitStorage_ = BitStorage;
    class URI implements Internal.Comparable<Internal.URI>, Internal.Serializable {
        constructor(arg0: string, arg1: string, arg2: string)
        constructor(arg0: string, arg1: string, arg2: string, arg3: string)
        constructor(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string)
        constructor(arg0: string, arg1: string, arg2: string, arg3: number, arg4: string, arg5: string, arg6: string)
        constructor(arg0: string)
        getQuery(): string;
        toURL(): Internal.URL;
        relativize(arg0: Internal.URI_): this;
        getPort(): number;
        compareTo(arg0: any): number;
        getRawUserInfo(): string;
        toASCIIString(): string;
        isOpaque(): boolean;
        getRawSchemeSpecificPart(): string;
        static create(arg0: string): Internal.URI;
        resolve(arg0: string): this;
        resolve(arg0: Internal.URI_): this;
        getPath(): string;
        getScheme(): string;
        compareTo(arg0: Internal.URI_): number;
        toString(): string;
        normalize(): this;
        getRawQuery(): string;
        getAuthority(): string;
        getUserInfo(): string;
        hashCode(): number;
        getSchemeSpecificPart(): string;
        parseServerAuthority(): this;
        getRawPath(): string;
        getFragment(): string;
        equals(arg0: any): boolean;
        isAbsolute(): boolean;
        getRawAuthority(): string;
        getHost(): string;
        getRawFragment(): string;
        get query(): string
        get port(): number
        get rawUserInfo(): string
        get opaque(): boolean
        get rawSchemeSpecificPart(): string
        get path(): string
        get scheme(): string
        get rawQuery(): string
        get authority(): string
        get userInfo(): string
        get schemeSpecificPart(): string
        get rawPath(): string
        get fragment(): string
        get absolute(): boolean
        get rawAuthority(): string
        get host(): string
        get rawFragment(): string
    }
    type URI_ = URI;
    class LivingPackSizeEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.Mob_)
        hasResult(): boolean;
        getMaxPackSize(): number;
        getListenerList(): Internal.ListenerList;
        setMaxPackSize(arg0: number): void;
        get maxPackSize(): number
        get listenerList(): Internal.ListenerList
        set maxPackSize(arg0: number)
    }
    type LivingPackSizeEvent_ = LivingPackSizeEvent;
    abstract class NoiseBasedStateProvider extends Internal.BlockStateProvider {
    }
    type NoiseBasedStateProvider_ = NoiseBasedStateProvider;
    abstract class AbstractByteBuf extends Internal.ByteBuf {
        indexOf(arg0: number, arg1: number, arg2: number): number;
        readShortLE(): number;
        readableBytes(): number;
        writeInt(arg0: number): Internal.ByteBuf;
        readDouble(): number;
        skipBytes(arg0: number): Internal.ByteBuf;
        forEachByteDesc(arg0: Internal.ByteProcessor_): number;
        markReaderIndex(): Internal.ByteBuf;
        markWriterIndex(): Internal.ByteBuf;
        nioBuffers(): Internal.ByteBuffer[];
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        getShortLE(arg0: number): number;
        getFloat(arg0: number): number;
        writeFloat(arg0: number): Internal.ByteBuf;
        setFloat(arg0: number, arg1: number): Internal.ByteBuf;
        ensureWritable(arg0: number): Internal.ByteBuf;
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        resetWriterIndex(): Internal.ByteBuf;
        isReadable(arg0: number): boolean;
        getMediumLE(arg0: number): number;
        maxWritableBytes(): number;
        readUnsignedMedium(): number;
        isReadable(): boolean;
        readIntLE(): number;
        getByte(arg0: number): number;
        writeShort(arg0: number): Internal.ByteBuf;
        getMedium(arg0: number): number;
        bytesBefore(arg0: number, arg1: number): number;
        writeBytes(arg0: Internal.InputStream_, arg1: number): number;
        compareTo(arg0: Internal.ByteBuf_): number;
        readUnsignedMediumLE(): number;
        readBoolean(): boolean;
        writeIntLE(arg0: number): Internal.ByteBuf;
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf;
        slice(): Internal.ByteBuf;
        writeMedium(arg0: number): Internal.ByteBuf;
        setCharSequence(arg0: number, arg1: Internal.CharSequence_, arg2: Internal.Charset_): number;
        isReadOnly(): boolean;
        resetReaderIndex(): Internal.ByteBuf;
        writeLongLE(arg0: number): Internal.ByteBuf;
        writeCharSequence(arg0: Internal.CharSequence_, arg1: Internal.Charset_): number;
        readBytes(arg0: number[]): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf_): Internal.ByteBuf;
        readByte(): number;
        writerIndex(arg0: number): Internal.ByteBuf;
        readUnsignedShort(): number;
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        writeMediumLE(arg0: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        forEachByte(arg0: Internal.ByteProcessor_): number;
        setBytes(arg0: number, arg1: Internal.ByteBuf_): Internal.ByteBuf;
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuffer_): Internal.ByteBuf;
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf;
        getUnsignedByte(arg0: number): number;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_, arg1: number): Internal.ByteBuf;
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        retainedSlice(): Internal.ByteBuf;
        setShort(arg0: number, arg1: number): Internal.ByteBuf;
        getUnsignedInt(arg0: number): number;
        getUnsignedMedium(arg0: number): number;
        getUnsignedMediumLE(arg0: number): number;
        toString(): string;
        getBoolean(arg0: number): boolean;
        writeZero(arg0: number): Internal.ByteBuf;
        maxCapacity(): number;
        nioBuffer(): Internal.ByteBuffer;
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset_): Internal.CharSequence;
        clear(): Internal.ByteBuf;
        readBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        readMedium(): number;
        readUnsignedShortLE(): number;
        writeBytes(arg0: number[]): Internal.ByteBuf;
        discardReadBytes(): Internal.ByteBuf;
        writeChar(arg0: number): Internal.ByteBuf;
        duplicate(): Internal.ByteBuf;
        isWritable(): boolean;
        readerIndex(): number;
        getDouble(arg0: number): number;
        setByte(arg0: number, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.GatheringByteChannel_, arg1: number): number;
        readUnsignedInt(): number;
        writeDouble(arg0: number): Internal.ByteBuf;
        writerIndex(): number;
        retainedDuplicate(): Internal.ByteBuf;
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf;
        compareTo(arg0: any): number;
        setLong(arg0: number, arg1: number): Internal.ByteBuf;
        readMediumLE(): number;
        writableBytes(): number;
        getUnsignedIntLE(arg0: number): number;
        getChar(arg0: number): string;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number): Internal.ByteBuf;
        readChar(): string;
        setInt(arg0: number, arg1: number): Internal.ByteBuf;
        discardSomeReadBytes(): Internal.ByteBuf;
        bytesBefore(arg0: number, arg1: number, arg2: number): number;
        isWritable(arg0: number): boolean;
        bytesBefore(arg0: number): number;
        readInt(): number;
        readRetainedSlice(arg0: number): Internal.ByteBuf;
        setChar(arg0: number, arg1: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuffer_): Internal.ByteBuf;
        writeShortLE(arg0: number): Internal.ByteBuf;
        readShort(): number;
        getLong(arg0: number): number;
        getIntLE(arg0: number): number;
        readBytes(arg0: Internal.OutputStream_, arg1: number): Internal.ByteBuf;
        slice(arg0: number, arg1: number): Internal.ByteBuf;
        readerIndex(arg0: number): Internal.ByteBuf;
        readCharSequence(arg0: number, arg1: Internal.Charset_): Internal.CharSequence;
        asReadOnly(): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): Internal.ByteBuf;
        getLongLE(arg0: number): number;
        setZero(arg0: number, arg1: number): Internal.ByteBuf;
        readSlice(arg0: number): Internal.ByteBuf;
        readLongLE(): number;
        getShort(arg0: number): number;
        writeLong(arg0: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): Internal.ByteBuf;
        readFloat(): number;
        readBytes(arg0: Internal.ByteBuf_): Internal.ByteBuf;
        readUnsignedIntLE(): number;
        getInt(arg0: number): number;
        writeBoolean(arg0: boolean): Internal.ByteBuf;
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        writeBytes(arg0: Internal.ScatteringByteChannel_, arg1: number): number;
        setIndex(arg0: number, arg1: number): Internal.ByteBuf;
        setMedium(arg0: number, arg1: number): Internal.ByteBuf;
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf_): Internal.ByteBuf;
        readLong(): number;
        writeByte(arg0: number): Internal.ByteBuf;
        copy(): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): Internal.ByteBuf;
        ensureWritable(arg0: number, arg1: boolean): number;
        getUnsignedShort(arg0: number): number;
        readBytes(arg0: number): Internal.ByteBuf;
        setDouble(arg0: number, arg1: number): Internal.ByteBuf;
        readUnsignedByte(): number;
        getUnsignedShortLE(arg0: number): number;
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf;
        hashCode(): number;
        toString(arg0: Internal.Charset_): string;
        order(arg0: Internal.ByteOrder_): Internal.ByteBuf;
        equals(arg0: any): boolean;
        toString(arg0: number, arg1: number, arg2: Internal.Charset_): string;
        get readable(): boolean
        get readOnly(): boolean
        get writable(): boolean
    }
    type AbstractByteBuf_ = AbstractByteBuf;
    class FancyFoliagePlacer extends Internal.BlobFoliagePlacer {
        constructor(arg0: Internal.IntProvider_, arg1: Internal.IntProvider_, arg2: number)
        readonly static "CODEC": any;
    }
    type FancyFoliagePlacer_ = FancyFoliagePlacer;
    class ModelBlockRenderer {
        constructor(arg0: Internal.BlockColors_)
        tesselateWithAO(arg0: Internal.BlockAndTintGetter_, arg1: Internal.BakedModel_, arg2: Internal.BlockState_, arg3: BlockPos_, arg4: Internal.PoseStack_, arg5: Internal.VertexConsumer_, arg6: boolean, arg7: Internal.Random_, arg8: number, arg9: number): boolean;
        tesselateBlock(arg0: Internal.BlockAndTintGetter_, arg1: Internal.BakedModel_, arg2: Internal.BlockState_, arg3: BlockPos_, arg4: Internal.PoseStack_, arg5: Internal.VertexConsumer_, arg6: boolean, arg7: Internal.Random_, arg8: number, arg9: number, arg10: Internal.IModelData_): boolean;
        tesselateWithoutAO(arg0: Internal.BlockAndTintGetter_, arg1: Internal.BakedModel_, arg2: Internal.BlockState_, arg3: BlockPos_, arg4: Internal.PoseStack_, arg5: Internal.VertexConsumer_, arg6: boolean, arg7: Internal.Random_, arg8: number, arg9: number, arg10: Internal.IModelData_): boolean;
        static enableCaching(): void;
        renderModel(arg0: Internal.PoseStack$Pose_, arg1: Internal.VertexConsumer_, arg2: Internal.BlockState_, arg3: Internal.BakedModel_, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number): void;
        static clearCache(): void;
        renderModel(arg0: Internal.PoseStack$Pose_, arg1: Internal.VertexConsumer_, arg2: Internal.BlockState_, arg3: Internal.BakedModel_, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: Internal.IModelData_): void;
        tesselateBlock(arg0: Internal.BlockAndTintGetter_, arg1: Internal.BakedModel_, arg2: Internal.BlockState_, arg3: BlockPos_, arg4: Internal.PoseStack_, arg5: Internal.VertexConsumer_, arg6: boolean, arg7: Internal.Random_, arg8: number, arg9: number): boolean;
        tesselateWithAO(arg0: Internal.BlockAndTintGetter_, arg1: Internal.BakedModel_, arg2: Internal.BlockState_, arg3: BlockPos_, arg4: Internal.PoseStack_, arg5: Internal.VertexConsumer_, arg6: boolean, arg7: Internal.Random_, arg8: number, arg9: number, arg10: Internal.IModelData_): boolean;
        tesselateWithoutAO(arg0: Internal.BlockAndTintGetter_, arg1: Internal.BakedModel_, arg2: Internal.BlockState_, arg3: BlockPos_, arg4: Internal.PoseStack_, arg5: Internal.VertexConsumer_, arg6: boolean, arg7: Internal.Random_, arg8: number, arg9: number): boolean;
    }
    type ModelBlockRenderer_ = ModelBlockRenderer;
    class WorldEvent extends Internal.Event implements Internal.EventHandlerImplCommon$WorldEventAttachment {
        constructor()
        constructor(arg0: Internal.LevelAccessor_)
        architectury$getAttachedLevel(): Internal.LevelAccessor;
        getListenerList(): Internal.ListenerList;
        architectury$attachLevel(level: Internal.LevelAccessor_): void;
        getWorld(): Internal.LevelAccessor;
        get listenerList(): Internal.ListenerList
        get world(): Internal.LevelAccessor
    }
    type WorldEvent_ = WorldEvent;
    class InventoryMenu extends Internal.RecipeBookMenu<Internal.CraftingContainer> {
        constructor(arg0: Internal.Inventory_, arg1: boolean, arg2: Internal.Player_)
        getRecipeBookType(): Internal.RecipeBookType;
        canTakeItemForPickAll(arg0: Internal.ItemStack_, arg1: Internal.Slot_): boolean;
        slotsChanged(arg0: Internal.Container_): void;
        clearCraftingContent(): void;
        getCraftSlots(): Internal.CraftingContainer;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        getGridWidth(): number;
        stillValid(arg0: Internal.Player_): boolean;
        static isHotbarSlot(arg0: number): boolean;
        getResultSlotIndex(): number;
        getSize(): number;
        recipeMatches(arg0: Internal.Recipe_<any>): boolean;
        getGridHeight(): number;
        fillCraftSlotsStackedContents(arg0: Internal.StackedContents_): void;
        removed(arg0: Internal.Player_): void;
        shouldMoveToInventory(arg0: number): boolean;
        get recipeBookType(): Internal.RecipeBookType
        get craftSlots(): Internal.CraftingContainer
        get gridWidth(): number
        get resultSlotIndex(): number
        get size(): number
        get gridHeight(): number
        readonly static "EMPTY_ARMOR_SLOT_BOOTS": ResourceLocation;
        readonly static "RESULT_SLOT": 0;
        readonly static "CONTAINER_ID": 0;
        readonly static "USE_ROW_SLOT_END": 45;
        readonly static "USE_ROW_SLOT_START": 36;
        readonly static "CRAFT_SLOT_END": 5;
        readonly static "ARMOR_SLOT_END": 9;
        readonly static "CRAFT_SLOT_START": 1;
        readonly static "EMPTY_ARMOR_SLOT_SHIELD": ResourceLocation;
        readonly static "EMPTY_ARMOR_SLOT_LEGGINGS": ResourceLocation;
        readonly "owner": Internal.Player;
        readonly static "EMPTY_ARMOR_SLOT_CHESTPLATE": ResourceLocation;
        readonly static "SHIELD_SLOT": 45;
        readonly "active": boolean;
        readonly static "ARMOR_SLOT_START": 5;
        readonly static "INV_SLOT_START": 9;
        readonly static "INV_SLOT_END": 36;
        readonly static "BLOCK_ATLAS": ResourceLocation;
        readonly static "EMPTY_ARMOR_SLOT_HELMET": ResourceLocation;
    }
    type InventoryMenu_ = InventoryMenu;
    class MegaPineFoliagePlacer extends Internal.FoliagePlacer {
        constructor(arg0: Internal.IntProvider_, arg1: Internal.IntProvider_, arg2: Internal.IntProvider_)
        foliageHeight(arg0: Internal.Random_, arg1: number, arg2: Internal.TreeConfiguration_): number;
        readonly static "CODEC": any;
    }
    type MegaPineFoliagePlacer_ = MegaPineFoliagePlacer;
    abstract class URLStreamHandler {
        constructor()
    }
    type URLStreamHandler_ = URLStreamHandler;
    class Optional <T> {
        ifPresentOrElse(arg0: Internal.Consumer_<any>, arg1: Internal.Runnable_): void;
        toString(): string;
        or(arg0: Internal.Supplier_<any>): this;
        orElseThrow(): T;
        stream(): Internal.Stream<T>;
        static empty(): Internal.Optional<T>;
        isEmpty(): boolean;
        map(arg0: Internal.Function_<any, any>): Internal.Optional<U>;
        filter(arg0: Internal.Predicate_<any>): this;
        static ofNullable(arg0: T): Internal.Optional<T>;
        hashCode(): number;
        orElse(arg0: T): T;
        isPresent(): boolean;
        ifPresent(arg0: Internal.Consumer_<any>): void;
        orElseThrow(arg0: Internal.Supplier_<any>): T;
        orElseGet(arg0: Internal.Supplier_<any>): T;
        flatMap(arg0: Internal.Function_<any, any>): Internal.Optional<U>;
        get(): T;
        equals(arg0: any): boolean;
        static of(arg0: T): Internal.Optional<T>;
        get empty(): boolean
        get present(): boolean
    }
    type Optional_<T> = Optional<T>;
    class ReloadableServerResources {
        constructor(arg0: Internal.RegistryAccess$Frozen_, arg1: Internal.Commands$CommandSelection_, arg2: number)
        getRecipeManager(): Internal.RecipeManager;
        updateRegistryTags(arg0: Internal.RegistryAccess_): void;
        getFunctionLibrary(): Internal.ServerFunctionLibrary;
        getLootTables(): Internal.LootTables;
        getPredicateManager(): Internal.PredicateManager;
        getConditionContext(): Internal.ICondition$IContext;
        handler$zzf000$updateRegistryTags(registryAccess: Internal.RegistryAccess_, ci: Internal.CallbackInfo_): void;
        listeners(): Internal.List<Internal.PreparableReloadListener>;
        static loadResources(arg0: Internal.ResourceManager_, arg1: Internal.RegistryAccess$Frozen_, arg2: Internal.Commands$CommandSelection_, arg3: number, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<Internal.ReloadableServerResources>;
        getItemModifierManager(): Internal.ItemModifierManager;
        getAdvancements(): Internal.ServerAdvancementManager;
        getCommands(): Internal.Commands;
        get recipeManager(): Internal.RecipeManager
        get functionLibrary(): Internal.ServerFunctionLibrary
        get lootTables(): Internal.LootTables
        get predicateManager(): Internal.PredicateManager
        get conditionContext(): Internal.ICondition$IContext
        get itemModifierManager(): Internal.ItemModifierManager
        get advancements(): Internal.ServerAdvancementManager
        get commands(): Internal.Commands
        readonly "tagManager": Internal.TagManager;
    }
    type ReloadableServerResources_ = ReloadableServerResources;
    abstract class GuiComponent {
        constructor()
        static drawString(arg0: Internal.PoseStack_, arg1: Internal.Font_, arg2: Internal.Component_, arg3: number, arg4: number, arg5: number): void;
        static fill(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        static drawCenteredString(arg0: Internal.PoseStack_, arg1: Internal.Font_, arg2: Internal.FormattedCharSequence_, arg3: number, arg4: number, arg5: number): void;
        static drawCenteredString(arg0: Internal.PoseStack_, arg1: Internal.Font_, arg2: string, arg3: number, arg4: number, arg5: number): void;
        static blit(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number): void;
        blit(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
        static blit(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.TextureAtlasSprite_): void;
        getBlitOffset(): number;
        static blit(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number): void;
        static drawString(arg0: Internal.PoseStack_, arg1: Internal.Font_, arg2: string, arg3: number, arg4: number, arg5: number): void;
        blitOutlineBlack(arg0: number, arg1: number, arg2: Internal.BiConsumer_<number, number>): void;
        setBlitOffset(arg0: number): void;
        static drawCenteredString(arg0: Internal.PoseStack_, arg1: Internal.Font_, arg2: Internal.Component_, arg3: number, arg4: number, arg5: number): void;
        static blit(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number): void;
        static drawString(arg0: Internal.PoseStack_, arg1: Internal.Font_, arg2: Internal.FormattedCharSequence_, arg3: number, arg4: number, arg5: number): void;
        get blitOffset(): number
        set blitOffset(arg0: number)
        readonly static "BACKGROUND_LOCATION": ResourceLocation;
        readonly static "GUI_ICONS_LOCATION": ResourceLocation;
        readonly static "STATS_ICON_LOCATION": ResourceLocation;
    }
    type GuiComponent_ = GuiComponent;
    interface PieceGeneratorSupplier <C> {
        checkForBiomeOnTop(arg0: Internal.Heightmap$Types_): Internal.Predicate<Internal.PieceGeneratorSupplier$Context<C>>;
        createGenerator(arg0: Internal.PieceGeneratorSupplier$Context_<C>): Internal.Optional<Internal.PieceGenerator<C>>;
        simple(arg0: Internal.Predicate_<Internal.PieceGeneratorSupplier$Context_<C>>, arg1: Internal.PieceGenerator_<C>): this;
    }
    type PieceGeneratorSupplier_<C> = ((arg0: Internal.PieceGeneratorSupplier$Context<C>)=>Internal.Optional_<Internal.PieceGenerator_<C>>) | PieceGeneratorSupplier<C>;
    class AdvancementJS {
        constructor(a: Internal.Advancement_)
        addChild(a: Internal.AdvancementJS_): void;
        hashCode(): number;
        getId(): ResourceLocation;
        toString(): string;
        getDisplayText(): Internal.Component;
        getTitle(): Internal.Component;
        id(): ResourceLocation;
        equals(o: any): boolean;
        hasDisplay(): boolean;
        getParent(): this;
        getDescription(): Internal.Component;
        getChildren(): Internal.Set<Internal.AdvancementJS>;
        get id(): ResourceLocation
        get displayText(): Internal.Component
        get title(): Internal.Component
        get parent(): Internal.AdvancementJS
        get description(): Internal.Component
        get children(): Internal.Set<Internal.AdvancementJS>
        readonly "advancement": Internal.Advancement;
    }
    type AdvancementJS_ = AdvancementJS;
    interface ContentHandlerFactory {
        createContentHandler(arg0: string): Internal.ContentHandler;
    }
    type ContentHandlerFactory_ = ContentHandlerFactory;
    interface ArchitecturyFluidAttributes {
        getSlopeFindDistance(): number;
        getLuminosity(): number;
        getColor(): number;
        getDensity(): number;
        getBlock(): Internal.LiquidBlock;
        isLighterThanAir(stack: dev.architectury.fluid.FluidStack_): boolean;
        getLuminosity(stack: dev.architectury.fluid.FluidStack_): number;
        getViscosity(arg0: dev.architectury.fluid.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): number;
        getRarity(): Rarity;
        getFillSound(stack: dev.architectury.fluid.FluidStack_): Internal.SoundEvent;
        getBucketItem(): Internal.Item;
        getName(): Internal.Component;
        getFlowingTexture(stack: dev.architectury.fluid.FluidStack_): ResourceLocation;
        getSlopeFindDistance(arg0: Internal.LevelReader_): number;
        getSourceTexture(arg0: dev.architectury.fluid.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): ResourceLocation;
        getExplosionResistance(): number;
        getFillSound(arg0: dev.architectury.fluid.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): Internal.SoundEvent;
        getColor(stack: dev.architectury.fluid.FluidStack_): number;
        getDensity(stack: dev.architectury.fluid.FluidStack_): number;
        getTranslationKey(arg0: dev.architectury.fluid.FluidStack_): string;
        getSourceTexture(): ResourceLocation;
        getTemperature(): number;
        getDropOff(): number;
        getEmptySound(): Internal.SoundEvent;
        getViscosity(): number;
        getRarity(arg0: dev.architectury.fluid.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): Rarity;
        getLuminosity(arg0: dev.architectury.fluid.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): number;
        getName(stack: dev.architectury.fluid.FluidStack_): Internal.Component;
        getFlowingTexture(): ResourceLocation;
        isLighterThanAir(arg0: dev.architectury.fluid.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): boolean;
        getTickDelay(arg0: Internal.LevelReader_): number;
        canConvertToSource(): boolean;
        getTemperature(arg0: dev.architectury.fluid.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): number;
        getEmptySound(arg0: dev.architectury.fluid.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): Internal.SoundEvent;
        getSourceFluid(): Internal.Fluid;
        isLighterThanAir(): boolean;
        getDensity(arg0: dev.architectury.fluid.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): number;
        getTranslationKey(): string;
        getFillSound(): Internal.SoundEvent;
        getFlowingTexture(arg0: dev.architectury.fluid.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): ResourceLocation;
        getViscosity(stack: dev.architectury.fluid.FluidStack_): number;
        getRarity(stack: dev.architectury.fluid.FluidStack_): Rarity;
        getFlowingFluid(): Internal.Fluid;
        getTemperature(stack: dev.architectury.fluid.FluidStack_): number;
        getEmptySound(stack: dev.architectury.fluid.FluidStack_): Internal.SoundEvent;
        getTickDelay(): number;
        getSourceTexture(stack: dev.architectury.fluid.FluidStack_): ResourceLocation;
        getDropOff(arg0: Internal.LevelReader_): number;
        getColor(arg0: dev.architectury.fluid.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): number;
        get slopeFindDistance(): number
        get luminosity(): number
        get color(): number
        get density(): number
        get block(): Internal.LiquidBlock
        get rarity(): Rarity
        get bucketItem(): Internal.Item
        get name(): Internal.Component
        get explosionResistance(): number
        get sourceTexture(): ResourceLocation
        get temperature(): number
        get dropOff(): number
        get emptySound(): Internal.SoundEvent
        get viscosity(): number
        get flowingTexture(): ResourceLocation
        get sourceFluid(): Internal.Fluid
        get lighterThanAir(): boolean
        get translationKey(): string
        get fillSound(): Internal.SoundEvent
        get flowingFluid(): Internal.Fluid
        get tickDelay(): number
    }
    type ArchitecturyFluidAttributes_ = ArchitecturyFluidAttributes;
    class BasicItemJS$Builder extends Internal.ItemBuilder {
        constructor(i: ResourceLocation_)
        createObject(): Internal.Item;
    }
    type BasicItemJS$Builder_ = BasicItemJS$Builder;
    class LootTable {
        getPool(arg0: string): Internal.LootPool;
        getLootTableId(): ResourceLocation;
        static createStackSplitter(arg0: Internal.Consumer_<Internal.ItemStack_>): Internal.Consumer<Internal.ItemStack>;
        getParamSet(): Internal.LootContextParamSet;
        getRandomItemsRaw(arg0: Internal.LootContext_, arg1: Internal.Consumer_<Internal.ItemStack_>): void;
        validate(arg0: Internal.ValidationContext_): void;
        isFrozen(): boolean;
        setLootTableId(arg0: ResourceLocation_): void;
        addPool(arg0: Internal.LootPool_): void;
        fill(arg0: Internal.Container_, arg1: Internal.LootContext_): void;
        getRandomItems(arg0: Internal.LootContext_): Internal.List<Internal.ItemStack>;
        getRandomItems(arg0: Internal.LootContext_, arg1: Internal.Consumer_<Internal.ItemStack_>): void;
        static lootTable(): Internal.LootTable$Builder;
        removePool(arg0: string): Internal.LootPool;
        freeze(): void;
        get lootTableId(): ResourceLocation
        get paramSet(): Internal.LootContextParamSet
        get frozen(): boolean
        set lootTableId(arg0: ResourceLocation_)
        readonly static "DEFAULT_PARAM_SET": Internal.LootContextParamSet;
        readonly static "EMPTY": Internal.LootTable;
    }
    type LootTable_ = LootTable;
    class SignBlockEntity extends Internal.BlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        requestModelDataUpdate(): void;
        hasGlowingText(): boolean;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getUpdateTag(): Internal.CompoundTag;
        getPlayerWhoMayEdit(): Internal.UUID;
        onlyOpCanSetNbt(): boolean;
        load(arg0: Internal.CompoundTag_): void;
        getUpdatePacket(): Internal.Packet<any>;
        onLoad(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderMessages(arg0: boolean, arg1: Internal.Function_<Internal.Component_, Internal.FormattedCharSequence_>): Internal.FormattedCharSequence[];
        getColor(): Internal.DyeColor;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        executeClickCommands(arg0: Internal.ServerPlayer_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getMessage(arg0: number, arg1: boolean): Internal.Component;
        serializeNBT(): Internal.CompoundTag;
        createCommandSourceStack(arg0: Internal.ServerPlayer_): Internal.CommandSourceStack;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        isEditable(): boolean;
        setMessage(arg0: number, arg1: Internal.Component_): void;
        setMessage(arg0: number, arg1: Internal.Component_, arg2: Internal.Component_): void;
        setHasGlowingText(arg0: boolean): boolean;
        setAllowedPlayerEditor(arg0: Internal.UUID_): void;
        setColor(arg0: Internal.DyeColor_): boolean;
        setEditable(arg0: boolean): void;
        getRenderBoundingBox(): Internal.AABB;
        get updateTag(): Internal.CompoundTag
        get playerWhoMayEdit(): Internal.UUID
        get updatePacket(): Internal.Packet<any>
        get color(): Internal.DyeColor
        get modelData(): Internal.IModelData
        get editable(): boolean
        set hasGlowingText(arg0: boolean)
        set allowedPlayerEditor(arg0: Internal.UUID_)
        set color(arg0: Internal.DyeColor_)
        set editable(arg0: boolean)
        get renderBoundingBox(): Internal.AABB
        readonly static "LINES": 4;
    }
    type SignBlockEntity_ = SignBlockEntity;
    class Hashtable <K, V> extends Internal.Dictionary<K, V> implements Internal.Cloneable, Internal.Map<K, V>, Internal.Serializable {
        constructor()
        constructor(arg0: number)
        constructor(arg0: Internal.Map_<any, any>)
        constructor(arg0: number, arg1: number)
        clone(): any;
        replace(arg0: K, arg1: V): V;
        containsValue(arg0: any): boolean;
        getOrDefault(arg0: any, arg1: V): V;
        putAll(arg0: Internal.Map_<any, any>): void;
        isEmpty(): boolean;
        keys(): Internal.Enumeration<K>;
        containsKey(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        replaceAll(arg0: Internal.BiFunction_<any, any, any>): void;
        get(arg0: any): V;
        remove(arg0: any): V;
        compute(arg0: K, arg1: Internal.BiFunction_<any, any, any>): V;
        merge(arg0: K, arg1: V, arg2: Internal.BiFunction_<any, any, any>): V;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<any, any, any>): V;
        contains(arg0: any): boolean;
        elements(): Internal.Enumeration<V>;
        keySet(): Internal.Set<K>;
        putIfAbsent(arg0: K, arg1: V): V;
        toString(): string;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        values(): Internal.Collection<V>;
        remove(arg0: any, arg1: any): boolean;
        computeIfAbsent(arg0: K, arg1: Internal.Function_<any, any>): V;
        size(): number;
        hashCode(): number;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        clear(): void;
        equals(arg0: any): boolean;
        get empty(): boolean
    }
    type Hashtable_<K, V> = Hashtable<K, V>;
    class VideoMode {
        constructor(arg0: any_)
        constructor(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number)
        constructor(arg0: any_)
        static read(arg0: string): Internal.Optional<Internal.VideoMode>;
        getRedBits(): number;
        hashCode(): number;
        toString(): string;
        getWidth(): number;
        getBlueBits(): number;
        write(): string;
        equals(arg0: any): boolean;
        getHeight(): number;
        getGreenBits(): number;
        getRefreshRate(): number;
        get redBits(): number
        get width(): number
        get blueBits(): number
        get height(): number
        get greenBits(): number
        get refreshRate(): number
    }
    type VideoMode_ = VideoMode;
    class CloudStatus extends Internal.Enum<Internal.CloudStatus> {
        getKey(): string;
        static valueOf(arg0: string): Internal.CloudStatus;
        static values(): Internal.CloudStatus[];
        get key(): string
        readonly static "OFF": Internal.CloudStatus;
        readonly static "FAST": Internal.CloudStatus;
        readonly static "FANCY": Internal.CloudStatus;
    }
    type CloudStatus_ = "off" | "fancy" | CloudStatus | "fast";
    class FireworkStarRecipe extends Internal.CustomRecipe {
        constructor(arg0: ResourceLocation_)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        matches(arg0: Internal.CraftingContainer_, arg1: Internal.Level_): boolean;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        getSerializer(): Internal.RecipeSerializer<any>;
        isIncomplete(): boolean;
        assemble(arg0: Internal.CraftingContainer_): Internal.ItemStack;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getResultItem(): Internal.ItemStack;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get serializer(): Internal.RecipeSerializer<any>
        get incomplete(): boolean
        get resultItem(): Internal.ItemStack
    }
    type FireworkStarRecipe_ = FireworkStarRecipe;
    class SystemReport {
        constructor()
        setDetail(arg0: string, arg1: Internal.Supplier_<string>): void;
        toLineSeparatedString(): string;
        setDetail(arg0: string, arg1: string): void;
        appendToCrashReportString(arg0: Internal.StringBuilder_): void;
        readonly static "BYTES_PER_MEBIBYTE": 1048576;
    }
    type SystemReport_ = SystemReport;
    class Silverfish extends Internal.Monster {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMyRidingOffset(): number;
        getMobType(): Internal.MobType;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        tick(): void;
        asKJS(): Internal.EntityJS;
        getWalkTargetValue(arg0: BlockPos_, arg1: Internal.LevelReader_): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        static checkSilverfishSpawnRules(arg0: Internal.EntityType_<Internal.Silverfish_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setYBodyRot(arg0: number): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get myRidingOffset(): number
        get mobType(): Internal.MobType
        get stepHeight(): number
        get multipartEntity(): boolean
        set YBodyRot(arg0: number)
        get parts(): Internal.PartEntity<any>[]
    }
    type Silverfish_ = Silverfish;
    class PoiTypeBuilder extends Internal.BuilderBase<Internal.PoiType> {
        constructor(i: ResourceLocation_)
        blocks(r: Internal.BlockState_[]): this;
        createObject(): any;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.PoiType>;
        maxTickets(i: number): this;
        block(r: Internal.Block_): this;
        validRange(i: number): this;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.PoiType>
    }
    type PoiTypeBuilder_ = PoiTypeBuilder;
    interface ItemStackKJS extends Internal.AsKJS<Internal.ItemStackJS> {
        removeTagKJS(): void;
        asKJS(): Internal.ItemStackJS;
    }
    type ItemStackKJS_ = ItemStackKJS;
    interface IForgeFriendlyByteBuf {
        readRegistryIdUnsafe(arg0: Internal.IForgeRegistry_<T>): T;
        writeRegistryIdUnsafe(arg0: Internal.IForgeRegistry_<T>, arg1: T): void;
        readRegistryId(): T;
        writeRegistryId(arg0: T): void;
        writeFluidStack(arg0: Internal.FluidStack_): void;
        readFluidStack(): Internal.FluidStack;
        writeRegistryIdUnsafe(arg0: Internal.IForgeRegistry_<any>, arg1: ResourceLocation_): void;
        readRegistryIdSafe(arg0: Internal.Class_<any>): T;
    }
    type IForgeFriendlyByteBuf_ = IForgeFriendlyByteBuf;
    abstract class RecipeBookMenu <C> extends Internal.AbstractContainerMenu {
        constructor(arg0: Internal.MenuType_<any>, arg1: number)
        getRecipeBookType(): Internal.RecipeBookType;
        handlePlacement(arg0: boolean, arg1: Internal.Recipe_<any>, arg2: Internal.ServerPlayer_): void;
        getResultSlotIndex(): number;
        getSize(): number;
        clearCraftingContent(): void;
        recipeMatches(arg0: Internal.Recipe_<any>): boolean;
        getRecipeBookCategories(): Internal.List<Internal.RecipeBookCategories>;
        getGridWidth(): number;
        getGridHeight(): number;
        fillCraftSlotsStackedContents(arg0: Internal.StackedContents_): void;
        shouldMoveToInventory(arg0: number): boolean;
        get recipeBookType(): Internal.RecipeBookType
        get resultSlotIndex(): number
        get size(): number
        get recipeBookCategories(): Internal.List<Internal.RecipeBookCategories>
        get gridWidth(): number
        get gridHeight(): number
    }
    type RecipeBookMenu_<C> = RecipeBookMenu<C>;
    class ServerboundRecipeBookSeenRecipePacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.Recipe_<any>)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getRecipe(): ResourceLocation;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        isSkippable(): boolean;
        get recipe(): ResourceLocation
        get skippable(): boolean
    }
    type ServerboundRecipeBookSeenRecipePacket_ = ServerboundRecipeBookSeenRecipePacket;
    class Husk extends Internal.Zombie {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        static checkHuskSpawnRules(arg0: Internal.EntityType_<Internal.Husk_>, arg1: Internal.ServerLevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type Husk_ = Husk;
    interface JsonDeserializationContext {
        deserialize(arg0: Internal.JsonElement_, arg1: Internal.Type_): T;
    }
    type JsonDeserializationContext_ = JsonDeserializationContext;
    class RarityFilter extends Internal.PlacementFilter {
        type(): Internal.PlacementModifierType<any>;
        static onAverageOnceEvery(arg0: number): Internal.RarityFilter;
        readonly static "CODEC": any;
    }
    type RarityFilter_ = RarityFilter;
    interface LevelSimulatedRW extends Internal.LevelSimulatedReader, Internal.LevelWriter {
        setBlock(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: number): boolean;
        addFreshEntity(arg0: Internal.Entity_): boolean;
        destroyBlock(arg0: BlockPos_, arg1: boolean, arg2: Internal.Entity_): boolean;
        destroyBlock(arg0: BlockPos_, arg1: boolean): boolean;
    }
    type LevelSimulatedRW_ = LevelSimulatedRW;
    interface Path extends Internal.Comparable<Internal.Path>, Internal.Iterable<Internal.Path>, Internal.Watchable {
        subpath(arg0: number, arg1: number): this;
        forEach(arg0: Internal.Consumer_<any>): void;
        relativize(arg0: Internal.Path_): this;
        toFile(): Internal.File;
        compareTo(arg0: any): number;
        of(arg0: Internal.URI_): this;
        getName(arg0: number): this;
        getFileName(): this;
        resolveSibling(arg0: Internal.Path_): this;
        startsWith(arg0: string): boolean;
        resolveSibling(arg0: string): this;
        iterator(): Internal.Iterator<Internal.Path>;
        getFileSystem(): Internal.FileSystem;
        toRealPath(...arg0: any_[]): this;
        startsWith(arg0: Internal.Path_): boolean;
        resolve(arg0: Internal.Path_): this;
        endsWith(arg0: string): boolean;
        compareTo(arg0: Internal.Path_): number;
        endsWith(arg0: Internal.Path_): boolean;
        resolve(arg0: string): this;
        getNameCount(): number;
        register(arg0: Internal.WatchService_, ...arg1: Internal.WatchEvent$Kind_<any>[]): Internal.WatchKey;
        toString(): string;
        toUri(): Internal.URI;
        spliterator(): Internal.Spliterator<Internal.Path>;
        toAbsolutePath(): this;
        register(arg0: Internal.WatchService_, arg1: Internal.WatchEvent$Kind_<any>[], ...arg2: any_[]): Internal.WatchKey;
        normalize(): this;
        of(arg0: string, ...arg1: string[]): this;
        hashCode(): number;
        getRoot(): this;
        getParent(): this;
        equals(arg0: any): boolean;
        isAbsolute(): boolean;
        get fileName(): Internal.Path
        get fileSystem(): Internal.FileSystem
        get nameCount(): number
        get root(): Internal.Path
        get parent(): Internal.Path
        get absolute(): boolean
    }
    type Path_ = Path;
    interface RecipeType <T> {
        tryMatch(arg0: Internal.Recipe_<C>, arg1: Internal.Level_, arg2: C): Internal.Optional<T>;
        register(arg0: string): this;
        readonly static "CAMPFIRE_COOKING": any;
        readonly static "SMITHING": any;
        readonly static "SMOKING": any;
        readonly static "BLASTING": any;
        readonly static "SMELTING": any;
        readonly static "CRAFTING": any;
        readonly static "STONECUTTING": any;
    }
    type RecipeType_<T> = RecipeType<T>;
    class WeightedPlacedFeature {
        constructor(arg0: Internal.Holder_<Internal.PlacedFeature_>, arg1: number)
        place(arg0: Internal.WorldGenLevel_, arg1: Internal.ChunkGenerator_, arg2: Internal.Random_, arg3: BlockPos_): boolean;
        readonly "feature": Internal.Holder<Internal.PlacedFeature>;
        readonly "chance": number;
        readonly static "CODEC": any;
    }
    type WeightedPlacedFeature_ = WeightedPlacedFeature;
    class ClientboundPlayerCombatKillPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.CombatTracker_, arg1: Internal.Component_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: number, arg2: Internal.Component_)
        handle(arg0: Internal.PacketListener_): void;
        getKillerId(): number;
        getMessage(): Internal.Component;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getPlayerId(): number;
        isSkippable(): boolean;
        get killerId(): number
        get message(): Internal.Component
        get playerId(): number
        get skippable(): boolean
    }
    type ClientboundPlayerCombatKillPacket_ = ClientboundPlayerCombatKillPacket;
    abstract class RenderStateShard {
        constructor(arg0: string, arg1: Internal.Runnable_, arg2: Internal.Runnable_)
        clearRenderState(): void;
        toString(): string;
        setupRenderState(): void;
        readonly static "RENDERTYPE_ENTITY_NO_OUTLINE_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "LIGHTMAP": Internal.RenderStateShard$LightmapStateShard;
        readonly static "CLOUDS_TARGET": Internal.RenderStateShard$OutputStateShard;
        readonly static "ITEM_ENTITY_TARGET": Internal.RenderStateShard$OutputStateShard;
        readonly static "POLYGON_OFFSET_LAYERING": Internal.RenderStateShard$LayeringStateShard;
        readonly static "RENDERTYPE_TRANSLUCENT_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_ENTITY_CUTOUT_NO_CULL_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_GLINT_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "VIEW_OFFSET_Z_LAYERING": Internal.RenderStateShard$LayeringStateShard;
        readonly static "CULL": Internal.RenderStateShard$CullStateShard;
        readonly static "RENDERTYPE_LINES_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_LIGHTNING_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "NEW_ENTITY_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "EQUAL_DEPTH_TEST": Internal.RenderStateShard$DepthTestStateShard;
        readonly static "BLOCK_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "NO_LIGHTMAP": Internal.RenderStateShard$LightmapStateShard;
        readonly static "TRANSLUCENT_TARGET": Internal.RenderStateShard$OutputStateShard;
        readonly static "POSITION_COLOR_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "POSITION_COLOR_TEX_LIGHTMAP_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_ENERGY_SWIRL_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_SOLID_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "COLOR_DEPTH_WRITE": Internal.RenderStateShard$WriteMaskStateShard;
        readonly static "CRUMBLING_TRANSPARENCY": Internal.RenderStateShard$TransparencyStateShard;
        readonly static "BLOCK_SHEET_MIPPED": Internal.RenderStateShard$TextureStateShard;
        readonly static "RENDERTYPE_ENTITY_TRANSLUCENT_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "POSITION_COLOR_LIGHTMAP_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_ENTITY_SMOOTH_CUTOUT_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_ENTITY_CUTOUT_NO_CULL_Z_OFFSET_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "POSITION_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "NO_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_ENTITY_DECAL_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "PARTICLES_TARGET": Internal.RenderStateShard$OutputStateShard;
        readonly static "NO_DEPTH_TEST": Internal.RenderStateShard$DepthTestStateShard;
        readonly static "VIEW_SCALE_Z_EPSILON": 0.99975586;
        readonly static "RENDERTYPE_ITEM_ENTITY_TRANSLUCENT_CULL_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "POSITION_COLOR_TEX_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "GLINT_TRANSPARENCY": Internal.RenderStateShard$TransparencyStateShard;
        readonly static "NO_TRANSPARENCY": Internal.RenderStateShard$TransparencyStateShard;
        readonly static "RENDERTYPE_GLINT_TRANSLUCENT_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "DEFAULT_TEXTURING": Internal.RenderStateShard$TexturingStateShard;
        readonly static "BLOCK_SHEET": Internal.RenderStateShard$TextureStateShard;
        readonly static "COLOR_WRITE": Internal.RenderStateShard$WriteMaskStateShard;
        readonly static "MAIN_TARGET": Internal.RenderStateShard$OutputStateShard;
        readonly static "RENDERTYPE_TEXT_SEE_THROUGH_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_CUTOUT_MIPPED_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_ENTITY_SHADOW_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "NO_LAYERING": Internal.RenderStateShard$LayeringStateShard;
        readonly static "RENDERTYPE_TRANSLUCENT_MOVING_BLOCK_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "DEPTH_WRITE": Internal.RenderStateShard$WriteMaskStateShard;
        readonly static "RENDERTYPE_TRIPWIRE_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "TRANSLUCENT_TRANSPARENCY": Internal.RenderStateShard$TransparencyStateShard;
        readonly static "RENDERTYPE_ARMOR_CUTOUT_NO_CULL_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_OUTLINE_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_GLINT_DIRECT_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_ENTITY_GLINT_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_TEXT_INTENSITY_SEE_THROUGH_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "DEFAULT_LINE": Internal.RenderStateShard$LineStateShard;
        readonly static "RENDERTYPE_WATER_MASK_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "NO_TEXTURE": Internal.RenderStateShard$EmptyTextureStateShard;
        readonly static "RENDERTYPE_ENTITY_CUTOUT_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "NO_CULL": Internal.RenderStateShard$CullStateShard;
        readonly static "LEQUAL_DEPTH_TEST": Internal.RenderStateShard$DepthTestStateShard;
        readonly static "RENDERTYPE_CRUMBLING_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_ENTITY_ALPHA_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "NO_OVERLAY": Internal.RenderStateShard$OverlayStateShard;
        readonly static "LIGHTNING_TRANSPARENCY": Internal.RenderStateShard$TransparencyStateShard;
        readonly static "RENDERTYPE_ENTITY_SOLID_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_LEASH_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_TEXT_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_TEXT_INTENSITY_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_ARMOR_GLINT_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_TRANSLUCENT_NO_CRUMBLING_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_ARMOR_ENTITY_GLINT_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_ENTITY_TRANSLUCENT_CULL_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "OVERLAY": Internal.RenderStateShard$OverlayStateShard;
        readonly static "ENTITY_GLINT_TEXTURING": Internal.RenderStateShard$TexturingStateShard;
        readonly static "GLINT_TEXTURING": Internal.RenderStateShard$TexturingStateShard;
        readonly static "POSITION_TEX_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_EYES_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "ADDITIVE_TRANSPARENCY": Internal.RenderStateShard$TransparencyStateShard;
        readonly static "WEATHER_TARGET": Internal.RenderStateShard$OutputStateShard;
        readonly static "RENDERTYPE_CUTOUT_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_END_GATEWAY_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_BEACON_BEAM_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_ENTITY_GLINT_DIRECT_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "RENDERTYPE_END_PORTAL_SHADER": Internal.RenderStateShard$ShaderStateShard;
        readonly static "OUTLINE_TARGET": Internal.RenderStateShard$OutputStateShard;
    }
    type RenderStateShard_ = RenderStateShard;
    class MinecartHopper extends Internal.AbstractMinecartContainer implements Internal.Hopper {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        stopOpen(arg0: Internal.Player_): void;
        isPoweredCart(): boolean;
        activateMinecart(arg0: number, arg1: number, arg2: number, arg3: boolean): void;
        getCurrentRailPosition(): BlockPos;
        getMaxCartSpeedOnRail(): number;
        setEnabled(arg0: boolean): void;
        countItem(arg0: Internal.Item_): number;
        createMenu(arg0: number, arg1: Internal.Inventory_): Internal.AbstractContainerMenu;
        getStepHeight(): number;
        isEnabled(): boolean;
        asKJS(): Internal.EntityJS;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        getSlopeAdjustment(): number;
        getDefaultDisplayOffset(): number;
        shouldDoRailFunctions(): boolean;
        canRiderInteract(): boolean;
        destroy(arg0: Internal.DamageSource_): void;
        isMultipartEntity(): boolean;
        canBeRidden(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        suckInItems(): boolean;
        getContainerSize(): number;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        isOnCooldown(): boolean;
        getDefaultDisplayBlockState(): Internal.BlockState;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMaxStackSize(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getCartItem(): Internal.ItemStack;
        tick(): void;
        setCooldown(arg0: number): void;
        getMinecartType(): Internal.AbstractMinecart$Type;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getSuckShape(): Internal.VoxelShape;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getComparatorLevel(): number;
        getLevelX(): number;
        getLevelY(): number;
        getLevelZ(): number;
        get poweredCart(): boolean
        get currentRailPosition(): BlockPos
        get maxCartSpeedOnRail(): number
        set enabled(arg0: boolean)
        get stepHeight(): number
        get enabled(): boolean
        get slopeAdjustment(): number
        get defaultDisplayOffset(): number
        get multipartEntity(): boolean
        get containerSize(): number
        get parts(): Internal.PartEntity<any>[]
        get onCooldown(): boolean
        get defaultDisplayBlockState(): Internal.BlockState
        get maxStackSize(): number
        get cartItem(): Internal.ItemStack
        set cooldown(arg0: number)
        get minecartType(): Internal.AbstractMinecart$Type
        get suckShape(): Internal.VoxelShape
        get comparatorLevel(): number
        get levelX(): number
        get levelY(): number
        get levelZ(): number
        readonly static "MOVE_ITEM_SPEED": 4;
    }
    type MinecartHopper_ = MinecartHopper;
    interface TemporalField {
        isTimeBased(): boolean;
        range(): Internal.ValueRange;
        toString(): string;
        rangeRefinedBy(arg0: Internal.TemporalAccessor_): Internal.ValueRange;
        isSupportedBy(arg0: Internal.TemporalAccessor_): boolean;
        getDisplayName(arg0: Internal.Locale_): string;
        isDateBased(): boolean;
        getBaseUnit(): Internal.TemporalUnit;
        resolve(arg0: Internal.Map_<Internal.TemporalField_, number>, arg1: Internal.TemporalAccessor_, arg2: Internal.ResolverStyle_): Internal.TemporalAccessor;
        adjustInto(arg0: R, arg1: number): R;
        getRangeUnit(): Internal.TemporalUnit;
        getFrom(arg0: Internal.TemporalAccessor_): number;
        get timeBased(): boolean
        get dateBased(): boolean
        get baseUnit(): Internal.TemporalUnit
        get rangeUnit(): Internal.TemporalUnit
    }
    type TemporalField_ = TemporalField;
    interface SoundInstance {
        getAttenuation(): Internal.SoundInstance$Attenuation;
        getLocation(): ResourceLocation;
        getSource(): Internal.SoundSource;
        canStartSilent(): boolean;
        resolve(arg0: Internal.SoundManager_): Internal.WeighedSoundEvents;
        getStream(arg0: Internal.SoundBufferLibrary_, arg1: Internal.Sound_, arg2: boolean): Internal.CompletableFuture<Internal.AudioStream>;
        canPlaySound(): boolean;
        getDelay(): number;
        getX(): number;
        isLooping(): boolean;
        getVolume(): number;
        getY(): number;
        getZ(): number;
        getPitch(): number;
        getSound(): Internal.Sound;
        isRelative(): boolean;
        get attenuation(): Internal.SoundInstance$Attenuation
        get location(): ResourceLocation
        get source(): Internal.SoundSource
        get delay(): number
        get x(): number
        get looping(): boolean
        get volume(): number
        get y(): number
        get z(): number
        get pitch(): number
        get sound(): Internal.Sound
        get relative(): boolean
    }
    type SoundInstance_ = SoundInstance;
    class ClientboundSectionBlocksUpdatePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.SectionPos_, arg1: any_, arg2: Internal.LevelChunkSection_, arg3: boolean)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        runUpdates(arg0: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>): void;
        shouldSuppressLightUpdates(): boolean;
        isSkippable(): boolean;
        get skippable(): boolean
    }
    type ClientboundSectionBlocksUpdatePacket_ = ClientboundSectionBlocksUpdatePacket;
    class ThrownPotion extends Internal.ThrowableItemProjectile implements Internal.ItemSupplier {
        constructor(arg0: Internal.Level_, arg1: Internal.LivingEntity_)
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        readonly static "SPLASH_RANGE": 4.0;
        readonly static "WATER_SENSITIVE": any;
    }
    type ThrownPotion_ = ThrownPotion;
    interface FormattedCharSink {
        accept(arg0: number, arg1: Internal.Style_, arg2: number): boolean;
    }
    type FormattedCharSink_ = ((arg0: number, arg1: Internal.Style, arg2: number)=>boolean) | FormattedCharSink;
    interface ToDoubleFunction <T> {
        applyAsDouble(arg0: T): number;
    }
    type ToDoubleFunction_<T> = ToDoubleFunction<T> | ((arg0: T)=>number);
    class StructureRenderer implements Internal.DebugRenderer$SimpleDebugRenderer {
        constructor(arg0: Internal.Minecraft_)
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource_, arg2: number, arg3: number, arg4: number): void;
        addBoundingBox(arg0: Internal.BoundingBox_, arg1: Internal.List_<Internal.BoundingBox_>, arg2: Internal.List_<boolean>, arg3: Internal.DimensionType_): void;
        clear(): void;
    }
    type StructureRenderer_ = StructureRenderer;
    class FallingBlockBuilder extends Internal.BlockBuilder {
        constructor(i: ResourceLocation_)
        createObject(): any;
        dustColor(color: Internal.Color_): this;
    }
    type FallingBlockBuilder_ = FallingBlockBuilder;
    class NoiseBasedChunkGenerator extends Internal.ChunkGenerator {
        constructor(arg0: Internal.Registry_<Internal.StructureSet_>, arg1: Internal.Registry_<Internal.NormalNoise$NoiseParameters_>, arg2: Internal.BiomeSource_, arg3: number, arg4: Internal.Holder_<Internal.NoiseGeneratorSettings_>)
        climateSampler(): Internal.Climate$Sampler;
        applyCarvers(arg0: Internal.WorldGenRegion_, arg1: number, arg2: Internal.BiomeManager_, arg3: Internal.StructureFeatureManager_, arg4: Internal.ChunkAccess_, arg5: CarvingGenerationStep_): void;
        getSeaLevel(): number;
        topMaterial(arg0: Internal.CarvingContext_, arg1: Internal.Function_<BlockPos_, Internal.Holder_<Internal.Biome_>>, arg2: Internal.ChunkAccess_, arg3: Internal.NoiseChunk_, arg4: BlockPos_, arg5: boolean): Internal.Optional<Internal.BlockState>;
        getBaseColumn(arg0: number, arg1: number, arg2: Internal.LevelHeightAccessor_): Internal.NoiseColumn;
        withSeed(arg0: number): Internal.ChunkGenerator;
        getGenDepth(): number;
        buildSurface(arg0: Internal.WorldGenRegion_, arg1: Internal.StructureFeatureManager_, arg2: Internal.ChunkAccess_): void;
        createBiomes(arg0: Internal.Registry_<Internal.Biome_>, arg1: Internal.Executor_, arg2: Internal.Blender_, arg3: Internal.StructureFeatureManager_, arg4: Internal.ChunkAccess_): Internal.CompletableFuture<Internal.ChunkAccess>;
        stable(arg0: number, arg1: Internal.ResourceKey_<Internal.NoiseGeneratorSettings_>): boolean;
        getBaseHeight(arg0: number, arg1: number, arg2: Internal.Heightmap$Types_, arg3: Internal.LevelHeightAccessor_): number;
        router(): Internal.NoiseRouter;
        addDebugScreenInfo(arg0: Internal.List_<string>, arg1: BlockPos_): void;
        spawnOriginalMobs(arg0: Internal.WorldGenRegion_): void;
        getMinY(): number;
        fillFromNoise(arg0: Internal.Executor_, arg1: Internal.Blender_, arg2: Internal.StructureFeatureManager_, arg3: Internal.ChunkAccess_): Internal.CompletableFuture<Internal.ChunkAccess>;
        get seaLevel(): number
        get genDepth(): number
        get minY(): number
        readonly static "CODEC": any;
    }
    type NoiseBasedChunkGenerator_ = NoiseBasedChunkGenerator;
    class GameType extends Internal.Enum<Internal.GameType> {
        static getNullableId(arg0: Internal.GameType_): number;
        static byId(arg0: number, arg1: Internal.GameType_): Internal.GameType;
        isSurvival(): boolean;
        static byName(arg0: string): Internal.GameType;
        static values(): Internal.GameType[];
        static valueOf(arg0: string): Internal.GameType;
        static byName(arg0: string, arg1: Internal.GameType_): Internal.GameType;
        getShortDisplayName(): Internal.Component;
        isCreative(): boolean;
        isBlockPlacingRestricted(): boolean;
        getName(): string;
        static byId(arg0: number): Internal.GameType;
        static byNullableId(arg0: number): Internal.GameType;
        updatePlayerAbilities(arg0: Internal.Abilities_): void;
        getLongDisplayName(): Internal.Component;
        getId(): number;
        get survival(): boolean
        get shortDisplayName(): Internal.Component
        get creative(): boolean
        get blockPlacingRestricted(): boolean
        get name(): string
        get longDisplayName(): Internal.Component
        get id(): number
        readonly static "DEFAULT_MODE": Internal.GameType;
        readonly static "ADVENTURE": Internal.GameType;
        readonly static "SPECTATOR": Internal.GameType;
        readonly static "CREATIVE": Internal.GameType;
        readonly static "SURVIVAL": Internal.GameType;
    }
    type GameType_ = "spectator" | "adventure" | GameType | "survival" | "creative";
    class ClientboundAddPaintingPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.Painting_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getPos(): BlockPos;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getUUID(): Internal.UUID;
        getMotive(): Internal.Motive;
        isSkippable(): boolean;
        getId(): number;
        getDirection(): Internal.Direction;
        get pos(): BlockPos
        get UUID(): Internal.UUID
        get motive(): Internal.Motive
        get skippable(): boolean
        get id(): number
        get direction(): Internal.Direction
    }
    type ClientboundAddPaintingPacket_ = ClientboundAddPaintingPacket;
    abstract class LootPoolEntryContainer$Builder <T> implements Internal.ConditionUserBuilder<T> {
        constructor()
        build(): Internal.LootPoolEntryContainer;
        otherwise(arg0: Internal.LootPoolEntryContainer$Builder_<any>): Internal.AlternativesEntry$Builder;
        append(arg0: Internal.LootPoolEntryContainer$Builder_<any>): Internal.EntryGroup$Builder;
        unwrap(): T;
        then(arg0: Internal.LootPoolEntryContainer$Builder_<any>): Internal.SequentialEntry$Builder;
        when(arg0: Internal.LootItemCondition$Builder_): any;
    }
    type LootPoolEntryContainer$Builder_<T> = LootPoolEntryContainer$Builder<T>;
    interface CloseableResourceManager extends Internal.ResourceManager, Internal.AutoCloseable {
        close(): void;
    }
    type CloseableResourceManager_ = (()=>void) | CloseableResourceManager;
    class GoalSelector {
        constructor(arg0: Internal.Supplier_<Internal.ProfilerFiller_>)
        removeGoal(arg0: Internal.Goal_): void;
        addGoal(arg0: number, arg1: Internal.Goal_): void;
        getRunningGoals(): Internal.Stream<Internal.WrappedGoal>;
        setControlFlag(arg0: Internal.Goal$Flag_, arg1: boolean): void;
        disableControlFlag(arg0: Internal.Goal$Flag_): void;
        tickRunningGoals(arg0: boolean): void;
        enableControlFlag(arg0: Internal.Goal$Flag_): void;
        getAvailableGoals(): Internal.Set<Internal.WrappedGoal>;
        tick(): void;
        setNewGoalRate(arg0: number): void;
        removeAllGoals(): void;
        get runningGoals(): Internal.Stream<Internal.WrappedGoal>
        get availableGoals(): Internal.Set<Internal.WrappedGoal>
        set newGoalRate(arg0: number)
    }
    type GoalSelector_ = GoalSelector;
    interface ICapabilityProvider {
        getCapability(arg0: Internal.Capability_<T>, arg1: Internal.Direction_): Internal.LazyOptional<T>;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
    }
    type ICapabilityProvider_ = ICapabilityProvider;
    class ClientboundSetTitleTextPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.Component_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getText(): Internal.Component;
        isSkippable(): boolean;
        get text(): Internal.Component
        get skippable(): boolean
    }
    type ClientboundSetTitleTextPacket_ = ClientboundSetTitleTextPacket;
    interface Script {
        exec(arg0: Internal.Context_, arg1: Internal.Scriptable_): any;
    }
    type Script_ = Script;
    class ClientboundBlockUpdatePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        constructor(arg0: Internal.BlockGetter_, arg1: BlockPos_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getPos(): BlockPos;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getBlockState(): Internal.BlockState;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get pos(): BlockPos
        get blockState(): Internal.BlockState
        get skippable(): boolean
    }
    type ClientboundBlockUpdatePacket_ = ClientboundBlockUpdatePacket;
    class AttributedCharacterIterator$Attribute implements Internal.Serializable {
        hashCode(): number;
        toString(): string;
        equals(arg0: any): boolean;
        readonly static "LANGUAGE": Internal.AttributedCharacterIterator$Attribute;
        readonly static "READING": Internal.AttributedCharacterIterator$Attribute;
        readonly static "INPUT_METHOD_SEGMENT": Internal.AttributedCharacterIterator$Attribute;
    }
    type AttributedCharacterIterator$Attribute_ = AttributedCharacterIterator$Attribute;
    abstract class Calendar implements Internal.Cloneable, Internal.Comparable<Internal.Calendar>, Internal.Serializable {
        getWeekYear(): number;
        getDisplayNames(arg0: number, arg1: number, arg2: Internal.Locale_): Internal.Map<string, number>;
        toInstant(): Internal.Instant;
        getMinimum(arg0: number): number;
        set(arg0: number, arg1: number, arg2: number): void;
        static getAvailableLocales(): Internal.Locale[];
        setFirstDayOfWeek(arg0: number): void;
        compareTo(arg0: any): number;
        getTimeInMillis(): number;
        static getInstance(arg0: Internal.Locale_): Internal.Calendar;
        clear(arg0: number): void;
        getGreatestMinimum(arg0: number): number;
        getMinimalDaysInFirstWeek(): number;
        setTime(arg0: Internal.Date_): void;
        roll(arg0: number, arg1: number): void;
        set(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        setLenient(arg0: boolean): void;
        clone(): any;
        static getInstance(arg0: Internal.TimeZone_, arg1: Internal.Locale_): Internal.Calendar;
        setWeekDate(arg0: number, arg1: number, arg2: number): void;
        set(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        isSet(arg0: number): boolean;
        compareTo(arg0: Internal.Calendar_): number;
        getCalendarType(): string;
        static getInstance(): Internal.Calendar;
        setMinimalDaysInFirstWeek(arg0: number): void;
        add(arg0: number, arg1: number): void;
        getLeastMaximum(arg0: number): number;
        isLenient(): boolean;
        set(arg0: number, arg1: number): void;
        isWeekDateSupported(): boolean;
        getWeeksInWeekYear(): number;
        getDisplayName(arg0: number, arg1: number, arg2: Internal.Locale_): string;
        getTime(): Internal.Date;
        setTimeInMillis(arg0: number): void;
        toString(): string;
        roll(arg0: number, arg1: boolean): void;
        after(arg0: any): boolean;
        getMaximum(arg0: number): number;
        hashCode(): number;
        static getInstance(arg0: Internal.TimeZone_): Internal.Calendar;
        getTimeZone(): Internal.TimeZone;
        setTimeZone(arg0: Internal.TimeZone_): void;
        clear(): void;
        getFirstDayOfWeek(): number;
        static getAvailableCalendarTypes(): Internal.Set<string>;
        get(arg0: number): number;
        getActualMinimum(arg0: number): number;
        getActualMaximum(arg0: number): number;
        equals(arg0: any): boolean;
        before(arg0: any): boolean;
        get weekYear(): number
        get availableLocales(): Internal.Locale[]
        set firstDayOfWeek(arg0: number)
        get timeInMillis(): number
        get minimalDaysInFirstWeek(): number
        set time(arg0: Internal.Date_)
        set lenient(arg0: boolean)
        get calendarType(): string
        get instance(): Internal.Calendar
        set minimalDaysInFirstWeek(arg0: number)
        get lenient(): boolean
        get weekDateSupported(): boolean
        get weeksInWeekYear(): number
        get time(): Internal.Date
        set timeInMillis(arg0: number)
        get timeZone(): Internal.TimeZone
        set timeZone(arg0: Internal.TimeZone_)
        get firstDayOfWeek(): number
        get availableCalendarTypes(): Internal.Set<string>
        readonly static "OCTOBER": 9;
        readonly static "LONG": 2;
        readonly static "TUESDAY": 3;
        readonly static "AM_PM": 9;
        readonly static "MONTH": 2;
        readonly static "JULY": 6;
        readonly static "MAY": 4;
        readonly static "UNDECIMBER": 12;
        readonly static "FEBRUARY": 1;
        readonly static "WEEK_OF_MONTH": 4;
        readonly static "DST_OFFSET": 16;
        readonly static "WEDNESDAY": 4;
        readonly static "NOVEMBER": 10;
        readonly static "LONG_STANDALONE": 32770;
        readonly static "SHORT_STANDALONE": 32769;
        readonly static "AM": 0;
        readonly static "HOUR_OF_DAY": 11;
        readonly static "ALL_STYLES": 0;
        readonly static "MARCH": 2;
        readonly static "SATURDAY": 7;
        readonly static "SHORT_FORMAT": 1;
        readonly static "JANUARY": 0;
        readonly static "NARROW_FORMAT": 4;
        readonly static "FIELD_COUNT": 17;
        readonly static "ERA": 0;
        readonly static "YEAR": 1;
        readonly static "DAY_OF_WEEK_IN_MONTH": 8;
        readonly static "MILLISECOND": 14;
        readonly static "WEEK_OF_YEAR": 3;
        readonly static "AUGUST": 7;
        readonly static "DATE": 5;
        readonly static "MONDAY": 2;
        readonly static "SHORT": 1;
        readonly static "LONG_FORMAT": 2;
        readonly static "APRIL": 3;
        readonly static "FRIDAY": 6;
        readonly static "NARROW_STANDALONE": 32772;
        readonly static "SECOND": 13;
        readonly static "ZONE_OFFSET": 15;
        readonly static "SUNDAY": 1;
        readonly static "DAY_OF_MONTH": 5;
        readonly static "DAY_OF_YEAR": 6;
        readonly static "THURSDAY": 5;
        readonly static "PM": 1;
        readonly static "JUNE": 5;
        readonly static "HOUR": 10;
        readonly static "DECEMBER": 11;
        readonly static "SEPTEMBER": 8;
        readonly static "MINUTE": 12;
        readonly static "DAY_OF_WEEK": 7;
    }
    type Calendar_ = Calendar;
    class AttributeInstance {
        constructor(arg0: Internal.Attribute_, arg1: Internal.Consumer_<Internal.AttributeInstance_>)
        save(): Internal.CompoundTag;
        getModifiers(): Internal.Set<Internal.AttributeModifier>;
        removeModifier(arg0: Internal.AttributeModifier_): void;
        hasModifier(arg0: Internal.AttributeModifier_): boolean;
        setBaseValue(arg0: number): void;
        removeModifiers(): void;
        removeModifier(arg0: Internal.UUID_): void;
        getModifiers(arg0: Internal.AttributeModifier$Operation_): Internal.Set<Internal.AttributeModifier>;
        getAttribute(): Internal.Attribute;
        getBaseValue(): number;
        addTransientModifier(arg0: Internal.AttributeModifier_): void;
        load(arg0: Internal.CompoundTag_): void;
        replaceFrom(arg0: Internal.AttributeInstance_): void;
        getModifier(arg0: Internal.UUID_): Internal.AttributeModifier;
        removePermanentModifier(arg0: Internal.UUID_): boolean;
        getValue(): number;
        addPermanentModifier(arg0: Internal.AttributeModifier_): void;
        get modifiers(): Internal.Set<Internal.AttributeModifier>
        set baseValue(arg0: number)
        get attribute(): Internal.Attribute
        get baseValue(): number
        get value(): number
    }
    type AttributeInstance_ = AttributeInstance;
    abstract class BlockBuilder extends Internal.BuilderBase<Internal.Block> {
        constructor(i: ResourceLocation_)
        createAdditionalObjects(): void;
        tagItem(tag: ResourceLocation_): this;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        model(m: string): this;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): this;
        redstoneConductor(b: boolean): this;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): this;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        textureAll(tex: string): this;
        defaultTranslucent(): this;
        tagBoth(tag: ResourceLocation_): this;
        unbreakable(): this;
        viewBlocking(b: boolean): this;
        color(index: number, c: Internal.Color_): this;
        property(property: Internal.Property_<any>): this;
        resistance(r: number): this;
        material(m: Internal.MaterialJS_): this;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): this;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): this;
        lightLevel(light: number): this;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        notSolid(): this;
        noCollission(): this;
        renderType(l: string): this;
        noDrops(): this;
        defaultState(callbackJS: Internal.Consumer_<Internal.BlockStateModifyCallbackJS_>): this;
        setWaterlogged(waterlogged: boolean): this;
        placementState(callbackJS: Internal.Consumer_<Internal.BlockStateModifyPlacementCallbackJS_>): this;
        createProperties(): Internal.BlockBehaviour$Properties;
        waterlogged(): this;
        jumpFactor(f: number): this;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        requiresTool(f: boolean): this;
        clientRegistry(minecraft: Internal.Supplier_<Internal.Minecraft_>): void;
        textureSide(direction: Internal.Direction_, tex: string): this;
        texture(id: string, tex: string): this;
        canBeWaterlogged(): boolean;
        hardness(h: number): this;
        noItem(): this;
        transformObject(arg0: any): any;
        getWaterlogged(): boolean;
        createShape(): Internal.VoxelShape;
        slipperiness(f: number): this;
        tagBlock(tag: ResourceLocation_): this;
        opaque(o: boolean): this;
        noValidSpawns(b: boolean): this;
        transformObject(obj: Internal.Block_): Internal.Block;
        defaultCutout(): this;
        transparent(b: boolean): this;
        fullBlock(f: boolean): this;
        noCollision(): this;
        suffocating(b: boolean): this;
        speedFactor(f: number): this;
        tag(arg0: ResourceLocation_): Internal.BuilderBase<any>;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>
        set waterlogged(waterlogged: boolean)
        get waterlogged(): boolean
        "lootTable": Internal.Consumer<Internal.LootBuilder>;
        "blockstateJson": Internal.JsonObject;
        "modelJson": Internal.JsonObject;
        "randomTickCallback": Internal.Consumer<Internal.RandomTickCallbackJS>;
    }
    type BlockBuilder_ = BlockBuilder;
    class Mirror extends Internal.Enum<Internal.Mirror> {
        getRotation(arg0: Internal.Direction_): Internal.Rotation;
        mirror(arg0: Internal.Direction_): Internal.Direction;
        static values(): Internal.Mirror[];
        mirror(arg0: number, arg1: number): number;
        rotation(): Internal.OctahedralGroup;
        static valueOf(arg0: string): Internal.Mirror;
        symbol(): Internal.Component;
        readonly static "FRONT_BACK": Internal.Mirror;
        readonly static "NONE": Internal.Mirror;
        readonly static "LEFT_RIGHT": Internal.Mirror;
    }
    type Mirror_ = "left_right" | "front_back" | Mirror | "none";
    interface ScheduledExecutorService extends Internal.ExecutorService {
        scheduleAtFixedRate(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        schedule(arg0: Internal.Callable_<V>, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<V>;
        schedule(arg0: Internal.Runnable_, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        scheduleWithFixedDelay(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
    }
    type ScheduledExecutorService_ = ScheduledExecutorService;
    abstract class StructBuffer <T, SELF> extends Internal.CustomBuffer<SELF> implements Internal.Iterable<T> {
        put(arg0: T): SELF;
        get(arg0: number): T;
        get(arg0: number, arg1: T): SELF;
        put(arg0: number, arg1: T): SELF;
        stream(): Internal.Stream<T>;
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<T>;
        parallelStream(): Internal.Stream<T>;
        get(): T;
        get(arg0: T): SELF;
        sizeof(): number;
        iterator(): Internal.Iterator<T>;
    }
    type StructBuffer_<T, SELF> = StructBuffer<T, SELF>;
    interface BlockAndTintGetter extends Internal.BlockGetter {
        getBlockTint(arg0: BlockPos_, arg1: Internal.ColorResolver_): number;
        getMinSection(): number;
        getShade(arg0: Internal.Direction_, arg1: boolean): number;
        getSectionIndex(arg0: number): number;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        getMaxSection(): number;
        getBrightness(arg0: Internal.LightLayer_, arg1: BlockPos_): number;
        getMaxBuildHeight(): number;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getSectionYFromSectionIndex(arg0: number): number;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        getLightEngine(): Internal.LevelLightEngine;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        getRawBrightness(arg0: BlockPos_, arg1: number): number;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        canSeeSky(arg0: BlockPos_): boolean;
        isOutsideBuildHeight(arg0: number): boolean;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        getSectionsCount(): number;
        getSectionIndexFromSectionY(arg0: number): number;
        getMaxLightLevel(): number;
        get minSection(): number
        get maxSection(): number
        get maxBuildHeight(): number
        get lightEngine(): Internal.LevelLightEngine
        get sectionsCount(): number
        get maxLightLevel(): number
    }
    type BlockAndTintGetter_ = BlockAndTintGetter;
    class LightningBolt extends Internal.Entity {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        setVisualOnly(arg0: boolean): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        getCause(): Internal.ServerPlayer;
        setDamage(arg0: number): void;
        getAddEntityPacket(): Internal.Packet<any>;
        canRiderInteract(): boolean;
        getSoundSource(): Internal.SoundSource;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRenderAtSqrDistance(arg0: number): boolean;
        getBlocksSetOnFire(): number;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        handler$zbj000$handleLightning(ci: Internal.CallbackInfo_, list: Internal.List_<any>): void;
        alwaysAccepts(): boolean;
        getHitEntities(): Internal.Stream<Internal.Entity>;
        getClassification(arg0: boolean): Internal.MobCategory;
        getDamage(): number;
        setCause(arg0: Internal.ServerPlayer_): void;
        set visualOnly(arg0: boolean)
        get stepHeight(): number
        get cause(): Internal.ServerPlayer
        set damage(arg0: number)
        get addEntityPacket(): Internal.Packet<any>
        get soundSource(): Internal.SoundSource
        get multipartEntity(): boolean
        get blocksSetOnFire(): number
        get parts(): Internal.PartEntity<any>[]
        get hitEntities(): Internal.Stream<Internal.Entity>
        get damage(): number
        set cause(arg0: Internal.ServerPlayer_)
        "seed": number;
    }
    type LightningBolt_ = LightningBolt;
    class AttributeModifier$Operation extends Internal.Enum<Internal.AttributeModifier$Operation> {
        static valueOf(arg0: string): Internal.AttributeModifier$Operation;
        static fromValue(arg0: number): Internal.AttributeModifier$Operation;
        static values(): Internal.AttributeModifier$Operation[];
        toValue(): number;
        readonly static "MULTIPLY_BASE": Internal.AttributeModifier$Operation;
        readonly static "MULTIPLY_TOTAL": Internal.AttributeModifier$Operation;
        readonly static "ADDITION": Internal.AttributeModifier$Operation;
    }
    type AttributeModifier$Operation_ = "addition" | AttributeModifier$Operation | "multiply_total" | "multiply_base";
    class TextStyle extends Internal.Enum<Internal.TextStyle> {
        isStandalone(): boolean;
        asNormal(): this;
        asStandalone(): this;
        static values(): Internal.TextStyle[];
        static valueOf(arg0: string): Internal.TextStyle;
        get standalone(): boolean
        readonly static "SHORT": Internal.TextStyle;
        readonly static "NARROW": Internal.TextStyle;
        readonly static "SHORT_STANDALONE": Internal.TextStyle;
        readonly static "FULL": Internal.TextStyle;
        readonly static "NARROW_STANDALONE": Internal.TextStyle;
        readonly static "FULL_STANDALONE": Internal.TextStyle;
    }
    type TextStyle_ = "narrow" | TextStyle | "short" | "full_standalone" | "short_standalone" | "full" | "narrow_standalone";
    abstract class AbstractMinecart extends Internal.Entity implements Internal.IForgeAbstractMinecart {
        push(arg0: Internal.Entity_): void;
        isPoweredCart(): boolean;
        activateMinecart(arg0: number, arg1: number, arg2: number, arg3: boolean): void;
        getMaxCartSpeedOnRail(): number;
        getDragAir(): number;
        getPos(arg0: number, arg1: number, arg2: number): Vec3;
        setCurrentCartSpeedCapOnRail(arg0: number): void;
        setCustomDisplay(arg0: boolean): void;
        getStepHeight(): number;
        getDisplayBlockState(): Internal.BlockState;
        getSlopeAdjustment(): number;
        getDefaultDisplayOffset(): number;
        setHurtTime(arg0: number): void;
        setDamage(arg0: number): void;
        getDisplayOffset(): number;
        getAddEntityPacket(): Internal.Packet<any>;
        getMaxSpeedAirVertical(): number;
        canBeRidden(): boolean;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getDefaultDisplayBlockState(): Internal.BlockState;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        setCanUseRail(arg0: boolean): void;
        canCollideWith(arg0: Internal.Entity_): boolean;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        getMotionDirection(): Internal.Direction;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getCartItem(): Internal.ItemStack;
        static registerCollisionHandler(arg0: Internal.IMinecartCollisionHandler_): void;
        isPickable(): boolean;
        tick(): void;
        lerpMotion(arg0: number, arg1: number, arg2: number): void;
        getMinecartType(): Internal.AbstractMinecart$Type;
        moveMinecartOnRail(arg0: BlockPos_): void;
        getHurtTime(): number;
        alwaysAccepts(): boolean;
        getCollisionHandler(): Internal.IMinecartCollisionHandler;
        getPickResult(): Internal.ItemStack;
        getComparatorLevel(): number;
        canUseRail(): boolean;
        setMaxSpeedAirLateral(arg0: number): void;
        getCurrentRailPosition(): BlockPos;
        setHurtDir(arg0: number): void;
        getDismountLocationForPassenger(arg0: Internal.LivingEntity_): Vec3;
        getCurrentCartSpeedCapOnRail(): number;
        asKJS(): Internal.EntityJS;
        animateHurt(): void;
        shouldDoRailFunctions(): boolean;
        canRiderInteract(): boolean;
        static createMinecart(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number, arg4: Internal.AbstractMinecart$Type_): Internal.AbstractMinecart;
        destroy(arg0: Internal.DamageSource_): void;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        hasCustomDisplay(): boolean;
        getHurtDir(): number;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getBoundingBoxForCulling(): Internal.AABB;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMaxSpeedAirLateral(): number;
        lerpTo(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: boolean): void;
        getPassengersRidingOffset(): number;
        setDisplayOffset(arg0: number): void;
        setDragAir(arg0: number): void;
        setMaxSpeedAirVertical(arg0: number): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        isPushable(): boolean;
        getDamage(): number;
        getMaxSpeedWithRail(): number;
        getPosOffs(arg0: number, arg1: number, arg2: number, arg3: number): Vec3;
        setDisplayBlockState(arg0: Internal.BlockState_): void;
        get poweredCart(): boolean
        get maxCartSpeedOnRail(): number
        get dragAir(): number
        set currentCartSpeedCapOnRail(arg0: number)
        set customDisplay(arg0: boolean)
        get stepHeight(): number
        get displayBlockState(): Internal.BlockState
        get slopeAdjustment(): number
        get defaultDisplayOffset(): number
        set hurtTime(arg0: number)
        set damage(arg0: number)
        get displayOffset(): number
        get addEntityPacket(): Internal.Packet<any>
        get maxSpeedAirVertical(): number
        get defaultDisplayBlockState(): Internal.BlockState
        set canUseRail(arg0: boolean)
        get motionDirection(): Internal.Direction
        get cartItem(): Internal.ItemStack
        get pickable(): boolean
        get minecartType(): Internal.AbstractMinecart$Type
        get hurtTime(): number
        get collisionHandler(): Internal.IMinecartCollisionHandler
        get pickResult(): Internal.ItemStack
        get comparatorLevel(): number
        set maxSpeedAirLateral(arg0: number)
        get currentRailPosition(): BlockPos
        set hurtDir(arg0: number)
        get currentCartSpeedCapOnRail(): number
        get multipartEntity(): boolean
        get hurtDir(): number
        get parts(): Internal.PartEntity<any>[]
        get boundingBoxForCulling(): Internal.AABB
        get maxSpeedAirLateral(): number
        get passengersRidingOffset(): number
        set displayOffset(arg0: number)
        set dragAir(arg0: number)
        set maxSpeedAirVertical(arg0: number)
        get pushable(): boolean
        get damage(): number
        get maxSpeedWithRail(): number
        set displayBlockState(arg0: Internal.BlockState_)
    }
    type AbstractMinecart_ = AbstractMinecart;
    interface Long2ObjectFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.LongFunction<V> {
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2ObjectFunction<V>;
        getOrDefault(arg0: any, arg1: V): V;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2ObjectFunction<V>;
        remove(arg0: number): V;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Long2ByteFunction;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2ObjectFunction<V>;
        containsKey(arg0: any): boolean;
        put(arg0: number, arg1: V): V;
        apply(arg0: number): V;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2ObjectFunction<V>;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Long2LongFunction;
        put(arg0: number, arg1: V): V;
        get(arg0: any): V;
        put(arg0: any, arg1: any): any;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Long2IntFunction;
        remove(arg0: any): V;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Long2FloatFunction;
        composeLong(arg0: Internal.Long2LongFunction_): this;
        apply(arg0: number): V;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Long2ShortFunction;
        composeObject(arg0: Internal.Object2LongFunction_<any>): Internal.Object2ObjectFunction<T, V>;
        andThenReference(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Long2ReferenceFunction<T>;
        containsKey(arg0: number): boolean;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Long2DoubleFunction;
        get(arg0: number): V;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        size(): number;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2ObjectFunction<V>;
        defaultReturnValue(): V;
        getOrDefault(arg0: number, arg1: V): V;
        composeReference(arg0: Internal.Reference2LongFunction_<any>): Internal.Reference2ObjectFunction<T, V>;
        andThenObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Long2ObjectFunction<T>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Long2CharFunction;
        defaultReturnValue(arg0: V): void;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
    }
    type Long2ObjectFunction_<V> = Long2ObjectFunction<V> | ((arg0: number)=>V);
    interface EffectsProperties {
        getWaterColor(): number;
        getBackgroundMusic(): Internal.Optional<Internal.Music>;
        getAmbientAdditionsSound(): Internal.Optional<Internal.AmbientAdditionsSettings>;
        getGrassColorModifier(): Internal.BiomeSpecialEffects$GrassColorModifier;
        getFoliageColorOverride(): Internal.OptionalInt;
        getAmbientMoodSound(): Internal.Optional<Internal.AmbientMoodSettings>;
        getWaterFogColor(): number;
        getAmbientLoopSound(): Internal.Optional<Internal.SoundEvent>;
        getAmbientParticle(): Internal.Optional<Internal.AmbientParticleSettings>;
        getFogColor(): number;
        getSkyColor(): number;
        getGrassColorOverride(): Internal.OptionalInt;
        get waterColor(): number
        get backgroundMusic(): Internal.Optional<Internal.Music>
        get ambientAdditionsSound(): Internal.Optional<Internal.AmbientAdditionsSettings>
        get grassColorModifier(): Internal.BiomeSpecialEffects$GrassColorModifier
        get foliageColorOverride(): Internal.OptionalInt
        get ambientMoodSound(): Internal.Optional<Internal.AmbientMoodSettings>
        get waterFogColor(): number
        get ambientLoopSound(): Internal.Optional<Internal.SoundEvent>
        get ambientParticle(): Internal.Optional<Internal.AmbientParticleSettings>
        get fogColor(): number
        get skyColor(): number
        get grassColorOverride(): Internal.OptionalInt
    }
    type EffectsProperties_ = EffectsProperties;
    class Weight {
        hashCode(): number;
        toString(): string;
        static of(arg0: number): Internal.Weight;
        equals(arg0: any): boolean;
        asInt(): number;
        readonly static "CODEC": any;
    }
    type Weight_ = Weight;
    class PlayerInteractEvent$EntityInteract extends Internal.PlayerInteractEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Hand_, arg2: Internal.Entity_)
        getTarget(): Internal.Entity;
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get target(): Internal.Entity
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type PlayerInteractEvent$EntityInteract_ = PlayerInteractEvent$EntityInteract;
    interface TagType <T> {
        getPrettyName(): string;
        skip(arg0: Internal.DataInput_, arg1: number): void;
        parseRoot(arg0: Internal.DataInput_, arg1: Internal.StreamTagVisitor_): void;
        getName(): string;
        isValue(): boolean;
        load(arg0: Internal.DataInput_, arg1: number, arg2: Internal.NbtAccounter_): T;
        createInvalid(arg0: number): Internal.TagType<Internal.EndTag>;
        parse(arg0: Internal.DataInput_, arg1: Internal.StreamTagVisitor_): Internal.StreamTagVisitor$ValueResult;
        skip(arg0: Internal.DataInput_): void;
        get prettyName(): string
        get name(): string
        get value(): boolean
    }
    type TagType_<T> = TagType<T>;
    abstract class AbstractFurnaceMenu extends Internal.RecipeBookMenu<Internal.Container> {
        getRecipeBookType(): Internal.RecipeBookType;
        clearCraftingContent(): void;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        getGridWidth(): number;
        stillValid(arg0: Internal.Player_): boolean;
        getResultSlotIndex(): number;
        getSize(): number;
        isLit(): boolean;
        recipeMatches(arg0: Internal.Recipe_<any>): boolean;
        getBurnProgress(): number;
        getGridHeight(): number;
        fillCraftSlotsStackedContents(arg0: Internal.StackedContents_): void;
        getLitProgress(): number;
        shouldMoveToInventory(arg0: number): boolean;
        get recipeBookType(): Internal.RecipeBookType
        get gridWidth(): number
        get resultSlotIndex(): number
        get size(): number
        get lit(): boolean
        get burnProgress(): number
        get gridHeight(): number
        get litProgress(): number
        readonly static "FUEL_SLOT": 1;
        readonly static "RESULT_SLOT": 2;
        readonly static "DATA_COUNT": 4;
        readonly static "SLOT_COUNT": 3;
        readonly static "INGREDIENT_SLOT": 0;
    }
    type AbstractFurnaceMenu_ = AbstractFurnaceMenu;
    class TreeDecoratorType <P> extends Internal.ForgeRegistryEntry<Internal.TreeDecoratorType<any>> {
        constructor(arg0: Internal.Codec_<P>)
        codec(): Internal.Codec<P>;
        readonly static "BEEHIVE": Internal.TreeDecoratorType<any>;
        readonly static "LEAVE_VINE": Internal.TreeDecoratorType<any>;
        readonly static "COCOA": Internal.TreeDecoratorType<any>;
        readonly static "TRUNK_VINE": Internal.TreeDecoratorType<any>;
        readonly static "ALTER_GROUND": Internal.TreeDecoratorType<any>;
    }
    type TreeDecoratorType_<P> = TreeDecoratorType<P> | Special.TreeDecoratorType;
    abstract class MultithreadEventLoopGroup extends Internal.MultithreadEventExecutorGroup implements Internal.EventLoopGroup {
        register(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        register(arg0: io.netty.channel.Channel_): Internal.ChannelFuture;
        next(): Internal.EventExecutor;
        forEach(arg0: Internal.Consumer_<any>): void;
        register(arg0: io.netty.channel.Channel_, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
    }
    type MultithreadEventLoopGroup_ = MultithreadEventLoopGroup;
    interface InstantSource {
        tick(arg0: Internal.InstantSource_, arg1: Internal.Duration_): this;
        offset(arg0: Internal.InstantSource_, arg1: Internal.Duration_): this;
        fixed(arg0: Internal.Instant_): this;
        instant(): Internal.Instant;
        system(): this;
        withZone(arg0: Internal.ZoneId_): Internal.Clock;
        millis(): number;
    }
    type InstantSource_ = InstantSource;
    class SmallFireball extends Internal.Fireball {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        constructor(arg0: Internal.Level_, arg1: Internal.LivingEntity_, arg2: number, arg3: number, arg4: number)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        isPickable(): boolean;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        get pickable(): boolean
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type SmallFireball_ = SmallFireball;
    interface MinecraftServerKJS extends Internal.AsKJS<Internal.ServerJS> {
        getReloadableResourcesKJS(): Internal.MinecraftServer$ReloadableResources;
        asKJS(): Internal.ServerJS;
        get reloadableResourcesKJS(): Internal.MinecraftServer$ReloadableResources
    }
    type MinecraftServerKJS_ = MinecraftServerKJS;
    class GameRules$Category extends Internal.Enum<Internal.GameRules$Category> {
        static valueOf(arg0: string): Internal.GameRules$Category;
        static values(): Internal.GameRules$Category[];
        getDescriptionId(): string;
        get descriptionId(): string
        readonly static "CHAT": Internal.GameRules$Category;
        readonly static "MISC": Internal.GameRules$Category;
        readonly static "DROPS": Internal.GameRules$Category;
        readonly static "UPDATES": Internal.GameRules$Category;
        readonly static "PLAYER": Internal.GameRules$Category;
        readonly static "MOBS": Internal.GameRules$Category;
        readonly static "SPAWNING": Internal.GameRules$Category;
    }
    type GameRules$Category_ = "chat" | "updates" | "misc" | "drops" | "player" | "mobs" | "spawning" | GameRules$Category;
    class ClipBlockStateContext {
        constructor(arg0: Vec3_, arg1: Vec3_, arg2: Internal.Predicate_<Internal.BlockState_>)
        getFrom(): Vec3;
        getTo(): Vec3;
        isTargetBlock(): Internal.Predicate<Internal.BlockState>;
        get from(): Vec3
        get to(): Vec3
    }
    type ClipBlockStateContext_ = ClipBlockStateContext;
    interface PlacementModifierType <P> {
        codec(): Internal.Codec<P>;
        readonly static "SURFACE_RELATIVE_THRESHOLD_FILTER": any;
        readonly static "IN_SQUARE": any;
        readonly static "HEIGHTMAP": any;
        readonly static "HEIGHT_RANGE": any;
        readonly static "BIOME_FILTER": any;
        readonly static "RANDOM_OFFSET": any;
        readonly static "BLOCK_PREDICATE_FILTER": any;
        readonly static "CARVING_MASK_PLACEMENT": any;
        readonly static "NOISE_BASED_COUNT": any;
        readonly static "ENVIRONMENT_SCAN": any;
        readonly static "SURFACE_WATER_DEPTH_FILTER": any;
        readonly static "COUNT_ON_EVERY_LAYER": any;
        readonly static "COUNT": any;
        readonly static "NOISE_THRESHOLD_COUNT": any;
        readonly static "RARITY_FILTER": any;
    }
    type PlacementModifierType_<P> = PlacementModifierType<P> | Special.PlacementModifierType;
    interface MapEncoder <A> extends Internal.Keyable {
        compressor(arg0: Internal.DynamicOps_<T>): Internal.KeyCompressor<T>;
        encode(arg0: A, arg1: Internal.DynamicOps_<T>, arg2: Internal.RecordBuilder_<T>): Internal.RecordBuilder<T>;
        compressedBuilder(arg0: Internal.DynamicOps_<T>): Internal.RecordBuilder<T>;
        comap(arg0: Internal.Function_<any, any>): Internal.MapEncoder<B>;
        flatComap(arg0: Internal.Function_<any, any>): Internal.MapEncoder<B>;
        makeCompressedBuilder(arg0: Internal.DynamicOps_<T>, arg1: Internal.KeyCompressor_<T>): Internal.RecordBuilder<T>;
        encoder(): Internal.Encoder<A>;
        withLifecycle(arg0: Internal.Lifecycle_): this;
    }
    type MapEncoder_<A> = MapEncoder<A>;
    interface LongToDoubleFunction {
        applyAsDouble(arg0: number): number;
    }
    type LongToDoubleFunction_ = ((arg0: number)=>number) | LongToDoubleFunction;
    interface Object2FloatMap$Entry <K> extends Internal.Map$Entry<K, number> {
        setValue(arg0: number): number;
        setValue(arg0: number): number;
        getValue(): number;
        setValue(arg0: any): any;
        getFloatValue(): number;
        set value(arg0: number)
        set value(arg0: number)
        get value(): number
        set value(arg0: any)
        get floatValue(): number
    }
    type Object2FloatMap$Entry_<K> = Object2FloatMap$Entry<K>;
    class DrawSelectionEvent$HighlightEntity extends Internal.DrawSelectionEvent {
        constructor()
        constructor(arg0: Internal.LevelRenderer_, arg1: Internal.Camera_, arg2: Internal.HitResult_, arg3: number, arg4: Internal.PoseStack_, arg5: Internal.MultiBufferSource_)
        getTarget(): Internal.HitResult;
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get target(): Internal.HitResult
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type DrawSelectionEvent$HighlightEntity_ = DrawSelectionEvent$HighlightEntity;
    class Holder$Reference$Type extends Internal.Enum<Internal.Holder$Reference$Type> {
        static values(): Internal.Holder$Reference$Type[];
        static valueOf(arg0: string): Internal.Holder$Reference$Type;
        readonly static "STAND_ALONE": Internal.Holder$Reference$Type;
        readonly static "INTRUSIVE": Internal.Holder$Reference$Type;
    }
    type Holder$Reference$Type_ = "stand_alone" | Holder$Reference$Type | "intrusive";
    class HolderSet$Direct <T> extends Internal.HolderSet$ListBacked<T> {
        unwrap(): Internal.Either<Internal.TagKey<T>, Internal.List<Internal.Holder<T>>>;
        contains(arg0: Internal.Holder_<T>): boolean;
        toString(): string;
        forEach(arg0: Internal.Consumer_<any>): void;
    }
    type HolderSet$Direct_<T> = HolderSet$Direct<T>;
    interface RecipeHolder {
        getRecipeUsed(): Internal.Recipe<any>;
        setRecipeUsed(arg0: Internal.Level_, arg1: Internal.ServerPlayer_, arg2: Internal.Recipe_<any>): boolean;
        setRecipeUsed(arg0: Internal.Recipe_<any>): void;
        awardUsedRecipes(arg0: Internal.Player_): void;
        get recipeUsed(): Internal.Recipe<any>
        set recipeUsed(arg0: Internal.Recipe_<any>)
    }
    type RecipeHolder_ = RecipeHolder;
    class UnderwaterMagmaConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: number, arg1: number, arg2: number)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "floorSearchRange": number;
        readonly "placementRadiusAroundFloor": number;
        readonly static "CODEC": any;
        readonly "placementProbabilityPerValidPosition": number;
    }
    type UnderwaterMagmaConfiguration_ = UnderwaterMagmaConfiguration;
    interface ClientboundBossEventPacket$Handler {
        updateStyle(arg0: Internal.UUID_, arg1: Internal.BossEvent$BossBarColor_, arg2: Internal.BossEvent$BossBarOverlay_): void;
        remove(arg0: Internal.UUID_): void;
        updateProgress(arg0: Internal.UUID_, arg1: number): void;
        updateProperties(arg0: Internal.UUID_, arg1: boolean, arg2: boolean, arg3: boolean): void;
        add(arg0: Internal.UUID_, arg1: Internal.Component_, arg2: number, arg3: Internal.BossEvent$BossBarColor_, arg4: Internal.BossEvent$BossBarOverlay_, arg5: boolean, arg6: boolean, arg7: boolean): void;
        updateName(arg0: Internal.UUID_, arg1: Internal.Component_): void;
    }
    type ClientboundBossEventPacket$Handler_ = ClientboundBossEventPacket$Handler;
    class AdvancementList {
        constructor()
        getAllAdvancements(): Internal.Collection<Internal.Advancement>;
        remove(arg0: Internal.Set_<ResourceLocation_>): void;
        setListener(arg0: Internal.AdvancementList$Listener_): void;
        getRoots(): Internal.Iterable<Internal.Advancement>;
        clear(): void;
        add(arg0: Internal.Map_<ResourceLocation_, Internal.Advancement$Builder_>): void;
        get(arg0: ResourceLocation_): Internal.Advancement;
        get allAdvancements(): Internal.Collection<Internal.Advancement>
        set listener(arg0: Internal.AdvancementList$Listener_)
        get roots(): Internal.Iterable<Internal.Advancement>
    }
    type AdvancementList_ = AdvancementList;
    class ClientboundMerchantOffersPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: Internal.MerchantOffers_, arg2: number, arg3: number, arg4: boolean, arg5: boolean)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        showProgress(): boolean;
        getVillagerLevel(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        canRestock(): boolean;
        getOffers(): Internal.MerchantOffers;
        getContainerId(): number;
        getVillagerXp(): number;
        isSkippable(): boolean;
        get villagerLevel(): number
        get offers(): Internal.MerchantOffers
        get containerId(): number
        get villagerXp(): number
        get skippable(): boolean
    }
    type ClientboundMerchantOffersPacket_ = ClientboundMerchantOffersPacket;
    class SmokingRecipe extends Internal.AbstractCookingRecipe {
        constructor(arg0: ResourceLocation_, arg1: string, arg2: Internal.Ingredient_, arg3: Internal.ItemStack_, arg4: number, arg5: number)
        isSpecial(): boolean;
        getSerializer(): Internal.RecipeSerializer<any>;
        getToastSymbol(): Internal.ItemStack;
        isIncomplete(): boolean;
        getRemainingItems(arg0: Internal.Container_): Internal.NonNullList<Internal.ItemStack>;
        get special(): boolean
        get serializer(): Internal.RecipeSerializer<any>
        get toastSymbol(): Internal.ItemStack
        get incomplete(): boolean
    }
    type SmokingRecipe_ = SmokingRecipe;
    abstract class CharsetEncoder {
        replaceWith(arg0: number[]): this;
        averageBytesPerChar(): number;
        canEncode(arg0: Internal.CharSequence_): boolean;
        charset(): Internal.Charset;
        onUnmappableCharacter(arg0: Internal.CodingErrorAction_): this;
        unmappableCharacterAction(): Internal.CodingErrorAction;
        onMalformedInput(arg0: Internal.CodingErrorAction_): this;
        replacement(): number[];
        isLegalReplacement(arg0: number[]): boolean;
        reset(): this;
        maxBytesPerChar(): number;
        encode(arg0: Internal.CharBuffer_, arg1: Internal.ByteBuffer_, arg2: boolean): Internal.CoderResult;
        encode(arg0: Internal.CharBuffer_): Internal.ByteBuffer;
        malformedInputAction(): Internal.CodingErrorAction;
        flush(arg0: Internal.ByteBuffer_): Internal.CoderResult;
        canEncode(arg0: string): boolean;
    }
    type CharsetEncoder_ = CharsetEncoder;
    abstract class Invokable <T, R> implements Internal.Member, Internal.AnnotatedElement {
        isFinal(): boolean;
        isVarArgs(): boolean;
        getOwnerType(): Internal.TypeToken<T>;
        getModifiers(): number;
        getDeclaredAnnotationsByType(arg0: Internal.Class_<T>): T[];
        getExceptionTypes(): Internal.ImmutableList<Internal.TypeToken<any>>;
        getAnnotation(arg0: Internal.Class_<A>): A;
        getAnnotatedReturnType(): Internal.AnnotatedType;
        isOverridable(): boolean;
        returning(arg0: Internal.TypeToken_<R1>): Internal.Invokable<T, R1>;
        isPublic(): boolean;
        getName(): string;
        isPrivate(): boolean;
        trySetAccessible(): boolean;
        getParameters(): Internal.ImmutableList<Internal.Parameter>;
        isStatic(): boolean;
        getDeclaredAnnotations(): Internal.Annotation[];
        getReturnType(): Internal.TypeToken<any>;
        static from(arg0: Internal.Method_): Internal.Invokable<any, any>;
        getAnnotationsByType(arg0: Internal.Class_<T>): T[];
        setAccessible(arg0: boolean): void;
        isPackagePrivate(): boolean;
        getDeclaredAnnotation(arg0: Internal.Class_<T>): T;
        isNative(): boolean;
        isAbstract(): boolean;
        toString(): string;
        isSynthetic(): boolean;
        static from(arg0: Internal.Constructor_<T>): Internal.Invokable<T, T>;
        isSynchronized(): boolean;
        getDeclaringClass(): Internal.Class<any>;
        invoke(arg0: T, ...arg1: any[]): R;
        hashCode(): number;
        isProtected(): boolean;
        getAnnotations(): Internal.Annotation[];
        isAnnotationPresent(arg0: Internal.Class_<any>): boolean;
        equals(arg0: any): boolean;
        getTypeParameters(): any[];
        returning(arg0: Internal.Class_<R1>): Internal.Invokable<T, R1>;
        isAccessible(): boolean;
        get final(): boolean
        get varArgs(): boolean
        get ownerType(): Internal.TypeToken<T>
        get modifiers(): number
        get exceptionTypes(): Internal.ImmutableList<Internal.TypeToken<any>>
        get annotatedReturnType(): Internal.AnnotatedType
        get overridable(): boolean
        get public(): boolean
        get name(): string
        get private(): boolean
        get parameters(): Internal.ImmutableList<Internal.Parameter>
        get static(): boolean
        get declaredAnnotations(): Internal.Annotation[]
        get returnType(): Internal.TypeToken<any>
        set accessible(arg0: boolean)
        get packagePrivate(): boolean
        get native(): boolean
        get abstract(): boolean
        get synthetic(): boolean
        get synchronized(): boolean
        get declaringClass(): Internal.Class<any>
        get protected(): boolean
        get annotations(): Internal.Annotation[]
        get typeParameters(): any[]
        get accessible(): boolean
    }
    type Invokable_<T, R> = Invokable<T, R>;
    class ReplaceSphereConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.BlockState_, arg1: Internal.BlockState_, arg2: Internal.IntProvider_)
        radius(): Internal.IntProvider;
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
        readonly "targetState": Internal.BlockState;
        readonly "replaceState": Internal.BlockState;
    }
    type ReplaceSphereConfiguration_ = ReplaceSphereConfiguration;
    class DeferredRegister <T> implements Internal.Iterable<Internal.RegistrySupplier<T>> {
        getRegistrar(): Internal.Registrar<T>;
        spliterator(): Internal.Spliterator<Internal.RegistrySupplier<T>>;
        register(id: ResourceLocation_, supplier: Internal.Supplier_<any>): Internal.RegistrySupplier<R>;
        register(): void;
        forEach(arg0: Internal.Consumer_<any>): void;
        iterator(): Internal.Iterator<Internal.RegistrySupplier<T>>;
        static create(modId: string, key: Internal.ResourceKey_<Internal.Registry_<T>>): Internal.DeferredRegister<T>;
        getRegistries(): Internal.Registries;
        register(id: string, supplier: Internal.Supplier_<any>): Internal.RegistrySupplier<R>;
        get registrar(): Internal.Registrar<T>
        get registries(): Internal.Registries
    }
    type DeferredRegister_<T> = DeferredRegister<T>;
    class VariantBlockStateGenerator {
        constructor()
        variant(key: string, model: string): void;
        variant(key: string, consumer: Internal.Consumer_<Internal.VariantBlockStateGenerator$Variant_>): void;
        toJson(): Internal.JsonObject;
    }
    type VariantBlockStateGenerator_ = VariantBlockStateGenerator;
    class ClientboundSetScorePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.ServerScoreboard$Method_, arg1: string, arg2: string, arg3: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getOwner(): string;
        getScore(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        getMethod(): Internal.ServerScoreboard$Method;
        getObjectiveName(): string;
        get owner(): string
        get score(): number
        get skippable(): boolean
        get method(): Internal.ServerScoreboard$Method
        get objectiveName(): string
    }
    type ClientboundSetScorePacket_ = ClientboundSetScorePacket;
    interface ColorResolver {
        getColor(arg0: Internal.Biome_, arg1: number, arg2: number): number;
    }
    type ColorResolver_ = ColorResolver | ((arg0: Internal.Biome, arg1: number, arg2: number)=>number);
    interface IForgeBlockState {
        getFlammability(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): number;
        onBlockExploded(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Explosion_): void;
        isPortalFrame(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        getExpDrop(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: number, arg3: number): number;
        canRedstoneConnectTo(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        getSoundType(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Entity_): Internal.SoundType;
        collisionExtendsVertically(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Entity_): boolean;
        isBed(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.LivingEntity_): boolean;
        canHarvestBlock(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        isConduitFrame(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_): boolean;
        setBedOccupied(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.LivingEntity_, arg3: boolean): void;
        getBlockPathType(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.BlockPathTypes;
        shouldCheckWeakPower(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        getStateAtViewpoint(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Vec3_): Internal.BlockState;
        isLadder(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.LivingEntity_): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.FluidState_): boolean;
        getToolModifiedState(arg0: Internal.UseOnContext_, arg1: Internal.ToolAction_, arg2: boolean): Internal.BlockState;
        getBedDirection(arg0: Internal.LevelReader_, arg1: BlockPos_): Internal.Direction;
        canSustainPlant(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_, arg3: Internal.IPlantable_): boolean;
        isSlimeBlock(): boolean;
        canStickTo(arg0: Internal.BlockState_): boolean;
        getBeaconColorMultiplier(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_): number[];
        addLandingEffects(arg0: Internal.ServerLevel_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.LivingEntity_, arg4: number): boolean;
        isFlammable(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        isFertile(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        onCaughtFire(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Direction_, arg3: Internal.LivingEntity_): void;
        onBlockStateChange(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.BlockState_): void;
        hidesNeighborFace(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.Direction_): boolean;
        canDropFromExplosion(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Explosion_): boolean;
        supportsExternalFaceHiding(): boolean;
        isScaffolding(arg0: Internal.LivingEntity_): boolean;
        getBlockPathType(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Mob_): Internal.BlockPathTypes;
        rotate(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: Internal.Rotation_): Internal.BlockState;
        onNeighborChange(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_): void;
        getEnchantPowerBonus(arg0: Internal.LevelReader_, arg1: BlockPos_): number;
        getToolModifiedState(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Player_, arg3: Internal.ItemStack_, arg4: Internal.ToolAction_): Internal.BlockState;
        isValidSpawn(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.SpawnPlacements$Type_, arg3: Internal.EntityType_<any>): boolean;
        isBurning(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        canEntityDestroy(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Entity_): boolean;
        getRespawnPosition(arg0: Internal.EntityType_<any>, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: number, arg4: Internal.LivingEntity_): Internal.Optional<Vec3>;
        getWeakChanges(arg0: Internal.LevelReader_, arg1: BlockPos_): boolean;
        addRunningEffects(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Entity_): boolean;
        getLightEmission(arg0: Internal.BlockGetter_, arg1: BlockPos_): number;
        isFireSource(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        getFriction(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Entity_): number;
        isStickyBlock(): boolean;
        onDestroyedByPlayer(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Player_, arg3: boolean, arg4: Internal.FluidState_): boolean;
        getCloneItemStack(arg0: Internal.HitResult_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Player_): Internal.ItemStack;
        getExplosionResistance(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Explosion_): number;
        getFireSpreadSpeed(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): number;
        get slimeBlock(): boolean
        get stickyBlock(): boolean
    }
    type IForgeBlockState_ = IForgeBlockState;
    class RenderChunkRegion implements Internal.BlockAndTintGetter {
        getBlockTint(arg0: BlockPos_, arg1: Internal.ColorResolver_): number;
        getMinSection(): number;
        getShade(arg0: Internal.Direction_, arg1: boolean): number;
        getBlockState(arg0: BlockPos_): Internal.BlockState;
        getSectionIndex(arg0: number): number;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        getMaxSection(): number;
        getBrightness(arg0: Internal.LightLayer_, arg1: BlockPos_): number;
        getMaxBuildHeight(): number;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getSectionYFromSectionIndex(arg0: number): number;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        getLightEngine(): Internal.LevelLightEngine;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        getHeight(): number;
        getBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        getRawBrightness(arg0: BlockPos_, arg1: number): number;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        canSeeSky(arg0: BlockPos_): boolean;
        isOutsideBuildHeight(arg0: number): boolean;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getFluidState(arg0: BlockPos_): Internal.FluidState;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        getSectionsCount(): number;
        getMinBuildHeight(): number;
        getSectionIndexFromSectionY(arg0: number): number;
        getMaxLightLevel(): number;
        get minSection(): number
        get maxSection(): number
        get maxBuildHeight(): number
        get lightEngine(): Internal.LevelLightEngine
        get height(): number
        get sectionsCount(): number
        get minBuildHeight(): number
        get maxLightLevel(): number
    }
    type RenderChunkRegion_ = RenderChunkRegion;
    interface ChannelHandlerContext extends Internal.ChannelOutboundInvoker, io.netty.util.AttributeMap, Internal.ChannelInboundInvoker {
        read(): this;
        handler(): Internal.ChannelHandler;
        pipeline(): Internal.ChannelPipeline;
        alloc(): Internal.ByteBufAllocator;
        executor(): Internal.EventExecutor;
        fireChannelReadComplete(): this;
        fireExceptionCaught(arg0: Internal.Throwable_): this;
        attr(arg0: Internal.AttributeKey_<T>): io.netty.util.Attribute<T>;
        flush(): this;
        fireChannelUnregistered(): this;
        channel(): io.netty.channel.Channel;
        name(): string;
        isRemoved(): boolean;
        fireChannelRead(arg0: any): this;
        fireUserEventTriggered(arg0: any): this;
        fireChannelRegistered(): this;
        fireChannelWritabilityChanged(): this;
        fireChannelInactive(): this;
        hasAttr(arg0: Internal.AttributeKey_<T>): boolean;
        fireChannelActive(): this;
        get removed(): boolean
    }
    type ChannelHandlerContext_ = ChannelHandlerContext;
    class TrunkVineDecorator extends Internal.TreeDecorator {
        constructor()
        place(arg0: Internal.LevelSimulatedReader_, arg1: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>, arg2: Internal.Random_, arg3: Internal.List_<BlockPos_>, arg4: Internal.List_<BlockPos_>): void;
        readonly static "CODEC": any;
        readonly static "INSTANCE": Internal.TrunkVineDecorator;
    }
    type TrunkVineDecorator_ = TrunkVineDecorator;
    interface PositionTracker {
        isVisibleBy(arg0: Internal.LivingEntity_): boolean;
        currentPosition(): Vec3;
        currentBlockPosition(): BlockPos;
    }
    type PositionTracker_ = PositionTracker;
    class SectionStorage <R> implements Internal.AutoCloseable {
        constructor(arg0: Internal.Path_, arg1: Internal.Function_<Internal.Runnable_, Internal.Codec_<R>>, arg2: Internal.Function_<Internal.Runnable_, R>, arg3: Internal.DataFixer_, arg4: any_, arg5: boolean, arg6: Internal.LevelHeightAccessor_)
        flush(arg0: Internal.ChunkPos_): void;
        close(): void;
        hasWork(): boolean;
    }
    type SectionStorage_<R> = SectionStorage<R>;
    class TextColor implements Internal.Color {
        toString(): string;
        getArgbJS(): number;
        specialEquals(o: any, shallow: boolean): boolean;
        static fromRgb(arg0: number): Internal.TextColor;
        getRgbJS(): number;
        getSerializeJS(): string;
        hashCode(): number;
        serialize(): string;
        static parseColor(arg0: string): Internal.TextColor;
        static fromLegacyFormat(arg0: Internal.ChatFormatting_): Internal.TextColor;
        createTextColorJS(): this;
        getValue(): number;
        getHexJS(): string;
        getFireworkColorJS(): number;
        equals(arg0: any): boolean;
        get argbJS(): number
        get rgbJS(): number
        get serializeJS(): string
        get value(): number
        get hexJS(): string
        get fireworkColorJS(): number
    }
    type TextColor_ = TextColor;
    class Locale$Category extends Internal.Enum<Internal.Locale$Category> {
        static valueOf(arg0: string): Internal.Locale$Category;
        static values(): Internal.Locale$Category[];
        readonly static "FORMAT": Internal.Locale$Category;
        readonly static "DISPLAY": Internal.Locale$Category;
    }
    type Locale$Category_ = Locale$Category | "display" | "format";
    class RenderLevelStageEvent$Stage {
        toString(): string;
        static fromRenderType(arg0: Internal.RenderType_): Internal.RenderLevelStageEvent$Stage;
        readonly static "AFTER_WEATHER": Internal.RenderLevelStageEvent$Stage;
        readonly static "AFTER_TRIPWIRE_BLOCKS": Internal.RenderLevelStageEvent$Stage;
        readonly static "AFTER_CUTOUT_MIPPED_BLOCKS_BLOCKS": Internal.RenderLevelStageEvent$Stage;
        readonly static "AFTER_CUTOUT_BLOCKS": Internal.RenderLevelStageEvent$Stage;
        readonly static "AFTER_SOLID_BLOCKS": Internal.RenderLevelStageEvent$Stage;
        readonly static "AFTER_TRANSLUCENT_BLOCKS": Internal.RenderLevelStageEvent$Stage;
        readonly static "AFTER_PARTICLES": Internal.RenderLevelStageEvent$Stage;
        readonly static "AFTER_SKY": Internal.RenderLevelStageEvent$Stage;
    }
    type RenderLevelStageEvent$Stage_ = RenderLevelStageEvent$Stage;
    class PlayerModelPart extends Internal.Enum<Internal.PlayerModelPart> {
        static valueOf(arg0: string): Internal.PlayerModelPart;
        getName(): Internal.Component;
        getBit(): number;
        static values(): Internal.PlayerModelPart[];
        getMask(): number;
        getId(): string;
        get name(): Internal.Component
        get bit(): number
        get mask(): number
        get id(): string
        readonly static "CAPE": Internal.PlayerModelPart;
        readonly static "LEFT_SLEEVE": Internal.PlayerModelPart;
        readonly static "RIGHT_PANTS_LEG": Internal.PlayerModelPart;
        readonly static "LEFT_PANTS_LEG": Internal.PlayerModelPart;
        readonly static "RIGHT_SLEEVE": Internal.PlayerModelPart;
        readonly static "JACKET": Internal.PlayerModelPart;
        readonly static "HAT": Internal.PlayerModelPart;
    }
    type PlayerModelPart_ = "jacket" | "hat" | "right_sleeve" | "cape" | "right_pants_leg" | "left_sleeve" | "left_pants_leg" | PlayerModelPart;
    class CustomBossEvent extends Internal.ServerBossEvent {
        constructor(arg0: ResourceLocation_, arg1: Internal.Component_)
        setValue(arg0: number): void;
        getDisplayName(): Internal.Component;
        save(): Internal.CompoundTag;
        setPlayers(arg0: Internal.Collection_<Internal.ServerPlayer_>): boolean;
        addOfflinePlayer(arg0: Internal.UUID_): void;
        removePlayer(arg0: Internal.ServerPlayer_): void;
        setMax(arg0: number): void;
        removeAllPlayers(): void;
        onPlayerDisconnect(arg0: Internal.ServerPlayer_): void;
        onPlayerConnect(arg0: Internal.ServerPlayer_): void;
        static load(arg0: Internal.CompoundTag_, arg1: ResourceLocation_): Internal.CustomBossEvent;
        getMax(): number;
        getTextId(): ResourceLocation;
        getValue(): number;
        addPlayer(arg0: Internal.ServerPlayer_): void;
        set value(arg0: number)
        get displayName(): Internal.Component
        set players(arg0: Internal.Collection_<Internal.ServerPlayer_>)
        set max(arg0: number)
        get max(): number
        get textId(): ResourceLocation
        get value(): number
    }
    type CustomBossEvent_ = CustomBossEvent;
    class ProbabilityFeatureConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: number)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "probability": number;
        readonly static "CODEC": any;
    }
    type ProbabilityFeatureConfiguration_ = ProbabilityFeatureConfiguration;
    class Package extends Internal.NamedPackage implements Internal.AnnotatedElement {
        getSpecificationVendor(): string;
        toString(): string;
        getSpecificationVersion(): string;
        static getPackage(arg0: string): Internal.Package;
        static getPackages(): Internal.Package[];
        isCompatibleWith(arg0: string): boolean;
        getAnnotation(arg0: Internal.Class_<A>): A;
        getImplementationVersion(): string;
        hashCode(): number;
        getImplementationVendor(): string;
        isSealed(arg0: Internal.URL_): boolean;
        getName(): string;
        getAnnotations(): Internal.Annotation[];
        isAnnotationPresent(arg0: Internal.Class_<any>): boolean;
        getDeclaredAnnotation(arg0: Internal.Class_<A>): A;
        getAnnotationsByType(arg0: Internal.Class_<A>): A[];
        getSpecificationTitle(): string;
        isSealed(): boolean;
        getDeclaredAnnotations(): Internal.Annotation[];
        getImplementationTitle(): string;
        getDeclaredAnnotationsByType(arg0: Internal.Class_<A>): A[];
        get specificationVendor(): string
        get specificationVersion(): string
        get packages(): Internal.Package[]
        get implementationVersion(): string
        get implementationVendor(): string
        get name(): string
        get annotations(): Internal.Annotation[]
        get specificationTitle(): string
        get sealed(): boolean
        get declaredAnnotations(): Internal.Annotation[]
        get implementationTitle(): string
    }
    type Package_ = Package;
    interface Float2LongFunction extends Internal.DoubleToLongFunction, it.unimi.dsi.fastutil.Function<number, number> {
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Float2ShortFunction;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2LongFunction;
        put(arg0: number, arg1: number): number;
        andThenObject(arg0: Internal.Long2ObjectFunction_<any>): Internal.Float2ObjectFunction<T>;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2LongFunction;
        getOrDefault(arg0: any, arg1: any): any;
        andThenLong(arg0: Internal.Long2LongFunction_): this;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2LongFunction;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Float2ByteFunction;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Float2DoubleFunction;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2LongFunction;
        get(arg0: any): number;
        containsKey(arg0: any): boolean;
        put(arg0: any, arg1: any): any;
        composeFloat(arg0: Internal.Float2FloatFunction_): this;
        containsKey(arg0: number): boolean;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2LongFunction;
        andThenReference(arg0: Internal.Long2ReferenceFunction_<any>): Internal.Float2ReferenceFunction<T>;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Float2CharFunction;
        defaultReturnValue(): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        getOrDefault(arg0: number, arg1: number): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        apply(arg0: number): number;
        applyAsLong(arg0: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Float2IntFunction;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2LongFunction;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Float2FloatFunction;
        size(): number;
        remove(arg0: number): number;
        get(arg0: number): number;
        clear(): void;
        composeObject(arg0: Internal.Object2FloatFunction_<any>): Internal.Object2LongFunction<T>;
        remove(arg0: any): any;
        composeReference(arg0: Internal.Reference2FloatFunction_<any>): Internal.Reference2LongFunction<T>;
        put(arg0: number, arg1: number): number;
        defaultReturnValue(arg0: number): void;
    }
    type Float2LongFunction_ = Float2LongFunction | ((arg0: number)=>number);
    interface RegistryObjectBuilderTypes$BuilderFactory <T> {
        createBuilder(arg0: ResourceLocation_): Internal.BuilderBase<any>;
    }
    type RegistryObjectBuilderTypes$BuilderFactory_<T> = RegistryObjectBuilderTypes$BuilderFactory<T>;
    abstract class ScreenEvent$KeyboardKeyPressedEvent extends Internal.ScreenEvent$KeyboardKeyEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number, arg3: number)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$KeyboardKeyPressedEvent_ = ScreenEvent$KeyboardKeyPressedEvent;
    class EntityHitResult extends Internal.HitResult {
        constructor(arg0: Internal.Entity_, arg1: Vec3_)
        constructor(arg0: Internal.Entity_)
        getEntity(): Internal.Entity;
        getType(): Internal.HitResult$Type;
        get entity(): Internal.Entity
        get type(): Internal.HitResult$Type
    }
    type EntityHitResult_ = EntityHitResult;
    class CompostablesRecipeEventJS extends Internal.EventJS {
        constructor()
        removeAll(): void;
        add(ingredient: Internal.IngredientJS_, f: number): void;
        remove(ingredient: Internal.IngredientJS_): void;
        static "originalMap": {[key: any]: 1.0, [key: any]: 0.5, [key: any]: 0.85, [key: any]: 0.65, [key: any]: 0.3, [key: Internal.Item]: 0.85, [key: any]: 0.65, [key: Internal.Item]: 0.65, [key: any]: 0.3, [key: any]: 0.65, [key: any]: 0.65, [key: any]: 0.65, [key: any]: 0.65, [key: any]: 0.65, [key: any]: 0.3, [key: any]: 0.65, [key: any]: 0.65, [key: any]: 0.65, [key: Internal.Item]: 0.65, [key: any]: 0.65, [key: any]: 0.3, [key: any]: 0.3, [key: any]: 0.65, [key: any]: 0.5, [key: any]: 0.5, [key: any]: 0.3, [key: any]: 0.3, [key: any]: 0.3, [key: any]: 0.65, [key: any]: 0.85, [key: any]: 0.85, [key: any]: 0.65, [key: Internal.Item]: 0.5, [key: any]: 0.65, [key: any]: 0.5, [key: any]: 0.65, [key: any]: 0.65, [key: any]: 0.3, [key: any]: 0.65, [key: any]: 0.65, [key: Internal.Item]: 0.85, [key: any]: 0.3, [key: any]: 0.65, [key: any]: 0.65, [key: any]: 0.3, [key: any]: 0.5, [key: any]: 0.65, [key: any]: 0.85, [key: any]: 0.65, [key: any]: 0.65, [key: any]: 0.85, [key: any]: 0.3, [key: any]: 0.65, [key: any]: 0.3, [key: any]: 0.3, [key: any]: 0.3, [key: any]: 0.3, [key: any]: 0.65, [key: any]: 0.5, [key: any]: 0.65, [key: any]: 0.65, [key: any]: 0.3, [key: any]: 0.65, [key: any]: 0.85, [key: any]: 0.65, [key: any]: 0.65, [key: any]: 0.3, [key: any]: 0.3, [key: any]: 0.65, [key: any]: 0.5, [key: any]: 0.65, [key: any]: 0.3, [key: any]: 0.65, [key: any]: 0.65, [key: Internal.Item]: 1.0, [key: any]: 0.3, [key: any]: 0.65, [key: Internal.Item]: 0.3, [key: any]: 0.5, [key: any]: 0.3, [key: any]: 0.65, [key: any]: 0.3, [key: Internal.Item]: 0.85, [key: any]: 0.5, [key: any]: 0.65, [key: any]: 0.5, [key: any]: 0.65, [key: any]: 0.65, [key: any]: 0.3, [key: Internal.Item]: 0.65, [key: any]: 0.3};
    }
    type CompostablesRecipeEventJS_ = CompostablesRecipeEventJS;
    class ClientboundAnimatePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.Entity_, arg1: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getAction(): number;
        isSkippable(): boolean;
        getId(): number;
        get action(): number
        get skippable(): boolean
        get id(): number
        readonly static "HURT": 1;
        readonly static "WAKE_UP": 2;
        readonly static "SWING_OFF_HAND": 3;
        readonly static "MAGIC_CRITICAL_HIT": 5;
        readonly static "SWING_MAIN_HAND": 0;
        readonly static "CRITICAL_HIT": 4;
    }
    type ClientboundAnimatePacket_ = ClientboundAnimatePacket;
    abstract class PlayerEventJS extends Internal.LivingEntityEventJS {
        constructor()
        getMinecraftPlayer(): Internal.Player;
        getPlayer(): Internal.PlayerJS<any>;
        removeGameStage(stage: string): void;
        addGameStage(stage: string): void;
        hasGameStage(stage: string): boolean;
        get minecraftPlayer(): Internal.Player
        get player(): Internal.PlayerJS<any>
    }
    type PlayerEventJS_ = PlayerEventJS;
    interface Consumer <T> {
        andThen(arg0: Internal.Consumer_<any>): this;
        accept(arg0: T): void;
    }
    type Consumer_<T> = ((arg0: T)=>void) | Consumer<T>;
    class GameEventListenerRegistrar {
        constructor(arg0: Internal.GameEventListener_)
        onListenerRemoved(arg0: Internal.Level_): void;
        onListenerMove(arg0: Internal.Level_): void;
    }
    type GameEventListenerRegistrar_ = GameEventListenerRegistrar;
    class DropperBlockEntity extends Internal.DispenserBlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        stopOpen(arg0: Internal.Player_): void;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getMaxStackSize(): number;
        countItem(arg0: Internal.Item_): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get modelData(): Internal.IModelData
        get maxStackSize(): number
        get renderBoundingBox(): Internal.AABB
    }
    type DropperBlockEntity_ = DropperBlockEntity;
    class DateTimeFormatter {
        static ofPattern(arg0: string, arg1: Internal.Locale_): Internal.DateTimeFormatter;
        withChronology(arg0: Internal.Chronology_): this;
        static parsedExcessDays(): Internal.TemporalQuery<Internal.Period>;
        parse(arg0: Internal.CharSequence_): Internal.TemporalAccessor;
        parse(arg0: Internal.CharSequence_, arg1: Internal.TemporalQuery_<T>): T;
        parse(arg0: Internal.CharSequence_, arg1: Internal.ParsePosition_): Internal.TemporalAccessor;
        localizedBy(arg0: Internal.Locale_): this;
        getZone(): Internal.ZoneId;
        parseBest(arg0: Internal.CharSequence_, ...arg1: Internal.TemporalQuery_<any>[]): Internal.TemporalAccessor;
        withResolverStyle(arg0: Internal.ResolverStyle_): this;
        toFormat(arg0: Internal.TemporalQuery_<any>): Internal.Format;
        static ofLocalizedDate(arg0: Internal.FormatStyle_): Internal.DateTimeFormatter;
        static parsedLeapSecond(): Internal.TemporalQuery<boolean>;
        formatTo(arg0: Internal.TemporalAccessor_, arg1: Internal.Appendable_): void;
        static ofLocalizedDateTime(arg0: Internal.FormatStyle_, arg1: Internal.FormatStyle_): Internal.DateTimeFormatter;
        withResolverFields(...arg0: Internal.TemporalField_[]): this;
        withDecimalStyle(arg0: Internal.DecimalStyle_): this;
        getChronology(): Internal.Chronology;
        toFormat(): Internal.Format;
        toString(): string;
        withResolverFields(arg0: Internal.Set_<Internal.TemporalField_>): this;
        withLocale(arg0: Internal.Locale_): this;
        getResolverStyle(): Internal.ResolverStyle;
        static ofLocalizedDateTime(arg0: Internal.FormatStyle_): Internal.DateTimeFormatter;
        static ofPattern(arg0: string): Internal.DateTimeFormatter;
        parseUnresolved(arg0: Internal.CharSequence_, arg1: Internal.ParsePosition_): Internal.TemporalAccessor;
        getResolverFields(): Internal.Set<Internal.TemporalField>;
        format(arg0: Internal.TemporalAccessor_): string;
        withZone(arg0: Internal.ZoneId_): this;
        getLocale(): Internal.Locale;
        getDecimalStyle(): Internal.DecimalStyle;
        static ofLocalizedTime(arg0: Internal.FormatStyle_): Internal.DateTimeFormatter;
        get zone(): Internal.ZoneId
        get chronology(): Internal.Chronology
        get resolverStyle(): Internal.ResolverStyle
        get resolverFields(): Internal.Set<Internal.TemporalField>
        get locale(): Internal.Locale
        get decimalStyle(): Internal.DecimalStyle
        readonly static "ISO_DATE": Internal.DateTimeFormatter;
        readonly static "ISO_WEEK_DATE": Internal.DateTimeFormatter;
        readonly static "ISO_OFFSET_DATE_TIME": Internal.DateTimeFormatter;
        readonly static "ISO_TIME": Internal.DateTimeFormatter;
        readonly static "ISO_ORDINAL_DATE": Internal.DateTimeFormatter;
        readonly static "ISO_OFFSET_TIME": Internal.DateTimeFormatter;
        readonly static "ISO_LOCAL_DATE_TIME": Internal.DateTimeFormatter;
        readonly static "ISO_OFFSET_DATE": Internal.DateTimeFormatter;
        readonly static "BASIC_ISO_DATE": Internal.DateTimeFormatter;
        readonly static "ISO_INSTANT": Internal.DateTimeFormatter;
        readonly static "ISO_LOCAL_DATE": Internal.DateTimeFormatter;
        readonly static "RFC_1123_DATE_TIME": Internal.DateTimeFormatter;
        readonly static "ISO_LOCAL_TIME": Internal.DateTimeFormatter;
        readonly static "ISO_DATE_TIME": Internal.DateTimeFormatter;
        readonly static "ISO_ZONED_DATE_TIME": Internal.DateTimeFormatter;
    }
    type DateTimeFormatter_ = DateTimeFormatter;
    class DirectionProperty extends Internal.EnumProperty<Internal.Direction> {
        static create(arg0: string, arg1: Internal.Collection_<Internal.Direction_>): Internal.DirectionProperty;
        static create(arg0: string, arg1: Internal.Predicate_<Internal.Direction_>): Internal.DirectionProperty;
        static create(arg0: string): Internal.DirectionProperty;
        static create(arg0: string, ...arg1: Internal.Direction_[]): Internal.DirectionProperty;
    }
    type DirectionProperty_ = DirectionProperty;
    class KeyPair implements Internal.Serializable {
        constructor(arg0: Internal.PublicKey_, arg1: Internal.PrivateKey_)
        getPublic(): Internal.PublicKey;
        getPrivate(): Internal.PrivateKey;
        get public(): Internal.PublicKey
        get private(): Internal.PrivateKey
    }
    type KeyPair_ = KeyPair;
    class Vex extends Internal.Monster {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        setLimitedLife(arg0: number): void;
        getBrightness(): number;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        setIsCharging(arg0: boolean): void;
        isCharging(): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        move(arg0: Internal.MoverType_, arg1: Vec3_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        setBoundOrigin(arg0: BlockPos_): void;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        getOwner(): Internal.Mob;
        getBoundOrigin(): BlockPos;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        setOwner(arg0: Internal.Mob_): void;
        isFlapping(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        set limitedLife(arg0: number)
        get brightness(): number
        get stepHeight(): number
        set isCharging(arg0: boolean)
        get charging(): boolean
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        set boundOrigin(arg0: BlockPos_)
        get owner(): Internal.Mob
        get boundOrigin(): BlockPos
        set owner(arg0: Internal.Mob_)
        get flapping(): boolean
        readonly static "TICKS_PER_FLAP": 4;
        readonly static "FLAP_DEGREES_PER_TICK": 45.836624;
    }
    type Vex_ = Vex;
    class DualNoiseProvider extends Internal.NoiseProvider {
        constructor(arg0: Internal.InclusiveRange_<number>, arg1: Internal.NormalNoise$NoiseParameters_, arg2: number, arg3: number, arg4: Internal.NormalNoise$NoiseParameters_, arg5: number, arg6: Internal.List_<Internal.BlockState_>)
        getState(arg0: Internal.Random_, arg1: BlockPos_): Internal.BlockState;
        readonly static "CODEC": any;
    }
    type DualNoiseProvider_ = DualNoiseProvider;
    class BooleanProperty extends Internal.Property<boolean> {
        getName(arg0: boolean): string;
        generateHashCode(): number;
        static create(arg0: string): Internal.BooleanProperty;
        getPossibleValues(): Internal.Collection<boolean>;
        getValue(arg0: string): Internal.Optional<boolean>;
        equals(arg0: any): boolean;
        getName(arg0: Internal.Comparable_<any>): string;
        get possibleValues(): Internal.Collection<boolean>
    }
    type BooleanProperty_ = BooleanProperty;
    class ForkingTrunkPlacer extends Internal.TrunkPlacer {
        constructor(arg0: number, arg1: number, arg2: number)
        placeTrunk(arg0: Internal.LevelSimulatedReader_, arg1: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>, arg2: Internal.Random_, arg3: number, arg4: BlockPos_, arg5: Internal.TreeConfiguration_): Internal.List<Internal.FoliagePlacer$FoliageAttachment>;
        readonly static "CODEC": any;
    }
    type ForkingTrunkPlacer_ = ForkingTrunkPlacer;
    class RenderHandEvent extends Internal.Event {
        constructor()
        constructor(arg0: Hand_, arg1: Internal.PoseStack_, arg2: Internal.MultiBufferSource_, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: Internal.ItemStack_)
        getPoseStack(): Internal.PoseStack;
        isCancelable(): boolean;
        getEquipProgress(): number;
        getListenerList(): Internal.ListenerList;
        getHand(): Hand;
        getPartialTicks(): number;
        getInterpolatedPitch(): number;
        getPackedLight(): number;
        getMultiBufferSource(): Internal.MultiBufferSource;
        getItemStack(): Internal.ItemStack;
        getSwingProgress(): number;
        get poseStack(): Internal.PoseStack
        get cancelable(): boolean
        get equipProgress(): number
        get listenerList(): Internal.ListenerList
        get hand(): Hand
        get partialTicks(): number
        get interpolatedPitch(): number
        get packedLight(): number
        get multiBufferSource(): Internal.MultiBufferSource
        get itemStack(): Internal.ItemStack
        get swingProgress(): number
    }
    type RenderHandEvent_ = RenderHandEvent;
    class BiomeDictionary$Type {
        toString(): string;
        static getType(arg0: string, ...arg1: Internal.BiomeDictionary$Type_[]): Internal.BiomeDictionary$Type;
        getName(): string;
        static getAll(): Internal.Collection<Internal.BiomeDictionary$Type>;
        static fromVanilla(arg0: Internal.Biome$BiomeCategory_): Internal.BiomeDictionary$Type;
        static hasType(arg0: string): boolean;
        get name(): string
        get all(): Internal.Collection<Internal.BiomeDictionary$Type>
        readonly static "SWAMP": Internal.BiomeDictionary$Type;
        readonly static "MOUNTAIN": Internal.BiomeDictionary$Type;
        readonly static "SNOWY": Internal.BiomeDictionary$Type;
        readonly static "DRY": Internal.BiomeDictionary$Type;
        readonly static "RIVER": Internal.BiomeDictionary$Type;
        readonly static "RARE": Internal.BiomeDictionary$Type;
        readonly static "SPARSE": Internal.BiomeDictionary$Type;
        readonly static "CONIFEROUS": Internal.BiomeDictionary$Type;
        readonly static "SANDY": Internal.BiomeDictionary$Type;
        readonly static "PEAK": Internal.BiomeDictionary$Type;
        readonly static "SAVANNA": Internal.BiomeDictionary$Type;
        readonly static "DENSE": Internal.BiomeDictionary$Type;
        readonly static "NETHER": Internal.BiomeDictionary$Type;
        readonly static "HILLS": Internal.BiomeDictionary$Type;
        readonly static "SPOOKY": Internal.BiomeDictionary$Type;
        readonly static "MODIFIED": Internal.BiomeDictionary$Type;
        readonly static "HOT": Internal.BiomeDictionary$Type;
        readonly static "WATER": Internal.BiomeDictionary$Type;
        readonly static "OVERWORLD": Internal.BiomeDictionary$Type;
        readonly static "WET": Internal.BiomeDictionary$Type;
        readonly static "JUNGLE": Internal.BiomeDictionary$Type;
        readonly static "PLAINS": Internal.BiomeDictionary$Type;
        readonly static "MAGICAL": Internal.BiomeDictionary$Type;
        readonly static "SLOPE": Internal.BiomeDictionary$Type;
        readonly static "VOID": Internal.BiomeDictionary$Type;
        readonly static "UNDERGROUND": Internal.BiomeDictionary$Type;
        readonly static "BEACH": Internal.BiomeDictionary$Type;
        readonly static "FOREST": Internal.BiomeDictionary$Type;
        readonly static "WASTELAND": Internal.BiomeDictionary$Type;
        readonly static "MUSHROOM": Internal.BiomeDictionary$Type;
        readonly static "END": Internal.BiomeDictionary$Type;
        readonly static "COLD": Internal.BiomeDictionary$Type;
        readonly static "OCEAN": Internal.BiomeDictionary$Type;
        readonly static "DEAD": Internal.BiomeDictionary$Type;
        readonly static "MESA": Internal.BiomeDictionary$Type;
        readonly static "LUSH": Internal.BiomeDictionary$Type;
        readonly static "PLATEAU": Internal.BiomeDictionary$Type;
    }
    type BiomeDictionary$Type_ = BiomeDictionary$Type;
    interface Watchable {
        register(arg0: Internal.WatchService_, ...arg1: Internal.WatchEvent$Kind_<any>[]): Internal.WatchKey;
        register(arg0: Internal.WatchService_, arg1: Internal.WatchEvent$Kind_<any>[], ...arg2: any_[]): Internal.WatchKey;
    }
    type Watchable_ = Watchable;
    class Cat extends Internal.TamableAnimal {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getRelaxStateOneAmount(arg0: number): number;
        customServerAiStep(): void;
        setCollarColor(arg0: Internal.DyeColor_): void;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        canMate(arg0: Internal.Animal_): boolean;
        getLieDownAmount(arg0: number): number;
        isSteppingCarefully(): boolean;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        setCatType(arg0: number): void;
        isFood(arg0: Internal.ItemStack_): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): this;
        isLying(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        getAmbientSoundInterval(): number;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        setRelaxStateOne(arg0: boolean): void;
        getResourceLocation(): ResourceLocation;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getClassification(arg0: boolean): Internal.MobCategory;
        getLieDownAmountTail(arg0: number): number;
        removeWhenFarAway(arg0: number): boolean;
        getCatType(): number;
        getCollarColor(): Internal.DyeColor;
        foodEatenKJS(is: Internal.ItemStack_): void;
        setLying(arg0: boolean): void;
        isRelaxStateOne(): boolean;
        hiss(): void;
        set collarColor(arg0: Internal.DyeColor_)
        get steppingCarefully(): boolean
        get stepHeight(): number
        set catType(arg0: number)
        get lying(): boolean
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get ambientSoundInterval(): number
        set relaxStateOne(arg0: boolean)
        get resourceLocation(): ResourceLocation
        get catType(): number
        get collarColor(): Internal.DyeColor
        set lying(arg0: boolean)
        get relaxStateOne(): boolean
        readonly static "TYPE_CALICO": 5;
        readonly static "TYPE_PERSIAN": 6;
        readonly static "TEMPT_SPEED_MOD": 0.6;
        readonly static "TYPE_SIAMESE": 3;
        readonly static "TYPE_ALL_BLACK": 10;
        readonly static "TYPE_TABBY": 0;
        readonly static "TYPE_WHITE": 8;
        readonly static "TYPE_BLACK": 1;
        readonly static "TYPE_JELLIE": 9;
        readonly static "TYPE_RED": 2;
        readonly static "TEXTURE_BY_TYPE": {0: ResourceLocation, 1: ResourceLocation, 2: ResourceLocation, 3: ResourceLocation, 4: ResourceLocation, 5: ResourceLocation, 6: ResourceLocation, 7: ResourceLocation, 8: ResourceLocation, 9: ResourceLocation, 10: ResourceLocation};
        readonly static "SPRINT_SPEED_MOD": 1.33;
        readonly static "TYPE_BRITISH": 4;
        readonly static "TYPE_RAGDOLL": 7;
        readonly static "WALK_SPEED_MOD": 0.8;
    }
    type Cat_ = Cat;
    interface TooltipComponent {
    }
    type TooltipComponent_ = TooltipComponent;
    interface BlockBuilderProvider {
        getBlockBuilderKJS(): Internal.BlockBuilder;
        get blockBuilderKJS(): Internal.BlockBuilder
    }
    type BlockBuilderProvider_ = BlockBuilderProvider;
    class Biome$Precipitation extends Internal.Enum<Internal.Biome$Precipitation> implements Internal.StringRepresentable {
        static byName(arg0: string): Internal.Biome$Precipitation;
        getSerializedName(): string;
        getName(): string;
        static valueOf(arg0: string): Internal.Biome$Precipitation;
        static values(): Internal.Biome$Precipitation[];
        get serializedName(): string
        get name(): string
        readonly static "RAIN": Internal.Biome$Precipitation;
        readonly static "NONE": Internal.Biome$Precipitation;
        readonly static "SNOW": Internal.Biome$Precipitation;
        readonly static "CODEC": any;
    }
    type Biome$Precipitation_ = "snow" | "rain" | Biome$Precipitation | "none";
    class LogicalSide extends Internal.Enum<Internal.LogicalSide> {
        isClient(): boolean;
        isServer(): boolean;
        static valueOf(arg0: string): Internal.LogicalSide;
        static values(): Internal.LogicalSide[];
        get client(): boolean
        get server(): boolean
        readonly static "CLIENT": Internal.LogicalSide;
        readonly static "SERVER": Internal.LogicalSide;
    }
    type LogicalSide_ = "server" | "client" | LogicalSide;
    class ExplosionDamageCalculator {
        constructor()
        shouldBlockExplode(arg0: Internal.Explosion_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: number): boolean;
        getBlockExplosionResistance(arg0: Internal.Explosion_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: Internal.FluidState_): Internal.Optional<number>;
    }
    type ExplosionDamageCalculator_ = ExplosionDamageCalculator;
    class WeighedSoundEvents implements Internal.Weighted<Internal.Sound> {
        constructor(arg0: ResourceLocation_, arg1: string)
        getSound(): any;
        addSound(arg0: Internal.Weighted_<Internal.Sound_>): void;
        getWeight(): number;
        preloadIfRequired(arg0: Internal.SoundEngine_): void;
        getResourceLocation(): ResourceLocation;
        getSubtitle(): Internal.Component;
        get sound(): any
        get weight(): number
        get resourceLocation(): ResourceLocation
        get subtitle(): Internal.Component
    }
    type WeighedSoundEvents_ = WeighedSoundEvents;
    interface AnnotatedType extends Internal.AnnotatedElement {
        getAnnotationsByType(arg0: Internal.Class_<T>): T[];
        getDeclaredAnnotation(arg0: Internal.Class_<T>): T;
        getAnnotatedOwnerType(): this;
        getDeclaredAnnotationsByType(arg0: Internal.Class_<T>): T[];
        getAnnotation(arg0: Internal.Class_<T>): T;
        getAnnotations(): Internal.Annotation[];
        isAnnotationPresent(arg0: Internal.Class_<any>): boolean;
        getType(): Internal.Type;
        getDeclaredAnnotations(): Internal.Annotation[];
        get annotatedOwnerType(): Internal.AnnotatedType
        get annotations(): Internal.Annotation[]
        get type(): Internal.Type
        get declaredAnnotations(): Internal.Annotation[]
    }
    type AnnotatedType_ = AnnotatedType;
    class WrapFactory {
        constructor()
        isJavaPrimitiveWrap(): boolean;
        setJavaPrimitiveWrap(value: boolean): void;
        wrap(data: Internal.SharedContextData_, scope: Internal.Scriptable_, obj: any, staticType: Internal.Class_<any>): any;
        wrapNewObject(data: Internal.SharedContextData_, scope: Internal.Scriptable_, obj: any): Internal.Scriptable;
        wrapJavaClass(data: Internal.SharedContextData_, scope: Internal.Scriptable_, javaClass: Internal.Class_<any>): Internal.Scriptable;
        wrapAsJavaObject(data: Internal.SharedContextData_, scope: Internal.Scriptable_, javaObject: any, staticType: Internal.Class_<any>): Internal.Scriptable;
        get javaPrimitiveWrap(): boolean
        set javaPrimitiveWrap(value: boolean)
    }
    type WrapFactory_ = WrapFactory;
    interface Chronology extends Internal.Comparable<Internal.Chronology> {
        dateNow(arg0: Internal.ZoneId_): Internal.ChronoLocalDate;
        eras(): Internal.List<Internal.Era>;
        from(arg0: Internal.TemporalAccessor_): this;
        compareTo(arg0: any): number;
        resolveDate(arg0: Internal.Map_<Internal.TemporalField_, number>, arg1: Internal.ResolverStyle_): Internal.ChronoLocalDate;
        dateNow(arg0: Internal.Clock_): Internal.ChronoLocalDate;
        getCalendarType(): string;
        compareTo(arg0: Internal.Chronology_): number;
        of(arg0: string): this;
        date(arg0: number, arg1: number, arg2: number): Internal.ChronoLocalDate;
        range(arg0: Internal.ChronoField_): Internal.ValueRange;
        prolepticYear(arg0: Internal.Era_, arg1: number): number;
        eraOf(arg0: number): Internal.Era;
        period(arg0: number, arg1: number, arg2: number): Internal.ChronoPeriod;
        toString(): string;
        epochSecond(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.ZoneOffset_): number;
        getAvailableChronologies(): Internal.Set<Internal.Chronology>;
        localDateTime(arg0: Internal.TemporalAccessor_): Internal.ChronoLocalDateTime<any>;
        zonedDateTime(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.ChronoZonedDateTime<any>;
        getId(): string;
        dateYearDay(arg0: Internal.Era_, arg1: number, arg2: number): Internal.ChronoLocalDate;
        isLeapYear(arg0: number): boolean;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        date(arg0: Internal.TemporalAccessor_): Internal.ChronoLocalDate;
        zonedDateTime(arg0: Internal.TemporalAccessor_): Internal.ChronoZonedDateTime<any>;
        hashCode(): number;
        dateEpochDay(arg0: number): Internal.ChronoLocalDate;
        dateYearDay(arg0: number, arg1: number): Internal.ChronoLocalDate;
        date(arg0: Internal.Era_, arg1: number, arg2: number, arg3: number): Internal.ChronoLocalDate;
        epochSecond(arg0: Internal.Era_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneOffset_): number;
        equals(arg0: any): boolean;
        ofLocale(arg0: Internal.Locale_): this;
        dateNow(): Internal.ChronoLocalDate;
        get calendarType(): string
        get availableChronologies(): Internal.Set<Internal.Chronology>
        get id(): string
    }
    type Chronology_ = Chronology;
    interface VillagerTrades$ItemListing {
        getOffer(arg0: Internal.Entity_, arg1: Internal.Random_): Internal.MerchantOffer;
    }
    type VillagerTrades$ItemListing_ = VillagerTrades$ItemListing;
    class InputConstants$Type extends Internal.Enum<Internal.InputConstants$Type> {
        getOrCreate(arg0: number): Internal.InputConstants$Key;
        static valueOf(arg0: string): Internal.InputConstants$Type;
        static values(): Internal.InputConstants$Type[];
        readonly static "KEYSYM": Internal.InputConstants$Type;
        readonly static "MOUSE": Internal.InputConstants$Type;
        readonly static "SCANCODE": Internal.InputConstants$Type;
    }
    type InputConstants$Type_ = "keysym" | "mouse" | InputConstants$Type | "scancode";
    interface RunningGame {
        getPerformanceMetrics(): Internal.PerformanceMetrics;
        setSessionEventListener(arg0: Internal.SessionEventListener_): void;
        getSelectedLanguage(): com.mojang.bridge.game.Language;
        getCurrentSession(): Internal.GameSession;
        getVersion(): Internal.GameVersion;
        get performanceMetrics(): Internal.PerformanceMetrics
        set sessionEventListener(arg0: Internal.SessionEventListener_)
        get selectedLanguage(): com.mojang.bridge.game.Language
        get currentSession(): Internal.GameSession
        get version(): Internal.GameVersion
    }
    type RunningGame_ = RunningGame;
    interface IntCollection extends Internal.IntIterable, Internal.Collection<number> {
        stream(): Internal.Stream<number>;
        forEach(arg0: Internal.Consumer_<any>): void;
        add(arg0: number): boolean;
        contains(arg0: number): boolean;
        toIntArray(): number[];
        forEach(arg0: Internal.IntConsumer_): void;
        intStream(): Internal.IntStream;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        toArray(arg0: number[]): number[];
        intParallelStream(): Internal.IntStream;
        removeAll(arg0: Internal.IntCollection_): boolean;
        intIterator(): Internal.IntIterator;
        contains(arg0: any): boolean;
        iterator(): Internal.IntIterator;
        removeIf(arg0: Internal.IntPredicate_): boolean;
        addAll(arg0: Internal.IntCollection_): boolean;
        retainAll(arg0: Internal.IntCollection_): boolean;
        forEach(arg0: it.unimi.dsi.fastutil.ints.IntConsumer_): void;
        add(arg0: number): boolean;
        toIntArray(arg0: number[]): number[];
        parallelStream(): Internal.Stream<number>;
        containsAll(arg0: Internal.IntCollection_): boolean;
        remove(arg0: any): boolean;
        removeIf(arg0: it.unimi.dsi.fastutil.ints.IntPredicate_): boolean;
        intSpliterator(): Internal.IntSpliterator;
        add(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        spliterator(): Internal.Spliterator<any>;
        rem(arg0: number): boolean;
    }
    type IntCollection_ = IntCollection;
    class AddLakeProperties {
        constructor()
        setInner(p: BlockStatePredicate_): void;
        setOuter(p: BlockStatePredicate_): void;
        set inner(p: BlockStatePredicate_)
        set outer(p: BlockStatePredicate_)
        "retrogen": number;
        "barrier": BlockStatePredicate;
        "worldgenLayer": DecorationGenerationStep;
        "chance": number;
        "biomes": Internal.BiomeFilter;
        "id": ResourceLocation;
        "fluid": BlockStatePredicate;
    }
    type AddLakeProperties_ = AddLakeProperties;
    class BlastFurnaceBlockEntity extends Internal.AbstractFurnaceBlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        stopOpen(arg0: Internal.Player_): void;
        setRecipeUsed(arg0: Internal.Level_, arg1: Internal.ServerPlayer_, arg2: Internal.Recipe_<any>): boolean;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getMaxStackSize(): number;
        countItem(arg0: Internal.Item_): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        startOpen(arg0: Internal.Player_): void;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get modelData(): Internal.IModelData
        get maxStackSize(): number
        get renderBoundingBox(): Internal.AABB
    }
    type BlastFurnaceBlockEntity_ = BlastFurnaceBlockEntity;
    class BlobFoliagePlacer extends Internal.FoliagePlacer {
        constructor(arg0: Internal.IntProvider_, arg1: Internal.IntProvider_, arg2: number)
        foliageHeight(arg0: Internal.Random_, arg1: number, arg2: Internal.TreeConfiguration_): number;
        readonly static "CODEC": any;
    }
    type BlobFoliagePlacer_ = BlobFoliagePlacer;
    class TagKey <T> extends Internal.Record {
        constructor(arg0: Internal.ResourceKey_<any>, arg1: ResourceLocation_)
        static create(arg0: Internal.ResourceKey_<any>, arg1: ResourceLocation_): Internal.TagKey<T>;
        hashCode(): number;
        registry(): Internal.ResourceKey<any>;
        toString(): string;
        cast(arg0: Internal.ResourceKey_<any>): Internal.Optional<Internal.TagKey<E>>;
        location(): ResourceLocation;
        equals(arg0: any): boolean;
        static codec(arg0: Internal.ResourceKey_<any>): Internal.Codec<Internal.TagKey<T>>;
        isFor(arg0: Internal.ResourceKey_<any>): boolean;
        static hashedCodec(arg0: Internal.ResourceKey_<any>): Internal.Codec<Internal.TagKey<T>>;
    }
    type TagKey_<T> = TagKey<T>;
    class WorldEvent$Load extends Internal.WorldEvent {
        constructor()
        constructor(arg0: Internal.LevelAccessor_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type WorldEvent$Load_ = WorldEvent$Load;
    interface IntIterator extends Internal.PrimitiveIterator$OfInt {
        forEachRemaining(arg0: any): void;
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): any;
        skip(arg0: number): number;
        forEachRemaining(arg0: it.unimi.dsi.fastutil.ints.IntConsumer_): void;
        forEachRemaining(arg0: Internal.IntConsumer_): void;
        nextInt(): number;
    }
    type IntIterator_ = IntIterator;
    class TypeWrappers {
        constructor()
        register(target: Internal.Class_<T>, validator: Internal.Predicate_<any>, factory: Internal.TypeWrapperFactory_<T>): void;
        register(id: string, from: Internal.Class_<F>, to: Internal.Class_<T>, factory: Internal.Function_<F, T>): void;
        register(target: Internal.Class_<T>, factory: Internal.TypeWrapperFactory_<T>): void;
        getWrapperFactory(target: Internal.Class_<any>, from: any): Internal.TypeWrapperFactory<any>;
    }
    type TypeWrappers_ = TypeWrappers;
    class AxolotlAttackablesSensor extends Internal.NearestVisibleLivingEntitySensor {
        constructor()
        readonly static "TARGET_DETECTION_DISTANCE": 8.0;
    }
    type AxolotlAttackablesSensor_ = AxolotlAttackablesSensor;
    class DataResult <R> implements Internal.App<Internal.DataResult$Mu, R> {
        get(): Internal.Either<R, Internal.DataResult$PartialResult<R>>;
        addLifecycle(arg0: Internal.Lifecycle_): this;
        static success(arg0: R): Internal.DataResult<R>;
        static error(arg0: string, arg1: R): Internal.DataResult<R>;
        error(): Internal.Optional<Internal.DataResult$PartialResult<R>>;
        map(arg0: Internal.Function_<any, any>): Internal.DataResult<T>;
        static instance(): Internal.DataResult$Instance;
        setPartial(arg0: Internal.Supplier_<R>): this;
        static error(arg0: string, arg1: Internal.Lifecycle_): Internal.DataResult<R>;
        result(): Internal.Optional<R>;
        static partialGet(arg0: Internal.Function_<K, V>, arg1: Internal.Supplier_<string>): Internal.Function<K, Internal.DataResult<V>>;
        apply2stable(arg0: Internal.BiFunction_<R, R2, S>, arg1: Internal.DataResult_<R2>): Internal.DataResult<S>;
        static unbox(arg0: Internal.App_<Internal.DataResult$Mu_, R>): Internal.DataResult<R>;
        toString(): string;
        ap(arg0: Internal.DataResult_<Internal.Function_<R, R2>>): Internal.DataResult<R2>;
        static success(arg0: R, arg1: Internal.Lifecycle_): Internal.DataResult<R>;
        mapError(arg0: Internal.UnaryOperator_<string>): this;
        lifecycle(): Internal.Lifecycle;
        setPartial(arg0: R): this;
        static error(arg0: string, arg1: R, arg2: Internal.Lifecycle_): Internal.DataResult<R>;
        hashCode(): number;
        setLifecycle(arg0: Internal.Lifecycle_): this;
        resultOrPartial(arg0: Internal.Consumer_<string>): Internal.Optional<R>;
        apply3(arg0: Internal.Function3_<R, R2, R3, S>, arg1: Internal.DataResult_<R2>, arg2: Internal.DataResult_<R3>): Internal.DataResult<S>;
        static error(arg0: string): Internal.DataResult<R>;
        apply2(arg0: Internal.BiFunction_<R, R2, S>, arg1: Internal.DataResult_<R2>): Internal.DataResult<S>;
        flatMap(arg0: Internal.Function_<any, any>): Internal.DataResult<R2>;
        equals(arg0: any): boolean;
        getOrThrow(arg0: boolean, arg1: Internal.Consumer_<string>): R;
        promotePartial(arg0: Internal.Consumer_<string>): this;
        set partial(arg0: Internal.Supplier_<R>)
        set partial(arg0: R)
        set lifecycle(arg0: Internal.Lifecycle_)
    }
    type DataResult_<R> = DataResult<R>;
    class SurfaceRelativeThresholdFilter extends Internal.PlacementFilter {
        type(): Internal.PlacementModifierType<any>;
        static of(arg0: Internal.Heightmap$Types_, arg1: number, arg2: number): Internal.SurfaceRelativeThresholdFilter;
        readonly static "CODEC": any;
    }
    type SurfaceRelativeThresholdFilter_ = SurfaceRelativeThresholdFilter;
    class ShulkerBoxBlockEntity$AnimationStatus extends Internal.Enum<Internal.ShulkerBoxBlockEntity$AnimationStatus> {
        static valueOf(arg0: string): Internal.ShulkerBoxBlockEntity$AnimationStatus;
        static values(): Internal.ShulkerBoxBlockEntity$AnimationStatus[];
        readonly static "OPENING": Internal.ShulkerBoxBlockEntity$AnimationStatus;
        readonly static "CLOSED": Internal.ShulkerBoxBlockEntity$AnimationStatus;
        readonly static "CLOSING": Internal.ShulkerBoxBlockEntity$AnimationStatus;
        readonly static "OPENED": Internal.ShulkerBoxBlockEntity$AnimationStatus;
    }
    type ShulkerBoxBlockEntity$AnimationStatus_ = "opening" | ShulkerBoxBlockEntity$AnimationStatus | "closing" | "closed" | "opened";
    class RenderLevelLastEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.LevelRenderer_, arg1: Internal.PoseStack_, arg2: number, arg3: Internal.Matrix4f_, arg4: number)
        getPartialTick(): number;
        getPoseStack(): Internal.PoseStack;
        getProjectionMatrix(): Internal.Matrix4f;
        getStartNanos(): number;
        getListenerList(): Internal.ListenerList;
        getLevelRenderer(): Internal.LevelRenderer;
        get partialTick(): number
        get poseStack(): Internal.PoseStack
        get projectionMatrix(): Internal.Matrix4f
        get startNanos(): number
        get listenerList(): Internal.ListenerList
        get levelRenderer(): Internal.LevelRenderer
    }
    type RenderLevelLastEvent_ = RenderLevelLastEvent;
    class ConstantInt extends Internal.IntProvider {
        getMinValue(): number;
        getType(): Internal.IntProviderType<any>;
        toString(): string;
        getMaxValue(): number;
        static of(arg0: number): Internal.ConstantInt;
        sample(arg0: Internal.Random_): number;
        getValue(): number;
        get minValue(): number
        get type(): Internal.IntProviderType<any>
        get maxValue(): number
        get value(): number
        readonly static "ZERO": Internal.ConstantInt;
        readonly static "CODEC": any;
    }
    type ConstantInt_ = ConstantInt;
    interface HeightProviderType <P> {
        codec(): Internal.Codec<P>;
        readonly static "UNIFORM": any;
        readonly static "CONSTANT": any;
        readonly static "WEIGHTED_LIST": any;
        readonly static "VERY_BIASED_TO_BOTTOM": any;
        readonly static "TRAPEZOID": any;
        readonly static "BIASED_TO_BOTTOM": any;
    }
    type HeightProviderType_<P> = Special.HeightProviderType | HeightProviderType<P>;
    class MinecartTNT extends Internal.AbstractMinecart {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        shouldBlockExplode(arg0: Internal.Explosion_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: number): boolean;
        isPoweredCart(): boolean;
        activateMinecart(arg0: number, arg1: number, arg2: number, arg3: boolean): void;
        getCurrentRailPosition(): BlockPos;
        getMaxCartSpeedOnRail(): number;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        getSlopeAdjustment(): number;
        shouldDoRailFunctions(): boolean;
        canRiderInteract(): boolean;
        destroy(arg0: Internal.DamageSource_): void;
        isMultipartEntity(): boolean;
        canBeRidden(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        getDefaultDisplayBlockState(): Internal.BlockState;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getBlockExplosionResistance(arg0: Internal.Explosion_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: Internal.FluidState_, arg5: number): number;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        primeFuse(): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getCartItem(): Internal.ItemStack;
        isPrimed(): boolean;
        tick(): void;
        getFuse(): number;
        getMinecartType(): Internal.AbstractMinecart$Type;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getComparatorLevel(): number;
        get poweredCart(): boolean
        get currentRailPosition(): BlockPos
        get maxCartSpeedOnRail(): number
        get stepHeight(): number
        get slopeAdjustment(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get defaultDisplayBlockState(): Internal.BlockState
        get cartItem(): Internal.ItemStack
        get primed(): boolean
        get fuse(): number
        get minecartType(): Internal.AbstractMinecart$Type
        get comparatorLevel(): number
    }
    type MinecartTNT_ = MinecartTNT;
    abstract class FoliagePlacer {
        constructor(arg0: Internal.IntProvider_, arg1: Internal.IntProvider_)
        foliageRadius(arg0: Internal.Random_, arg1: number): number;
        createFoliage(arg0: Internal.LevelSimulatedReader_, arg1: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>, arg2: Internal.Random_, arg3: Internal.TreeConfiguration_, arg4: number, arg5: Internal.FoliagePlacer$FoliageAttachment_, arg6: number, arg7: number): void;
        foliageHeight(arg0: Internal.Random_, arg1: number, arg2: Internal.TreeConfiguration_): number;
        readonly static "CODEC": any;
    }
    type FoliagePlacer_ = FoliagePlacer;
    interface AmbiguityConsumer <S> {
        ambiguous(arg0: Internal.CommandNode_<S>, arg1: Internal.CommandNode_<S>, arg2: Internal.CommandNode_<S>, arg3: Internal.Collection_<string>): void;
    }
    type AmbiguityConsumer_<S> = AmbiguityConsumer<S> | ((arg0: Internal.CommandNode<S>, arg1: Internal.CommandNode<S>, arg2: Internal.CommandNode<S>, arg3: Internal.Collection<string>)=>void);
    interface TimerCallback <T> {
        handle(arg0: T, arg1: Internal.TimerQueue_<T>, arg2: number): void;
    }
    type TimerCallback_<T> = TimerCallback<T> | ((arg0: T, arg1: Internal.TimerQueue<T>, arg2: number)=>void);
    class StonePressurePlateBlockBuilder extends Internal.ShapedBlockBuilder {
        constructor(i: ResourceLocation_)
        createObject(): any;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
    }
    type StonePressurePlateBlockBuilder_ = StonePressurePlateBlockBuilder;
    abstract class StructurePoolElement {
        static legacy(arg0: string, arg1: Internal.Holder_<Internal.StructureProcessorList_>): Internal.Function<Internal.StructureTemplatePool$Projection, Internal.LegacySinglePoolElement>;
        getType(): Internal.StructurePoolElementType<any>;
        getSize(arg0: Internal.StructureManager_, arg1: Internal.Rotation_): Vec3i;
        getShuffledJigsawBlocks(arg0: Internal.StructureManager_, arg1: BlockPos_, arg2: Internal.Rotation_, arg3: Internal.Random_): Internal.List<Internal.StructureTemplate$StructureBlockInfo>;
        static single(arg0: string): Internal.Function<Internal.StructureTemplatePool$Projection, Internal.SinglePoolElement>;
        getBoundingBox(arg0: Internal.StructureManager_, arg1: BlockPos_, arg2: Internal.Rotation_): Internal.BoundingBox;
        getGroundLevelDelta(): number;
        handleDataMarker(arg0: Internal.LevelAccessor_, arg1: Internal.StructureTemplate$StructureBlockInfo_, arg2: BlockPos_, arg3: Internal.Rotation_, arg4: Internal.Random_, arg5: Internal.BoundingBox_): void;
        setProjection(arg0: Internal.StructureTemplatePool$Projection_): this;
        place(arg0: Internal.StructureManager_, arg1: Internal.WorldGenLevel_, arg2: Internal.StructureFeatureManager_, arg3: Internal.ChunkGenerator_, arg4: BlockPos_, arg5: BlockPos_, arg6: Internal.Rotation_, arg7: Internal.BoundingBox_, arg8: Internal.Random_, arg9: boolean): boolean;
        static legacy(arg0: string): Internal.Function<Internal.StructureTemplatePool$Projection, Internal.LegacySinglePoolElement>;
        static list(arg0: Internal.List_<Internal.Function_<Internal.StructureTemplatePool$Projection_, any>>): Internal.Function<Internal.StructureTemplatePool$Projection, Internal.ListPoolElement>;
        getProjection(): Internal.StructureTemplatePool$Projection;
        static empty(): Internal.Function<Internal.StructureTemplatePool$Projection, Internal.EmptyPoolElement>;
        static single(arg0: string, arg1: Internal.Holder_<Internal.StructureProcessorList_>): Internal.Function<Internal.StructureTemplatePool$Projection, Internal.SinglePoolElement>;
        static feature(arg0: Internal.Holder_<Internal.PlacedFeature_>): Internal.Function<Internal.StructureTemplatePool$Projection, Internal.FeaturePoolElement>;
        get type(): Internal.StructurePoolElementType<any>
        get groundLevelDelta(): number
        set projection(arg0: Internal.StructureTemplatePool$Projection_)
        get projection(): Internal.StructureTemplatePool$Projection
        readonly static "CODEC": any;
    }
    type StructurePoolElement_ = StructurePoolElement;
    interface ItemColor {
        getColor(arg0: Internal.ItemStack_, arg1: number): number;
    }
    type ItemColor_ = ItemColor;
    interface ScheduledFuture <V> extends Internal.Delayed, Internal.Future<V> {
    }
    type ScheduledFuture_<V> = ScheduledFuture<V>;
    class ClientboundSetChunkCacheCenterPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getX(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getZ(): number;
        isSkippable(): boolean;
        get x(): number
        get z(): number
        get skippable(): boolean
    }
    type ClientboundSetChunkCacheCenterPacket_ = ClientboundSetChunkCacheCenterPacket;
    class Inventory implements Internal.Container, Internal.Nameable {
        constructor(arg0: Internal.Player_)
        stopOpen(arg0: Internal.Player_): void;
        removeFromSelected(arg0: boolean): Internal.ItemStack;
        getSlotWithRemainingSpace(arg0: Internal.ItemStack_): number;
        add(arg0: number, arg1: Internal.ItemStack_): boolean;
        static getSelectionSize(): number;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        add(arg0: Internal.ItemStack_): boolean;
        removeItem(arg0: number, arg1: number): Internal.ItemStack;
        dropAll(): void;
        placeItemBackInInventory(arg0: Internal.ItemStack_): void;
        setChanged(): void;
        contains(arg0: Internal.TagKey_<Internal.Item_>): boolean;
        setPickedItem(arg0: Internal.ItemStack_): void;
        getContainerSize(): number;
        swapPaint(arg0: number): void;
        setItem(arg0: number, arg1: Internal.ItemStack_): void;
        replaceWith(arg0: Internal.Inventory_): void;
        getSuitableHotbarSlot(): number;
        getName(): Internal.Component;
        findSlotMatchingItem(arg0: Internal.ItemStack_): number;
        load(arg0: Internal.ListTag_): void;
        getMaxStackSize(): number;
        getArmor(arg0: number): Internal.ItemStack;
        removeItemNoUpdate(arg0: number): Internal.ItemStack;
        getDestroySpeed(arg0: Internal.BlockState_): number;
        hasCustomName(): boolean;
        tick(): void;
        removeItem(arg0: Internal.ItemStack_): void;
        getItem(arg0: number): Internal.ItemStack;
        getSelected(): Internal.ItemStack;
        getCustomName(): Internal.Component;
        getDisplayName(): Internal.Component;
        countItem(arg0: Internal.Item_): number;
        isEmpty(): boolean;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        clearOrCountMatchingItems(arg0: Internal.Predicate_<Internal.ItemStack_>, arg1: number, arg2: Internal.Container_): number;
        hurtArmor(arg0: Internal.DamageSource_, arg1: number, arg2: number[]): void;
        save(arg0: Internal.ListTag_): Internal.ListTag;
        fillStackedContents(arg0: Internal.StackedContents_): void;
        stillValid(arg0: Internal.Player_): boolean;
        getTimesChanged(): number;
        static isHotbarSlot(arg0: number): boolean;
        placeItemBackInInventory(arg0: Internal.ItemStack_, arg1: boolean): void;
        contains(arg0: Internal.ItemStack_): boolean;
        pickSlot(arg0: number): void;
        clearContent(): void;
        findSlotMatchingUnusedItem(arg0: Internal.ItemStack_): number;
        getFreeSlot(): number;
        get selectionSize(): number
        set pickedItem(arg0: Internal.ItemStack_)
        get containerSize(): number
        get suitableHotbarSlot(): number
        get name(): Internal.Component
        get maxStackSize(): number
        get selected(): Internal.ItemStack
        get customName(): Internal.Component
        get displayName(): Internal.Component
        get empty(): boolean
        get timesChanged(): number
        get freeSlot(): number
        readonly "armor": Internal.NonNullList<Internal.ItemStack>;
        readonly "player": Internal.Player;
        readonly static "INVENTORY_SIZE": 36;
        readonly static "SLOT_OFFHAND": 40;
        readonly "offhand": Internal.NonNullList<Internal.ItemStack>;
        readonly static "NOT_FOUND_INDEX": -1;
        readonly static "ALL_ARMOR_SLOTS": any;
        readonly static "HELMET_SLOT_ONLY": any;
        "selected": number;
        readonly static "POP_TIME_DURATION": 5;
        readonly "items": Internal.NonNullList<Internal.ItemStack>;
    }
    type Inventory_ = Inventory;
    class Player$BedSleepingProblem extends Internal.Enum<Internal.Player$BedSleepingProblem> {
        static values(): Internal.Player$BedSleepingProblem[];
        getMessage(): Internal.Component;
        static valueOf(arg0: string): Internal.Player$BedSleepingProblem;
        get message(): Internal.Component
        readonly static "NOT_POSSIBLE_HERE": Internal.Player$BedSleepingProblem;
        readonly static "OTHER_PROBLEM": Internal.Player$BedSleepingProblem;
        readonly static "NOT_SAFE": Internal.Player$BedSleepingProblem;
        readonly static "NOT_POSSIBLE_NOW": Internal.Player$BedSleepingProblem;
        readonly static "OBSTRUCTED": Internal.Player$BedSleepingProblem;
        readonly static "TOO_FAR_AWAY": Internal.Player$BedSleepingProblem;
    }
    type Player$BedSleepingProblem_ = "obstructed" | "too_far_away" | Player$BedSleepingProblem | "not_possible_here" | "not_possible_now" | "not_safe" | "other_problem";
    class Biome$BiomeCategory extends Internal.Enum<Internal.Biome$BiomeCategory> implements Internal.StringRepresentable {
        static values(): Internal.Biome$BiomeCategory[];
        getSerializedName(): string;
        getName(): string;
        static byName(arg0: string): Internal.Biome$BiomeCategory;
        static valueOf(arg0: string): Internal.Biome$BiomeCategory;
        get serializedName(): string
        get name(): string
        readonly static "DESERT": Internal.Biome$BiomeCategory;
        readonly static "CODEC": any;
        readonly static "TAIGA": Internal.Biome$BiomeCategory;
        readonly static "MESA": Internal.Biome$BiomeCategory;
        readonly static "NONE": Internal.Biome$BiomeCategory;
        readonly static "ICY": Internal.Biome$BiomeCategory;
        readonly static "EXTREME_HILLS": Internal.Biome$BiomeCategory;
        readonly static "THEEND": Internal.Biome$BiomeCategory;
        readonly static "OCEAN": Internal.Biome$BiomeCategory;
        readonly static "RIVER": Internal.Biome$BiomeCategory;
        readonly static "NETHER": Internal.Biome$BiomeCategory;
        readonly static "PLAINS": Internal.Biome$BiomeCategory;
        readonly static "MOUNTAIN": Internal.Biome$BiomeCategory;
        readonly static "SWAMP": Internal.Biome$BiomeCategory;
        readonly static "MUSHROOM": Internal.Biome$BiomeCategory;
        readonly static "FOREST": Internal.Biome$BiomeCategory;
        readonly static "JUNGLE": Internal.Biome$BiomeCategory;
        readonly static "SAVANNA": Internal.Biome$BiomeCategory;
        readonly static "BEACH": Internal.Biome$BiomeCategory;
        readonly static "UNDERGROUND": Internal.Biome$BiomeCategory;
    }
    type Biome$BiomeCategory_ = "forest" | "taiga" | "jungle" | "plains" | "river" | "mushroom" | "ocean" | "theend" | "nether" | "underground" | "beach" | Biome$BiomeCategory | "none" | "mesa" | "swamp" | "icy" | "mountain" | "extreme_hills" | "savanna" | "desert";
    interface DoubleBidirectionalIterator extends Internal.DoubleIterator, Internal.ObjectBidirectionalIterator<number> {
        forEachRemaining(arg0: any): void;
        remove(): void;
        forEachRemaining(arg0: it.unimi.dsi.fastutil.doubles.DoubleConsumer_): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): any;
        skip(arg0: number): number;
        forEachRemaining(arg0: Internal.DoubleConsumer_): void;
        previous(): number;
        back(arg0: number): number;
        previousDouble(): number;
    }
    type DoubleBidirectionalIterator_ = DoubleBidirectionalIterator;
    class BendingTrunkPlacer extends Internal.TrunkPlacer {
        constructor(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.IntProvider_)
        placeTrunk(arg0: Internal.LevelSimulatedReader_, arg1: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>, arg2: Internal.Random_, arg3: number, arg4: BlockPos_, arg5: Internal.TreeConfiguration_): Internal.List<Internal.FoliagePlacer$FoliageAttachment>;
        readonly static "CODEC": any;
    }
    type BendingTrunkPlacer_ = BendingTrunkPlacer;
    class DifficultyInstance {
        constructor(arg0: Internal.Difficulty_, arg1: number, arg2: number, arg3: number)
        getDifficulty(): Internal.Difficulty;
        isHard(): boolean;
        getEffectiveDifficulty(): number;
        isHarderThan(arg0: number): boolean;
        getSpecialMultiplier(): number;
        get difficulty(): Internal.Difficulty
        get hard(): boolean
        get effectiveDifficulty(): number
        get specialMultiplier(): number
    }
    type DifficultyInstance_ = DifficultyInstance;
    interface UnitVariables {
        getVariables(): Internal.VariableSet;
        get variables(): Internal.VariableSet
    }
    type UnitVariables_ = UnitVariables | (()=>Internal.VariableSet_);
    class OffsetTime implements Internal.Comparable<Internal.OffsetTime>, Internal.Temporal, Internal.TemporalAdjuster, Internal.Serializable {
        getHour(): number;
        minusHours(arg0: number): this;
        toLocalTime(): Internal.LocalTime;
        plusHours(arg0: number): this;
        isBefore(arg0: Internal.OffsetTime_): boolean;
        compareTo(arg0: any): number;
        getMinute(): number;
        isEqual(arg0: Internal.OffsetTime_): boolean;
        minusMinutes(arg0: number): this;
        compareTo(arg0: Internal.OffsetTime_): number;
        static now(arg0: Internal.Clock_): Internal.OffsetTime;
        static parse(arg0: Internal.CharSequence_, arg1: Internal.DateTimeFormatter_): Internal.OffsetTime;
        with(arg0: Internal.TemporalField_, arg1: number): this;
        toEpochSecond(arg0: Internal.LocalDate_): number;
        plusNanos(arg0: number): this;
        minusSeconds(arg0: number): this;
        isSupported(arg0: Internal.TemporalField_): boolean;
        format(arg0: Internal.DateTimeFormatter_): string;
        withMinute(arg0: number): this;
        static of(arg0: Internal.LocalTime_, arg1: Internal.ZoneOffset_): Internal.OffsetTime;
        static from(arg0: Internal.TemporalAccessor_): Internal.OffsetTime;
        with(arg0: Internal.TemporalAdjuster_): this;
        atDate(arg0: Internal.LocalDate_): Internal.OffsetDateTime;
        static parse(arg0: Internal.CharSequence_): Internal.OffsetTime;
        truncatedTo(arg0: Internal.TemporalUnit_): this;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        withNano(arg0: number): this;
        get(arg0: Internal.TemporalField_): number;
        static ofInstant(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.OffsetTime;
        withOffsetSameInstant(arg0: Internal.ZoneOffset_): this;
        plusMinutes(arg0: number): this;
        plusSeconds(arg0: number): this;
        withHour(arg0: number): this;
        withSecond(arg0: number): this;
        getLong(arg0: Internal.TemporalField_): number;
        static now(arg0: Internal.ZoneId_): Internal.OffsetTime;
        withOffsetSameLocal(arg0: Internal.ZoneOffset_): this;
        plus(arg0: number, arg1: Internal.TemporalUnit_): this;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Temporal;
        getOffset(): Internal.ZoneOffset;
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.ZoneOffset_): Internal.OffsetTime;
        isAfter(arg0: Internal.OffsetTime_): boolean;
        toString(): string;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        query(arg0: Internal.TemporalQuery_<R>): R;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        getNano(): number;
        getSecond(): number;
        plus(arg0: Internal.TemporalAmount_): Internal.Temporal;
        static now(): Internal.OffsetTime;
        hashCode(): number;
        equals(arg0: any): boolean;
        minus(arg0: Internal.TemporalAmount_): Internal.Temporal;
        minusNanos(arg0: number): this;
        get hour(): number
        get minute(): number
        get offset(): Internal.ZoneOffset
        get nano(): number
        get second(): number
        readonly static "MAX": Internal.OffsetTime;
        readonly static "MIN": Internal.OffsetTime;
    }
    type OffsetTime_ = OffsetTime;
    class User {
        constructor(arg0: string, arg1: string, arg2: string, arg3: Internal.Optional_<string>, arg4: Internal.Optional_<string>, arg5: Internal.User$Type_)
        getGameProfile(): Internal.GameProfile;
        getClientId(): Internal.Optional<string>;
        getSessionId(): string;
        getName(): string;
        hasCachedProperties(): boolean;
        getXuid(): Internal.Optional<string>;
        setProperties(arg0: Internal.PropertyMap_): void;
        getUuid(): string;
        getType(): Internal.User$Type;
        getAccessToken(): string;
        get gameProfile(): Internal.GameProfile
        get clientId(): Internal.Optional<string>
        get sessionId(): string
        get name(): string
        get xuid(): Internal.Optional<string>
        set properties(arg0: Internal.PropertyMap_)
        get uuid(): string
        get type(): Internal.User$Type
        get accessToken(): string
    }
    type User_ = User;
    class UnboundedMapCodec <K, V> implements Internal.BaseMapCodec<K, V>, Internal.Codec<Internal.Map<K, V>> {
        constructor(arg0: Internal.Codec_<K>, arg1: Internal.Codec_<V>)
        keyCodec(): Internal.Codec<K>;
        orElse(arg0: Internal.Map_<K, V>): Internal.Codec<Internal.Map<K, V>>;
        optionalFieldOf(arg0: string, arg1: Internal.Map_<K, V>): Internal.MapCodec<Internal.Map<K, V>>;
        promotePartial(arg0: Internal.Consumer_<string>): Internal.Codec<Internal.Map<K, V>>;
        listOf(): Internal.Codec<Internal.List<Internal.Map<K, V>>>;
        deprecated(arg0: number): Internal.Codec<Internal.Map<K, V>>;
        orElseGet(arg0: Internal.UnaryOperator_<string>, arg1: Internal.Supplier_<any>): Internal.Codec<Internal.Map<K, V>>;
        fieldOf(arg0: string): Internal.MapCodec<Internal.Map<K, V>>;
        xmap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<S>;
        parse(arg0: Internal.Dynamic_<T>): Internal.DataResult<Internal.Map<K, V>>;
        simple(): Internal.Decoder$Simple<Internal.Map<K, V>>;
        stable(): Internal.Codec<Internal.Map<K, V>>;
        encode(arg0: any, arg1: Internal.DynamicOps_<any>, arg2: any): Internal.DataResult<any>;
        decode(arg0: Internal.DynamicOps_<T>, arg1: Internal.MapLike_<T>): Internal.DataResult<Internal.Map<K, V>>;
        flatXmap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<S>;
        optionalFieldOf(arg0: string, arg1: Internal.Map_<K, V>, arg2: Internal.Lifecycle_): Internal.MapCodec<Internal.Map<K, V>>;
        orElseGet(arg0: Internal.Consumer_<string>, arg1: Internal.Supplier_<any>): Internal.Codec<Internal.Map<K, V>>;
        decode(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<com.mojang.datafixers.util.Pair<Internal.Map<K, V>, T>>;
        flatMap(arg0: Internal.Function_<any, any>): Internal.Decoder<B>;
        orElse(arg0: Internal.Consumer_<string>, arg1: Internal.Map_<K, V>): Internal.Codec<Internal.Map<K, V>>;
        encode(arg0: Internal.Map_<K, V>, arg1: Internal.DynamicOps_<T>, arg2: Internal.RecordBuilder_<T>): Internal.RecordBuilder<T>;
        map(arg0: Internal.Function_<any, any>): Internal.Decoder<B>;
        mapResult(arg0: Internal.Codec$ResultFunction_<Internal.Map_<K, V>>): Internal.Codec<Internal.Map<K, V>>;
        dispatchMap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.MapCodec<E>;
        encodeStart(arg0: Internal.DynamicOps_<T>, arg1: Internal.Map_<K, V>): Internal.DataResult<T>;
        partialDispatch(arg0: string, arg1: Internal.Function_<any, any>, arg2: Internal.Function_<any, any>): Internal.Codec<E>;
        parse(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<Internal.Map<K, V>>;
        terminal(): Internal.Decoder$Terminal<Internal.Map<K, V>>;
        optionalFieldOf(arg0: string, arg1: Internal.Lifecycle_, arg2: Internal.Map_<K, V>, arg3: Internal.Lifecycle_): Internal.MapCodec<Internal.Map<K, V>>;
        dispatch(arg0: string, arg1: Internal.Function_<any, any>, arg2: Internal.Function_<any, any>): Internal.Codec<E>;
        toString(): string;
        flatComapMap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<S>;
        dispatch(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<E>;
        dispatchMap(arg0: string, arg1: Internal.Function_<any, any>, arg2: Internal.Function_<any, any>): Internal.MapCodec<E>;
        comapFlatMap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<S>;
        flatComap(arg0: Internal.Function_<any, any>): Internal.Encoder<B>;
        orElseGet(arg0: Internal.Supplier_<any>): Internal.Codec<Internal.Map<K, V>>;
        withLifecycle(arg0: Internal.Lifecycle_): Internal.Codec<Internal.Map<K, V>>;
        decode(arg0: Internal.Dynamic_<T>): Internal.DataResult<com.mojang.datafixers.util.Pair<Internal.Map<K, V>, T>>;
        hashCode(): number;
        elementCodec(): Internal.Codec<V>;
        comap(arg0: Internal.Function_<any, any>): Internal.Encoder<B>;
        boxed(): Internal.Decoder$Boxed<Internal.Map<K, V>>;
        orElse(arg0: Internal.UnaryOperator_<string>, arg1: Internal.Map_<K, V>): Internal.Codec<Internal.Map<K, V>>;
        dispatchStable(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<E>;
        equals(arg0: any): boolean;
        optionalFieldOf(arg0: string): Internal.MapCodec<Internal.Optional<Internal.Map<K, V>>>;
        encode(arg0: Internal.Map_<K, V>, arg1: Internal.DynamicOps_<T>, arg2: T): Internal.DataResult<T>;
    }
    type UnboundedMapCodec_<K, V> = UnboundedMapCodec<K, V>;
    class Suggestions {
        constructor(arg0: Internal.StringRange_, arg1: Internal.List_<Internal.Suggestion_>)
        static create(arg0: string, arg1: Internal.Collection_<Internal.Suggestion_>): Internal.Suggestions;
        hashCode(): number;
        toString(): string;
        static merge(arg0: string, arg1: Internal.Collection_<Internal.Suggestions_>): Internal.Suggestions;
        getList(): Internal.List<Internal.Suggestion>;
        static empty(): Internal.CompletableFuture<Internal.Suggestions>;
        isEmpty(): boolean;
        equals(arg0: any): boolean;
        getRange(): Internal.StringRange;
        get list(): Internal.List<Internal.Suggestion>
        get empty(): boolean
        get range(): Internal.StringRange
    }
    type Suggestions_ = Suggestions;
    class SimpleRandomFeatureConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.HolderSet_<Internal.PlacedFeature_>)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
        readonly "features": Internal.HolderSet<Internal.PlacedFeature>;
    }
    type SimpleRandomFeatureConfiguration_ = SimpleRandomFeatureConfiguration;
    abstract class CharBuffer extends Internal.Buffer implements Internal.Comparable<Internal.CharBuffer>, Internal.CharSequence, Internal.Appendable, Internal.Readable {
        put(arg0: string): this;
        isDirect(): boolean;
        compareTo(arg0: any): number;
        order(): Internal.ByteOrder;
        reset(): this;
        put(arg0: number, arg1: string[]): this;
        charAt(arg0: number): string;
        get(arg0: number, arg1: string[]): this;
        put(arg0: Internal.CharBuffer_): this;
        length(): number;
        put(arg0: number, arg1: string[], arg2: number, arg3: number): this;
        put(arg0: number, arg1: Internal.CharBuffer_, arg2: number, arg3: number): this;
        limit(arg0: number): this;
        append(arg0: Internal.CharSequence_): Internal.Appendable;
        static allocate(arg0: number): Internal.CharBuffer;
        put(arg0: string): this;
        static wrap(arg0: Internal.CharSequence_, arg1: number, arg2: number): Internal.CharBuffer;
        append(arg0: string): this;
        slice(): this;
        static wrap(arg0: string[]): Internal.CharBuffer;
        compareTo(arg0: Internal.CharBuffer_): number;
        chars(): Internal.IntStream;
        get(arg0: string[], arg1: number, arg2: number): this;
        put(arg0: string[], arg1: number, arg2: number): this;
        static wrap(arg0: string[], arg1: number, arg2: number): Internal.CharBuffer;
        array(): string[];
        get(): string;
        static wrap(arg0: Internal.CharSequence_): Internal.CharBuffer;
        arrayOffset(): number;
        isEmpty(): boolean;
        flip(): this;
        clear(): this;
        read(arg0: Internal.CharBuffer_): number;
        asReadOnlyBuffer(): this;
        subSequence(arg0: number, arg1: number): Internal.CharSequence;
        get(arg0: number, arg1: string[], arg2: number, arg3: number): this;
        put(arg0: number, arg1: string): this;
        hasArray(): boolean;
        compact(): this;
        toString(): string;
        get(arg0: number): string;
        get(arg0: string[]): this;
        rewind(): Internal.Buffer;
        put(arg0: string, arg1: number, arg2: number): this;
        put(arg0: string[]): this;
        mark(): Internal.Buffer;
        hashCode(): number;
        mismatch(arg0: Internal.CharBuffer_): number;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): this;
        position(arg0: number): Internal.Buffer;
        equals(arg0: any): boolean;
        slice(arg0: number, arg1: number): this;
        codePoints(): Internal.IntStream;
        duplicate(): this;
        get direct(): boolean
        get empty(): boolean
    }
    type CharBuffer_ = CharBuffer;
    interface Codec$ResultFunction <A> {
        apply(arg0: Internal.DynamicOps_<T>, arg1: T, arg2: Internal.DataResult_<com.mojang.datafixers.util.Pair_<A, T>>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>;
        coApply(arg0: Internal.DynamicOps_<T>, arg1: A, arg2: Internal.DataResult_<T>): Internal.DataResult<T>;
    }
    type Codec$ResultFunction_<A> = Codec$ResultFunction<A>;
    class Uniform extends Internal.AbstractUniform implements Internal.AutoCloseable {
        constructor(arg0: string, arg1: number, arg2: number, arg3: Internal.Shader_)
        upload(): void;
        getCount(): number;
        getFloatBuffer(): Internal.FloatBuffer;
        set(arg0: number): void;
        setMat3x2(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        static glGetAttribLocation(arg0: number, arg1: Internal.CharSequence_): number;
        set(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setLocation(arg0: number): void;
        set(arg0: number, arg1: number): void;
        setMat3x3(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number): void;
        set(arg0: number, arg1: number, arg2: number): void;
        getIntBuffer(): Internal.IntBuffer;
        set(arg0: Internal.Vector3f_): void;
        set(arg0: Internal.Vector4f_): void;
        setMat4x2(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        set(arg0: number, arg1: number): void;
        setMat4x4(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number, arg11: number, arg12: number, arg13: number, arg14: number, arg15: number): void;
        getType(): number;
        setSafe(arg0: number, arg1: number, arg2: number, arg3: number): void;
        static glGetUniformLocation(arg0: number, arg1: Internal.CharSequence_): number;
        getName(): string;
        set(arg0: number, arg1: number, arg2: number, arg3: number): void;
        set(arg0: number, arg1: number): void;
        getLocation(): number;
        setMat2x2(arg0: number, arg1: number, arg2: number, arg3: number): void;
        set(arg0: number, arg1: number, arg2: number): void;
        setMat3x4(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number, arg11: number): void;
        setSafe(arg0: number, arg1: number, arg2: number, arg3: number): void;
        static uploadInteger(arg0: number, arg1: number): void;
        set(arg0: Internal.Matrix3f_): void;
        set(arg0: Internal.Matrix4f_): void;
        set(arg0: number): void;
        set(arg0: number[]): void;
        setMat4x3(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number, arg11: number): void;
        static glBindAttribLocation(arg0: number, arg1: number, arg2: Internal.CharSequence_): void;
        setMat2x4(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        close(): void;
        setMat2x3(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        static getTypeFromString(arg0: string): number;
        get count(): number
        get floatBuffer(): Internal.FloatBuffer
        set location(arg0: number)
        get intBuffer(): Internal.IntBuffer
        get type(): number
        get name(): string
        get location(): number
        readonly static "UT_MAT4": 10;
        readonly static "UT_FLOAT4": 7;
        readonly static "UT_MAT2": 8;
        readonly static "UT_MAT3": 9;
        readonly static "UT_INT2": 1;
        readonly static "UT_INT1": 0;
        readonly static "UT_INT4": 3;
        readonly static "UT_FLOAT3": 6;
        readonly static "UT_INT3": 2;
        readonly static "UT_FLOAT2": 5;
        readonly static "UT_FLOAT1": 4;
    }
    type Uniform_ = Uniform;
    class PieceGenerator$Context <C> extends Internal.Record {
        constructor(arg0: C, arg1: Internal.ChunkGenerator_, arg2: Internal.StructureManager_, arg3: Internal.ChunkPos_, arg4: Internal.LevelHeightAccessor_, arg5: Internal.WorldgenRandom_, arg6: number)
        hashCode(): number;
        random(): Internal.WorldgenRandom;
        toString(): string;
        seed(): number;
        heightAccessor(): Internal.LevelHeightAccessor;
        structureManager(): Internal.StructureManager;
        chunkGenerator(): Internal.ChunkGenerator;
        equals(arg0: any): boolean;
        config(): C;
        chunkPos(): Internal.ChunkPos;
    }
    type PieceGenerator$Context_<C> = PieceGenerator$Context<C>;
    class LootPoolEntryType extends Internal.SerializerType<Internal.LootPoolEntryContainer> {
        constructor(arg0: Internal.Serializer_<any>)
    }
    type LootPoolEntryType_ = LootPoolEntryType | Special.LootPoolEntryType;
    class ClientboundRecipePacket$State extends Internal.Enum<Internal.ClientboundRecipePacket$State> {
        static values(): Internal.ClientboundRecipePacket$State[];
        static valueOf(arg0: string): Internal.ClientboundRecipePacket$State;
        readonly static "REMOVE": Internal.ClientboundRecipePacket$State;
        readonly static "ADD": Internal.ClientboundRecipePacket$State;
        readonly static "INIT": Internal.ClientboundRecipePacket$State;
    }
    type ClientboundRecipePacket$State_ = "init" | "remove" | ClientboundRecipePacket$State | "add";
    class LivingEvent extends Internal.EntityEvent {
        constructor()
        constructor(arg0: Internal.LivingEntity_)
        getEntityLiving(): Internal.LivingEntity;
        getListenerList(): Internal.ListenerList;
        get entityLiving(): Internal.LivingEntity
        get listenerList(): Internal.ListenerList
    }
    type LivingEvent_ = LivingEvent;
    class MushroomCow extends Internal.Cow implements Internal.Shearable, Internal.IForgeShearable {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        isShearable(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: BlockPos_): boolean;
        static checkMushroomSpawnRules(arg0: Internal.EntityType_<Internal.MushroomCow_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        getMushroomType(): Internal.MushroomCow$MushroomType;
        thunderHit(arg0: Internal.ServerLevel_, arg1: Internal.LightningBolt_): void;
        shear(arg0: Internal.SoundSource_): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readyForShearing(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        getWalkTargetValue(arg0: BlockPos_, arg1: Internal.LevelReader_): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        onSheared(arg0: Internal.Player_, arg1: Internal.ItemStack_, arg2: Internal.Level_, arg3: BlockPos_, arg4: number): Internal.List<Internal.ItemStack>;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get mushroomType(): Internal.MushroomCow$MushroomType
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type MushroomCow_ = MushroomCow;
    class ClientboundBlockDestructionPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: BlockPos_, arg2: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getProgress(): number;
        getPos(): BlockPos;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        getId(): number;
        get progress(): number
        get pos(): BlockPos
        get skippable(): boolean
        get id(): number
    }
    type ClientboundBlockDestructionPacket_ = ClientboundBlockDestructionPacket;
    class ClientboundChatPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.Component_, arg1: Internal.ChatType_, arg2: Internal.UUID_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getMessage(): Internal.Component;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getType(): Internal.ChatType;
        isSkippable(): boolean;
        getSender(): Internal.UUID;
        get message(): Internal.Component
        get type(): Internal.ChatType
        get skippable(): boolean
        get sender(): Internal.UUID
    }
    type ClientboundChatPacket_ = ClientboundChatPacket;
    class ArmorItemBuilder$Helmet extends Internal.ArmorItemBuilder {
        constructor(i: ResourceLocation_)
        createObject(): any;
    }
    type ArmorItemBuilder$Helmet_ = ArmorItemBuilder$Helmet;
    class RenderStateShard$WriteMaskStateShard extends Internal.RenderStateShard {
        constructor(arg0: boolean, arg1: boolean)
        toString(): string;
    }
    type RenderStateShard$WriteMaskStateShard_ = RenderStateShard$WriteMaskStateShard;
    interface Hash {
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "PRIMES": any;
        readonly static "DEFAULT_LOAD_FACTOR": 0.75;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "FREE": 0;
        readonly static "VERY_FAST_LOAD_FACTOR": 0.25;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "DEFAULT_GROWTH_FACTOR": 16;
        readonly static "FAST_LOAD_FACTOR": 0.5;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "OCCUPIED": -1;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "REMOVED": 1;
        readonly static "DEFAULT_INITIAL_SIZE": 16;
    }
    type Hash_ = Hash;
    class Toast$Visibility extends Internal.Enum<Internal.Toast$Visibility> {
        playSound(arg0: Internal.SoundManager_): void;
        static values(): Internal.Toast$Visibility[];
        static valueOf(arg0: string): Internal.Toast$Visibility;
        readonly static "HIDE": Internal.Toast$Visibility;
        readonly static "SHOW": Internal.Toast$Visibility;
    }
    type Toast$Visibility_ = "hide" | "show" | Toast$Visibility;
    abstract class AbstractSet <E> extends Internal.AbstractCollection<E> implements Internal.Set<E> {
        hashCode(): number;
        stream(): Internal.Stream<E>;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<E>;
        parallelStream(): Internal.Stream<E>;
        equals(arg0: any): boolean;
    }
    type AbstractSet_<E> = AbstractSet<E>;
    class ClampedInt extends Internal.IntProvider {
        constructor(arg0: Internal.IntProvider_, arg1: number, arg2: number)
        getMinValue(): number;
        getType(): Internal.IntProviderType<any>;
        static of(arg0: Internal.IntProvider_, arg1: number, arg2: number): Internal.ClampedInt;
        getMaxValue(): number;
        sample(arg0: Internal.Random_): number;
        get minValue(): number
        get type(): Internal.IntProviderType<any>
        get maxValue(): number
        readonly static "CODEC": any;
    }
    type ClampedInt_ = ClampedInt;
    class ClientPacketListener implements Internal.ClientGamePacketListener {
        constructor(arg0: Internal.Minecraft_, arg1: Internal.Screen_, arg2: Internal.Connection_, arg3: Internal.GameProfile_, arg4: Internal.ClientTelemetryManager_)
        setActionBarText(arg0: Internal.ClientboundSetActionBarTextPacket_): void;
        handleContainerSetSlot(arg0: Internal.ClientboundContainerSetSlotPacket_): void;
        handleAddPlayer(arg0: Internal.ClientboundAddPlayerPacket_): void;
        handleSetScore(arg0: Internal.ClientboundSetScorePacket_): void;
        handleAnimate(arg0: Internal.ClientboundAnimatePacket_): void;
        handleResourcePack(arg0: Internal.ClientboundResourcePackPacket_): void;
        handleContainerContent(arg0: Internal.ClientboundContainerSetContentPacket_): void;
        handleOpenScreen(arg0: Internal.ClientboundOpenScreenPacket_): void;
        handleLogin(arg0: Internal.ClientboundLoginPacket_): void;
        handleTagQueryPacket(arg0: Internal.ClientboundTagQueryPacket_): void;
        getConnection(): Internal.Connection;
        onDisconnect(arg0: Internal.Component_): void;
        getPlayerInfo(arg0: string): Internal.PlayerInfo;
        handleUpdateAttributes(arg0: Internal.ClientboundUpdateAttributesPacket_): void;
        handleSetSpawn(arg0: Internal.ClientboundSetDefaultSpawnPositionPacket_): void;
        handleCustomPayload(arg0: Internal.ClientboundCustomPayloadPacket_): void;
        handleLookAt(arg0: Internal.ClientboundPlayerLookAtPacket_): void;
        handleParticleEvent(arg0: Internal.ClientboundLevelParticlesPacket_): void;
        levels(): Internal.Set<Internal.ResourceKey<Internal.Level>>;
        getCommands(): Internal.CommandDispatcher<Internal.SharedSuggestionProvider>;
        handleTitlesClear(arg0: Internal.ClientboundClearTitlesPacket_): void;
        handleContainerClose(arg0: Internal.ClientboundContainerClosePacket_): void;
        handleRemoveEntities(arg0: Internal.ClientboundRemoveEntitiesPacket_): void;
        handleSetCamera(arg0: Internal.ClientboundSetCameraPacket_): void;
        handleTeleportEntity(arg0: Internal.ClientboundTeleportEntityPacket_): void;
        handlePlayerCombatEnter(arg0: Internal.ClientboundPlayerCombatEnterPacket_): void;
        handleForgetLevelChunk(arg0: Internal.ClientboundForgetLevelChunkPacket_): void;
        handleBlockEvent(arg0: Internal.ClientboundBlockEventPacket_): void;
        handleLightUpdatePacket(arg0: Internal.ClientboundLightUpdatePacket_): void;
        handleMoveVehicle(arg0: Internal.ClientboundMoveVehiclePacket_): void;
        handleCommands(arg0: Internal.ClientboundCommandsPacket_): void;
        handleSetBorderCenter(arg0: Internal.ClientboundSetBorderCenterPacket_): void;
        getOnlinePlayers(): Internal.Collection<Internal.PlayerInfo>;
        handleItemCooldown(arg0: Internal.ClientboundCooldownPacket_): void;
        setSubtitleText(arg0: Internal.ClientboundSetSubtitleTextPacket_): void;
        handleAddExperienceOrb(arg0: Internal.ClientboundAddExperienceOrbPacket_): void;
        handleRespawn(arg0: Internal.ClientboundRespawnPacket_): void;
        getLevel(): Internal.ClientLevel;
        handleCommandSuggestions(arg0: Internal.ClientboundCommandSuggestionsPacket_): void;
        handleSetEquipment(arg0: Internal.ClientboundSetEquipmentPacket_): void;
        handleChunkBlocksUpdate(arg0: Internal.ClientboundSectionBlocksUpdatePacket_): void;
        getOnlinePlayerIds(): Internal.Collection<Internal.UUID>;
        handleExplosion(arg0: Internal.ClientboundExplodePacket_): void;
        handleUpdateMobEffect(arg0: Internal.ClientboundUpdateMobEffectPacket_): void;
        handleKeepAlive(arg0: Internal.ClientboundKeepAlivePacket_): void;
        handleUpdateRecipes(arg0: Internal.ClientboundUpdateRecipesPacket_): void;
        handleLevelChunkWithLight(arg0: Internal.ClientboundLevelChunkWithLightPacket_): void;
        handleOpenBook(arg0: Internal.ClientboundOpenBookPacket_): void;
        handleBlockEntityData(arg0: Internal.ClientboundBlockEntityDataPacket_): void;
        handleCustomSoundEvent(arg0: Internal.ClientboundCustomSoundPacket_): void;
        handlePlayerInfo(arg0: Internal.ClientboundPlayerInfoPacket_): void;
        handleUpdateAdvancementsPacket(arg0: Internal.ClientboundUpdateAdvancementsPacket_): void;
        handleSetChunkCacheRadius(arg0: Internal.ClientboundSetChunkCacheRadiusPacket_): void;
        handleAddVibrationSignal(arg0: Internal.ClientboundAddVibrationSignalPacket_): void;
        handleMapItemData(arg0: Internal.ClientboundMapItemDataPacket_): void;
        handleInitializeBorder(arg0: Internal.ClientboundInitializeBorderPacket_): void;
        getAdvancements(): Internal.ClientAdvancements;
        handleSetPlayerTeamPacket(arg0: Internal.ClientboundSetPlayerTeamPacket_): void;
        handleBlockDestruction(arg0: Internal.ClientboundBlockDestructionPacket_): void;
        handleTakeItemEntity(arg0: Internal.ClientboundTakeItemEntityPacket_): void;
        handleEntityLinkPacket(arg0: Internal.ClientboundSetEntityLinkPacket_): void;
        handleSetBorderSize(arg0: Internal.ClientboundSetBorderSizePacket_): void;
        handleSetTime(arg0: Internal.ClientboundSetTimePacket_): void;
        handleSetCarriedItem(arg0: Internal.ClientboundSetCarriedItemPacket_): void;
        setTitlesAnimation(arg0: Internal.ClientboundSetTitlesAnimationPacket_): void;
        cleanup(): void;
        handleSetBorderLerpSize(arg0: Internal.ClientboundSetBorderLerpSizePacket_): void;
        handleSetExperience(arg0: Internal.ClientboundSetExperiencePacket_): void;
        handleSetDisplayObjective(arg0: Internal.ClientboundSetDisplayObjectivePacket_): void;
        handleAddPainting(arg0: Internal.ClientboundAddPaintingPacket_): void;
        handleDisconnect(arg0: Internal.ClientboundDisconnectPacket_): void;
        handleSetHealth(arg0: Internal.ClientboundSetHealthPacket_): void;
        handleTabListCustomisation(arg0: Internal.ClientboundTabListPacket_): void;
        handleAddObjective(arg0: Internal.ClientboundSetObjectivePacket_): void;
        handleUpdateTags(arg0: Internal.ClientboundUpdateTagsPacket_): void;
        handleMerchantOffers(arg0: Internal.ClientboundMerchantOffersPacket_): void;
        handleStopSoundEvent(arg0: Internal.ClientboundStopSoundPacket_): void;
        handleRemoveMobEffect(arg0: Internal.ClientboundRemoveMobEffectPacket_): void;
        handleSetSimulationDistance(arg0: Internal.ClientboundSetSimulationDistancePacket_): void;
        handleSetChunkCacheCenter(arg0: Internal.ClientboundSetChunkCacheCenterPacket_): void;
        handleChat(arg0: Internal.ClientboundChatPacket_): void;
        getId(): Internal.UUID;
        handlePing(arg0: Internal.ClientboundPingPacket_): void;
        handleBlockUpdate(arg0: Internal.ClientboundBlockUpdatePacket_): void;
        handleRotateMob(arg0: Internal.ClientboundRotateHeadPacket_): void;
        handleMovePlayer(arg0: Internal.ClientboundPlayerPositionPacket_): void;
        handleAddEntity(arg0: Internal.ClientboundAddEntityPacket_): void;
        handleSoundEntityEvent(arg0: Internal.ClientboundSoundEntityPacket_): void;
        handleHorseScreenOpen(arg0: Internal.ClientboundHorseScreenOpenPacket_): void;
        handleChangeDifficulty(arg0: Internal.ClientboundChangeDifficultyPacket_): void;
        handleEntityEvent(arg0: Internal.ClientboundEntityEventPacket_): void;
        handleSetBorderWarningDelay(arg0: Internal.ClientboundSetBorderWarningDelayPacket_): void;
        handleOpenSignEditor(arg0: Internal.ClientboundOpenSignEditorPacket_): void;
        setTitleText(arg0: Internal.ClientboundSetTitleTextPacket_): void;
        handleSetEntityData(arg0: Internal.ClientboundSetEntityDataPacket_): void;
        getDebugQueryHandler(): Internal.DebugQueryHandler;
        handleBossUpdate(arg0: Internal.ClientboundBossEventPacket_): void;
        handlePlaceRecipe(arg0: Internal.ClientboundPlaceGhostRecipePacket_): void;
        getSuggestionsProvider(): Internal.ClientSuggestionProvider;
        getLocalGameProfile(): Internal.GameProfile;
        getPlayerInfo(arg0: Internal.UUID_): Internal.PlayerInfo;
        handleGameEvent(arg0: Internal.ClientboundGameEventPacket_): void;
        handleAddMob(arg0: Internal.ClientboundAddMobPacket_): void;
        handleSoundEvent(arg0: Internal.ClientboundSoundPacket_): void;
        handleSetEntityMotion(arg0: Internal.ClientboundSetEntityMotionPacket_): void;
        handleContainerSetData(arg0: Internal.ClientboundContainerSetDataPacket_): void;
        handlePlayerCombatEnd(arg0: Internal.ClientboundPlayerCombatEndPacket_): void;
        registryAccess(): Internal.RegistryAccess;
        handleMoveEntity(arg0: Internal.ClientboundMoveEntityPacket_): void;
        handleLevelEvent(arg0: Internal.ClientboundLevelEventPacket_): void;
        handlePlayerAbilities(arg0: Internal.ClientboundPlayerAbilitiesPacket_): void;
        shouldPropagateHandlingExceptions(): boolean;
        handlePlayerCombatKill(arg0: Internal.ClientboundPlayerCombatKillPacket_): void;
        handleSetBorderWarningDistance(arg0: Internal.ClientboundSetBorderWarningDistancePacket_): void;
        getRecipeManager(): Internal.RecipeManager;
        handleBlockBreakAck(arg0: Internal.ClientboundBlockBreakAckPacket_): void;
        handleSetEntityPassengersPacket(arg0: Internal.ClientboundSetPassengersPacket_): void;
        handleAwardStats(arg0: Internal.ClientboundAwardStatsPacket_): void;
        handleSelectAdvancementsTab(arg0: Internal.ClientboundSelectAdvancementsTabPacket_): void;
        send(arg0: Internal.Packet_<any>): void;
        handleAddOrRemoveRecipes(arg0: Internal.ClientboundRecipePacket_): void;
        set actionBarText(arg0: Internal.ClientboundSetActionBarTextPacket_)
        get connection(): Internal.Connection
        get commands(): Internal.CommandDispatcher<Internal.SharedSuggestionProvider>
        get onlinePlayers(): Internal.Collection<Internal.PlayerInfo>
        set subtitleText(arg0: Internal.ClientboundSetSubtitleTextPacket_)
        get level(): Internal.ClientLevel
        get onlinePlayerIds(): Internal.Collection<Internal.UUID>
        get advancements(): Internal.ClientAdvancements
        set titlesAnimation(arg0: Internal.ClientboundSetTitlesAnimationPacket_)
        get id(): Internal.UUID
        set titleText(arg0: Internal.ClientboundSetTitleTextPacket_)
        get debugQueryHandler(): Internal.DebugQueryHandler
        get suggestionsProvider(): Internal.ClientSuggestionProvider
        get localGameProfile(): Internal.GameProfile
        get recipeManager(): Internal.RecipeManager
        "commands": Internal.CommandDispatcher<Internal.SharedSuggestionProvider>;
    }
    type ClientPacketListener_ = ClientPacketListener;
    class Dynamic2CommandExceptionType implements Internal.CommandExceptionType {
        constructor(arg0: any_)
        createWithContext(arg0: Internal.ImmutableStringReader_, arg1: any, arg2: any): Internal.CommandSyntaxException;
        create(arg0: any, arg1: any): Internal.CommandSyntaxException;
    }
    type Dynamic2CommandExceptionType_ = Dynamic2CommandExceptionType;
    interface Byte2DoubleFunction extends Internal.IntToDoubleFunction, it.unimi.dsi.fastutil.Function<number, number> {
        applyAsDouble(arg0: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Byte2CharFunction;
        getOrDefault(arg0: any, arg1: any): any;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Byte2ShortFunction;
        get(arg0: any): number;
        apply(arg0: number): number;
        remove(arg0: number): number;
        andThenObject(arg0: Internal.Double2ObjectFunction_<any>): Internal.Byte2ObjectFunction<T>;
        get(arg0: number): number;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2DoubleFunction;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Byte2LongFunction;
        containsKey(arg0: any): boolean;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Byte2ByteFunction;
        put(arg0: number, arg1: number): number;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2DoubleFunction;
        put(arg0: any, arg1: any): any;
        defaultReturnValue(arg0: number): void;
        containsKey(arg0: number): boolean;
        getOrDefault(arg0: any, arg1: number): number;
        composeObject(arg0: Internal.Object2ByteFunction_<any>): Internal.Object2DoubleFunction<T>;
        composeByte(arg0: Internal.Byte2ByteFunction_): this;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2DoubleFunction;
        andThenReference(arg0: Internal.Double2ReferenceFunction_<any>): Internal.Byte2ReferenceFunction<T>;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2DoubleFunction;
        defaultReturnValue(): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeReference(arg0: Internal.Reference2ByteFunction_<any>): Internal.Reference2DoubleFunction<T>;
        size(): number;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Byte2IntFunction;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Byte2FloatFunction;
        clear(): void;
        put(arg0: number, arg1: number): number;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2DoubleFunction;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2DoubleFunction;
        remove(arg0: any): any;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): this;
    }
    type Byte2DoubleFunction_ = ((arg0: number)=>number) | Byte2DoubleFunction;
    class HumanoidModel$ArmPose extends Internal.Enum<Internal.HumanoidModel$ArmPose> {
        isTwoHanded(): boolean;
        static valueOf(arg0: string): Internal.HumanoidModel$ArmPose;
        static values(): Internal.HumanoidModel$ArmPose[];
        get twoHanded(): boolean
        readonly static "THROW_SPEAR": Internal.HumanoidModel$ArmPose;
        readonly static "BLOCK": Internal.HumanoidModel$ArmPose;
        readonly static "SPYGLASS": Internal.HumanoidModel$ArmPose;
        readonly static "ITEM": Internal.HumanoidModel$ArmPose;
        readonly static "CROSSBOW_CHARGE": Internal.HumanoidModel$ArmPose;
        readonly static "CROSSBOW_HOLD": Internal.HumanoidModel$ArmPose;
        readonly static "EMPTY": Internal.HumanoidModel$ArmPose;
        readonly static "BOW_AND_ARROW": Internal.HumanoidModel$ArmPose;
    }
    type HumanoidModel$ArmPose_ = "block" | "throw_spear" | "empty" | "spyglass" | "crossbow_hold" | "bow_and_arrow" | "crossbow_charge" | HumanoidModel$ArmPose | "item";
    class ModifyRecipeCraftingGrid {
        constructor(c: Internal.CraftingContainer_)
        findAll(): Internal.List<Internal.ItemStackJS>;
        getPlayer(): Internal.PlayerJS<any>;
        getMenu(): Internal.AbstractContainerMenu;
        getWidth(): number;
        get(index: number): Internal.ItemStackJS;
        find(ingredient: Internal.IngredientJS_): Internal.ItemStackJS;
        findAll(ingredient: Internal.IngredientJS_): Internal.List<Internal.ItemStackJS>;
        find(ingredient: Internal.IngredientJS_, skip: number): Internal.ItemStackJS;
        getHeight(): number;
        get player(): Internal.PlayerJS<any>
        get menu(): Internal.AbstractContainerMenu
        get width(): number
        get height(): number
    }
    type ModifyRecipeCraftingGrid_ = ModifyRecipeCraftingGrid;
    abstract class AbstractMinecartContainer extends Internal.AbstractMinecart implements Internal.Container, Internal.MenuProvider {
        setLootTable(arg0: ResourceLocation_, arg1: number): void;
        stopOpen(arg0: Internal.Player_): void;
        isPoweredCart(): boolean;
        getCapability(arg0: Internal.Capability_<T>, arg1: Internal.Direction_): Internal.LazyOptional<T>;
        getCurrentRailPosition(): BlockPos;
        getMaxCartSpeedOnRail(): number;
        interact(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        countItem(arg0: Internal.Item_): number;
        getSlot(arg0: number): Internal.SlotAccess;
        isEmpty(): boolean;
        remove(arg0: Internal.Entity$RemovalReason_): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        getSlopeAdjustment(): number;
        createMenu(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Player_): Internal.AbstractContainerMenu;
        removeItem(arg0: number, arg1: number): Internal.ItemStack;
        shouldDoRailFunctions(): boolean;
        canRiderInteract(): boolean;
        setChanged(): void;
        destroy(arg0: Internal.DamageSource_): void;
        isMultipartEntity(): boolean;
        canBeRidden(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        setItem(arg0: number, arg1: Internal.ItemStack_): void;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        invalidateCaps(): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMaxStackSize(): number;
        removeItemNoUpdate(arg0: number): Internal.ItemStack;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getCartItem(): Internal.ItemStack;
        stillValid(arg0: Internal.Player_): boolean;
        unpackLootTable(arg0: Internal.Player_): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getItem(arg0: number): Internal.ItemStack;
        getComparatorLevel(): number;
        clearContent(): void;
        reviveCaps(): void;
        get poweredCart(): boolean
        get currentRailPosition(): BlockPos
        get maxCartSpeedOnRail(): number
        get empty(): boolean
        get stepHeight(): number
        get slopeAdjustment(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get maxStackSize(): number
        get cartItem(): Internal.ItemStack
        get comparatorLevel(): number
    }
    type AbstractMinecartContainer_ = AbstractMinecartContainer;
    class RenderTooltipEvent$Color extends Internal.RenderTooltipEvent {
        constructor()
        constructor(arg0: Internal.ItemStack_, arg1: Internal.PoseStack_, arg2: number, arg3: number, arg4: Internal.Font_, arg5: number, arg6: number, arg7: number, arg8: Internal.List_<Internal.ClientTooltipComponent_>)
        setBackgroundStart(arg0: number): void;
        setBackgroundEnd(arg0: number): void;
        setBorderEnd(arg0: number): void;
        setBorderStart(arg0: number): void;
        getOriginalBackgroundStart(): number;
        getOriginalBorderStart(): number;
        setBackground(arg0: number): void;
        getBorderEnd(): number;
        getBorderStart(): number;
        getBackgroundEnd(): number;
        getBackgroundStart(): number;
        getOriginalBorderEnd(): number;
        getListenerList(): Internal.ListenerList;
        getOriginalBackgroundEnd(): number;
        set backgroundStart(arg0: number)
        set backgroundEnd(arg0: number)
        set borderEnd(arg0: number)
        set borderStart(arg0: number)
        get originalBackgroundStart(): number
        get originalBorderStart(): number
        set background(arg0: number)
        get borderEnd(): number
        get borderStart(): number
        get backgroundEnd(): number
        get backgroundStart(): number
        get originalBorderEnd(): number
        get listenerList(): Internal.ListenerList
        get originalBackgroundEnd(): number
    }
    type RenderTooltipEvent$Color_ = RenderTooltipEvent$Color;
    class PropertyChangeEvent extends Internal.EventObject {
        constructor(arg0: any, arg1: string, arg2: any, arg3: any)
        setPropagationId(arg0: any): void;
        toString(): string;
        getPropertyName(): string;
        getPropagationId(): any;
        getNewValue(): any;
        getOldValue(): any;
        set propagationId(arg0: any)
        get propertyName(): string
        get propagationId(): any
        get newValue(): any
        get oldValue(): any
    }
    type PropertyChangeEvent_ = PropertyChangeEvent;
    interface EnchantmentBuilder$DamageBonusFunction {
        getDamageBonus(arg0: number, arg1: string): number;
    }
    type EnchantmentBuilder$DamageBonusFunction_ = EnchantmentBuilder$DamageBonusFunction | ((arg0: number, arg1: string)=>number);
    interface Reference2ObjectFunction <K, V> extends it.unimi.dsi.fastutil.Function<K, V> {
        andThenReference(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Reference2ReferenceFunction<K, T>;
        getOrDefault(arg0: any, arg1: V): V;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2ObjectFunction<V>;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Reference2DoubleFunction<K>;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2ObjectFunction<V>;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Reference2FloatFunction<K>;
        containsKey(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Reference2LongFunction<K>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Reference2ByteFunction<K>;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2ObjectFunction<V>;
        composeReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Reference2ObjectFunction<T, V>;
        composeObject(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Object2ObjectFunction<T, V>;
        get(arg0: any): V;
        remove(arg0: any): V;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Reference2ShortFunction<K>;
        apply(arg0: K): V;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Reference2CharFunction<K>;
        andThenObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Reference2ObjectFunction<K, T>;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2ObjectFunction<V>;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2ObjectFunction<V>;
        size(): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Reference2IntFunction<K>;
        clear(): void;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2ObjectFunction<V>;
        defaultReturnValue(): V;
        defaultReturnValue(arg0: V): void;
    }
    type Reference2ObjectFunction_<K, V> = ((arg0: any)=>V) | Reference2ObjectFunction<K, V>;
    class PotionBuilder extends Internal.BuilderBase<Internal.Potion> {
        constructor(i: ResourceLocation_)
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Potion>;
        effect(effect: Internal.MobEffect_, duration: number, amplifier: number): this;
        effect(effect: Internal.MobEffect_, duration: number, amplifier: number, ambient: boolean, visible: boolean, showIcon: boolean, hiddenEffect: Internal.MobEffectInstance_): this;
        effect(effect: Internal.MobEffect_): this;
        createObject(): any;
        effect(effect: Internal.MobEffect_, duration: number, amplifier: number, ambient: boolean, visible: boolean): this;
        effect(effect: Internal.MobEffect_, duration: number): this;
        addEffect(effect: Internal.MobEffectInstance_): this;
        effect(effect: Internal.MobEffect_, duration: number, amplifier: number, ambient: boolean, visible: boolean, showIcon: boolean): this;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Potion>
    }
    type PotionBuilder_ = PotionBuilder;
    class EntityEvent$EnteringSection extends Internal.EntityEvent {
        constructor()
        constructor(arg0: Internal.Entity_, arg1: number, arg2: number)
        getPackedOldPos(): number;
        getOldPos(): Internal.SectionPos;
        didChunkChange(): boolean;
        getListenerList(): Internal.ListenerList;
        getNewPos(): Internal.SectionPos;
        getPackedNewPos(): number;
        get packedOldPos(): number
        get oldPos(): Internal.SectionPos
        get listenerList(): Internal.ListenerList
        get newPos(): Internal.SectionPos
        get packedNewPos(): number
    }
    type EntityEvent$EnteringSection_ = EntityEvent$EnteringSection;
    class ArmorItemBuilder$Chestplate extends Internal.ArmorItemBuilder {
        constructor(i: ResourceLocation_)
        createObject(): any;
    }
    type ArmorItemBuilder$Chestplate_ = ArmorItemBuilder$Chestplate;
    class ModelLayerLocation {
        constructor(arg0: ResourceLocation_, arg1: string)
        hashCode(): number;
        getModel(): ResourceLocation;
        toString(): string;
        getLayer(): string;
        equals(arg0: any): boolean;
        get model(): ResourceLocation
        get layer(): string
    }
    type ModelLayerLocation_ = ModelLayerLocation;
    class Attribute extends Internal.ForgeRegistryEntry<Internal.Attribute> {
        isClientSyncable(): boolean;
        getDefaultValue(): number;
        sanitizeValue(arg0: number): number;
        setSyncable(arg0: boolean): this;
        getDescriptionId(): string;
        get clientSyncable(): boolean
        get defaultValue(): number
        set syncable(arg0: boolean)
        get descriptionId(): string
        readonly static "MAX_NAME_LENGTH": 64;
    }
    type Attribute_ = Attribute;
    interface WatchService extends Internal.Closeable {
        poll(): Internal.WatchKey;
        take(): Internal.WatchKey;
        close(): void;
        poll(arg0: number, arg1: Internal.TimeUnit_): Internal.WatchKey;
    }
    type WatchService_ = WatchService;
    interface ClassDesc extends Internal.TypeDescriptor$OfField<Internal.ClassDesc>, Internal.ConstantDesc {
        componentType(): Internal.TypeDescriptor$OfField<any>;
        displayName(): string;
        isPrimitive(): boolean;
        ofDescriptor(arg0: string): this;
        of(arg0: string): this;
        descriptorString(): string;
        nested(arg0: string, ...arg1: string[]): this;
        of(arg0: string, arg1: string): this;
        isArray(): boolean;
        nested(arg0: string): this;
        isClassOrInterface(): boolean;
        packageName(): string;
        equals(arg0: any): boolean;
        arrayType(arg0: number): this;
        arrayType(): Internal.TypeDescriptor$OfField<any>;
        get primitive(): boolean
        get array(): boolean
        get classOrInterface(): boolean
    }
    type ClassDesc_ = ClassDesc;
    abstract class AbstractSchoolingFish extends Internal.AbstractFish {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        stopFollowing(): void;
        isFollower(): boolean;
        canRiderInteract(): boolean;
        getMaxSpawnClusterSize(): number;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getMaxSchoolSize(): number;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        inRangeOfLeader(): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        pathToLeader(): void;
        tick(): void;
        hasFollowers(): boolean;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        addFollowers(arg0: Internal.Stream_<any>): void;
        canBeFollowed(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        startFollowing(arg0: Internal.AbstractSchoolingFish_): this;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get follower(): boolean
        get maxSpawnClusterSize(): number
        get multipartEntity(): boolean
        get maxSchoolSize(): number
        get parts(): Internal.PartEntity<any>[]
    }
    type AbstractSchoolingFish_ = AbstractSchoolingFish;
    class RenderStateShard$OverlayStateShard extends Internal.RenderStateShard$BooleanStateShard {
        constructor(arg0: boolean)
    }
    type RenderStateShard$OverlayStateShard_ = RenderStateShard$OverlayStateShard;
    interface GatheringByteChannel extends Internal.WritableByteChannel {
        write(arg0: Internal.ByteBuffer_[], arg1: number, arg2: number): number;
        write(arg0: Internal.ByteBuffer_[]): number;
    }
    type GatheringByteChannel_ = GatheringByteChannel;
    class ClientboundLevelChunkPacketData {
        constructor(arg0: Internal.FriendlyByteBuf_, arg1: number, arg2: number)
        constructor(arg0: Internal.LevelChunk_)
        write(arg0: Internal.FriendlyByteBuf_): void;
        getHeightmaps(): Internal.CompoundTag;
        getReadBuffer(): Internal.FriendlyByteBuf;
        static extractChunkData(arg0: Internal.FriendlyByteBuf_, arg1: Internal.LevelChunk_): void;
        getBlockEntitiesTagsConsumer(arg0: number, arg1: number): Internal.Consumer<Internal.ClientboundLevelChunkPacketData$BlockEntityTagOutput>;
        get heightmaps(): Internal.CompoundTag
        get readBuffer(): Internal.FriendlyByteBuf
    }
    type ClientboundLevelChunkPacketData_ = ClientboundLevelChunkPacketData;
    class MinecraftProfileTexture$Type extends Internal.Enum<Internal.MinecraftProfileTexture$Type> {
        static values(): Internal.MinecraftProfileTexture$Type[];
        static valueOf(arg0: string): Internal.MinecraftProfileTexture$Type;
        readonly static "CAPE": Internal.MinecraftProfileTexture$Type;
        readonly static "ELYTRA": Internal.MinecraftProfileTexture$Type;
        readonly static "SKIN": Internal.MinecraftProfileTexture$Type;
    }
    type MinecraftProfileTexture$Type_ = MinecraftProfileTexture$Type | "elytra" | "skin" | "cape";
    class RandomBooleanFeatureConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.Holder_<Internal.PlacedFeature_>, arg1: Internal.Holder_<Internal.PlacedFeature_>)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
        readonly "featureFalse": Internal.Holder<Internal.PlacedFeature>;
        readonly "featureTrue": Internal.Holder<Internal.PlacedFeature>;
    }
    type RandomBooleanFeatureConfiguration_ = RandomBooleanFeatureConfiguration;
    class MaterialColor$Brightness extends Internal.Enum<Internal.MaterialColor$Brightness> {
        static values(): Internal.MaterialColor$Brightness[];
        static byId(arg0: number): Internal.MaterialColor$Brightness;
        static valueOf(arg0: string): Internal.MaterialColor$Brightness;
        readonly static "LOWEST": Internal.MaterialColor$Brightness;
        readonly static "LOW": Internal.MaterialColor$Brightness;
        readonly "id": number;
        readonly "modifier": number;
        readonly static "HIGH": Internal.MaterialColor$Brightness;
        readonly static "NORMAL": Internal.MaterialColor$Brightness;
    }
    type MaterialColor$Brightness_ = "normal" | "high" | "low" | "lowest" | MaterialColor$Brightness;
    class ServerboundContainerClickPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.ClickType_, arg5: Internal.ItemStack_, arg6: Internal.Int2ObjectMap_<Internal.ItemStack_>)
        handle(arg0: Internal.PacketListener_): void;
        getButtonNum(): number;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getStateId(): number;
        getChangedSlots(): Internal.Int2ObjectMap<Internal.ItemStack>;
        getCarriedItem(): Internal.ItemStack;
        getSlotNum(): number;
        getClickType(): Internal.ClickType;
        getContainerId(): number;
        isSkippable(): boolean;
        get buttonNum(): number
        get stateId(): number
        get changedSlots(): Internal.Int2ObjectMap<Internal.ItemStack>
        get carriedItem(): Internal.ItemStack
        get slotNum(): number
        get clickType(): Internal.ClickType
        get containerId(): number
        get skippable(): boolean
    }
    type ServerboundContainerClickPacket_ = ServerboundContainerClickPacket;
    abstract class ScreenEvent$KeyboardKeyEvent extends Internal.ScreenEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number, arg3: number)
        getKeyCode(): number;
        getModifiers(): number;
        getListenerList(): Internal.ListenerList;
        getScanCode(): number;
        get keyCode(): number
        get modifiers(): number
        get listenerList(): Internal.ListenerList
        get scanCode(): number
    }
    type ScreenEvent$KeyboardKeyEvent_ = ScreenEvent$KeyboardKeyEvent;
    interface Holder <T> extends Internal.IReverseTag<T> {
        isValidInRegistry(arg0: Internal.Registry_<T>): boolean;
        hackyErase(arg0: Internal.Holder_<any>): this;
        containsTag(arg0: Internal.TagKey_<T>): boolean;
        isBound(): boolean;
        is(arg0: ResourceLocation_): boolean;
        direct(arg0: T): this;
        value(): T;
        is(arg0: Internal.Predicate_<Internal.ResourceKey_<T>>): boolean;
        unwrap(): Internal.Either<Internal.ResourceKey<T>, T>;
        unwrapKey(): Internal.Optional<Internal.ResourceKey<T>>;
        getTagKeys(): Internal.Stream<Internal.TagKey<T>>;
        kind(): Internal.Holder$Kind;
        is(arg0: Internal.ResourceKey_<T>): boolean;
        tags(): Internal.Stream<Internal.TagKey<T>>;
        containsTag(arg0: Internal.ITag_<T>): boolean;
        is(arg0: Internal.TagKey_<T>): boolean;
        get bound(): boolean
        get tagKeys(): Internal.Stream<Internal.TagKey<T>>
    }
    type Holder_<T> = Holder<T>;
    abstract class Pair <L, R> implements Internal.Map$Entry<L, R>, Internal.Comparable<Internal.Pair<L, R>>, Internal.Serializable {
        constructor()
        getKey(): L;
        toString(): string;
        getLeft(): L;
        static of(arg0: L, arg1: R): Internal.Pair<L, R>;
        getRight(): R;
        compareTo(arg0: Internal.Pair_<L, R>): number;
        static emptyArray(): Internal.Pair<L, R>[];
        compareTo(arg0: any): number;
        getValue(): R;
        hashCode(): number;
        static of(arg0: Internal.Map$Entry_<L, R>): Internal.Pair<L, R>;
        equals(arg0: any): boolean;
        toString(arg0: string): string;
        get key(): L
        get left(): L
        get right(): R
        get value(): R
        readonly static "EMPTY_ARRAY": any;
    }
    type Pair_<L, R> = Pair<L, R>;
    class Duration implements Internal.TemporalAmount, Internal.Comparable<Internal.Duration>, Internal.Serializable {
        static parse(arg0: Internal.CharSequence_): Internal.Duration;
        compareTo(arg0: any): number;
        minusHours(arg0: number): this;
        plusMillis(arg0: number): this;
        toNanosPart(): number;
        multipliedBy(arg0: number): this;
        getUnits(): Internal.List<Internal.TemporalUnit>;
        dividedBy(arg0: number): this;
        get(arg0: Internal.TemporalUnit_): number;
        minusNanos(arg0: number): this;
        static ofSeconds(arg0: number): Internal.Duration;
        static ofMinutes(arg0: number): Internal.Duration;
        minus(arg0: Internal.Duration_): this;
        isNegative(): boolean;
        static ofNanos(arg0: number): Internal.Duration;
        toDays(): number;
        toHoursPart(): number;
        toSecondsPart(): number;
        minusDays(arg0: number): this;
        static ofMillis(arg0: number): Internal.Duration;
        plusNanos(arg0: number): this;
        minusSeconds(arg0: number): this;
        toMinutes(): number;
        plus(arg0: number, arg1: Internal.TemporalUnit_): this;
        toMillis(): number;
        toHours(): number;
        getSeconds(): number;
        static ofSeconds(arg0: number, arg1: number): Internal.Duration;
        toMinutesPart(): number;
        isZero(): boolean;
        withSeconds(arg0: number): this;
        static of(arg0: number, arg1: Internal.TemporalUnit_): Internal.Duration;
        static between(arg0: Internal.Temporal_, arg1: Internal.Temporal_): Internal.Duration;
        plusSeconds(arg0: number): this;
        plusMinutes(arg0: number): this;
        toNanos(): number;
        negated(): this;
        static ofDays(arg0: number): Internal.Duration;
        addTo(arg0: Internal.Temporal_): Internal.Temporal;
        compareTo(arg0: Internal.Duration_): number;
        minus(arg0: number, arg1: Internal.TemporalUnit_): this;
        toString(): string;
        plus(arg0: Internal.Duration_): this;
        toDaysPart(): number;
        plusDays(arg0: number): this;
        plusHours(arg0: number): this;
        static from(arg0: Internal.TemporalAmount_): Internal.Duration;
        truncatedTo(arg0: Internal.TemporalUnit_): this;
        getNano(): number;
        subtractFrom(arg0: Internal.Temporal_): Internal.Temporal;
        minusMillis(arg0: number): this;
        hashCode(): number;
        dividedBy(arg0: Internal.Duration_): number;
        minusMinutes(arg0: number): this;
        abs(): this;
        static ofHours(arg0: number): Internal.Duration;
        equals(arg0: any): boolean;
        withNanos(arg0: number): this;
        toSeconds(): number;
        toMillisPart(): number;
        get units(): Internal.List<Internal.TemporalUnit>
        get negative(): boolean
        get seconds(): number
        get zero(): boolean
        get nano(): number
        readonly static "ZERO": Internal.Duration;
    }
    type Duration_ = Duration;
    class ServerboundJigsawGeneratePacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: BlockPos_, arg1: number, arg2: boolean)
        handle(arg0: Internal.PacketListener_): void;
        keepJigsaws(): boolean;
        getPos(): BlockPos;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        isSkippable(): boolean;
        levels(): number;
        get pos(): BlockPos
        get skippable(): boolean
    }
    type ServerboundJigsawGeneratePacket_ = ServerboundJigsawGeneratePacket;
    class ZoneOffset extends Internal.ZoneId implements Internal.TemporalAccessor, Internal.Comparable<Internal.ZoneOffset>, Internal.TemporalAdjuster, Internal.Serializable {
        static ofHoursMinutes(arg0: number, arg1: number): Internal.ZoneOffset;
        toString(): string;
        static ofTotalSeconds(arg0: number): Internal.ZoneOffset;
        compareTo(arg0: Internal.ZoneOffset_): number;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        static ofHours(arg0: number): Internal.ZoneOffset;
        query(arg0: Internal.TemporalQuery_<R>): R;
        static of(arg0: string): Internal.ZoneOffset;
        getId(): string;
        compareTo(arg0: any): number;
        static ofHoursMinutesSeconds(arg0: number, arg1: number, arg2: number): Internal.ZoneOffset;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        hashCode(): number;
        getRules(): Internal.ZoneRules;
        get(arg0: Internal.TemporalField_): number;
        getLong(arg0: Internal.TemporalField_): number;
        static from(arg0: Internal.TemporalAccessor_): Internal.ZoneOffset;
        equals(arg0: any): boolean;
        getTotalSeconds(): number;
        isSupported(arg0: Internal.TemporalField_): boolean;
        get id(): string
        get rules(): Internal.ZoneRules
        get totalSeconds(): number
        readonly static "MIN": Internal.ZoneOffset;
        readonly static "MAX": Internal.ZoneOffset;
        readonly static "UTC": Internal.ZoneOffset;
    }
    type ZoneOffset_ = ZoneOffset;
    abstract class HolderSet$ListBacked <T> implements Internal.HolderSet<T> {
        constructor()
        isValidInRegistry(arg0: Internal.Registry_<T>): boolean;
        getRandomElement(arg0: Internal.Random_): Internal.Optional<Internal.Holder<T>>;
        iterator(): Internal.Iterator<Internal.Holder<T>>;
        size(): number;
        forEach(arg0: Internal.Consumer_<any>): void;
        get(arg0: number): Internal.Holder<T>;
        spliterator(): Internal.Spliterator<Internal.Holder<T>>;
        stream(): Internal.Stream<Internal.Holder<T>>;
    }
    type HolderSet$ListBacked_<T> = HolderSet$ListBacked<T>;
    abstract class Triple <L, M, R> implements Internal.Comparable<Internal.Triple<L, M, R>>, Internal.Serializable {
        constructor()
        compareTo(arg0: Internal.Triple_<L, M, R>): number;
        hashCode(): number;
        getMiddle(): M;
        toString(): string;
        getLeft(): L;
        getRight(): R;
        static of(arg0: L, arg1: M, arg2: R): Internal.Triple<L, M, R>;
        equals(arg0: any): boolean;
        static emptyArray(): Internal.Triple<L, M, R>[];
        compareTo(arg0: any): number;
        toString(arg0: string): string;
        get middle(): M
        get left(): L
        get right(): R
        readonly static "EMPTY_ARRAY": any;
    }
    type Triple_<L, M, R> = Triple<L, M, R>;
    interface WeightedEntry {
        getWeight(): Internal.Weight;
        wrap(arg0: T, arg1: number): Internal.WeightedEntry$Wrapper<T>;
        get weight(): Internal.Weight
    }
    type WeightedEntry_ = WeightedEntry;
    class PlayerEvent$PlayerLoggedInEvent extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type PlayerEvent$PlayerLoggedInEvent_ = PlayerEvent$PlayerLoggedInEvent;
    class ScriptFile implements Internal.Comparable<Internal.ScriptFile> {
        constructor(p: Internal.ScriptPack_, i: Internal.ScriptFileInfo_, s: Internal.ScriptSource_)
        getError(): Internal.Throwable;
        load(): boolean;
        compareTo(o: Internal.ScriptFile_): number;
        compareTo(arg0: any): number;
        get error(): Internal.Throwable
        readonly "source": Internal.ScriptSource;
        readonly "info": Internal.ScriptFileInfo;
        readonly "pack": Internal.ScriptPack;
    }
    type ScriptFile_ = ScriptFile;
    class ModuleDescriptor$Version implements Internal.Comparable<Internal.ModuleDescriptor$Version> {
        hashCode(): number;
        compareTo(arg0: Internal.ModuleDescriptor$Version_): number;
        toString(): string;
        equals(arg0: any): boolean;
        static parse(arg0: string): Internal.ModuleDescriptor$Version;
        compareTo(arg0: any): number;
    }
    type ModuleDescriptor$Version_ = ModuleDescriptor$Version;
    class Ravager extends Internal.Raider {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getStepHeight(): number;
        getControllingPassenger(): Internal.Entity;
        asKJS(): Internal.EntityJS;
        canBeLeader(): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        getMaxHeadYRot(): number;
        serializeNBT(): Internal.Tag;
        checkSpawnObstruction(arg0: Internal.LevelReader_): boolean;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getCelebrateSound(): Internal.SoundEvent;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        getRoarTick(): number;
        canBeControlledByRider(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getPassengersRidingOffset(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStunnedTick(): number;
        getAttackTick(): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        hasLineOfSight(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        applyRaidBuffs(arg0: number, arg1: boolean): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get controllingPassenger(): Internal.Entity
        get multipartEntity(): boolean
        get maxHeadYRot(): number
        get celebrateSound(): Internal.SoundEvent
        get parts(): Internal.PartEntity<any>[]
        get roarTick(): number
        get passengersRidingOffset(): number
        get stunnedTick(): number
        get attackTick(): number
        readonly static "STUN_DURATION": 40;
    }
    type Ravager_ = Ravager;
    interface Reference2ShortFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToIntFunction<K> {
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Reference2FloatFunction<K>;
        put(arg0: K, arg1: number): number;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Reference2DoubleFunction<K>;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Reference2LongFunction<K>;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Reference2ByteFunction<K>;
        getOrDefault(arg0: any, arg1: any): any;
        remove(arg0: any): number;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Reference2IntFunction<K>;
        composeObject(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Object2ShortFunction<T>;
        andThenShort(arg0: Internal.Short2ShortFunction_): this;
        containsKey(arg0: any): boolean;
        defaultReturnValue(): number;
        composeReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Reference2ShortFunction<T>;
        getOrDefault(arg0: any, arg1: number): number;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2ShortFunction;
        apply(arg0: K): number;
        andThenReference(arg0: Internal.Short2ReferenceFunction_<any>): Internal.Reference2ReferenceFunction<K, T>;
        put(arg0: any, arg1: any): any;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2ShortFunction;
        getShort(arg0: any): number;
        removeShort(arg0: any): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        put(arg0: K, arg1: number): number;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2ShortFunction;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Reference2CharFunction<K>;
        andThenObject(arg0: Internal.Short2ObjectFunction_<any>): Internal.Reference2ObjectFunction<K, T>;
        applyAsInt(arg0: K): number;
        size(): number;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2ShortFunction;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2ShortFunction;
        defaultReturnValue(arg0: number): void;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        clear(): void;
        getOrDefault(arg0: any, arg1: number): number;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2ShortFunction;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2ShortFunction;
        get(arg0: any): any;
    }
    type Reference2ShortFunction_<K> = ((arg0: any)=>number) | Reference2ShortFunction<K>;
    abstract class MapCodec <A> extends Internal.CompressorHolder implements Internal.MapEncoder<A>, Internal.MapDecoder<A> {
        constructor()
        codec(): Internal.Codec<A>;
        forGetter(arg0: Internal.Function_<O, A>): Internal.RecordCodecBuilder<O, A>;
        flatXmap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.MapCodec<S>;
        ap(arg0: Internal.MapDecoder_<Internal.Function_<any, any>>): Internal.MapDecoder<E>;
        fieldOf(arg0: string): this;
        stable(): this;
        setPartial(arg0: Internal.Supplier_<A>): this;
        orElse(arg0: Internal.Consumer_<string>, arg1: A): this;
        compressedBuilder(arg0: Internal.DynamicOps_<T>): Internal.RecordBuilder<T>;
        map(arg0: Internal.Function_<any, any>): Internal.MapDecoder<B>;
        orElseGet(arg0: Internal.Consumer_<string>, arg1: Internal.Supplier_<any>): this;
        mapResult(arg0: Internal.MapCodec$ResultFunction_<A>): this;
        static of(arg0: Internal.MapEncoder_<A>, arg1: Internal.MapDecoder_<A>): Internal.MapCodec<A>;
        compressedDecode(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<A>;
        static unit(arg0: A): Internal.MapCodec<A>;
        deprecated(arg0: number): this;
        xmap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.MapCodec<S>;
        withLifecycle(arg0: Internal.Lifecycle_): Internal.MapEncoder<any>;
        dependent(arg0: Internal.MapCodec_<E>, arg1: Internal.Function_<A, com.mojang.datafixers.util.Pair_<E, Internal.MapCodec_<E>>>, arg2: Internal.BiFunction_<A, E, A>): this;
        orElseGet(arg0: Internal.Supplier_<any>): this;
        encoder(): Internal.Encoder<A>;
        keys(arg0: Internal.DynamicOps_<T>): Internal.Stream<T>;
        decoder(): Internal.Decoder<A>;
        static of(arg0: Internal.MapEncoder_<A>, arg1: Internal.MapDecoder_<A>, arg2: Internal.Supplier_<string>): Internal.MapCodec<A>;
        orElseGet(arg0: Internal.UnaryOperator_<string>, arg1: Internal.Supplier_<any>): this;
        flatMap(arg0: Internal.Function_<any, any>): Internal.MapDecoder<B>;
        comap(arg0: Internal.Function_<any, any>): Internal.MapEncoder<B>;
        flatComap(arg0: Internal.Function_<any, any>): Internal.MapEncoder<B>;
        static unit(arg0: Internal.Supplier_<A>): Internal.MapCodec<A>;
        orElse(arg0: A): this;
        orElse(arg0: Internal.UnaryOperator_<string>, arg1: A): this;
        set partial(arg0: Internal.Supplier_<A>)
    }
    type MapCodec_<A> = MapCodec<A>;
    class BakedQuad implements Internal.IVertexProducer {
        constructor(arg0: number[], arg1: number, arg2: Internal.Direction_, arg3: Internal.TextureAtlasSprite_, arg4: boolean)
        pipe(arg0: Internal.IVertexConsumer_): void;
        getSprite(): Internal.TextureAtlasSprite;
        getTintIndex(): number;
        isTinted(): boolean;
        getVertices(): number[];
        isShade(): boolean;
        getDirection(): Internal.Direction;
        get sprite(): Internal.TextureAtlasSprite
        get tintIndex(): number
        get tinted(): boolean
        get vertices(): number[]
        get shade(): boolean
        get direction(): Internal.Direction
    }
    type BakedQuad_ = BakedQuad;
    class ItemTransform {
        constructor(arg0: Internal.Vector3f_, arg1: Internal.Vector3f_, arg2: Internal.Vector3f_)
        hashCode(): number;
        apply(arg0: boolean, arg1: Internal.PoseStack_): void;
        equals(arg0: any): boolean;
        readonly static "NO_TRANSFORM": Internal.ItemTransform;
        readonly "scale": Internal.Vector3f;
        readonly "rotation": Internal.Vector3f;
        readonly "translation": Internal.Vector3f;
    }
    type ItemTransform_ = ItemTransform;
    abstract class TrunkPlacer {
        constructor(arg0: number, arg1: number, arg2: number)
        placeTrunk(arg0: Internal.LevelSimulatedReader_, arg1: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>, arg2: Internal.Random_, arg3: number, arg4: BlockPos_, arg5: Internal.TreeConfiguration_): Internal.List<Internal.FoliagePlacer$FoliageAttachment>;
        getTreeHeight(arg0: Internal.Random_): number;
        readonly static "MAX_HEIGHT": 80;
        readonly static "CODEC": any;
    }
    type TrunkPlacer_ = TrunkPlacer;
    interface Double2CharFunction extends it.unimi.dsi.fastutil.Function<number, string>, Internal.DoubleToIntFunction {
        put(arg0: number, arg1: string): string;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2CharFunction;
        getOrDefault(arg0: any, arg1: string): string;
        composeDouble(arg0: Internal.Double2DoubleFunction_): this;
        composeObject(arg0: Internal.Object2DoubleFunction_<any>): Internal.Object2CharFunction<T>;
        getOrDefault(arg0: any, arg1: any): any;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Double2DoubleFunction;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2CharFunction;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2CharFunction;
        defaultReturnValue(): string;
        put(arg0: number, arg1: string): string;
        containsKey(arg0: any): boolean;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2CharFunction;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Double2ByteFunction;
        defaultReturnValue(arg0: string): void;
        get(arg0: any): string;
        apply(arg0: number): string;
        andThenChar(arg0: Internal.Char2CharFunction_): this;
        put(arg0: any, arg1: any): any;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2CharFunction;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Double2IntFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Double2FloatFunction;
        getOrDefault(arg0: number, arg1: string): string;
        containsKey(arg0: number): boolean;
        composeReference(arg0: Internal.Reference2DoubleFunction_<any>): Internal.Reference2CharFunction<T>;
        size(): number;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Double2LongFunction;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2CharFunction;
        clear(): void;
        andThenObject(arg0: Internal.Char2ObjectFunction_<any>): Internal.Double2ObjectFunction<T>;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Double2ShortFunction;
        remove(arg0: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, string>;
        get(arg0: number): string;
        remove(arg0: number): string;
        applyAsInt(arg0: number): number;
        andThenReference(arg0: Internal.Char2ReferenceFunction_<any>): Internal.Double2ReferenceFunction<T>;
    }
    type Double2CharFunction_ = Double2CharFunction | ((arg0: number)=>string);
    class Half extends Internal.Enum<Internal.Half> implements Internal.StringRepresentable {
        static values(): Internal.Half[];
        toString(): string;
        getSerializedName(): string;
        static valueOf(arg0: string): Internal.Half;
        get serializedName(): string
        readonly static "TOP": Internal.Half;
        readonly static "BOTTOM": Internal.Half;
    }
    type Half_ = Half | "bottom" | "top";
    interface IntSpliterator extends Internal.Spliterator$OfInt {
        forEachRemaining(arg0: any): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        getComparator(): Internal.Comparator<any>;
        trySplit(): Internal.Spliterator<any>;
        getExactSizeIfKnown(): number;
        hasCharacteristics(arg0: number): boolean;
        tryAdvance(arg0: Internal.Consumer_<any>): boolean;
        forEachRemaining(arg0: it.unimi.dsi.fastutil.ints.IntConsumer_): void;
        forEachRemaining(arg0: Internal.IntConsumer_): void;
        skip(arg0: number): number;
        tryAdvance(arg0: any): boolean;
        tryAdvance(arg0: it.unimi.dsi.fastutil.ints.IntConsumer_): boolean;
        get comparator(): Internal.Comparator<any>
        get exactSizeIfKnown(): number
    }
    type IntSpliterator_ = IntSpliterator;
    interface EventExecutor extends Internal.EventExecutorGroup {
        inEventLoop(arg0: Internal.Thread_): boolean;
        parent(): Internal.EventExecutorGroup;
        newPromise(): Internal.Promise<V>;
        next(): this;
        newProgressivePromise(): Internal.ProgressivePromise<V>;
        forEach(arg0: Internal.Consumer_<any>): void;
        newFailedFuture(arg0: Internal.Throwable_): io.netty.util.concurrent.Future<V>;
        newSucceededFuture(arg0: V): io.netty.util.concurrent.Future<V>;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        inEventLoop(): boolean;
    }
    type EventExecutor_ = EventExecutor;
    class VertexFormat$IndexType extends Internal.Enum<Internal.VertexFormat$IndexType> {
        static values(): Internal.VertexFormat$IndexType[];
        static valueOf(arg0: string): Internal.VertexFormat$IndexType;
        static least(arg0: number): Internal.VertexFormat$IndexType;
        readonly static "SHORT": Internal.VertexFormat$IndexType;
        readonly "asGLType": number;
        readonly static "BYTE": Internal.VertexFormat$IndexType;
        readonly static "INT": Internal.VertexFormat$IndexType;
        readonly "bytes": number;
    }
    type VertexFormat$IndexType_ = VertexFormat$IndexType | "int" | "short" | "byte";
    class CaveSurface extends Internal.Enum<Internal.CaveSurface> implements Internal.StringRepresentable {
        static byName(arg0: string): Internal.CaveSurface;
        getY(): number;
        getSerializedName(): string;
        static values(): Internal.CaveSurface[];
        static valueOf(arg0: string): Internal.CaveSurface;
        getDirection(): Internal.Direction;
        get y(): number
        get serializedName(): string
        get direction(): Internal.Direction
        readonly static "FLOOR": Internal.CaveSurface;
        readonly static "CEILING": Internal.CaveSurface;
        readonly static "CODEC": any;
    }
    type CaveSurface_ = "floor" | CaveSurface | "ceiling";
    class ChannelOption <T> extends Internal.AbstractConstant<Internal.ChannelOption<T>> {
        static valueOf(arg0: Internal.Class_<any>, arg1: string): Internal.ChannelOption<T>;
        static newInstance(arg0: string): Internal.ChannelOption<T>;
        validate(arg0: T): void;
        static valueOf(arg0: string): Internal.ChannelOption<T>;
        static exists(arg0: string): boolean;
        readonly static "IP_TOS": Internal.ChannelOption<any>;
        readonly static "IP_MULTICAST_LOOP_DISABLED": Internal.ChannelOption<any>;
        readonly static "IP_MULTICAST_IF": Internal.ChannelOption<any>;
        readonly static "AUTO_READ": Internal.ChannelOption<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "MAX_MESSAGES_PER_READ": Internal.ChannelOption<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "WRITE_BUFFER_HIGH_WATER_MARK": Internal.ChannelOption<any>;
        readonly static "WRITE_SPIN_COUNT": Internal.ChannelOption<any>;
        readonly static "SO_TIMEOUT": Internal.ChannelOption<any>;
        readonly static "SO_RCVBUF": Internal.ChannelOption<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "WRITE_BUFFER_LOW_WATER_MARK": Internal.ChannelOption<any>;
        readonly static "SO_LINGER": Internal.ChannelOption<any>;
        readonly static "TCP_FASTOPEN": Internal.ChannelOption<any>;
        readonly static "AUTO_CLOSE": Internal.ChannelOption<any>;
        readonly static "IP_MULTICAST_ADDR": Internal.ChannelOption<any>;
        readonly static "SO_KEEPALIVE": Internal.ChannelOption<any>;
        readonly static "IP_MULTICAST_TTL": Internal.ChannelOption<any>;
        readonly static "ALLOW_HALF_CLOSURE": Internal.ChannelOption<any>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION": Internal.ChannelOption<any>;
        readonly static "MAX_MESSAGES_PER_WRITE": Internal.ChannelOption<any>;
        readonly static "RCVBUF_ALLOCATOR": Internal.ChannelOption<any>;
        readonly static "SO_BROADCAST": Internal.ChannelOption<any>;
        readonly static "SO_BACKLOG": Internal.ChannelOption<any>;
        readonly static "ALLOCATOR": Internal.ChannelOption<any>;
        readonly static "CONNECT_TIMEOUT_MILLIS": Internal.ChannelOption<any>;
        readonly static "TCP_FASTOPEN_CONNECT": Internal.ChannelOption<any>;
        readonly static "SINGLE_EVENTEXECUTOR_PER_GROUP": Internal.ChannelOption<any>;
        readonly static "SO_SNDBUF": Internal.ChannelOption<any>;
        readonly static "MESSAGE_SIZE_ESTIMATOR": Internal.ChannelOption<any>;
        readonly static "SO_REUSEADDR": Internal.ChannelOption<any>;
        readonly static "WRITE_BUFFER_WATER_MARK": Internal.ChannelOption<any>;
        readonly static "TCP_NODELAY": Internal.ChannelOption<any>;
    }
    type ChannelOption_<T> = ChannelOption<T>;
    class EntityType <T> extends Internal.ForgeRegistryEntry<Internal.EntityType<any>> implements Internal.InjectedEntityTypeExtension, Internal.EntityTypeTest<Internal.Entity, T> {
        constructor(arg0: any_<T>, arg1: Internal.MobCategory_, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: Internal.ImmutableSet_<Internal.Block_>, arg7: Internal.EntityDimensions_, arg8: number, arg9: number)
        constructor(arg0: any_<T>, arg1: Internal.MobCategory_, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: Internal.ImmutableSet_<Internal.Block_>, arg7: Internal.EntityDimensions_, arg8: number, arg9: number, arg10: Internal.Predicate_<Internal.EntityType_<any>>, arg11: Internal.ToIntFunction_<Internal.EntityType_<any>>, arg12: Internal.ToIntFunction_<Internal.EntityType_<any>>, arg13: Internal.BiFunction_<Internal.PlayMessages$SpawnEntity_, Internal.Level_, T>)
        isBlockDangerous(arg0: Internal.BlockState_): boolean;
        spawn(arg0: Internal.ServerLevel_, arg1: Internal.CompoundTag_, arg2: Internal.Component_, arg3: Internal.Player_, arg4: BlockPos_, arg5: Internal.MobSpawnType_, arg6: boolean, arg7: boolean): T;
        arch$holder(): Internal.Holder<Internal.EntityType<any>>;
        tryCast(arg0: Internal.Entity_): T;
        toShortString(): string;
        static loadEntitiesRecursive(arg0: Internal.List_<any>, arg1: Internal.Level_): Internal.Stream<Internal.Entity>;
        builtInRegistryHolder(): Internal.Holder$Reference<Internal.EntityType<any>>;
        getBaseClass(): Internal.Class<any>;
        customClientSpawn(arg0: Internal.PlayMessages$SpawnEntity_, arg1: Internal.Level_): T;
        clientTrackingRange(): number;
        getCategory(): Internal.MobCategory;
        getDefaultLootTable(): ResourceLocation;
        getWidth(): number;
        getAABB(arg0: number, arg1: number, arg2: number): Internal.AABB;
        spawn(arg0: Internal.ServerLevel_, arg1: Internal.ItemStack_, arg2: Internal.Player_, arg3: BlockPos_, arg4: Internal.MobSpawnType_, arg5: boolean, arg6: boolean): Internal.Entity;
        static loadEntityRecursive(arg0: Internal.CompoundTag_, arg1: Internal.Level_, arg2: Internal.Function_<Internal.Entity_, Internal.Entity_>): Internal.Entity;
        tryCast(arg0: any): any;
        getHeight(): number;
        fireImmune(): boolean;
        arch$registryName(): ResourceLocation;
        getDescriptionId(): string;
        getTags(): Internal.Stream<Internal.TagKey<Internal.EntityType<any>>>;
        canSpawnFarFromPlayer(): boolean;
        static by(arg0: Internal.CompoundTag_): Internal.Optional<Internal.EntityType<any>>;
        static getKey(arg0: Internal.EntityType_<any>): ResourceLocation;
        canSummon(): boolean;
        updateInterval(): number;
        static byString(arg0: string): Internal.Optional<Internal.EntityType<any>>;
        getDimensions(): Internal.EntityDimensions;
        toString(): string;
        create(arg0: Internal.Level_): T;
        static create(arg0: Internal.CompoundTag_, arg1: Internal.Level_): Internal.Optional<Internal.Entity>;
        trackDeltas(): boolean;
        canSerialize(): boolean;
        create(arg0: Internal.ServerLevel_, arg1: Internal.CompoundTag_, arg2: Internal.Component_, arg3: Internal.Player_, arg4: BlockPos_, arg5: Internal.MobSpawnType_, arg6: boolean, arg7: boolean): T;
        static create(arg0: number, arg1: Internal.Level_): Internal.Entity;
        is(arg0: Internal.TagKey_<Internal.EntityType_<any>>): boolean;
        getDescription(): Internal.Component;
        static updateCustomEntityTag(arg0: Internal.Level_, arg1: Internal.Player_, arg2: Internal.Entity_, arg3: Internal.CompoundTag_): void;
        get baseClass(): Internal.Class<any>
        get category(): Internal.MobCategory
        get defaultLootTable(): ResourceLocation
        get width(): number
        get height(): number
        get descriptionId(): string
        get tags(): Internal.Stream<Internal.TagKey<Internal.EntityType<any>>>
        get dimensions(): Internal.EntityDimensions
        get description(): Internal.Component
        readonly static "TURTLE": Internal.EntityType<any>;
        readonly static "EVOKER": Internal.EntityType<any>;
        readonly static "SHULKER_BULLET": Internal.EntityType<any>;
        readonly static "ARROW": Internal.EntityType<any>;
        readonly static "DOLPHIN": Internal.EntityType<any>;
        readonly static "PUFFERFISH": Internal.EntityType<any>;
        readonly static "HUSK": Internal.EntityType<any>;
        readonly static "PANDA": Internal.EntityType<any>;
        readonly static "ENDER_DRAGON": Internal.EntityType<any>;
        readonly static "PILLAGER": Internal.EntityType<any>;
        readonly static "GUARDIAN": Internal.EntityType<any>;
        readonly static "PIG": Internal.EntityType<any>;
        readonly static "WITCH": Internal.EntityType<any>;
        readonly static "ITEM_FRAME": Internal.EntityType<any>;
        readonly static "FURNACE_MINECART": Internal.EntityType<any>;
        readonly static "AREA_EFFECT_CLOUD": Internal.EntityType<any>;
        readonly static "STRAY": Internal.EntityType<any>;
        readonly static "OCELOT": Internal.EntityType<any>;
        readonly static "CAVE_SPIDER": Internal.EntityType<any>;
        readonly static "VINDICATOR": Internal.EntityType<any>;
        readonly static "CHEST_MINECART": Internal.EntityType<any>;
        readonly static "TNT": Internal.EntityType<any>;
        readonly static "WITHER": Internal.EntityType<any>;
        readonly static "ENDER_PEARL": Internal.EntityType<any>;
        readonly static "CHICKEN": Internal.EntityType<any>;
        readonly static "END_CRYSTAL": Internal.EntityType<any>;
        readonly static "ARMOR_STAND": Internal.EntityType<any>;
        readonly static "PHANTOM": Internal.EntityType<any>;
        readonly static "FIREBALL": Internal.EntityType<any>;
        readonly static "SALMON": Internal.EntityType<any>;
        readonly static "WITHER_SKULL": Internal.EntityType<any>;
        readonly static "BAT": Internal.EntityType<any>;
        readonly static "SMALL_FIREBALL": Internal.EntityType<any>;
        readonly static "PAINTING": Internal.EntityType<any>;
        readonly static "WOLF": Internal.EntityType<any>;
        readonly static "GHAST": Internal.EntityType<any>;
        readonly static "MARKER": Internal.EntityType<any>;
        readonly static "ZOGLIN": Internal.EntityType<any>;
        readonly static "SHEEP": Internal.EntityType<any>;
        readonly static "ZOMBIE_VILLAGER": Internal.EntityType<any>;
        readonly static "SPECTRAL_ARROW": Internal.EntityType<any>;
        readonly static "ENTITY_TAG": "EntityTag";
        readonly static "CREEPER": Internal.EntityType<any>;
        readonly static "SPIDER": Internal.EntityType<any>;
        readonly static "LLAMA": Internal.EntityType<any>;
        readonly static "BLAZE": Internal.EntityType<any>;
        readonly static "TNT_MINECART": Internal.EntityType<any>;
        readonly static "GLOW_SQUID": Internal.EntityType<any>;
        readonly static "FOX": Internal.EntityType<any>;
        readonly static "SILVERFISH": Internal.EntityType<any>;
        readonly static "SQUID": Internal.EntityType<any>;
        readonly static "WITHER_SKELETON": Internal.EntityType<any>;
        readonly static "ZOMBIFIED_PIGLIN": Internal.EntityType<any>;
        readonly static "COD": Internal.EntityType<any>;
        readonly static "SPAWNER_MINECART": Internal.EntityType<any>;
        readonly static "COMMAND_BLOCK_MINECART": Internal.EntityType<any>;
        readonly static "GLOW_ITEM_FRAME": Internal.EntityType<any>;
        readonly static "ZOMBIE_HORSE": Internal.EntityType<any>;
        readonly static "STRIDER": Internal.EntityType<any>;
        readonly static "SLIME": Internal.EntityType<any>;
        readonly static "MULE": Internal.EntityType<any>;
        readonly static "TRADER_LLAMA": Internal.EntityType<any>;
        readonly static "DROWNED": Internal.EntityType<any>;
        readonly static "EVOKER_FANGS": Internal.EntityType<any>;
        readonly static "MINECART": Internal.EntityType<any>;
        readonly static "PIGLIN": Internal.EntityType<any>;
        readonly static "EXPERIENCE_ORB": Internal.EntityType<any>;
        readonly static "LLAMA_SPIT": Internal.EntityType<any>;
        readonly static "TROPICAL_FISH": Internal.EntityType<any>;
        readonly static "IRON_GOLEM": Internal.EntityType<any>;
        readonly static "VEX": Internal.EntityType<any>;
        readonly static "EXPERIENCE_BOTTLE": Internal.EntityType<any>;
        readonly static "ENDERMITE": Internal.EntityType<any>;
        readonly static "BOAT": Internal.EntityType<any>;
        readonly static "EYE_OF_ENDER": Internal.EntityType<any>;
        readonly static "WANDERING_TRADER": Internal.EntityType<any>;
        readonly static "SNOW_GOLEM": Internal.EntityType<any>;
        readonly static "SNOWBALL": Internal.EntityType<any>;
        readonly static "VILLAGER": Internal.EntityType<any>;
        readonly static "FIREWORK_ROCKET": Internal.EntityType<any>;
        readonly static "LEASH_KNOT": Internal.EntityType<any>;
        readonly static "RAVAGER": Internal.EntityType<any>;
        readonly static "MAGMA_CUBE": Internal.EntityType<any>;
        readonly static "ZOMBIE": Internal.EntityType<any>;
        readonly static "CAT": Internal.EntityType<any>;
        readonly static "HOGLIN": Internal.EntityType<any>;
        readonly static "GOAT": Internal.EntityType<any>;
        readonly static "PARROT": Internal.EntityType<any>;
        readonly static "AXOLOTL": Internal.EntityType<any>;
        readonly static "DRAGON_FIREBALL": Internal.EntityType<any>;
        readonly static "PIGLIN_BRUTE": Internal.EntityType<any>;
        readonly static "POLAR_BEAR": Internal.EntityType<any>;
        readonly static "ELDER_GUARDIAN": Internal.EntityType<any>;
        readonly static "ENDERMAN": Internal.EntityType<any>;
        readonly static "BEE": Internal.EntityType<any>;
        readonly static "POTION": Internal.EntityType<any>;
        readonly static "HOPPER_MINECART": Internal.EntityType<any>;
        readonly static "SKELETON": Internal.EntityType<any>;
        readonly static "PLAYER": Internal.EntityType<any>;
        readonly static "SHULKER": Internal.EntityType<any>;
        readonly static "GIANT": Internal.EntityType<any>;
        readonly static "FISHING_BOBBER": Internal.EntityType<any>;
        readonly static "FALLING_BLOCK": Internal.EntityType<any>;
        readonly static "COW": Internal.EntityType<any>;
        readonly static "TRIDENT": Internal.EntityType<any>;
        readonly static "SKELETON_HORSE": Internal.EntityType<any>;
        readonly static "ITEM": Internal.EntityType<any>;
        readonly static "HORSE": Internal.EntityType<any>;
        readonly static "ILLUSIONER": Internal.EntityType<any>;
        readonly static "LIGHTNING_BOLT": Internal.EntityType<any>;
        readonly static "MOOSHROOM": Internal.EntityType<any>;
        readonly static "RABBIT": Internal.EntityType<any>;
        readonly static "DONKEY": Internal.EntityType<any>;
        readonly static "EGG": Internal.EntityType<any>;
    }
    type EntityType_<T> = Special.EntityType | EntityType<T>;
    class CommandRegistryEventJS extends Internal.ServerEventJS {
        constructor(dispatcher: Internal.CommandDispatcher_<Internal.CommandSourceStack_>, selection: Internal.Commands$CommandSelection_)
        register(command: Internal.LiteralArgumentBuilder_<Internal.CommandSourceStack_>): Internal.LiteralCommandNode<Internal.CommandSourceStack>;
        isForMultiPlayer(): boolean;
        getBuiltinSuggestions(): Internal.ClassWrapper<Internal.SharedSuggestionProvider>;
        isForSinglePlayer(): boolean;
        getCommands(): Internal.ClassWrapper<Internal.Commands>;
        getArguments(): Internal.ClassWrapper<Internal.ArgumentTypeWrapper>;
        get forMultiPlayer(): boolean
        get builtinSuggestions(): Internal.ClassWrapper<Internal.SharedSuggestionProvider>
        get forSinglePlayer(): boolean
        get commands(): Internal.ClassWrapper<Internal.Commands>
        get arguments(): Internal.ClassWrapper<Internal.ArgumentTypeWrapper>
        readonly "selection": Internal.Commands$CommandSelection;
        readonly "dispatcher": Internal.CommandDispatcher<Internal.CommandSourceStack>;
    }
    type CommandRegistryEventJS_ = CommandRegistryEventJS;
    interface DoubleFunction <R> {
        apply(arg0: number): R;
    }
    type DoubleFunction_<R> = DoubleFunction<R> | ((arg0: number)=>R);
    class ArmorDyeRecipe extends Internal.CustomRecipe {
        constructor(arg0: ResourceLocation_)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        getSerializer(): Internal.RecipeSerializer<any>;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        matches(arg0: Internal.CraftingContainer_, arg1: Internal.Level_): boolean;
        isIncomplete(): boolean;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        assemble(arg0: Internal.CraftingContainer_): Internal.ItemStack;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get serializer(): Internal.RecipeSerializer<any>
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get incomplete(): boolean
    }
    type ArmorDyeRecipe_ = ArmorDyeRecipe;
    class Criterion {
        constructor(arg0: Internal.CriterionTriggerInstance_)
        constructor()
        getTrigger(): Internal.CriterionTriggerInstance;
        serializeToJson(): Internal.JsonElement;
        static criterionFromJson(arg0: Internal.JsonObject_, arg1: Internal.DeserializationContext_): Internal.Criterion;
        static criterionFromNetwork(arg0: Internal.FriendlyByteBuf_): Internal.Criterion;
        static criteriaFromNetwork(arg0: Internal.FriendlyByteBuf_): Internal.Map<string, Internal.Criterion>;
        static criteriaFromJson(arg0: Internal.JsonObject_, arg1: Internal.DeserializationContext_): Internal.Map<string, Internal.Criterion>;
        serializeToNetwork(arg0: Internal.FriendlyByteBuf_): void;
        static serializeToNetwork(arg0: Internal.Map_<string, Internal.Criterion_>, arg1: Internal.FriendlyByteBuf_): void;
        get trigger(): Internal.CriterionTriggerInstance
    }
    type Criterion_ = Criterion;
    class ClientboundLevelEventPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: BlockPos_, arg2: number, arg3: boolean)
        handle(arg0: Internal.PacketListener_): void;
        getPos(): BlockPos;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getType(): number;
        getData(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isGlobalEvent(): boolean;
        isSkippable(): boolean;
        get pos(): BlockPos
        get type(): number
        get data(): number
        get globalEvent(): boolean
        get skippable(): boolean
    }
    type ClientboundLevelEventPacket_ = ClientboundLevelEventPacket;
    abstract class Locale$IsoCountryCode extends Internal.Enum<Internal.Locale$IsoCountryCode> {
        static valueOf(arg0: string): Internal.Locale$IsoCountryCode;
        static values(): Internal.Locale$IsoCountryCode[];
        readonly static "PART1_ALPHA2": any;
        readonly static "PART1_ALPHA3": any;
        readonly static "PART3": any;
    }
    type Locale$IsoCountryCode_ = Locale$IsoCountryCode | "part1_alpha2" | "part3" | "part1_alpha3";
    class GeodeConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.GeodeBlockSettings_, arg1: Internal.GeodeLayerSettings_, arg2: Internal.GeodeCrackSettings_, arg3: number, arg4: number, arg5: boolean, arg6: Internal.IntProvider_, arg7: Internal.IntProvider_, arg8: Internal.IntProvider_, arg9: number, arg10: number, arg11: number, arg12: number)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
        readonly "placementsRequireLayer0Alternate": boolean;
        readonly "geodeLayerSettings": Internal.GeodeLayerSettings;
        readonly "minGenOffset": number;
        readonly "geodeBlockSettings": Internal.GeodeBlockSettings;
        readonly "usePotentialPlacementsChance": number;
        readonly "distributionPoints": Internal.IntProvider;
        readonly "maxGenOffset": number;
        readonly static "CHANCE_RANGE": any;
        readonly "noiseMultiplier": number;
        readonly "useAlternateLayer0Chance": number;
        readonly "geodeCrackSettings": Internal.GeodeCrackSettings;
        readonly "outerWallDistance": Internal.IntProvider;
        readonly "pointOffset": Internal.IntProvider;
        readonly "invalidBlocksThreshold": number;
    }
    type GeodeConfiguration_ = GeodeConfiguration;
    interface SearchTree <T> {
        search(arg0: string): Internal.List<T>;
    }
    type SearchTree_<T> = SearchTree<T>;
    interface BlockKJS extends Internal.BlockBuilderProvider {
        getBlockBuilderKJS(): Internal.BlockBuilder;
        getTypeDataKJS(): Internal.CompoundTag;
        setSpeedFactorKJS(v: number): void;
        setFrictionKJS(v: number): void;
        getBlockStatesKJS(): Internal.List<Internal.BlockState>;
        setMaterialKJS(v: Internal.Material_): void;
        setSoundTypeKJS(v: Internal.SoundType_): void;
        setIsRandomlyTickingKJS(v: boolean): void;
        setExplosionResistanceKJS(v: number): void;
        setJumpFactorKJS(v: number): void;
        setBlockBuilderKJS(b: Internal.BlockBuilder_): void;
        setHasCollisionKJS(v: boolean): void;
        get blockBuilderKJS(): Internal.BlockBuilder
        get typeDataKJS(): Internal.CompoundTag
        set speedFactorKJS(v: number)
        set frictionKJS(v: number)
        get blockStatesKJS(): Internal.List<Internal.BlockState>
        set materialKJS(v: Internal.Material_)
        set soundTypeKJS(v: Internal.SoundType_)
        set isRandomlyTickingKJS(v: boolean)
        set explosionResistanceKJS(v: number)
        set jumpFactorKJS(v: number)
        set blockBuilderKJS(b: Internal.BlockBuilder_)
        set hasCollisionKJS(v: boolean)
    }
    type BlockKJS_ = BlockKJS;
    class ShovelItemBuilder extends Internal.HandheldItemBuilder {
        constructor(i: ResourceLocation_)
        createObject(): Internal.Item;
    }
    type ShovelItemBuilder_ = ShovelItemBuilder;
    class PermissionGatherEvent extends Internal.Event {
        constructor()
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type PermissionGatherEvent_ = PermissionGatherEvent;
    interface DensityFunction$Visitor extends Internal.Function<Internal.DensityFunction, Internal.DensityFunction> {
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<Internal.DensityFunction, V>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, Internal.DensityFunction>;
    }
    type DensityFunction$Visitor_ = DensityFunction$Visitor;
    class AddOreProperties {
        constructor()
        aboveBottom(y: number): Internal.VerticalAnchor;
        size(s: number): this;
        belowTop(y: number): Internal.VerticalAnchor;
        bottom(): Internal.VerticalAnchor;
        count(c: number): this;
        addTarget(ruleTest: Internal.RuleTest_, targetState: BlockStatePredicate_): void;
        squared(): this;
        triangleHeight(absolute: Internal.VerticalAnchor_, absolute1: Internal.VerticalAnchor_): this;
        triangleHeight(min: number, max: number): this;
        top(): Internal.VerticalAnchor;
        count(c: Internal.IntProvider_): this;
        count(min: number, max: number): this;
        chance(c: number): this;
        uniformHeight(absolute: Internal.VerticalAnchor_, absolute1: Internal.VerticalAnchor_): this;
        uniformHeight(min: number, max: number): this;
        "height": Internal.HeightRangePlacement;
        "retrogen": number;
        "count": Internal.IntProvider;
        "worldgenLayer": DecorationGenerationStep;
        "chance": number;
        "squared": boolean;
        "noSurface": number;
        "biomes": Internal.BiomeFilter;
        "size": number;
        "id": ResourceLocation;
        "targets": Internal.List<Internal.OreConfiguration$TargetBlockState>;
    }
    type AddOreProperties_ = AddOreProperties;
    class ClientboundKeepAlivePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getId(): number;
        isSkippable(): boolean;
        get id(): number
        get skippable(): boolean
    }
    type ClientboundKeepAlivePacket_ = ClientboundKeepAlivePacket;
    class VarHandle$VarHandleDesc extends Internal.DynamicConstantDesc<Internal.VarHandle> {
        toString(): string;
        static ofArray(arg0: Internal.ClassDesc_): Internal.VarHandle$VarHandleDesc;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup_): any;
        static ofField(arg0: Internal.ClassDesc_, arg1: string, arg2: Internal.ClassDesc_): Internal.VarHandle$VarHandleDesc;
        static ofStaticField(arg0: Internal.ClassDesc_, arg1: string, arg2: Internal.ClassDesc_): Internal.VarHandle$VarHandleDesc;
        varType(): Internal.ClassDesc;
    }
    type VarHandle$VarHandleDesc_ = VarHandle$VarHandleDesc;
    abstract class RenderLayer <T, M> {
        constructor(arg0: Internal.RenderLayerParent_<T, M>)
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource_, arg2: number, arg3: T, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number): void;
        getParentModel(): M;
        get parentModel(): M
    }
    type RenderLayer_<T, M> = RenderLayer<T, M>;
    class DataLayer {
        constructor()
        constructor(arg0: number[])
        getData(): number[];
        get(arg0: number, arg1: number, arg2: number): number;
        toString(): string;
        copy(): this;
        layerToString(arg0: number): string;
        set(arg0: number, arg1: number, arg2: number, arg3: number): void;
        isEmpty(): boolean;
        get data(): number[]
        get empty(): boolean
        readonly static "LAYER_SIZE": 128;
        readonly static "SIZE": 2048;
        readonly static "LAYER_COUNT": 16;
    }
    type DataLayer_ = DataLayer;
    class ClientboundSetEquipmentPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: Internal.List_<com.mojang.datafixers.util.Pair_<EquipmentSlot_, Internal.ItemStack_>>)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getEntity(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getSlots(): Internal.List<com.mojang.datafixers.util.Pair<EquipmentSlot, Internal.ItemStack>>;
        isSkippable(): boolean;
        get entity(): number
        get slots(): Internal.List<com.mojang.datafixers.util.Pair<EquipmentSlot, Internal.ItemStack>>
        get skippable(): boolean
    }
    type ClientboundSetEquipmentPacket_ = ClientboundSetEquipmentPacket;
    class CanyonCarverConfiguration extends Internal.CarverConfiguration {
        constructor(arg0: number, arg1: Internal.HeightProvider_, arg2: Internal.FloatProvider_, arg3: Internal.VerticalAnchor_, arg4: Internal.CarverDebugSettings_, arg5: Internal.FloatProvider_, arg6: Internal.CanyonCarverConfiguration$CanyonShapeConfiguration_)
        constructor(arg0: Internal.CarverConfiguration_, arg1: Internal.FloatProvider_, arg2: Internal.CanyonCarverConfiguration$CanyonShapeConfiguration_)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
        readonly "shape": Internal.CanyonCarverConfiguration$CanyonShapeConfiguration;
        readonly "verticalRotation": Internal.FloatProvider;
    }
    type CanyonCarverConfiguration_ = CanyonCarverConfiguration;
    class Abilities {
        constructor()
        addSaveData(arg0: Internal.CompoundTag_): void;
        getFlyingSpeed(): number;
        setWalkingSpeed(arg0: number): void;
        setFlyingSpeed(arg0: number): void;
        getWalkingSpeed(): number;
        loadSaveData(arg0: Internal.CompoundTag_): void;
        get flyingSpeed(): number
        set walkingSpeed(arg0: number)
        set flyingSpeed(arg0: number)
        get walkingSpeed(): number
        "instabuild": boolean;
        "flying": boolean;
        "invulnerable": boolean;
        "mayfly": boolean;
        "mayBuild": boolean;
    }
    type Abilities_ = Abilities;
    interface FloatCollection extends Internal.FloatIterable, Internal.Collection<number> {
        containsAll(arg0: Internal.FloatCollection_): boolean;
        retainAll(arg0: Internal.FloatCollection_): boolean;
        forEach(arg0: Internal.Consumer_<any>): void;
        addAll(arg0: Internal.FloatCollection_): boolean;
        removeIf(arg0: Internal.DoublePredicate_): boolean;
        iterator(): Internal.FloatIterator;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        contains(arg0: number): boolean;
        doubleParallelStream(): Internal.DoubleStream;
        doubleStream(): Internal.DoubleStream;
        parallelStream(): Internal.Stream<number>;
        contains(arg0: any): boolean;
        forEach(arg0: Internal.FloatConsumer_): void;
        rem(arg0: number): boolean;
        toArray(arg0: number[]): number[];
        remove(arg0: any): boolean;
        doubleIterator(): Internal.DoubleIterator;
        add(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        doubleSpliterator(): Internal.DoubleSpliterator;
        spliterator(): Internal.Spliterator<any>;
        forEach(arg0: Internal.DoubleConsumer_): void;
        removeIf(arg0: Internal.FloatPredicate_): boolean;
        toFloatArray(arg0: number[]): number[];
        add(arg0: number): boolean;
        removeAll(arg0: Internal.FloatCollection_): boolean;
        stream(): Internal.Stream<number>;
        add(arg0: number): boolean;
        toFloatArray(): number[];
    }
    type FloatCollection_ = FloatCollection;
    class IntegratedServer extends Internal.MinecraftServer {
        constructor(arg0: Internal.Thread_, arg1: Internal.Minecraft_, arg2: Internal.LevelStorageSource$LevelStorageAccess_, arg3: Internal.PackRepository_, arg4: Internal.WorldStem_, arg5: Internal.MinecraftSessionService_, arg6: Internal.GameProfileRepository_, arg7: Internal.GameProfileCache_, arg8: any_)
        tickServer(arg0: Internal.BooleanSupplier_): void;
        ask(arg0: Internal.Function_<any, any>): Internal.CompletableFuture<Source>;
        forceSynchronousWrites(): boolean;
        fillServerSystemReport(arg0: Internal.SystemReport_): Internal.SystemReport;
        getPort(): number;
        getFunctionCompilationLevel(): number;
        setDefaultGameType(arg0: Internal.GameType_): void;
        isSingleplayerOwner(arg0: Internal.GameProfile_): boolean;
        isCommandBlockEnabled(): boolean;
        initServer(): boolean;
        getServerDirectory(): Internal.File;
        onServerCrash(arg0: Internal.CrashReport_): void;
        askEither(arg0: Internal.Function_<any, any>): Internal.CompletableFuture<Source>;
        isPublished(): boolean;
        halt(arg0: boolean): void;
        getScaledTrackingDistance(arg0: number): number;
        publishServer(arg0: Internal.GameType_, arg1: boolean, arg2: number): boolean;
        getRateLimitPacketsPerSecond(): number;
        isEpollEnabled(): boolean;
        getOperatorUserPermissionLevel(): number;
        stopServer(): void;
        shouldRconBroadcast(): boolean;
        getModdedStatus(): Internal.ModCheck;
        shouldInformAdmins(): boolean;
        isDedicatedServer(): boolean;
        alwaysAccepts(): boolean;
        asKJS(): Internal.ServerJS;
        setUUID(arg0: Internal.UUID_): void;
        getForcedGameType(): Internal.GameType;
        get port(): number
        get functionCompilationLevel(): number
        set defaultGameType(arg0: Internal.GameType_)
        get commandBlockEnabled(): boolean
        get serverDirectory(): Internal.File
        get published(): boolean
        get rateLimitPacketsPerSecond(): number
        get epollEnabled(): boolean
        get operatorUserPermissionLevel(): number
        get moddedStatus(): Internal.ModCheck
        get dedicatedServer(): boolean
        set UUID(arg0: Internal.UUID_)
        get forcedGameType(): Internal.GameType
    }
    type IntegratedServer_ = IntegratedServer;
    interface LongUnaryOperator {
        andThen(arg0: Internal.LongUnaryOperator_): this;
        compose(arg0: Internal.LongUnaryOperator_): this;
        applyAsLong(arg0: number): number;
        identity(): this;
    }
    type LongUnaryOperator_ = LongUnaryOperator | ((arg0: number)=>number);
    class IngredientStackJS implements Internal.IngredientJS {
        constructor(i: Internal.IngredientJS_, c: number)
        getVanillaItems(): Internal.Set<Internal.Item>;
        x(c: number): Internal.IngredientJS;
        getCount(): number;
        isInvalidRecipeIngredient(): boolean;
        toString(): string;
        getStacks(): Internal.Set<Internal.ItemStackJS>;
        asIngredientStack(): this;
        getItemIds(): Internal.Set<string>;
        copy(): Internal.Copyable;
        test(stack: Internal.ItemStackJS_): boolean;
        static stackOf(in_: Internal.IngredientJS_): Internal.IngredientStackJS;
        isEmpty(): boolean;
        getIngredient(): Internal.IngredientJS;
        toJson(): Internal.JsonElement;
        testVanillaItem(item: Internal.Item_): boolean;
        filter(filter: Internal.IngredientJS_): Internal.IngredientJS;
        not(): Internal.IngredientJS;
        anyStackMatches(ingredient: Internal.IngredientJS_): boolean;
        createVanillaIngredient(): Internal.Ingredient;
        getVanillaPredicate(): Internal.Predicate<Internal.ItemStack>;
        getFirst(): Internal.ItemStackJS;
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>;
        withCount(count: number): Internal.IngredientJS;
        testVanilla(stack: Internal.ItemStack_): boolean;
        get vanillaItems(): Internal.Set<Internal.Item>
        get count(): number
        get invalidRecipeIngredient(): boolean
        get stacks(): Internal.Set<Internal.ItemStackJS>
        get itemIds(): Internal.Set<string>
        get empty(): boolean
        get ingredient(): Internal.IngredientJS
        get vanillaPredicate(): Internal.Predicate<Internal.ItemStack>
        get first(): Internal.ItemStackJS
        "ingredientKey": string;
        "countKey": string;
        "ingredient": Internal.IngredientJS;
    }
    type IngredientStackJS_ = IngredientStackJS;
    class DayOfWeek extends Internal.Enum<Internal.DayOfWeek> implements Internal.TemporalAccessor, Internal.TemporalAdjuster {
        minus(arg0: number): this;
        plus(arg0: number): this;
        static from(arg0: Internal.TemporalAccessor_): Internal.DayOfWeek;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        static values(): Internal.DayOfWeek[];
        query(arg0: Internal.TemporalQuery_<R>): R;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        static of(arg0: number): Internal.DayOfWeek;
        get(arg0: Internal.TemporalField_): number;
        getLong(arg0: Internal.TemporalField_): number;
        getValue(): number;
        static valueOf(arg0: string): Internal.DayOfWeek;
        isSupported(arg0: Internal.TemporalField_): boolean;
        get value(): number
        readonly static "SUNDAY": Internal.DayOfWeek;
        readonly static "SATURDAY": Internal.DayOfWeek;
        readonly static "THURSDAY": Internal.DayOfWeek;
        readonly static "FRIDAY": Internal.DayOfWeek;
        readonly static "MONDAY": Internal.DayOfWeek;
        readonly static "WEDNESDAY": Internal.DayOfWeek;
        readonly static "TUESDAY": Internal.DayOfWeek;
    }
    type DayOfWeek_ = DayOfWeek | "tuesday" | "friday" | "thursday" | "monday" | "saturday" | "sunday" | "wednesday";
    interface ClientboundLevelChunkPacketData$BlockEntityTagOutput {
        accept(arg0: BlockPos_, arg1: Internal.BlockEntityType_<any>, arg2: Internal.CompoundTag_): void;
    }
    type ClientboundLevelChunkPacketData$BlockEntityTagOutput_ = ((arg0: BlockPos, arg1: Internal.BlockEntityType<any>, arg2: Internal.CompoundTag)=>void) | ClientboundLevelChunkPacketData$BlockEntityTagOutput;
    interface WrappedJS {
    }
    type WrappedJS_ = WrappedJS;
    class StringRange {
        constructor(arg0: number, arg1: number)
        static at(arg0: number): Internal.StringRange;
        getStart(): number;
        hashCode(): number;
        static encompassing(arg0: Internal.StringRange_, arg1: Internal.StringRange_): Internal.StringRange;
        getEnd(): number;
        toString(): string;
        get(arg0: string): string;
        get(arg0: Internal.ImmutableStringReader_): string;
        isEmpty(): boolean;
        equals(arg0: any): boolean;
        getLength(): number;
        static between(arg0: number, arg1: number): Internal.StringRange;
        get start(): number
        get end(): number
        get empty(): boolean
        get length(): number
    }
    type StringRange_ = StringRange;
    class ClientTickEventJS extends Internal.ClientEventJS {
        constructor()
    }
    type ClientTickEventJS_ = ClientTickEventJS;
    interface SoundEventListener {
        onPlaySound(arg0: Internal.SoundInstance_, arg1: Internal.WeighedSoundEvents_): void;
    }
    type SoundEventListener_ = SoundEventListener;
    class EnvironmentScanPlacement extends Internal.PlacementModifier {
        type(): Internal.PlacementModifierType<any>;
        static scanningFor(arg0: Internal.Direction_, arg1: net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_, arg2: number): Internal.EnvironmentScanPlacement;
        getPositions(arg0: Internal.PlacementContext_, arg1: Internal.Random_, arg2: BlockPos_): Internal.Stream<BlockPos>;
        static scanningFor(arg0: Internal.Direction_, arg1: net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_, arg2: net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_, arg3: number): Internal.EnvironmentScanPlacement;
        readonly static "CODEC": any;
    }
    type EnvironmentScanPlacement_ = EnvironmentScanPlacement;
    interface FloatConsumer extends Internal.DoubleConsumer, Internal.Consumer<number> {
        andThen(arg0: Internal.FloatConsumer_): this;
        accept(arg0: number): void;
        andThen(arg0: Internal.Consumer_<any>): Internal.Consumer<number>;
        accept(arg0: any): void;
        accept(arg0: number): void;
        andThen(arg0: Internal.DoubleConsumer_): Internal.DoubleConsumer;
        accept(arg0: number): void;
    }
    type FloatConsumer_ = FloatConsumer | ((arg0: number)=>void);
    interface ListIterator <E> extends Internal.Iterator<E> {
        nextIndex(): number;
        hasPrevious(): boolean;
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): E;
        previous(): E;
        hasNext(): boolean;
        add(arg0: E): void;
        set(arg0: E): void;
        previousIndex(): number;
    }
    type ListIterator_<E> = ListIterator<E>;
    interface ChannelId extends Internal.Comparable<Internal.ChannelId>, Internal.Serializable {
        asShortText(): string;
        asLongText(): string;
    }
    type ChannelId_ = ChannelId;
    class Donkey extends Internal.AbstractChestedHorse {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        canMate(arg0: Internal.Animal_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type Donkey_ = Donkey;
    interface ChangeListener <T> {
        onChanged(arg0: T): void;
    }
    type ChangeListener_<T> = ChangeListener<T> | ((arg0: T)=>void);
    class BlockLeftClickEventJS extends Internal.PlayerEventJS {
        constructor(player: Internal.Player_, hand: Hand_, pos: BlockPos_, direction: Internal.Direction_)
        getFacing(): Internal.Direction;
        getEntity(): Internal.EntityJS;
        canCancel(): boolean;
        getItem(): Internal.ItemStackJS;
        getBlock(): Internal.BlockContainerJS;
        get facing(): Internal.Direction
        get entity(): Internal.EntityJS
        get item(): Internal.ItemStackJS
        get block(): Internal.BlockContainerJS
    }
    type BlockLeftClickEventJS_ = BlockLeftClickEventJS;
    class ClientboundCommandSuggestionsPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: Internal.Suggestions_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getSuggestions(): Internal.Suggestions;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        getId(): number;
        get suggestions(): Internal.Suggestions
        get skippable(): boolean
        get id(): number
    }
    type ClientboundCommandSuggestionsPacket_ = ClientboundCommandSuggestionsPacket;
    class SkinManager {
        constructor(arg0: Internal.TextureManager_, arg1: Internal.File_, arg2: Internal.MinecraftSessionService_)
        getInsecureSkinInformation(arg0: Internal.GameProfile_): Internal.Map<Internal.MinecraftProfileTexture$Type, Internal.MinecraftProfileTexture>;
        registerSkins(arg0: Internal.GameProfile_, arg1: Internal.SkinManager$SkinTextureCallback_, arg2: boolean): void;
        registerTexture(arg0: Internal.MinecraftProfileTexture_, arg1: Internal.MinecraftProfileTexture$Type_): ResourceLocation;
        readonly static "PROPERTY_TEXTURES": "textures";
    }
    type SkinManager_ = SkinManager;
    interface SessionEventListener {
        onStartGameSession(arg0: Internal.GameSession_): void;
        onLeaveGameSession(arg0: Internal.GameSession_): void;
        readonly static "NONE": any;
    }
    type SessionEventListener_ = SessionEventListener;
    interface FlyingAnimal {
        isFlying(): boolean;
        get flying(): boolean
    }
    type FlyingAnimal_ = FlyingAnimal;
    abstract class ServerboundMovePlayerPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        handle(arg0: Internal.PacketListener_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        hasRotation(): boolean;
        getYRot(arg0: number): number;
        isOnGround(): boolean;
        getX(arg0: number): number;
        getY(arg0: number): number;
        getZ(arg0: number): number;
        hasPosition(): boolean;
        isSkippable(): boolean;
        getXRot(arg0: number): number;
        get onGround(): boolean
        get skippable(): boolean
    }
    type ServerboundMovePlayerPacket_ = ServerboundMovePlayerPacket;
    class ClientLoggedInEventJS extends Internal.ClientEventJS {
        constructor()
    }
    type ClientLoggedInEventJS_ = ClientLoggedInEventJS;
    class PermissionGatherEvent$Handler extends Internal.PermissionGatherEvent {
        constructor()
        getListenerList(): Internal.ListenerList;
        addPermissionHandler(arg0: ResourceLocation_, arg1: Internal.IPermissionHandlerFactory_): void;
        getAvailablePermissionHandlerFactories(): Internal.Map<ResourceLocation, Internal.IPermissionHandlerFactory>;
        get listenerList(): Internal.ListenerList
        get availablePermissionHandlerFactories(): Internal.Map<ResourceLocation, Internal.IPermissionHandlerFactory>
    }
    type PermissionGatherEvent$Handler_ = PermissionGatherEvent$Handler;
    class NoiseChunk implements Internal.DensityFunction$ContextProvider, Internal.DensityFunction$FunctionContext {
        updateForZ(arg0: number, arg1: number): void;
        updateForY(arg0: number, arg1: number): void;
        getBlender(): Internal.Blender;
        stopInterpolation(): void;
        selectCellYZ(arg0: number, arg1: number): void;
        updateForX(arg0: number, arg1: number): void;
        aquifer(): Internal.Aquifer;
        swapSlices(): void;
        forIndex(arg0: number): Internal.DensityFunction$FunctionContext;
        blockX(): number;
        static forColumn(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.NoiseRouter_, arg5: Internal.NoiseGeneratorSettings_, arg6: Internal.Aquifer$FluidPicker_): Internal.NoiseChunk;
        initializeForFirstCellX(): void;
        fillAllDirectly(arg0: number[], arg1: Internal.DensityFunction_): void;
        static forChunk(arg0: Internal.ChunkAccess_, arg1: Internal.NoiseRouter_, arg2: Internal.Supplier_<Internal.DensityFunctions$BeardifierOrMarker_>, arg3: Internal.NoiseGeneratorSettings_, arg4: Internal.Aquifer$FluidPicker_, arg5: Internal.Blender_): Internal.NoiseChunk;
        advanceCellX(arg0: number): void;
        preliminarySurfaceLevel(arg0: number, arg1: number): number;
        blockZ(): number;
        blockY(): number;
        get blender(): Internal.Blender
    }
    type NoiseChunk_ = NoiseChunk;
    class FluidBuilder extends Internal.BuilderBase<Internal.FlowingFluid> {
        constructor(i: ResourceLocation_)
        bucketColor(c: Internal.Color_): this;
        flowingTexture(id: ResourceLocation_): this;
        createAdditionalObjects(): void;
        noBucket(): this;
        luminosity(luminosity: number): this;
        gaseous(): this;
        builtinTextures(): this;
        stillTexture(id: ResourceLocation_): this;
        createObject(): any;
        viscosity(viscosity: number): this;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Fluid>;
        displayName(name: string): Internal.BuilderBase<Internal.FlowingFluid>;
        createAttributes(): Internal.ArchitecturyFluidAttributes;
        thickTexture(color: Internal.Color_): this;
        rarity(rarity: Rarity_): this;
        color(c: Internal.Color_): this;
        density(density: number): this;
        noBlock(): this;
        thinTexture(color: Internal.Color_): this;
        temperature(temperature: number): this;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Fluid>
        "bucketItem": Internal.FluidBucketItemBuilder;
        "attributes": Internal.ArchitecturyFluidAttributes;
        "flowingFluid": Internal.FlowingFluidBuilder;
        "block": Internal.FluidBlockBuilder;
    }
    type FluidBuilder_ = FluidBuilder;
    class FancyTrunkPlacer extends Internal.TrunkPlacer {
        constructor(arg0: number, arg1: number, arg2: number)
        placeTrunk(arg0: Internal.LevelSimulatedReader_, arg1: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>, arg2: Internal.Random_, arg3: number, arg4: BlockPos_, arg5: Internal.TreeConfiguration_): Internal.List<Internal.FoliagePlacer$FoliageAttachment>;
        readonly static "CODEC": any;
    }
    type FancyTrunkPlacer_ = FancyTrunkPlacer;
    interface Short2CharFunction extends Internal.IntUnaryOperator, it.unimi.dsi.fastutil.Function<number, string> {
        put(arg0: number, arg1: string): string;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2CharFunction;
        getOrDefault(arg0: any, arg1: string): string;
        put(arg0: number, arg1: string): string;
        get(arg0: number): string;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Short2LongFunction;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Short2ShortFunction;
        composeObject(arg0: Internal.Object2ShortFunction_<any>): Internal.Object2CharFunction<T>;
        getOrDefault(arg0: any, arg1: any): any;
        defaultReturnValue(): string;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeReference(arg0: Internal.Reference2ShortFunction_<any>): Internal.Reference2CharFunction<T>;
        apply(arg0: number): string;
        containsKey(arg0: any): boolean;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Short2FloatFunction;
        remove(arg0: number): string;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        defaultReturnValue(arg0: string): void;
        applyAsInt(arg0: number): number;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2CharFunction;
        get(arg0: any): string;
        put(arg0: any, arg1: any): any;
        containsKey(arg0: number): boolean;
        getOrDefault(arg0: number, arg1: string): string;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2CharFunction;
        composeShort(arg0: Internal.Short2ShortFunction_): this;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Short2DoubleFunction;
        andThenReference(arg0: Internal.Char2ReferenceFunction_<any>): Internal.Short2ReferenceFunction<T>;
        andThenChar(arg0: Internal.Char2CharFunction_): this;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2CharFunction;
        size(): number;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2CharFunction;
        clear(): void;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Short2IntFunction;
        andThenObject(arg0: Internal.Char2ObjectFunction_<any>): Internal.Short2ObjectFunction<T>;
        remove(arg0: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, string>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Short2ByteFunction;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2CharFunction;
    }
    type Short2CharFunction_ = Short2CharFunction | ((arg0: number)=>string);
    abstract class FileSystem implements Internal.Closeable {
        getSeparator(): string;
        getRootDirectories(): Internal.Iterable<Internal.Path>;
        supportedFileAttributeViews(): Internal.Set<string>;
        getFileStores(): Internal.Iterable<Internal.FileStore>;
        isOpen(): boolean;
        newWatchService(): Internal.WatchService;
        close(): void;
        getUserPrincipalLookupService(): Internal.UserPrincipalLookupService;
        provider(): Internal.FileSystemProvider;
        getPath(arg0: string, ...arg1: string[]): Internal.Path;
        isReadOnly(): boolean;
        getPathMatcher(arg0: string): Internal.PathMatcher;
        get separator(): string
        get rootDirectories(): Internal.Iterable<Internal.Path>
        get fileStores(): Internal.Iterable<Internal.FileStore>
        get open(): boolean
        get userPrincipalLookupService(): Internal.UserPrincipalLookupService
        get readOnly(): boolean
    }
    type FileSystem_ = FileSystem;
    class SculkSensorPhase extends Internal.Enum<Internal.SculkSensorPhase> implements Internal.StringRepresentable {
        static values(): Internal.SculkSensorPhase[];
        toString(): string;
        static valueOf(arg0: string): Internal.SculkSensorPhase;
        getSerializedName(): string;
        get serializedName(): string
        readonly static "ACTIVE": Internal.SculkSensorPhase;
        readonly static "COOLDOWN": Internal.SculkSensorPhase;
        readonly static "INACTIVE": Internal.SculkSensorPhase;
    }
    type SculkSensorPhase_ = "inactive" | "active" | SculkSensorPhase | "cooldown";
    interface AttributedCharacterIterator extends Internal.CharacterIterator {
        getAttributes(): Internal.Map<Internal.AttributedCharacterIterator$Attribute, any>;
        getRunStart(arg0: Internal.AttributedCharacterIterator$Attribute_): number;
        getRunLimit(): number;
        getAttribute(arg0: Internal.AttributedCharacterIterator$Attribute_): any;
        getAllAttributeKeys(): Internal.Set<Internal.AttributedCharacterIterator$Attribute>;
        getRunLimit(arg0: Internal.AttributedCharacterIterator$Attribute_): number;
        getRunStart(): number;
        getRunLimit(arg0: Internal.Set_<any>): number;
        getRunStart(arg0: Internal.Set_<any>): number;
        get attributes(): Internal.Map<Internal.AttributedCharacterIterator$Attribute, any>
        get runLimit(): number
        get allAttributeKeys(): Internal.Set<Internal.AttributedCharacterIterator$Attribute>
        get runStart(): number
    }
    type AttributedCharacterIterator_ = AttributedCharacterIterator;
    class RecipeManager extends Internal.SimpleJsonResourceReloadListener implements Internal.RecipeManagerAccessor {
        constructor()
        constructor(arg0: Internal.ICondition$IContext_)
        getRecipeIds(): Internal.Stream<ResourceLocation>;
        static fromJson(arg0: ResourceLocation_, arg1: Internal.JsonObject_, arg2: Internal.ICondition$IContext_): Internal.Recipe<any>;
        getContext(): Internal.ICondition$IContext;
        getRecipeFor(arg0: Internal.RecipeType_<T>, arg1: C, arg2: Internal.Level_): Internal.Optional<T>;
        replaceRecipes(arg0: Internal.Iterable_<Internal.Recipe_<any>>): void;
        hadErrorsLoading(): boolean;
        byKey(arg0: ResourceLocation_): Internal.Optional<any>;
        getRecipes(): Internal.Collection<Internal.Recipe<any>>;
        getRemainingItemsFor(arg0: Internal.RecipeType_<T>, arg1: C, arg2: Internal.Level_): Internal.NonNullList<Internal.ItemStack>;
        getAllRecipesFor(arg0: Internal.RecipeType_<T>): Internal.List<T>;
        static fromJson(arg0: ResourceLocation_, arg1: Internal.JsonObject_): Internal.Recipe<any>;
        getName(): string;
        getRecipesFor(arg0: Internal.RecipeType_<T>, arg1: C, arg2: Internal.Level_): Internal.List<T>;
        get recipeIds(): Internal.Stream<ResourceLocation>
        get context(): Internal.ICondition$IContext
        get recipes(): Internal.Collection<Internal.Recipe<any>>
        get name(): string
        "byName": Internal.Map<ResourceLocation, Internal.Recipe<any>>;
        "recipes": Internal.Map<Internal.RecipeType<any>, Internal.Map<ResourceLocation, Internal.Recipe<any>>>;
    }
    type RecipeManager_ = RecipeManager;
    class MethodSignature {
        hashCode(): number;
        toString(): string;
        static of(...types: Internal.Class_<any>[]): Internal.MethodSignature;
        matches(actualArguments: Internal.MethodSignature_, data: Internal.SharedContextData_): boolean;
        equals(obj: any): boolean;
        readonly static "DOUBLE": Internal.MethodSignature;
        readonly static "STRING": Internal.MethodSignature;
        readonly static "SHORT": Internal.MethodSignature;
        readonly static "EMPTY": Internal.MethodSignature;
        readonly static "BYTE": Internal.MethodSignature;
        readonly static "INT": Internal.MethodSignature;
        readonly static "BOOLEAN": Internal.MethodSignature;
        readonly static "FLOAT": Internal.MethodSignature;
        readonly "types": Internal.Class<any>[];
        readonly static "OBJECT_ARRAY": Internal.MethodSignature;
        readonly static "OBJECT": Internal.MethodSignature;
        readonly static "LONG": Internal.MethodSignature;
        readonly static "CHAR": Internal.MethodSignature;
    }
    type MethodSignature_ = MethodSignature;
    interface Spliterator <T> {
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        getComparator(): Internal.Comparator<any>;
        getExactSizeIfKnown(): number;
        hasCharacteristics(arg0: number): boolean;
        tryAdvance(arg0: Internal.Consumer_<any>): boolean;
        characteristics(): number;
        estimateSize(): number;
        trySplit(): this;
        get comparator(): Internal.Comparator<any>
        get exactSizeIfKnown(): number
        readonly static "SORTED": 4;
        readonly static "IMMUTABLE": 1024;
        readonly static "DISTINCT": 1;
        readonly static "CONCURRENT": 4096;
        readonly static "ORDERED": 16;
        readonly static "NONNULL": 256;
        readonly static "SUBSIZED": 16384;
        readonly static "SIZED": 64;
    }
    type Spliterator_<T> = Spliterator<T>;
    class Strider extends Internal.Animal implements Internal.ItemSteerable, Internal.Saddleable {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        travel(arg0: Vec3_): void;
        getStepHeight(): number;
        getDismountLocationForPassenger(arg0: Internal.LivingEntity_): Vec3;
        getControllingPassenger(): Internal.Entity;
        asKJS(): Internal.EntityJS;
        travelWithInput(arg0: Vec3_): void;
        travel(arg0: Internal.Mob_, arg1: Internal.ItemBasedSteering_, arg2: Vec3_): boolean;
        isFood(arg0: Internal.ItemStack_): boolean;
        boost(): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        equipSaddle(arg0: Internal.SoundSource_): void;
        canRiderInteract(): boolean;
        canStandOnFluid(arg0: Internal.FluidState_): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        checkSpawnObstruction(arg0: Internal.LevelReader_): boolean;
        isOnFire(): boolean;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        setSuffocating(arg0: boolean): void;
        getSteeringSpeed(): number;
        isSuffocating(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        isSaddled(): boolean;
        canBeControlledByRider(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getPassengersRidingOffset(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        getWalkTargetValue(arg0: BlockPos_, arg1: Internal.LevelReader_): number;
        isSensitiveToWater(): boolean;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        static checkStriderSpawnRules(arg0: Internal.EntityType_<Internal.Strider_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        getLeashOffset(): Vec3;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getClassification(arg0: boolean): Internal.MobCategory;
        getMoveSpeed(): number;
        foodEatenKJS(is: Internal.ItemStack_): void;
        isSaddleable(): boolean;
        get stepHeight(): number
        get controllingPassenger(): Internal.Entity
        get multipartEntity(): boolean
        get onFire(): boolean
        get parts(): Internal.PartEntity<any>[]
        set suffocating(arg0: boolean)
        get steeringSpeed(): number
        get suffocating(): boolean
        get saddled(): boolean
        get passengersRidingOffset(): number
        get sensitiveToWater(): boolean
        get leashOffset(): Vec3
        get moveSpeed(): number
        get saddleable(): boolean
    }
    type Strider_ = Strider;
    class LanguageInfo implements com.mojang.bridge.game.Language, Internal.Comparable<Internal.LanguageInfo> {
        constructor(arg0: string, arg1: string, arg2: string, arg3: boolean)
        hashCode(): number;
        toString(): string;
        compareTo(arg0: Internal.LanguageInfo_): number;
        getCode(): string;
        getName(): string;
        isBidirectional(): boolean;
        getJavaLocale(): Internal.Locale;
        equals(arg0: any): boolean;
        compareTo(arg0: any): number;
        getRegion(): string;
        get code(): string
        get name(): string
        get bidirectional(): boolean
        get javaLocale(): Internal.Locale
        get region(): string
    }
    type LanguageInfo_ = LanguageInfo;
    class RaidDebugRenderer implements Internal.DebugRenderer$SimpleDebugRenderer {
        constructor(arg0: Internal.Minecraft_)
        setRaidCenters(arg0: Internal.Collection_<BlockPos_>): void;
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource_, arg2: number, arg3: number, arg4: number): void;
        clear(): void;
        set raidCenters(arg0: Internal.Collection_<BlockPos_>)
    }
    type RaidDebugRenderer_ = RaidDebugRenderer;
    class LegacySinglePoolElement extends Internal.SinglePoolElement {
        getType(): Internal.StructurePoolElementType<any>;
        toString(): string;
        get type(): Internal.StructurePoolElementType<any>
        readonly static "CODEC": any;
    }
    type LegacySinglePoolElement_ = LegacySinglePoolElement;
    class MobSpawnType extends Internal.Enum<Internal.MobSpawnType> {
        static valueOf(arg0: string): Internal.MobSpawnType;
        static values(): Internal.MobSpawnType[];
        readonly static "SPAWNER": Internal.MobSpawnType;
        readonly static "BREEDING": Internal.MobSpawnType;
        readonly static "CHUNK_GENERATION": Internal.MobSpawnType;
        readonly static "EVENT": Internal.MobSpawnType;
        readonly static "MOB_SUMMONED": Internal.MobSpawnType;
        readonly static "CONVERSION": Internal.MobSpawnType;
        readonly static "TRIGGERED": Internal.MobSpawnType;
        readonly static "COMMAND": Internal.MobSpawnType;
        readonly static "STRUCTURE": Internal.MobSpawnType;
        readonly static "JOCKEY": Internal.MobSpawnType;
        readonly static "PATROL": Internal.MobSpawnType;
        readonly static "DISPENSER": Internal.MobSpawnType;
        readonly static "REINFORCEMENT": Internal.MobSpawnType;
        readonly static "BUCKET": Internal.MobSpawnType;
        readonly static "SPAWN_EGG": Internal.MobSpawnType;
        readonly static "NATURAL": Internal.MobSpawnType;
    }
    type MobSpawnType_ = "bucket" | "spawner" | "chunk_generation" | "spawn_egg" | "triggered" | "breeding" | "dispenser" | "mob_summoned" | "reinforcement" | "event" | "patrol" | "jockey" | "command" | "natural" | MobSpawnType | "structure" | "conversion";
    class ScheduledEvent {
        reschedule(): void;
        reschedule(timer: number): this;
        getData(): any;
        isUsingTicks(): boolean;
        getTimerDuration(): number;
        getTimer(): number;
        getEndTime(): number;
        getServer(): Internal.ServerJS;
        get data(): any
        get usingTicks(): boolean
        get timerDuration(): number
        get timer(): number
        get endTime(): number
        get server(): Internal.ServerJS
    }
    type ScheduledEvent_ = ScheduledEvent;
    interface IForgeFluid {
        getAttributes(): Internal.FluidAttributes;
        getExplosionResistance(arg0: Internal.FluidState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        isAABBInsideLiquid(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.AABB_): boolean;
        isEntityInside(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_, arg4: number, arg5: Internal.HolderSet_<Internal.Fluid_>, arg6: boolean): boolean;
        isAABBInsideMaterial(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.AABB_, arg4: Internal.Material_): boolean;
        get attributes(): Internal.FluidAttributes
    }
    type IForgeFluid_ = IForgeFluid;
    class Stack <E> extends Internal.Vector<E> {
        constructor()
        empty(): boolean;
        peek(): E;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        stream(): Internal.Stream<E>;
        parallelStream(): Internal.Stream<E>;
        search(arg0: any): number;
        pop(): E;
        push(arg0: E): E;
    }
    type Stack_<E> = Stack<E>;
    interface DoubleUnaryOperator {
        compose(arg0: Internal.DoubleUnaryOperator_): this;
        andThen(arg0: Internal.DoubleUnaryOperator_): this;
        identity(): this;
        applyAsDouble(arg0: number): number;
    }
    type DoubleUnaryOperator_ = ((arg0: number)=>number) | DoubleUnaryOperator;
    class StructureFeatureManager {
        constructor(arg0: Internal.LevelAccessor_, arg1: Internal.WorldGenSettings_, arg2: any_)
        getStructureAt(arg0: BlockPos_, arg1: Internal.ConfiguredStructureFeature_<any, any>): Internal.StructureStart;
        getStartForFeature(arg0: Internal.SectionPos_, arg1: Internal.ConfiguredStructureFeature_<any, any>, arg2: Internal.FeatureAccess_): Internal.StructureStart;
        registryAccess(): Internal.RegistryAccess;
        forWorldGenRegion(arg0: Internal.WorldGenRegion_): this;
        addReference(arg0: Internal.StructureStart_): void;
        getStructureWithPieceAt(arg0: BlockPos_, arg1: Internal.ConfiguredStructureFeature_<any, any>): Internal.StructureStart;
        addReferenceForFeature(arg0: Internal.SectionPos_, arg1: Internal.ConfiguredStructureFeature_<any, any>, arg2: number, arg3: Internal.FeatureAccess_): void;
        startsForFeature(arg0: Internal.SectionPos_, arg1: Internal.ConfiguredStructureFeature_<any, any>): Internal.List<Internal.StructureStart>;
        getAllStructuresAt(arg0: BlockPos_): Internal.Map<Internal.ConfiguredStructureFeature<any, any>, Internal.LongSet>;
        shouldGenerateFeatures(): boolean;
        startsForFeature(arg0: Internal.SectionPos_, arg1: Internal.Predicate_<Internal.ConfiguredStructureFeature_<any, any>>): Internal.List<Internal.StructureStart>;
        checkStructurePresence(arg0: Internal.ChunkPos_, arg1: Internal.ConfiguredStructureFeature_<any, any>, arg2: boolean): Internal.StructureCheckResult;
        setStartForFeature(arg0: Internal.SectionPos_, arg1: Internal.ConfiguredStructureFeature_<any, any>, arg2: Internal.StructureStart_, arg3: Internal.FeatureAccess_): void;
        hasAnyStructureAt(arg0: BlockPos_): boolean;
        structureHasPieceAt(arg0: BlockPos_, arg1: Internal.StructureStart_): boolean;
        getStructureWithPieceAt(arg0: BlockPos_, arg1: Internal.ResourceKey_<Internal.ConfiguredStructureFeature_<any, any>>): Internal.StructureStart;
        fillStartsForFeature(arg0: Internal.ConfiguredStructureFeature_<any, any>, arg1: Internal.LongSet_, arg2: Internal.Consumer_<Internal.StructureStart_>): void;
    }
    type StructureFeatureManager_ = StructureFeatureManager;
    class RenderTooltipEvent$Pre extends Internal.RenderTooltipEvent {
        constructor()
        constructor(arg0: Internal.ItemStack_, arg1: Internal.PoseStack_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.Font_, arg7: Internal.List_<Internal.ClientTooltipComponent_>)
        isCancelable(): boolean;
        getScreenHeight(): number;
        getScreenWidth(): number;
        setY(arg0: number): void;
        setX(arg0: number): void;
        getListenerList(): Internal.ListenerList;
        setFont(arg0: Internal.Font_): void;
        get cancelable(): boolean
        get screenHeight(): number
        get screenWidth(): number
        set y(arg0: number)
        set x(arg0: number)
        get listenerList(): Internal.ListenerList
        set font(arg0: Internal.Font_)
    }
    type RenderTooltipEvent$Pre_ = RenderTooltipEvent$Pre;
    abstract class LivingEntityRenderer <T, M> extends Internal.EntityRenderer<T> implements Internal.RenderLayerParent<T, M> {
        constructor(arg0: any_, arg1: M, arg2: number)
        getModel(): M;
        static isEntityUpsideDown(arg0: Internal.LivingEntity_): boolean;
        addLayer(arg0: Internal.RenderLayer_<T, M>): boolean;
        render(arg0: Internal.Entity_, arg1: number, arg2: number, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number): void;
        render(arg0: T, arg1: number, arg2: number, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number): void;
        static getOverlayCoords(arg0: Internal.LivingEntity_, arg1: number): number;
        get model(): M
    }
    type LivingEntityRenderer_<T, M> = LivingEntityRenderer<T, M>;
    interface Thread$UncaughtExceptionHandler {
        uncaughtException(arg0: Internal.Thread_, arg1: Internal.Throwable_): void;
    }
    type Thread$UncaughtExceptionHandler_ = ((arg0: Internal.Thread, arg1: Internal.Throwable)=>void) | Thread$UncaughtExceptionHandler;
    class CommandEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.ParseResults_<Internal.CommandSourceStack_>)
        getException(): Internal.Throwable;
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        setException(arg0: Internal.Throwable_): void;
        setParseResults(arg0: Internal.ParseResults_<Internal.CommandSourceStack_>): void;
        getParseResults(): Internal.ParseResults<Internal.CommandSourceStack>;
        get exception(): Internal.Throwable
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
        set exception(arg0: Internal.Throwable_)
        set parseResults(arg0: Internal.ParseResults_<Internal.CommandSourceStack_>)
        get parseResults(): Internal.ParseResults<Internal.CommandSourceStack>
    }
    type CommandEvent_ = CommandEvent;
    class CheckLivingEntitySpawnEventJS extends Internal.LivingEntityEventJS {
        constructor(entity: Internal.LivingEntity_, level: Internal.Level_, x: number, y: number, z: number, type: Internal.MobSpawnType_)
        getEntity(): Internal.EntityJS;
        canCancel(): boolean;
        getLevel(): Internal.LevelJS;
        getType(): Internal.MobSpawnType;
        getBlock(): Internal.BlockContainerJS;
        get entity(): Internal.EntityJS
        get level(): Internal.LevelJS
        get type(): Internal.MobSpawnType
        get block(): Internal.BlockContainerJS
        readonly "z": number;
        readonly "type": Internal.MobSpawnType;
        readonly "x": number;
        readonly "y": number;
    }
    type CheckLivingEntitySpawnEventJS_ = CheckLivingEntitySpawnEventJS;
    class RenderLivingEvent$Post <T, M> extends Internal.RenderLivingEvent<T, M> {
        constructor()
        constructor(arg0: Internal.LivingEntity_, arg1: Internal.LivingEntityRenderer_<T, M>, arg2: number, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type RenderLivingEvent$Post_<T, M> = RenderLivingEvent$Post<T, M>;
    class TickEvent$ServerTickEvent extends Internal.TickEvent {
        constructor()
        constructor(arg0: Internal.TickEvent$Phase_)
        constructor(arg0: Internal.TickEvent$Phase_, arg1: Internal.BooleanSupplier_)
        getListenerList(): Internal.ListenerList;
        haveTime(): boolean;
        get listenerList(): Internal.ListenerList
    }
    type TickEvent$ServerTickEvent_ = TickEvent$ServerTickEvent;
    interface ChronoLocalDate extends Internal.Comparable<Internal.ChronoLocalDate>, Internal.Temporal, Internal.TemporalAdjuster {
        lengthOfYear(): number;
        until(arg0: Internal.ChronoLocalDate_): Internal.ChronoPeriod;
        plus(arg0: Internal.TemporalAmount_): this;
        isAfter(arg0: Internal.ChronoLocalDate_): boolean;
        compareTo(arg0: any): number;
        getEra(): Internal.Era;
        with(arg0: Internal.TemporalAdjuster_): Internal.Temporal;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Temporal;
        with(arg0: Internal.TemporalField_, arg1: number): Internal.Temporal;
        isSupported(arg0: Internal.TemporalField_): boolean;
        toEpochDay(): number;
        format(arg0: Internal.DateTimeFormatter_): string;
        getChronology(): Internal.Chronology;
        toString(): string;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        timeLineOrder(): Internal.Comparator<Internal.ChronoLocalDate>;
        query(arg0: Internal.TemporalQuery_<R>): R;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        compareTo(arg0: Internal.ChronoLocalDate_): number;
        atTime(arg0: Internal.LocalTime_): Internal.ChronoLocalDateTime<any>;
        hashCode(): number;
        isEqual(arg0: Internal.ChronoLocalDate_): boolean;
        plus(arg0: number, arg1: Internal.TemporalUnit_): this;
        get(arg0: Internal.TemporalField_): number;
        lengthOfMonth(): number;
        from(arg0: Internal.TemporalAccessor_): this;
        isBefore(arg0: Internal.ChronoLocalDate_): boolean;
        equals(arg0: any): boolean;
        minus(arg0: Internal.TemporalAmount_): Internal.Temporal;
        isLeapYear(): boolean;
        get era(): Internal.Era
        get chronology(): Internal.Chronology
        get leapYear(): boolean
    }
    type ChronoLocalDate_ = ChronoLocalDate;
    class NearestVisibleLivingEntities {
        constructor(arg0: Internal.LivingEntity_, arg1: Internal.List_<Internal.LivingEntity_>)
        findClosest(arg0: Internal.Predicate_<Internal.LivingEntity_>): Internal.Optional<Internal.LivingEntity>;
        contains(arg0: Internal.Predicate_<Internal.LivingEntity_>): boolean;
        contains(arg0: Internal.LivingEntity_): boolean;
        static empty(): Internal.NearestVisibleLivingEntities;
        findAll(arg0: Internal.Predicate_<Internal.LivingEntity_>): Internal.Iterable<Internal.LivingEntity>;
        find(arg0: Internal.Predicate_<Internal.LivingEntity_>): Internal.Stream<Internal.LivingEntity>;
    }
    type NearestVisibleLivingEntities_ = NearestVisibleLivingEntities;
    abstract class RhinoException extends Internal.RuntimeException {
        details(): string;
        getMessage(): string;
        getScriptStackTrace(limit: number, functionName: string): string;
        sourceName(): string;
        getScriptStackTrace(): string;
        initSourceName(sourceName: string): void;
        lineSource(): string;
        initLineNumber(lineNumber: number): void;
        getScriptStack(): any[];
        columnNumber(): number;
        initColumnNumber(columnNumber: number): void;
        lineNumber(): number;
        printStackTrace(s: Internal.PrintWriter_): void;
        initLineSource(lineSource: string): void;
        getScriptStack(limit: number, hideFunction: string): any[];
        printStackTrace(s: Internal.PrintStream_): void;
        get message(): string
        get scriptStackTrace(): string
        get scriptStack(): any[]
    }
    type RhinoException_ = RhinoException;
    class ChestLootEventJS extends Internal.LootEventJS {
        constructor(c: Internal.Map_<ResourceLocation_, Internal.JsonElement_>)
        getType(): string;
        addChest(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        getDirectory(): string;
        get type(): string
        get directory(): string
    }
    type ChestLootEventJS_ = ChestLootEventJS;
    class ClientboundAddEntityPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.Entity_, arg1: Internal.EntityType_<any>, arg2: number, arg3: BlockPos_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: Internal.UUID_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.EntityType_<any>, arg8: number, arg9: Vec3_)
        constructor(arg0: Internal.Entity_, arg1: number)
        constructor(arg0: Internal.Entity_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getData(): number;
        getyRot(): number;
        getZa(): number;
        isSkippable(): boolean;
        getX(): number;
        getxRot(): number;
        getY(): number;
        getZ(): number;
        getXa(): number;
        getYa(): number;
        getUUID(): Internal.UUID;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getType(): Internal.EntityType<any>;
        getId(): number;
        get data(): number
        get yRot(): number
        get za(): number
        get skippable(): boolean
        get x(): number
        get xRot(): number
        get y(): number
        get z(): number
        get xa(): number
        get ya(): number
        get UUID(): Internal.UUID
        get type(): Internal.EntityType<any>
        get id(): number
        readonly static "LIMIT": 3.9;
        readonly static "MAGICAL_QUANTIZATION": 8000.0;
    }
    type ClientboundAddEntityPacket_ = ClientboundAddEntityPacket;
    interface Long2LongFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.LongUnaryOperator {
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2LongFunction;
        getOrDefault(arg0: any, arg1: any): any;
        identity(): this;
        remove(arg0: number): number;
        andThenReference(arg0: Internal.Long2ReferenceFunction_<any>): Internal.Long2ReferenceFunction<T>;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Long2FloatFunction;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2LongFunction;
        composeObject(arg0: Internal.Object2LongFunction_<any>): Internal.Object2LongFunction<T>;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Long2CharFunction;
        getOrDefault(arg0: number, arg1: number): number;
        andThen(arg0: Internal.LongUnaryOperator_): Internal.LongUnaryOperator;
        containsKey(arg0: any): boolean;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2LongFunction;
        remove(arg0: any): number;
        composeLong(arg0: Internal.Long2LongFunction_): this;
        put(arg0: any, arg1: any): any;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Long2ByteFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        get(arg0: number): number;
        composeReference(arg0: Internal.Reference2LongFunction_<any>): Internal.Reference2LongFunction<T>;
        defaultReturnValue(): number;
        andThenLong(arg0: Internal.Long2LongFunction_): this;
        andThenObject(arg0: Internal.Long2ObjectFunction_<any>): Internal.Long2ObjectFunction<T>;
        containsKey(arg0: number): boolean;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        compose(arg0: Internal.LongUnaryOperator_): Internal.LongUnaryOperator;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2LongFunction;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2LongFunction;
        getOrDefault(arg0: any, arg1: number): number;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2LongFunction;
        applyAsLong(arg0: number): number;
        apply(arg0: number): number;
        size(): number;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Long2DoubleFunction;
        put(arg0: number, arg1: number): number;
        clear(): void;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Long2IntFunction;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Long2ShortFunction;
        get(arg0: any): any;
        put(arg0: number, arg1: number): number;
        defaultReturnValue(arg0: number): void;
    }
    type Long2LongFunction_ = Long2LongFunction | ((arg0: number)=>number);
    interface IntStream$IntMapMultiConsumer {
        accept(arg0: number, arg1: Internal.IntConsumer_): void;
    }
    type IntStream$IntMapMultiConsumer_ = IntStream$IntMapMultiConsumer | ((arg0: number, arg1: Internal.IntConsumer)=>void);
    class LeashFenceKnotEntity extends Internal.HangingEntity {
        constructor(arg0: Internal.Level_, arg1: BlockPos_)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static getOrCreateKnot(arg0: Internal.Level_, arg1: BlockPos_): Internal.LeashFenceKnotEntity;
        interact(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        playPlacementSound(): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getAddEntityPacket(): Internal.Packet<any>;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRenderAtSqrDistance(arg0: number): boolean;
        shouldRiderSit(): boolean;
        getHeight(): number;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getRopeHoldPosition(arg0: number): Vec3;
        deserializeNBT(arg0: Internal.Tag_): void;
        getWidth(): number;
        dropItem(arg0: Internal.Entity_): void;
        survives(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        setDirection(arg0: Internal.Direction_): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getPickResult(): Internal.ItemStack;
        get stepHeight(): number
        get addEntityPacket(): Internal.Packet<any>
        get multipartEntity(): boolean
        get height(): number
        get parts(): Internal.PartEntity<any>[]
        get width(): number
        set direction(arg0: Internal.Direction_)
        get pickResult(): Internal.ItemStack
        readonly static "OFFSET_Y": 0.375;
    }
    type LeashFenceKnotEntity_ = LeashFenceKnotEntity;
    interface Comparator <T> {
        thenComparingLong(arg0: Internal.ToLongFunction_<any>): this;
        comparingInt(arg0: Internal.ToIntFunction_<any>): this;
        compare(arg0: T, arg1: T): number;
        thenComparingDouble(arg0: Internal.ToDoubleFunction_<any>): this;
        reverseOrder(): this;
        nullsFirst(arg0: Internal.Comparator_<any>): this;
        thenComparing(arg0: Internal.Function_<any, any>): this;
        nullsLast(arg0: Internal.Comparator_<any>): this;
        thenComparing(arg0: Internal.Function_<any, any>, arg1: Internal.Comparator_<any>): this;
        thenComparing(arg0: Internal.Comparator_<any>): this;
        thenComparingInt(arg0: Internal.ToIntFunction_<any>): this;
        naturalOrder(): this;
        reversed(): this;
        comparingDouble(arg0: Internal.ToDoubleFunction_<any>): this;
        comparingLong(arg0: Internal.ToLongFunction_<any>): this;
        equals(arg0: any): boolean;
        comparing(arg0: Internal.Function_<any, any>): this;
        comparing(arg0: Internal.Function_<any, any>, arg1: Internal.Comparator_<any>): this;
    }
    type Comparator_<T> = Comparator<T>;
    interface MethodHandleDesc extends Internal.ConstantDesc {
        asType(arg0: Internal.MethodTypeDesc_): this;
        invocationType(): Internal.MethodTypeDesc;
        of(arg0: Internal.DirectMethodHandleDesc$Kind_, arg1: Internal.ClassDesc_, arg2: string, arg3: string): Internal.DirectMethodHandleDesc;
        ofConstructor(arg0: Internal.ClassDesc_, ...arg1: Internal.ClassDesc_[]): Internal.DirectMethodHandleDesc;
        ofField(arg0: Internal.DirectMethodHandleDesc$Kind_, arg1: Internal.ClassDesc_, arg2: string, arg3: Internal.ClassDesc_): Internal.DirectMethodHandleDesc;
        equals(arg0: any): boolean;
        ofMethod(arg0: Internal.DirectMethodHandleDesc$Kind_, arg1: Internal.ClassDesc_, arg2: string, arg3: Internal.MethodTypeDesc_): Internal.DirectMethodHandleDesc;
    }
    type MethodHandleDesc_ = MethodHandleDesc;
    interface ContextAwareComponent {
        resolve(arg0: Internal.CommandSourceStack_, arg1: Internal.Entity_, arg2: number): Internal.MutableComponent;
    }
    type ContextAwareComponent_ = ContextAwareComponent;
    interface UnaryOperator <T> extends Internal.Function<T, T> {
        identity(): this;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, T>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
    }
    type UnaryOperator_<T> = UnaryOperator<T>;
    class WitherBoss extends Internal.Monster implements Internal.PowerableMob, Internal.RangedAttackMob {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        addEffect(arg0: Internal.MobEffectInstance_, arg1: Internal.Entity_): boolean;
        getMobType(): Internal.MobType;
        setCustomName(arg0: Internal.Component_): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        performRangedAttack(arg0: Internal.LivingEntity_, arg1: number): void;
        stopSeenByPlayer(arg0: Internal.ServerPlayer_): void;
        getHeadYRot(arg0: number): number;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        startSeenByPlayer(arg0: Internal.ServerPlayer_): void;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getAlternativeTarget(arg0: number): number;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        canBeAffected(arg0: Internal.MobEffectInstance_): boolean;
        isPowered(): boolean;
        makeInvulnerable(): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getInvulnerableTicks(): number;
        deserializeNBT(arg0: Internal.Tag_): void;
        setInvulnerableTicks(arg0: number): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setAlternativeTarget(arg0: number, arg1: number): void;
        aiStep(): void;
        static canDestroy(arg0: Internal.BlockState_): boolean;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        checkDespawn(): void;
        makeStuckInBlock(arg0: Internal.BlockState_, arg1: Vec3_): void;
        canChangeDimensions(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getHeadXRot(arg0: number): number;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get mobType(): Internal.MobType
        set customName(arg0: Internal.Component_)
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get powered(): boolean
        get invulnerableTicks(): number
        set invulnerableTicks(arg0: number)
    }
    type WitherBoss_ = WitherBoss;
    class PalettedContainer <T> implements Internal.PaletteResize<T> {
        constructor(arg0: Internal.IdMap_<T>, arg1: T, arg2: Internal.PalettedContainer$Strategy_)
        constructor(arg0: Internal.IdMap_<T>, arg1: Internal.PalettedContainer$Strategy_, arg2: Internal.PalettedContainer$Configuration_<T>, arg3: Internal.BitStorage_, arg4: Internal.List_<T>)
        read(arg0: Internal.FriendlyByteBuf_): void;
        getAndSet(arg0: number, arg1: number, arg2: number, arg3: T): T;
        write(arg0: Internal.FriendlyByteBuf_): void;
        maybeHas(arg0: Internal.Predicate_<T>): boolean;
        getSerializedSize(): number;
        set(arg0: number, arg1: number, arg2: number, arg3: T): void;
        onResize(arg0: number, arg1: T): number;
        count(arg0: Internal.PalettedContainer$CountConsumer_<T>): void;
        getAll(arg0: Internal.Consumer_<T>): void;
        static codec(arg0: Internal.IdMap_<T>, arg1: Internal.Codec_<T>, arg2: Internal.PalettedContainer$Strategy_, arg3: T): Internal.Codec<Internal.PalettedContainer<T>>;
        copy(): this;
        release(): void;
        acquire(): void;
        getAndSetUnchecked(arg0: number, arg1: number, arg2: number, arg3: T): T;
        get(arg0: number, arg1: number, arg2: number): T;
        get serializedSize(): number
    }
    type PalettedContainer_<T> = PalettedContainer<T>;
    class DoubleSummaryStatistics implements Internal.DoubleConsumer {
        constructor()
        constructor(arg0: number, arg1: number, arg2: number, arg3: number)
        combine(arg0: Internal.DoubleSummaryStatistics_): void;
        accept(arg0: number): void;
        getSum(): number;
        toString(): string;
        getCount(): number;
        getAverage(): number;
        andThen(arg0: Internal.DoubleConsumer_): Internal.DoubleConsumer;
        getMin(): number;
        getMax(): number;
        get sum(): number
        get count(): number
        get average(): number
        get min(): number
        get max(): number
    }
    type DoubleSummaryStatistics_ = DoubleSummaryStatistics;
    class Camera$NearPlane {
        getBottomRight(): Vec3;
        getPointOnPlane(arg0: number, arg1: number): Vec3;
        getTopLeft(): Vec3;
        getBottomLeft(): Vec3;
        getTopRight(): Vec3;
        get bottomRight(): Vec3
        get topLeft(): Vec3
        get bottomLeft(): Vec3
        get topRight(): Vec3
    }
    type Camera$NearPlane_ = Camera$NearPlane;
    interface StatFormatter {
        format(arg0: number): string;
        readonly static "DECIMAL_FORMAT": Internal.DecimalFormat;
        readonly static "DIVIDE_BY_TEN": any;
        readonly static "DISTANCE": any;
        readonly static "DEFAULT": any;
        readonly static "TIME": any;
    }
    type StatFormatter_ = StatFormatter;
    interface ChunkHolder$ChunkLoadingFailure {
        readonly static "UNLOADED": any;
    }
    type ChunkHolder$ChunkLoadingFailure_ = ChunkHolder$ChunkLoadingFailure;
    class SimpleBlockConfiguration extends Internal.Record implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.BlockStateProvider_)
        hashCode(): number;
        toPlace(): Internal.BlockStateProvider;
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        toString(): string;
        equals(arg0: any): boolean;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
    }
    type SimpleBlockConfiguration_ = SimpleBlockConfiguration;
    class WorldgenRandom$Algorithm extends Internal.Enum<Internal.WorldgenRandom$Algorithm> {
        newInstance(arg0: number): Internal.RandomSource;
        static values(): Internal.WorldgenRandom$Algorithm[];
        static valueOf(arg0: string): Internal.WorldgenRandom$Algorithm;
        readonly static "XOROSHIRO": Internal.WorldgenRandom$Algorithm;
        readonly static "LEGACY": Internal.WorldgenRandom$Algorithm;
    }
    type WorldgenRandom$Algorithm_ = "legacy" | "xoroshiro" | WorldgenRandom$Algorithm;
    class InterfaceAddress {
        hashCode(): number;
        toString(): string;
        getNetworkPrefixLength(): number;
        equals(arg0: any): boolean;
        getAddress(): Internal.InetAddress;
        getBroadcast(): Internal.InetAddress;
        get networkPrefixLength(): number
        get address(): Internal.InetAddress
        get broadcast(): Internal.InetAddress
    }
    type InterfaceAddress_ = InterfaceAddress;
    interface CharacterIterator extends Internal.Cloneable {
        clone(): any;
        first(): string;
        previous(): string;
        getBeginIndex(): number;
        getIndex(): number;
        setIndex(arg0: number): string;
        next(): string;
        current(): string;
        last(): string;
        getEndIndex(): number;
        get beginIndex(): number
        get index(): number
        set index(arg0: number)
        get endIndex(): number
        readonly static "DONE": "";
    }
    type CharacterIterator_ = CharacterIterator;
    class ServerboundBlockEntityTagQuery implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: number, arg1: BlockPos_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getPos(): BlockPos;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getTransactionId(): number;
        isSkippable(): boolean;
        get pos(): BlockPos
        get transactionId(): number
        get skippable(): boolean
    }
    type ServerboundBlockEntityTagQuery_ = ServerboundBlockEntityTagQuery;
    interface PrivilegedExceptionAction <T> {
        run(): T;
    }
    type PrivilegedExceptionAction_<T> = PrivilegedExceptionAction<T> | (()=>T);
    interface IForgeRegistry <V> extends Internal.Iterable<V> {
        getResourceKey(arg0: V): Internal.Optional<Internal.ResourceKey<V>>;
        register(arg0: V): void;
        getDefaultKey(): ResourceLocation;
        getValues(): Internal.Collection<V>;
        getHolder(arg0: V): Internal.Optional<Internal.Holder<V>>;
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<V>;
        getHolder(arg0: Internal.ResourceKey_<V>): Internal.Optional<Internal.Holder<V>>;
        getKeys(): Internal.Set<ResourceLocation>;
        tags(): Internal.ITagManager<V>;
        registerAll(...arg0: V[]): void;
        isEmpty(): boolean;
        getSlaveMap(arg0: ResourceLocation_, arg1: Internal.Class_<T>): T;
        getRegistryKey(): Internal.ResourceKey<Internal.Registry<V>>;
        containsValue(arg0: V): boolean;
        containsKey(arg0: ResourceLocation_): boolean;
        getRegistrySuperType(): Internal.Class<V>;
        getHolder(arg0: ResourceLocation_): Internal.Optional<Internal.Holder<V>>;
        getValue(arg0: ResourceLocation_): V;
        getRegistryName(): ResourceLocation;
        getEntries(): Internal.Set<Internal.Map$Entry<Internal.ResourceKey<V>, V>>;
        getCodec(): Internal.Codec<V>;
        getKey(arg0: V): ResourceLocation;
        get defaultKey(): ResourceLocation
        get values(): Internal.Collection<V>
        get keys(): Internal.Set<ResourceLocation>
        get empty(): boolean
        get registryKey(): Internal.ResourceKey<Internal.Registry<V>>
        get registrySuperType(): Internal.Class<V>
        get registryName(): ResourceLocation
        get entries(): Internal.Set<Internal.Map$Entry<Internal.ResourceKey<V>, V>>
        get codec(): Internal.Codec<V>
    }
    type IForgeRegistry_<V> = IForgeRegistry<V>;
    class WouldSurvivePredicate implements net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate {
        type(): Internal.BlockPredicateType<any>;
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: any, arg1: any): boolean;
        negate(): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: Internal.WorldGenLevel_, arg1: BlockPos_): boolean;
        readonly static "CODEC": any;
    }
    type WouldSurvivePredicate_ = WouldSurvivePredicate;
    interface ServerPacketListener extends Internal.PacketListener {
        shouldPropagateHandlingExceptions(): boolean;
    }
    type ServerPacketListener_ = ServerPacketListener;
    class StreamTagVisitor$ValueResult extends Internal.Enum<Internal.StreamTagVisitor$ValueResult> {
        static values(): Internal.StreamTagVisitor$ValueResult[];
        static valueOf(arg0: string): Internal.StreamTagVisitor$ValueResult;
        readonly static "CONTINUE": Internal.StreamTagVisitor$ValueResult;
        readonly static "BREAK": Internal.StreamTagVisitor$ValueResult;
        readonly static "HALT": Internal.StreamTagVisitor$ValueResult;
    }
    type StreamTagVisitor$ValueResult_ = "break" | "halt" | StreamTagVisitor$ValueResult | "continue";
    class MoverType extends Internal.Enum<Internal.MoverType> {
        static valueOf(arg0: string): Internal.MoverType;
        static values(): Internal.MoverType[];
        readonly static "SHULKER": Internal.MoverType;
        readonly static "PISTON": Internal.MoverType;
        readonly static "SELF": Internal.MoverType;
        readonly static "SHULKER_BOX": Internal.MoverType;
        readonly static "PLAYER": Internal.MoverType;
    }
    type MoverType_ = "player" | MoverType | "shulker" | "shulker_box" | "self" | "piston";
    interface Int2ShortFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntUnaryOperator {
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Int2FloatFunction;
        andThenReference(arg0: Internal.Short2ReferenceFunction_<any>): Internal.Int2ReferenceFunction<T>;
        put(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: any): any;
        containsKey(arg0: number): boolean;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        containsKey(arg0: any): boolean;
        get(arg0: any): number;
        apply(arg0: number): number;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Int2CharFunction;
        remove(arg0: number): number;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2ShortFunction;
        put(arg0: number, arg1: number): number;
        defaultReturnValue(): number;
        get(arg0: number): number;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2ShortFunction;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        applyAsInt(arg0: number): number;
        put(arg0: any, arg1: any): any;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2ShortFunction;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Int2LongFunction;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2ShortFunction;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Int2DoubleFunction;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Int2ByteFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2ShortFunction;
        size(): number;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2ShortFunction;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Int2IntFunction;
        defaultReturnValue(arg0: number): void;
        clear(): void;
        andThenObject(arg0: Internal.Short2ObjectFunction_<any>): Internal.Int2ObjectFunction<T>;
        composeInt(arg0: Internal.Int2IntFunction_): this;
        getOrDefault(arg0: any, arg1: number): number;
        remove(arg0: any): any;
        composeReference(arg0: Internal.Reference2IntFunction_<any>): Internal.Reference2ShortFunction<T>;
        composeObject(arg0: Internal.Object2IntFunction_<any>): Internal.Object2ShortFunction<T>;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): this;
    }
    type Int2ShortFunction_ = ((arg0: number)=>number) | Int2ShortFunction;
    interface Int2ReferenceFunction <V> extends Internal.IntFunction<V>, it.unimi.dsi.fastutil.Function<number, V> {
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Int2ShortFunction;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Int2CharFunction;
        put(arg0: number, arg1: V): V;
        composeInt(arg0: Internal.Int2IntFunction_): this;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2ReferenceFunction<V>;
        composeReference(arg0: Internal.Reference2IntFunction_<any>): Internal.Reference2ReferenceFunction<T, V>;
        getOrDefault(arg0: any, arg1: V): V;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2ReferenceFunction<V>;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2ReferenceFunction<V>;
        containsKey(arg0: number): boolean;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Int2DoubleFunction;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Int2ByteFunction;
        get(arg0: number): V;
        containsKey(arg0: any): boolean;
        put(arg0: number, arg1: V): V;
        andThenObject(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Int2ObjectFunction<T>;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Int2LongFunction;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2ReferenceFunction<V>;
        get(arg0: any): V;
        apply(arg0: number): V;
        put(arg0: any, arg1: any): any;
        apply(arg0: number): V;
        remove(arg0: any): V;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Int2IntFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
        remove(arg0: number): V;
        getOrDefault(arg0: number, arg1: V): V;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Int2FloatFunction;
        composeObject(arg0: Internal.Object2IntFunction_<any>): Internal.Object2ReferenceFunction<T, V>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        size(): number;
        andThenReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Int2ReferenceFunction<T>;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2ReferenceFunction<V>;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2ReferenceFunction<V>;
        clear(): void;
        defaultReturnValue(): V;
        defaultReturnValue(arg0: V): void;
    }
    type Int2ReferenceFunction_<V> = Int2ReferenceFunction<V> | ((arg0: number)=>V);
    interface DiscreteVoxelShape$IntFaceConsumer {
        consume(arg0: Internal.Direction_, arg1: number, arg2: number, arg3: number): void;
    }
    type DiscreteVoxelShape$IntFaceConsumer_ = DiscreteVoxelShape$IntFaceConsumer;
    interface GroupPrincipal extends Internal.UserPrincipal {
        implies(arg0: Internal.Subject_): boolean;
    }
    type GroupPrincipal_ = GroupPrincipal;
    class RandomSpreadFoliagePlacer extends Internal.FoliagePlacer {
        constructor(arg0: Internal.IntProvider_, arg1: Internal.IntProvider_, arg2: Internal.IntProvider_, arg3: number)
        foliageHeight(arg0: Internal.Random_, arg1: number, arg2: Internal.TreeConfiguration_): number;
        readonly static "CODEC": any;
    }
    type RandomSpreadFoliagePlacer_ = RandomSpreadFoliagePlacer;
    class ScreenEvent$KeyboardCharTypedEvent extends Internal.ScreenEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: string, arg2: number)
        getModifiers(): number;
        getListenerList(): Internal.ListenerList;
        getCodePoint(): string;
        get modifiers(): number
        get listenerList(): Internal.ListenerList
        get codePoint(): string
    }
    type ScreenEvent$KeyboardCharTypedEvent_ = ScreenEvent$KeyboardCharTypedEvent;
    interface RandomAccess {
    }
    type RandomAccess_ = RandomAccess;
    class SpectatorGui extends Internal.GuiComponent implements Internal.SpectatorMenuListener {
        constructor(arg0: Internal.Minecraft_)
        isMenuActive(): boolean;
        onHotbarSelected(arg0: number): void;
        onMouseScrolled(arg0: number): void;
        renderTooltip(arg0: Internal.PoseStack_): void;
        renderHotbar(arg0: Internal.PoseStack_): void;
        onMouseMiddleClick(): void;
        onSpectatorMenuClosed(arg0: Internal.SpectatorMenu_): void;
        get menuActive(): boolean
        readonly static "SPECTATOR_LOCATION": ResourceLocation;
    }
    type SpectatorGui_ = SpectatorGui;
    interface Promise <V> extends io.netty.util.concurrent.Future<V> {
        removeListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        setFailure(arg0: Internal.Throwable_): this;
        setSuccess(arg0: V): this;
        syncUninterruptibly(): this;
        tryFailure(arg0: Internal.Throwable_): boolean;
        awaitUninterruptibly(): this;
        await(): this;
        sync(): this;
        addListener(arg0: Internal.GenericFutureListener_<any>): this;
        addListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        setUncancellable(): boolean;
        trySuccess(arg0: V): boolean;
        removeListener(arg0: Internal.GenericFutureListener_<any>): this;
        set failure(arg0: Internal.Throwable_)
        set success(arg0: V)
    }
    type Promise_<V> = Promise<V>;
    interface SpriteSet {
        get(arg0: number, arg1: number): Internal.TextureAtlasSprite;
        get(arg0: Internal.Random_): Internal.TextureAtlasSprite;
    }
    type SpriteSet_ = SpriteSet;
    class ItemModelShaper {
        constructor(arg0: Internal.ModelManager_)
        getItemModel(arg0: Internal.ItemStack_): Internal.BakedModel;
        getModelManager(): Internal.ModelManager;
        register(arg0: Internal.Item_, arg1: Internal.ModelResourceLocation_): void;
        rebuildCache(): void;
        getItemModel(arg0: Internal.Item_): Internal.BakedModel;
        get modelManager(): Internal.ModelManager
        readonly "shapes": Internal.Int2ObjectMap<Internal.ModelResourceLocation>;
    }
    type ItemModelShaper_ = ItemModelShaper;
    class UniformFloat extends Internal.FloatProvider {
        getMinValue(): number;
        toString(): string;
        getMaxValue(): number;
        sample(arg0: Internal.Random_): number;
        static of(arg0: number, arg1: number): Internal.UniformFloat;
        getType(): Internal.FloatProviderType<any>;
        get minValue(): number
        get maxValue(): number
        get type(): Internal.FloatProviderType<any>
        readonly static "CODEC": any;
    }
    type UniformFloat_ = UniformFloat;
    class File implements Internal.Comparable<Internal.File>, Internal.Serializable {
        constructor(arg0: string, arg1: string)
        constructor(arg0: string)
        constructor(arg0: Internal.URI_)
        constructor(arg0: Internal.File_, arg1: string)
        getAbsolutePath(): string;
        getParent(): string;
        toURL(): Internal.URL;
        delete(): boolean;
        setWritable(arg0: boolean, arg1: boolean): boolean;
        static createTempFile(arg0: string, arg1: string): Internal.File;
        isDirectory(): boolean;
        compareTo(arg0: any): number;
        getParentFile(): this;
        listFiles(): Internal.File[];
        toPath(): Internal.Path;
        mkdir(): boolean;
        compareTo(arg0: Internal.File_): number;
        isFile(): boolean;
        getFreeSpace(): number;
        deleteOnExit(): void;
        setReadable(arg0: boolean, arg1: boolean): boolean;
        setExecutable(arg0: boolean): boolean;
        static listRoots(): Internal.File[];
        listFiles(arg0: Internal.FilenameFilter_): Internal.File[];
        static createTempFile(arg0: string, arg1: string, arg2: Internal.File_): Internal.File;
        list(): string[];
        toURI(): Internal.URI;
        canExecute(): boolean;
        getAbsoluteFile(): this;
        canWrite(): boolean;
        getCanonicalFile(): this;
        listFiles(arg0: Internal.FileFilter_): Internal.File[];
        setLastModified(arg0: number): boolean;
        setReadable(arg0: boolean): boolean;
        getName(): string;
        getUsableSpace(): number;
        setWritable(arg0: boolean): boolean;
        list(arg0: Internal.FilenameFilter_): string[];
        getPath(): string;
        lastModified(): number;
        createNewFile(): boolean;
        setExecutable(arg0: boolean, arg1: boolean): boolean;
        length(): number;
        toString(): string;
        isHidden(): boolean;
        setReadOnly(): boolean;
        mkdirs(): boolean;
        hashCode(): number;
        renameTo(arg0: Internal.File_): boolean;
        getCanonicalPath(): string;
        canRead(): boolean;
        exists(): boolean;
        getTotalSpace(): number;
        equals(arg0: any): boolean;
        isAbsolute(): boolean;
        get absolutePath(): string
        get parent(): string
        get directory(): boolean
        get parentFile(): Internal.File
        get file(): boolean
        get freeSpace(): number
        set executable(arg0: boolean)
        get absoluteFile(): Internal.File
        get canonicalFile(): Internal.File
        set lastModified(arg0: number)
        set readable(arg0: boolean)
        get name(): string
        get usableSpace(): number
        set writable(arg0: boolean)
        get path(): string
        get hidden(): boolean
        get canonicalPath(): string
        get totalSpace(): number
        get absolute(): boolean
        readonly static "separator": "\\";
        readonly static "separatorChar": "\\";
        readonly static "pathSeparatorChar": ";";
        readonly static "pathSeparator": ";";
    }
    type File_ = File;
    interface ISkyRenderHandler {
        render(arg0: number, arg1: number, arg2: Internal.PoseStack_, arg3: Internal.ClientLevel_, arg4: Internal.Minecraft_): void;
    }
    type ISkyRenderHandler_ = ((arg0: number, arg1: number, arg2: Internal.PoseStack, arg3: Internal.ClientLevel, arg4: Internal.Minecraft)=>void) | ISkyRenderHandler;
    class ServerboundLockDifficultyPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: boolean)
        handle(arg0: Internal.PacketListener_): void;
        isLocked(): boolean;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        isSkippable(): boolean;
        get locked(): boolean
        get skippable(): boolean
    }
    type ServerboundLockDifficultyPacket_ = ServerboundLockDifficultyPacket;
    class ServerboundPlayerActionPacket$Action extends Internal.Enum<Internal.ServerboundPlayerActionPacket$Action> {
        static values(): Internal.ServerboundPlayerActionPacket$Action[];
        static valueOf(arg0: string): Internal.ServerboundPlayerActionPacket$Action;
        readonly static "DROP_ITEM": Internal.ServerboundPlayerActionPacket$Action;
        readonly static "DROP_ALL_ITEMS": Internal.ServerboundPlayerActionPacket$Action;
        readonly static "RELEASE_USE_ITEM": Internal.ServerboundPlayerActionPacket$Action;
        readonly static "START_DESTROY_BLOCK": Internal.ServerboundPlayerActionPacket$Action;
        readonly static "ABORT_DESTROY_BLOCK": Internal.ServerboundPlayerActionPacket$Action;
        readonly static "STOP_DESTROY_BLOCK": Internal.ServerboundPlayerActionPacket$Action;
        readonly static "SWAP_ITEM_WITH_OFFHAND": Internal.ServerboundPlayerActionPacket$Action;
    }
    type ServerboundPlayerActionPacket$Action_ = ServerboundPlayerActionPacket$Action | "drop_item" | "drop_all_items" | "abort_destroy_block" | "start_destroy_block" | "release_use_item" | "swap_item_with_offhand" | "stop_destroy_block";
    interface RegistryAccess$Frozen extends Internal.RegistryAccess {
        registry(arg0: Internal.ResourceKey_<any>): Internal.Optional<any>;
        allElementsLifecycle(): Internal.Lifecycle;
        registryOrThrow(arg0: Internal.ResourceKey_<any>): Internal.Registry<E>;
        networkSafeRegistries(): Internal.Stream<Internal.RegistryAccess$RegistryEntry<any>>;
        freeze(): this;
        registries(): Internal.Stream<Internal.RegistryAccess$RegistryEntry<any>>;
        ownedRegistryOrThrow(arg0: Internal.ResourceKey_<any>): Internal.Registry<E>;
    }
    type RegistryAccess$Frozen_ = RegistryAccess$Frozen;
    interface ClientTooltipComponent {
        create(arg0: Internal.FormattedCharSequence_): this;
        create(arg0: Internal.TooltipComponent_): this;
        renderImage(arg0: Internal.Font_, arg1: number, arg2: number, arg3: Internal.PoseStack_, arg4: Internal.ItemRenderer_, arg5: number): void;
        renderText(arg0: Internal.Font_, arg1: number, arg2: number, arg3: Internal.Matrix4f_, arg4: Internal.MultiBufferSource$BufferSource_): void;
        getHeight(): number;
        getWidth(arg0: Internal.Font_): number;
        get height(): number
    }
    type ClientTooltipComponent_ = ClientTooltipComponent;
    class DecimalStyle {
        getDecimalSeparator(): string;
        getNegativeSign(): string;
        static getAvailableLocales(): Internal.Set<Internal.Locale>;
        withZeroDigit(arg0: string): this;
        toString(): string;
        getZeroDigit(): string;
        withPositiveSign(arg0: string): this;
        static of(arg0: Internal.Locale_): Internal.DecimalStyle;
        withDecimalSeparator(arg0: string): this;
        hashCode(): number;
        getPositiveSign(): string;
        withNegativeSign(arg0: string): this;
        static ofDefaultLocale(): Internal.DecimalStyle;
        equals(arg0: any): boolean;
        get decimalSeparator(): string
        get negativeSign(): string
        get availableLocales(): Internal.Set<Internal.Locale>
        get zeroDigit(): string
        get positiveSign(): string
        readonly static "STANDARD": Internal.DecimalStyle;
    }
    type DecimalStyle_ = DecimalStyle;
    class GameProfileCache {
        constructor(arg0: Internal.GameProfileRepository_, arg1: Internal.File_)
        add(arg0: Internal.GameProfile_): void;
        get(arg0: string): Internal.Optional<Internal.GameProfile>;
        static setUsesAuthentication(arg0: boolean): void;
        clearExecutor(): void;
        save(): void;
        get(arg0: Internal.UUID_): Internal.Optional<Internal.GameProfile>;
        getAsync(arg0: string, arg1: Internal.Consumer_<Internal.Optional_<Internal.GameProfile_>>): void;
        setExecutor(arg0: Internal.Executor_): void;
        load(): Internal.List<Internal.GameProfileCache$GameProfileInfo>;
        set usesAuthentication(arg0: boolean)
        set executor(arg0: Internal.Executor_)
    }
    type GameProfileCache_ = GameProfileCache;
    class ItemLeftClickEventJS extends Internal.PlayerEventJS {
        constructor(player: Internal.Player_, hand: Hand_)
        getEntity(): Internal.EntityJS;
        getItem(): Internal.ItemStackJS;
        get entity(): Internal.EntityJS
        get item(): Internal.ItemStackJS
    }
    type ItemLeftClickEventJS_ = ItemLeftClickEventJS;
    class OrderedCompoundTag extends Internal.CompoundTag {
        constructor()
        constructor(map: Internal.Map_<string, Internal.Tag_>)
        getAsString(): string;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        copy(): Internal.Tag;
        write(dataOutput: Internal.DataOutput_): void;
        get asString(): string
        readonly "tagMap": Internal.Map<string, Internal.Tag>;
    }
    type OrderedCompoundTag_ = OrderedCompoundTag;
    class Bat extends Internal.AmbientCreature {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static checkBatSpawnRules(arg0: Internal.EntityType_<Internal.Bat_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        isResting(): boolean;
        getStepHeight(): number;
        setResting(arg0: boolean): void;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getAmbientSound(): Internal.SoundEvent;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        getVoicePitch(): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        isFlapping(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        isPushable(): boolean;
        isIgnoringBlockTriggers(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get resting(): boolean
        get stepHeight(): number
        set resting(arg0: boolean)
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get ambientSound(): Internal.SoundEvent
        get voicePitch(): number
        get flapping(): boolean
        get pushable(): boolean
        get ignoringBlockTriggers(): boolean
        readonly static "TICKS_PER_FLAP": 3;
        readonly static "FLAP_DEGREES_PER_TICK": 74.48451;
    }
    type Bat_ = Bat;
    class RenderStateShard$OutputStateShard extends Internal.RenderStateShard {
        constructor(arg0: string, arg1: Internal.Runnable_, arg2: Internal.Runnable_)
    }
    type RenderStateShard$OutputStateShard_ = RenderStateShard$OutputStateShard;
    interface ServerPlayerConnection {
        send(arg0: Internal.Packet_<any>): void;
        getPlayer(): Internal.ServerPlayer;
        get player(): Internal.ServerPlayer
    }
    type ServerPlayerConnection_ = ServerPlayerConnection;
    abstract class ScreenEvent$MouseReleasedEvent extends Internal.ScreenEvent$MouseInputEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number, arg3: number)
        getButton(): number;
        getListenerList(): Internal.ListenerList;
        get button(): number
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$MouseReleasedEvent_ = ScreenEvent$MouseReleasedEvent;
    class NetworkEvent$PacketDispatcher {
        sendPacket(arg0: ResourceLocation_, arg1: Internal.FriendlyByteBuf_): void;
    }
    type NetworkEvent$PacketDispatcher_ = NetworkEvent$PacketDispatcher;
    class Pair$Mu <S> implements Internal.K1 {
        constructor()
    }
    type Pair$Mu_<S> = Pair$Mu<S>;
    class ServerboundPlayerInputPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: number, arg1: number, arg2: boolean, arg3: boolean)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getXxa(): number;
        isJumping(): boolean;
        isShiftKeyDown(): boolean;
        getZza(): number;
        isSkippable(): boolean;
        get xxa(): number
        get jumping(): boolean
        get shiftKeyDown(): boolean
        get zza(): number
        get skippable(): boolean
    }
    type ServerboundPlayerInputPacket_ = ServerboundPlayerInputPacket;
    interface IKeyConflictContext {
        isActive(): boolean;
        conflicts(arg0: Internal.IKeyConflictContext_): boolean;
        get active(): boolean
    }
    type IKeyConflictContext_ = IKeyConflictContext;
    class DripstoneClusterConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: number, arg1: Internal.IntProvider_, arg2: Internal.IntProvider_, arg3: number, arg4: number, arg5: Internal.IntProvider_, arg6: Internal.FloatProvider_, arg7: Internal.FloatProvider_, arg8: number, arg9: number, arg10: number)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "heightDeviation": number;
        readonly "maxDistanceFromCenterAffectingHeightBias": number;
        readonly "maxStalagmiteStalactiteHeightDiff": number;
        readonly "wetness": Internal.FloatProvider;
        readonly "floorToCeilingSearchRange": number;
        readonly "height": Internal.IntProvider;
        readonly "maxDistanceFromEdgeAffectingChanceOfDripstoneColumn": number;
        readonly "dripstoneBlockLayerThickness": Internal.IntProvider;
        readonly "density": Internal.FloatProvider;
        readonly "chanceOfDripstoneColumnAtMaxDistanceFromCenter": number;
        readonly static "CODEC": any;
        readonly "radius": Internal.IntProvider;
    }
    type DripstoneClusterConfiguration_ = DripstoneClusterConfiguration;
    interface Float2BooleanFunction extends Internal.DoublePredicate, it.unimi.dsi.fastutil.Function<number, boolean> {
        or(arg0: Internal.DoublePredicate_): Internal.DoublePredicate;
        test(arg0: number): boolean;
        getOrDefault(arg0: any, arg1: any): any;
        get(arg0: number): boolean;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Float2IntFunction;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2BooleanFunction;
        composeReference(arg0: Internal.Reference2FloatFunction_<any>): Internal.Reference2BooleanFunction<T>;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2BooleanFunction;
        containsKey(arg0: any): boolean;
        get(arg0: any): boolean;
        apply(arg0: number): boolean;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Float2FloatFunction;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Float2CharFunction;
        andThenObject(arg0: Internal.Boolean2ObjectFunction_<any>): Internal.Float2ObjectFunction<T>;
        put(arg0: any, arg1: any): any;
        andThenReference(arg0: Internal.Boolean2ReferenceFunction_<any>): Internal.Float2ReferenceFunction<T>;
        containsKey(arg0: number): boolean;
        defaultReturnValue(): boolean;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2BooleanFunction;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2BooleanFunction;
        and(arg0: Internal.DoublePredicate_): Internal.DoublePredicate;
        getOrDefault(arg0: any, arg1: boolean): boolean;
        put(arg0: number, arg1: boolean): boolean;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2BooleanFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Float2ByteFunction;
        composeObject(arg0: Internal.Object2FloatFunction_<any>): Internal.Object2BooleanFunction<T>;
        put(arg0: number, arg1: boolean): boolean;
        composeFloat(arg0: Internal.Float2FloatFunction_): this;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, boolean>;
        remove(arg0: number): boolean;
        size(): number;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Float2ShortFunction;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2BooleanFunction;
        clear(): void;
        remove(arg0: any): any;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Float2DoubleFunction;
        getOrDefault(arg0: number, arg1: boolean): boolean;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Float2LongFunction;
        negate(): Internal.DoublePredicate;
        defaultReturnValue(arg0: boolean): void;
    }
    type Float2BooleanFunction_ = Float2BooleanFunction | ((arg0: number)=>boolean);
    class HotbarManager {
        constructor(arg0: Internal.File_, arg1: Internal.DataFixer_)
        get(arg0: number): Internal.Hotbar;
        save(): void;
        readonly static "NUM_HOTBAR_GROUPS": 9;
    }
    type HotbarManager_ = HotbarManager;
    class GameTestDebugRenderer implements Internal.DebugRenderer$SimpleDebugRenderer {
        constructor()
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource_, arg2: number, arg3: number, arg4: number): void;
        addMarker(arg0: BlockPos_, arg1: number, arg2: string, arg3: number): void;
        clear(): void;
    }
    type GameTestDebugRenderer_ = GameTestDebugRenderer;
    class DataResult$Mu implements Internal.K1 {
        constructor()
    }
    type DataResult$Mu_ = DataResult$Mu;
    class VillagerBabiesSensor extends Internal.Sensor<Internal.LivingEntity> {
        constructor()
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
    }
    type VillagerBabiesSensor_ = VillagerBabiesSensor;
    class MusicManager {
        constructor(arg0: Internal.Minecraft_)
        startPlaying(arg0: Internal.Music_): void;
        stopPlaying(): void;
        tick(): void;
        isPlayingMusic(arg0: Internal.Music_): boolean;
    }
    type MusicManager_ = MusicManager;
    class LootBuilder implements Internal.FunctionContainer, Internal.ConditionContainer {
        constructor(prev: Internal.JsonElement_)
        clearPools(): void;
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer;
        name(name: Internal.Component_, entity: Internal.LootContext$EntityTarget_): Internal.FunctionContainer;
        damage(damage: Internal.NumberProvider_): Internal.FunctionContainer;
        addPool(p: Internal.Consumer_<Internal.LootBuilderPool_>): void;
        toJson(): Internal.JsonObject;
        survivesExplosion(): Internal.ConditionContainer;
        count(count: Internal.NumberProvider_): Internal.FunctionContainer;
        addFunction(o: Internal.JsonObject_): this;
        clearConditions(): void;
        copyName(source: Internal.CopyNameFunction$NameSource_): Internal.FunctionContainer;
        addCondition(o: Internal.JsonObject_): this;
        lootTable(table: ResourceLocation_, seed: number): Internal.FunctionContainer;
        enchantWithLevels(levels: Internal.NumberProvider_, treasure: boolean): Internal.FunctionContainer;
        enchantRandomly(enchantments: ResourceLocation_[]): Internal.FunctionContainer;
        furnaceSmelt(): Internal.FunctionContainer;
        entityProperties(entity: Internal.LootContext$EntityTarget_, properties: Internal.JsonObject_): Internal.ConditionContainer;
        clearFunctions(): void;
        lootingEnchant(count: Internal.NumberProvider_, limit: number): Internal.FunctionContainer;
        addConditionalFunction(func: Internal.Consumer_<Internal.ConditionalFunction_>): Internal.FunctionContainer;
        randomChance(chance: number): Internal.ConditionContainer;
        killedByPlayer(): Internal.ConditionContainer;
        nbt(tag: Internal.CompoundTag_): Internal.FunctionContainer;
        entityScores(entity: Internal.LootContext$EntityTarget_, scores: Internal.Map_<string, any>): Internal.ConditionContainer;
        name(name: Internal.Component_): Internal.FunctionContainer;
        "type": string;
        "conditions": Internal.JsonArray;
        "pools": Internal.JsonArray;
        "functions": Internal.JsonArray;
        "customId": ResourceLocation;
    }
    type LootBuilder_ = LootBuilder;
    class GameRules$Key <T> {
        constructor(arg0: string, arg1: Internal.GameRules$Category_)
        hashCode(): number;
        getCategory(): Internal.GameRules$Category;
        toString(): string;
        equals(arg0: any): boolean;
        getId(): string;
        getDescriptionId(): string;
        get category(): Internal.GameRules$Category
        get id(): string
        get descriptionId(): string
    }
    type GameRules$Key_<T> = GameRules$Key<T>;
    class DataJsonGenerator extends Internal.JsonGenerator {
        constructor(m: Internal.Map_<ResourceLocation_, Internal.JsonElement_>)
    }
    type DataJsonGenerator_ = DataJsonGenerator;
    abstract class Behavior <E> {
        constructor(arg0: Internal.Map_<Internal.MemoryModuleType_<any>, Internal.MemoryStatus_>, arg1: number)
        constructor(arg0: Internal.Map_<Internal.MemoryModuleType_<any>, Internal.MemoryStatus_>)
        constructor(arg0: Internal.Map_<Internal.MemoryModuleType_<any>, Internal.MemoryStatus_>, arg1: number, arg2: number)
        tryStart(arg0: Internal.ServerLevel_, arg1: E, arg2: number): boolean;
        toString(): string;
        doStop(arg0: Internal.ServerLevel_, arg1: E, arg2: number): void;
        getStatus(): Internal.Behavior$Status;
        tickOrStop(arg0: Internal.ServerLevel_, arg1: E, arg2: number): void;
        get status(): Internal.Behavior$Status
    }
    type Behavior_<E> = Behavior<E>;
    class Commands {
        constructor(arg0: Internal.Commands$CommandSelection_)
        static literal(arg0: string): Internal.LiteralArgumentBuilder<Internal.CommandSourceStack>;
        static argument(arg0: string, arg1: Internal.ArgumentType_<T>): Internal.RequiredArgumentBuilder<Internal.CommandSourceStack, T>;
        static getParseException(arg0: Internal.ParseResults_<S>): Internal.CommandSyntaxException;
        getDispatcher(): Internal.CommandDispatcher<Internal.CommandSourceStack>;
        performCommand(arg0: Internal.CommandSourceStack_, arg1: string): number;
        static createValidator(arg0: Internal.Commands$ParseFunction_): Internal.Predicate<string>;
        static validate(): void;
        sendCommands(arg0: Internal.ServerPlayer_): void;
        get dispatcher(): Internal.CommandDispatcher<Internal.CommandSourceStack>
        readonly static "LEVEL_OWNERS": 4;
        readonly static "LEVEL_ALL": 0;
        readonly static "LEVEL_MODERATORS": 1;
        readonly static "LEVEL_ADMINS": 3;
        readonly static "LEVEL_GAMEMASTERS": 2;
    }
    type Commands_ = Commands;
    class StonecutterMenu extends Internal.AbstractContainerMenu {
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: any_)
        constructor(arg0: number, arg1: Internal.Inventory_)
        stillValid(arg0: Internal.Player_): boolean;
        getRecipes(): Internal.List<Internal.StonecutterRecipe>;
        getSelectedRecipeIndex(): number;
        canTakeItemForPickAll(arg0: Internal.ItemStack_, arg1: Internal.Slot_): boolean;
        slotsChanged(arg0: Internal.Container_): void;
        clickMenuButton(arg0: Internal.Player_, arg1: number): boolean;
        hasInputItem(): boolean;
        getType(): Internal.MenuType<any>;
        getNumRecipes(): number;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        registerUpdateListener(arg0: Internal.Runnable_): void;
        removed(arg0: Internal.Player_): void;
        get recipes(): Internal.List<Internal.StonecutterRecipe>
        get selectedRecipeIndex(): number
        get type(): Internal.MenuType<any>
        get numRecipes(): number
        readonly static "INPUT_SLOT": 0;
        readonly static "RESULT_SLOT": 1;
        readonly "container": Internal.Container;
    }
    type StonecutterMenu_ = StonecutterMenu;
    interface PlayerSelector {
        uuid(uuid: Internal.UUID_): this;
        getPlayer(arg0: Internal.Map_<Internal.UUID_, any>): Internal.ServerPlayerJS;
        or(fallback: Internal.PlayerSelector_): this;
        mc(player: Internal.Player_): this;
        fuzzyName(name: string): this;
        of(o: any): this;
        identity(player: Internal.ServerPlayerJS_): this;
        name(name: string): this;
    }
    type PlayerSelector_ = PlayerSelector | ((arg0: Internal.Map<Internal.UUID, any>)=>Internal.ServerPlayerJS_);
    abstract class AbstractHurtingProjectile extends Internal.Projectile {
        constructor(arg0: Internal.EntityType_<any>, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.Level_)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.LivingEntity_, arg2: number, arg3: number, arg4: number, arg5: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        recreateFromPacket(arg0: Internal.ClientboundAddEntityPacket_): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getBrightness(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getPickRadius(): number;
        getStepHeight(): number;
        isPickable(): boolean;
        tick(): void;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getAddEntityPacket(): Internal.Packet<any>;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRenderAtSqrDistance(arg0: number): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get brightness(): number
        get pickRadius(): number
        get stepHeight(): number
        get pickable(): boolean
        get addEntityPacket(): Internal.Packet<any>
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        "zPower": number;
        "yPower": number;
        "xPower": number;
    }
    type AbstractHurtingProjectile_ = AbstractHurtingProjectile;
    class LivingKnockBackEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.LivingEntity_, arg1: number, arg2: number, arg3: number)
        getOriginalRatioX(): number;
        getRatioZ(): number;
        setRatioX(arg0: number): void;
        getRatioX(): number;
        getOriginalStrength(): number;
        isCancelable(): boolean;
        getStrength(): number;
        getOriginalRatioZ(): number;
        setRatioZ(arg0: number): void;
        getListenerList(): Internal.ListenerList;
        setStrength(arg0: number): void;
        get originalRatioX(): number
        get ratioZ(): number
        set ratioX(arg0: number)
        get ratioX(): number
        get originalStrength(): number
        get cancelable(): boolean
        get strength(): number
        get originalRatioZ(): number
        set ratioZ(arg0: number)
        get listenerList(): Internal.ListenerList
        set strength(arg0: number)
    }
    type LivingKnockBackEvent_ = LivingKnockBackEvent;
    class ClientboundDisconnectPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.Component_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getReason(): Internal.Component;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get reason(): Internal.Component
        get skippable(): boolean
    }
    type ClientboundDisconnectPacket_ = ClientboundDisconnectPacket;
    interface Symbol {
    }
    type Symbol_ = Symbol;
    class ClientboundUpdateAdvancementsPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: boolean, arg1: Internal.Collection_<Internal.Advancement_>, arg2: Internal.Set_<ResourceLocation_>, arg3: Internal.Map_<ResourceLocation_, Internal.AdvancementProgress_>)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getRemoved(): Internal.Set<ResourceLocation>;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getAdded(): Internal.Map<ResourceLocation, Internal.Advancement$Builder>;
        getProgress(): Internal.Map<ResourceLocation, Internal.AdvancementProgress>;
        isSkippable(): boolean;
        shouldReset(): boolean;
        get removed(): Internal.Set<ResourceLocation>
        get added(): Internal.Map<ResourceLocation, Internal.Advancement$Builder>
        get progress(): Internal.Map<ResourceLocation, Internal.AdvancementProgress>
        get skippable(): boolean
    }
    type ClientboundUpdateAdvancementsPacket_ = ClientboundUpdateAdvancementsPacket;
    class CompositeByteBuf extends Internal.AbstractReferenceCountedByteBuf implements Internal.Iterable<Internal.ByteBuf> {
        constructor(arg0: Internal.ByteBufAllocator_, arg1: boolean, arg2: number, ...arg3: Internal.ByteBuf_[])
        constructor(arg0: Internal.ByteBufAllocator_, arg1: boolean, arg2: number, arg3: Internal.Iterable_<Internal.ByteBuf_>)
        constructor(arg0: Internal.ByteBufAllocator_, arg1: boolean, arg2: number)
        resetWriterIndex(): this;
        resetReaderIndex(): this;
        writeInt(arg0: number): Internal.ByteBuf;
        addComponent(arg0: boolean, arg1: Internal.ByteBuf_): this;
        markReaderIndex(): Internal.ByteBuf;
        nioBufferCount(): number;
        markWriterIndex(): Internal.ByteBuf;
        nioBuffers(): Internal.ByteBuffer[];
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        writeFloat(arg0: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        toComponentIndex(arg0: number): number;
        memoryAddress(): number;
        setFloat(arg0: number, arg1: number): Internal.ByteBuf;
        ensureWritable(arg0: number): Internal.ByteBuf;
        writeShort(arg0: number): this;
        removeComponent(arg0: number): this;
        internalComponentAtOffset(arg0: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.OutputStream_, arg2: number): this;
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel_, arg2: number): number;
        getByte(arg0: number): number;
        maxNumComponents(): number;
        retain(arg0: number): Internal.ReferenceCounted;
        skipBytes(arg0: number): this;
        component(arg0: number): Internal.ByteBuf;
        writeMedium(arg0: number): Internal.ByteBuf;
        copy(arg0: number, arg1: number): Internal.ByteBuf;
        addComponents(arg0: number, arg1: Internal.Iterable_<Internal.ByteBuf_>): this;
        addComponent(arg0: boolean, arg1: number, arg2: Internal.ByteBuf_): this;
        consolidate(arg0: number, arg1: number): this;
        readBytes(arg0: number[]): Internal.ByteBuf;
        iterator(): Internal.Iterator<Internal.ByteBuf>;
        writerIndex(arg0: number): Internal.ByteBuf;
        decompose(arg0: number, arg1: number): Internal.List<Internal.ByteBuf>;
        spliterator(): Internal.Spliterator<Internal.ByteBuf>;
        arrayOffset(): number;
        readBytes(arg0: Internal.ByteBuffer_): Internal.ByteBuf;
        writeBoolean(arg0: boolean): this;
        readBytes(arg0: Internal.ByteBuf_, arg1: number): Internal.ByteBuf;
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        addComponents(...arg0: Internal.ByteBuf_[]): this;
        setBoolean(arg0: number, arg1: boolean): this;
        addComponent(arg0: Internal.ByteBuf_): this;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): this;
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        setShort(arg0: number, arg1: number): Internal.ByteBuf;
        toString(): string;
        addComponents(arg0: boolean, arg1: Internal.Iterable_<Internal.ByteBuf_>): this;
        writeBytes(arg0: Internal.ByteBuf_): this;
        addFlattenedComponents(arg0: boolean, arg1: Internal.ByteBuf_): this;
        setBytes(arg0: number, arg1: Internal.ByteBuffer_): this;
        capacity(arg0: number): this;
        getBytes(arg0: number, arg1: Internal.ByteBuffer_): this;
        consolidate(): this;
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): this;
        unwrap(): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): this;
        retain(): Internal.ReferenceCounted;
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        writeBytes(arg0: number[]): Internal.ByteBuf;
        toByteIndex(arg0: number): number;
        writeChar(arg0: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.InputStream_, arg2: number): number;
        isDirect(): boolean;
        writeByte(arg0: number): this;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number): this;
        componentAtOffset(arg0: number): Internal.ByteBuf;
        touch(): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): Internal.ByteBuf;
        addComponents(arg0: boolean, ...arg1: Internal.ByteBuf_[]): this;
        setLong(arg0: number, arg1: number): Internal.ByteBuf;
        order(): Internal.ByteOrder;
        setMedium(arg0: number, arg1: number): this;
        getBytes(arg0: number, arg1: number[]): this;
        setInt(arg0: number, arg1: number): Internal.ByteBuf;
        setByte(arg0: number, arg1: number): this;
        discardSomeReadBytes(): Internal.ByteBuf;
        alloc(): Internal.ByteBufAllocator;
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        writeBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): this;
        setChar(arg0: number, arg1: number): this;
        numComponents(): number;
        writeBytes(arg0: Internal.ByteBuffer_): Internal.ByteBuf;
        array(): number[];
        setBytes(arg0: number, arg1: number[]): this;
        readBytes(arg0: Internal.OutputStream_, arg1: number): Internal.ByteBuf;
        capacity(): number;
        readerIndex(arg0: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        addComponent(arg0: number, arg1: Internal.ByteBuf_): this;
        forEach(arg0: Internal.Consumer_<any>): void;
        clear(): this;
        hasMemoryAddress(): boolean;
        addComponents(arg0: Internal.Iterable_<Internal.ByteBuf_>): this;
        setZero(arg0: number, arg1: number): Internal.ByteBuf;
        internalComponent(arg0: number): Internal.ByteBuf;
        writeLong(arg0: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_): Internal.ByteBuf;
        setIndex(arg0: number, arg1: number): Internal.ByteBuf;
        removeComponents(arg0: number, arg1: number): this;
        writeZero(arg0: number): this;
        hasArray(): boolean;
        setBytes(arg0: number, arg1: Internal.ByteBuf_): this;
        addComponents(arg0: number, ...arg1: Internal.ByteBuf_[]): this;
        writeDouble(arg0: number): this;
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel_, arg2: number): number;
        getBytes(arg0: number, arg1: Internal.ByteBuf_): this;
        readBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): Internal.ByteBuf;
        discardReadComponents(): this;
        getBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        setDouble(arg0: number, arg1: number): Internal.ByteBuf;
        discardReadBytes(): this;
        touch(arg0: any): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): this;
        get direct(): boolean
    }
    type CompositeByteBuf_ = CompositeByteBuf;
    class OffsetDateTime implements Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.OffsetDateTime>, Internal.Serializable {
        getHour(): number;
        minusDays(arg0: number): this;
        getMonth(): Internal.Month;
        toLocalTime(): Internal.LocalTime;
        toInstant(): Internal.Instant;
        getDayOfWeek(): Internal.DayOfWeek;
        toZonedDateTime(): Internal.ZonedDateTime;
        minus(arg0: number, arg1: Internal.TemporalUnit_): this;
        withOffsetSameInstant(arg0: Internal.ZoneOffset_): this;
        compareTo(arg0: any): number;
        getMinute(): number;
        plus(arg0: Internal.TemporalAmount_): this;
        getDayOfMonth(): number;
        with(arg0: Internal.TemporalAdjuster_): Internal.Temporal;
        plusSeconds(arg0: number): this;
        plusMinutes(arg0: number): this;
        withYear(arg0: number): this;
        withDayOfYear(arg0: number): this;
        isSupported(arg0: Internal.TemporalField_): boolean;
        plusDays(arg0: number): this;
        format(arg0: Internal.DateTimeFormatter_): string;
        static parse(arg0: Internal.CharSequence_): Internal.OffsetDateTime;
        minusMinutes(arg0: number): this;
        plusWeeks(arg0: number): this;
        withHour(arg0: number): this;
        plus(arg0: number, arg1: Internal.TemporalUnit_): this;
        withOffsetSameLocal(arg0: Internal.ZoneOffset_): this;
        atZoneSimilarLocal(arg0: Internal.ZoneId_): Internal.ZonedDateTime;
        getYear(): number;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        withDayOfMonth(arg0: number): this;
        withMonth(arg0: number): this;
        get(arg0: Internal.TemporalField_): number;
        truncatedTo(arg0: Internal.TemporalUnit_): this;
        minusYears(arg0: number): this;
        toEpochSecond(): number;
        static now(arg0: Internal.Clock_): Internal.OffsetDateTime;
        toOffsetTime(): Internal.OffsetTime;
        compareTo(arg0: Internal.OffsetDateTime_): number;
        getMonthValue(): number;
        plusHours(arg0: number): this;
        isEqual(arg0: Internal.OffsetDateTime_): boolean;
        withNano(arg0: number): this;
        plusMonths(arg0: number): this;
        minusNanos(arg0: number): this;
        static now(): Internal.OffsetDateTime;
        static from(arg0: Internal.TemporalAccessor_): Internal.OffsetDateTime;
        toLocalDate(): Internal.LocalDate;
        with(arg0: Internal.TemporalField_, arg1: number): this;
        isAfter(arg0: Internal.OffsetDateTime_): boolean;
        minusHours(arg0: number): this;
        isBefore(arg0: Internal.OffsetDateTime_): boolean;
        static ofInstant(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.OffsetDateTime;
        static timeLineOrder(): Internal.Comparator<Internal.OffsetDateTime>;
        getLong(arg0: Internal.TemporalField_): number;
        plusYears(arg0: number): this;
        getOffset(): Internal.ZoneOffset;
        static parse(arg0: Internal.CharSequence_, arg1: Internal.DateTimeFormatter_): Internal.OffsetDateTime;
        withSecond(arg0: number): this;
        static of(arg0: Internal.LocalDate_, arg1: Internal.LocalTime_, arg2: Internal.ZoneOffset_): Internal.OffsetDateTime;
        toString(): string;
        minusSeconds(arg0: number): this;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        getDayOfYear(): number;
        query(arg0: Internal.TemporalQuery_<R>): R;
        minusWeeks(arg0: number): this;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        toLocalDateTime(): Internal.LocalDateTime;
        minus(arg0: Internal.TemporalAmount_): this;
        minusMonths(arg0: number): this;
        getNano(): number;
        getSecond(): number;
        plusNanos(arg0: number): this;
        hashCode(): number;
        withMinute(arg0: number): this;
        static of(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneOffset_): Internal.OffsetDateTime;
        atZoneSameInstant(arg0: Internal.ZoneId_): Internal.ZonedDateTime;
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneOffset_): Internal.OffsetDateTime;
        static now(arg0: Internal.ZoneId_): Internal.OffsetDateTime;
        equals(arg0: any): boolean;
        get hour(): number
        get month(): Internal.Month
        get dayOfWeek(): Internal.DayOfWeek
        get minute(): number
        get dayOfMonth(): number
        get year(): number
        get monthValue(): number
        get offset(): Internal.ZoneOffset
        get dayOfYear(): number
        get nano(): number
        get second(): number
        readonly static "MIN": Internal.OffsetDateTime;
        readonly static "MAX": Internal.OffsetDateTime;
    }
    type OffsetDateTime_ = OffsetDateTime;
    abstract class BossEvent {
        constructor(arg0: Internal.UUID_, arg1: Internal.Component_, arg2: Internal.BossEvent$BossBarColor_, arg3: Internal.BossEvent$BossBarOverlay_)
        setCreateWorldFog(arg0: boolean): this;
        getColor(): Internal.BossEvent$BossBarColor;
        shouldCreateWorldFog(): boolean;
        getProgress(): number;
        setPlayBossMusic(arg0: boolean): this;
        getName(): Internal.Component;
        setOverlay(arg0: Internal.BossEvent$BossBarOverlay_): void;
        getOverlay(): Internal.BossEvent$BossBarOverlay;
        setColor(arg0: Internal.BossEvent$BossBarColor_): void;
        setDarkenScreen(arg0: boolean): this;
        setName(arg0: Internal.Component_): void;
        setProgress(arg0: number): void;
        shouldPlayBossMusic(): boolean;
        getId(): Internal.UUID;
        shouldDarkenScreen(): boolean;
        set createWorldFog(arg0: boolean)
        get color(): Internal.BossEvent$BossBarColor
        get progress(): number
        set playBossMusic(arg0: boolean)
        get name(): Internal.Component
        set overlay(arg0: Internal.BossEvent$BossBarOverlay_)
        get overlay(): Internal.BossEvent$BossBarOverlay
        set color(arg0: Internal.BossEvent$BossBarColor_)
        set darkenScreen(arg0: boolean)
        set name(arg0: Internal.Component_)
        set progress(arg0: number)
        get id(): Internal.UUID
    }
    type BossEvent_ = BossEvent;
    class CarverConfiguration extends Internal.ProbabilityFeatureConfiguration {
        constructor(arg0: number, arg1: Internal.HeightProvider_, arg2: Internal.FloatProvider_, arg3: Internal.VerticalAnchor_, arg4: Internal.CarverDebugSettings_)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "lavaLevel": Internal.VerticalAnchor;
        readonly "y": Internal.HeightProvider;
        readonly "debugSettings": Internal.CarverDebugSettings;
        readonly static "CODEC": any;
        readonly "yScale": Internal.FloatProvider;
    }
    type CarverConfiguration_ = CarverConfiguration;
    interface Command <S> {
        run(arg0: Internal.CommandContext_<S>): number;
        readonly static "SINGLE_SUCCESS": 1;
    }
    type Command_<S> = Command<S> | ((arg0: Internal.CommandContext<S>)=>number);
    class BeeDebugRenderer$HiveInfo {
        constructor(arg0: BlockPos_, arg1: string, arg2: number, arg3: number, arg4: boolean, arg5: number)
        readonly "pos": BlockPos;
        readonly "occupantCount": number;
        readonly "lastSeen": number;
        readonly "hiveType": string;
        readonly "sedated": boolean;
        readonly "honeyLevel": number;
    }
    type BeeDebugRenderer$HiveInfo_ = BeeDebugRenderer$HiveInfo;
    class ItemModifierManager extends Internal.SimpleJsonResourceReloadListener {
        constructor(arg0: Internal.PredicateManager_, arg1: Internal.LootTables_)
        getName(): string;
        getKeys(): Internal.Set<ResourceLocation>;
        get(arg0: ResourceLocation_, arg1: Internal.LootItemFunction_): Internal.LootItemFunction;
        get(arg0: ResourceLocation_): Internal.LootItemFunction;
        get name(): string
        get keys(): Internal.Set<ResourceLocation>
    }
    type ItemModifierManager_ = ItemModifierManager;
    class HashMap <K, V> extends Internal.AbstractMap<K, V> implements Internal.Cloneable, Internal.Map<K, V>, Internal.Serializable {
        constructor()
        constructor(arg0: number)
        constructor(arg0: Internal.Map_<any, any>)
        constructor(arg0: number, arg1: number)
        clone(): any;
        replace(arg0: K, arg1: V): V;
        keySet(): Internal.Set<K>;
        putIfAbsent(arg0: K, arg1: V): V;
        values(): Internal.Collection<V>;
        containsValue(arg0: any): boolean;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        getOrDefault(arg0: any, arg1: V): V;
        putAll(arg0: Internal.Map_<any, any>): void;
        remove(arg0: any, arg1: any): boolean;
        isEmpty(): boolean;
        computeIfAbsent(arg0: K, arg1: Internal.Function_<any, any>): V;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        containsKey(arg0: any): boolean;
        size(): number;
        put(arg0: K, arg1: V): V;
        replaceAll(arg0: Internal.BiFunction_<any, any, any>): void;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        clear(): void;
        get(arg0: any): V;
        remove(arg0: any): V;
        compute(arg0: K, arg1: Internal.BiFunction_<any, any, any>): V;
        merge(arg0: K, arg1: V, arg2: Internal.BiFunction_<any, any, any>): V;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<any, any, any>): V;
        get empty(): boolean
    }
    type HashMap_<K, V> = HashMap<K, V>;
    interface Multimap <K, V> {
        putAll(arg0: Internal.Multimap_<any, any>): boolean;
        keySet(): Internal.Set<K>;
        removeAll(arg0: any): Internal.Collection<V>;
        get(arg0: K): Internal.Collection<V>;
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>;
        putAll(arg0: K, arg1: Internal.Iterable_<any>): boolean;
        values(): Internal.Collection<V>;
        containsValue(arg0: any): boolean;
        remove(arg0: any, arg1: any): boolean;
        isEmpty(): boolean;
        containsEntry(arg0: any, arg1: any): boolean;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        containsKey(arg0: any): boolean;
        size(): number;
        hashCode(): number;
        replaceValues(arg0: K, arg1: Internal.Iterable_<any>): Internal.Collection<V>;
        put(arg0: K, arg1: V): boolean;
        clear(): void;
        keys(): Internal.Multiset<K>;
        equals(arg0: any): boolean;
        asMap(): Internal.Map<K, Internal.Collection<V>>;
        get empty(): boolean
    }
    type Multimap_<K, V> = Multimap<K, V>;
    interface ContainerEventHandler extends Internal.GuiEventListener {
        charTyped(arg0: string, arg1: number): boolean;
        magicalSpecialHackyFocus(arg0: Internal.GuiEventListener_): void;
        mouseReleased(arg0: number, arg1: number, arg2: number): boolean;
        changeFocus(arg0: boolean): boolean;
        mouseClicked(arg0: number, arg1: number, arg2: number): boolean;
        mouseScrolled(arg0: number, arg1: number, arg2: number): boolean;
        keyReleased(arg0: number, arg1: number, arg2: number): boolean;
        setFocused(arg0: Internal.GuiEventListener_): void;
        keyPressed(arg0: number, arg1: number, arg2: number): boolean;
        setInitialFocus(arg0: Internal.GuiEventListener_): void;
        setDragging(arg0: boolean): void;
        children(): Internal.List<any>;
        mouseDragged(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): boolean;
        getChildAt(arg0: number, arg1: number): Internal.Optional<Internal.GuiEventListener>;
        isDragging(): boolean;
        mouseMoved(arg0: number, arg1: number): void;
        isMouseOver(arg0: number, arg1: number): boolean;
        getFocused(): Internal.GuiEventListener;
        set focused(arg0: Internal.GuiEventListener_)
        set initialFocus(arg0: Internal.GuiEventListener_)
        set dragging(arg0: boolean)
        get dragging(): boolean
        get focused(): Internal.GuiEventListener
    }
    type ContainerEventHandler_ = ContainerEventHandler;
    class EvaluatorException extends Internal.RhinoException {
        constructor(detail: string, sourceName: string, lineNumber: number, lineSource: string, columnNumber: number)
        constructor(detail: string, sourceName: string, lineNumber: number)
        constructor(detail: string)
    }
    type EvaluatorException_ = EvaluatorException;
    abstract class JsonElement {
        constructor()
        getAsBigDecimal(): Internal.BigDecimal;
        isJsonPrimitive(): boolean;
        isJsonNull(): boolean;
        toString(): string;
        getAsBigInteger(): Internal.BigInteger;
        getAsDouble(): number;
        getAsCharacter(): string;
        getAsJsonPrimitive(): Internal.JsonPrimitive;
        getAsFloat(): number;
        getAsLong(): number;
        getAsString(): string;
        getAsInt(): number;
        isJsonObject(): boolean;
        getAsByte(): number;
        isJsonArray(): boolean;
        getAsJsonArray(): Internal.JsonArray;
        getAsNumber(): Internal.Number;
        getAsJsonObject(): Internal.JsonObject;
        deepCopy(): this;
        getAsShort(): number;
        getAsJsonNull(): Internal.JsonNull;
        getAsBoolean(): boolean;
        get asBigDecimal(): Internal.BigDecimal
        get jsonPrimitive(): boolean
        get jsonNull(): boolean
        get asBigInteger(): Internal.BigInteger
        get asDouble(): number
        get asCharacter(): string
        get asJsonPrimitive(): Internal.JsonPrimitive
        get asFloat(): number
        get asLong(): number
        get asString(): string
        get asInt(): number
        get jsonObject(): boolean
        get asByte(): number
        get jsonArray(): boolean
        get asJsonArray(): Internal.JsonArray
        get asNumber(): Internal.Number
        get asJsonObject(): Internal.JsonObject
        get asShort(): number
        get asJsonNull(): Internal.JsonNull
        get asBoolean(): boolean
    }
    type JsonElement_ = JsonElement;
    class ComparatorBlockEntity extends Internal.BlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        setOutputSignal(arg0: number): void;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        serializeNBT(): Internal.CompoundTag;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        load(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getOutputSignal(): number;
        getRenderBoundingBox(): Internal.AABB;
        set outputSignal(arg0: number)
        get modelData(): Internal.IModelData
        get outputSignal(): number
        get renderBoundingBox(): Internal.AABB
    }
    type ComparatorBlockEntity_ = ComparatorBlockEntity;
    abstract class ScreenEvent$KeyboardKeyReleasedEvent extends Internal.ScreenEvent$KeyboardKeyEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number, arg3: number)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$KeyboardKeyReleasedEvent_ = ScreenEvent$KeyboardKeyReleasedEvent;
    class DamageSource {
        constructor(arg0: string)
        isBypassArmor(): boolean;
        damageHelmet(): this;
        isBypassMagic(): boolean;
        isNoAggro(): boolean;
        getSourcePosition(): Vec3;
        static badRespawnPointExplosion(): Internal.DamageSource;
        static thrown(arg0: Internal.Entity_, arg1: Internal.Entity_): Internal.DamageSource;
        setExplosion(): this;
        scalesWithDifficulty(): boolean;
        getImmediate(): Internal.EntityJS;
        isDamageHelmet(): boolean;
        static indirectMobAttack(arg0: Internal.Entity_, arg1: Internal.LivingEntity_): Internal.DamageSource;
        static fireworks(arg0: Internal.FireworkRocketEntity_, arg1: Internal.Entity_): Internal.DamageSource;
        static fireball(arg0: Internal.Fireball_, arg1: Internal.Entity_): Internal.DamageSource;
        setIsFall(): this;
        getLocalizedDeathMessage(arg0: Internal.LivingEntity_): Internal.Component;
        static sting(arg0: Internal.LivingEntity_): Internal.DamageSource;
        getActual(): Internal.EntityJS;
        isFire(): boolean;
        bypassInvul(): this;
        static playerAttack(arg0: Internal.Player_): Internal.DamageSource;
        setProjectile(): this;
        getType(): string;
        static trident(arg0: Internal.Entity_, arg1: Internal.Entity_): Internal.DamageSource;
        static indirectMagic(arg0: Internal.Entity_, arg1: Internal.Entity_): Internal.DamageSource;
        static explosion(arg0: Internal.LivingEntity_): Internal.DamageSource;
        isMagic(): boolean;
        static thorns(arg0: Internal.Entity_): Internal.DamageSource;
        bypassMagic(): this;
        setNoAggro(): this;
        isExplosion(): boolean;
        getPlayer(): Internal.PlayerJS<any>;
        toString(): string;
        isBypassInvul(): boolean;
        static arrow(arg0: Internal.AbstractArrow_, arg1: Internal.Entity_): Internal.DamageSource;
        isFall(): boolean;
        getFoodExhaustion(): number;
        static mobAttack(arg0: Internal.LivingEntity_): Internal.DamageSource;
        static explosion(arg0: Internal.Explosion_): Internal.DamageSource;
        isCreativePlayer(): boolean;
        static witherSkull(arg0: Internal.WitherSkull_, arg1: Internal.Entity_): Internal.DamageSource;
        setMagic(): this;
        bypassArmor(): this;
        isProjectile(): boolean;
        setIsFire(): this;
        setScalesWithDifficulty(): this;
        get bypassArmor(): boolean
        get bypassMagic(): boolean
        get noAggro(): boolean
        get sourcePosition(): Vec3
        get immediate(): Internal.EntityJS
        get damageHelmet(): boolean
        get actual(): Internal.EntityJS
        get fire(): boolean
        get type(): string
        get magic(): boolean
        get explosion(): boolean
        get player(): Internal.PlayerJS<any>
        get bypassInvul(): boolean
        get fall(): boolean
        get foodExhaustion(): number
        get creativePlayer(): boolean
        get projectile(): boolean
        readonly static "DROWN": Internal.DamageSource;
        readonly static "ANVIL": Internal.DamageSource;
        readonly static "DRY_OUT": Internal.DamageSource;
        readonly static "MAGIC": Internal.DamageSource;
        readonly static "CACTUS": Internal.DamageSource;
        readonly static "FALL": Internal.DamageSource;
        readonly static "STALAGMITE": Internal.DamageSource;
        readonly static "IN_WALL": Internal.DamageSource;
        readonly "msgId": string;
        readonly static "FREEZE": Internal.DamageSource;
        readonly static "SWEET_BERRY_BUSH": Internal.DamageSource;
        readonly static "DRAGON_BREATH": Internal.DamageSource;
        readonly static "LIGHTNING_BOLT": Internal.DamageSource;
        readonly static "ON_FIRE": Internal.DamageSource;
        readonly static "IN_FIRE": Internal.DamageSource;
        readonly static "FLY_INTO_WALL": Internal.DamageSource;
        readonly static "LAVA": Internal.DamageSource;
        readonly static "OUT_OF_WORLD": Internal.DamageSource;
        readonly static "CRAMMING": Internal.DamageSource;
        readonly static "WITHER": Internal.DamageSource;
        readonly static "FALLING_STALACTITE": Internal.DamageSource;
        readonly static "GENERIC": Internal.DamageSource;
        readonly static "FALLING_BLOCK": Internal.DamageSource;
        readonly static "HOT_FLOOR": Internal.DamageSource;
        readonly static "STARVE": Internal.DamageSource;
    }
    type DamageSource_ = "wither" | "lightningBolt" | "lava" | "outOfWorld" | "starve" | "dragonBreath" | "fallingBlock" | "inWall" | "cactus" | "onFire" | "stalagmite" | "flyIntoWall" | "dryout" | "freeze" | DamageSource | "anvil" | "fall" | "magic" | "inFire" | "sweetBerryBush" | "generic" | "fallingStalactite" | "cramming" | "hotFloor" | "drown";
    interface PlayerKJS {
        getStagesRawKJS(): Internal.Stages;
        getStagesKJS(): Internal.Stages;
        setStagesKJS(arg0: Internal.Stages_): void;
        get stagesRawKJS(): Internal.Stages
        get stagesKJS(): Internal.Stages
        set stagesKJS(arg0: Internal.Stages_)
    }
    type PlayerKJS_ = PlayerKJS;
    class BiasedToBottomInt extends Internal.IntProvider {
        getMinValue(): number;
        getType(): Internal.IntProviderType<any>;
        static of(arg0: number, arg1: number): Internal.BiasedToBottomInt;
        toString(): string;
        getMaxValue(): number;
        sample(arg0: Internal.Random_): number;
        get minValue(): number
        get type(): Internal.IntProviderType<any>
        get maxValue(): number
        readonly static "CODEC": any;
    }
    type BiasedToBottomInt_ = BiasedToBottomInt;
    interface ItemTooltipEventJS$StaticTooltipHandlerFromJS {
        accept(arg0: Internal.ItemStackJS_, arg1: boolean, arg2: Internal.List_<any>): void;
    }
    type ItemTooltipEventJS$StaticTooltipHandlerFromJS_ = ((arg0: Internal.ItemStackJS, arg1: boolean, arg2: Internal.List<any>)=>void) | ItemTooltipEventJS$StaticTooltipHandlerFromJS;
    class RenderGameOverlayEvent$Text extends Internal.RenderGameOverlayEvent$Pre {
        constructor()
        constructor(arg0: Internal.PoseStack_, arg1: Internal.RenderGameOverlayEvent_, arg2: Internal.ArrayList_<string>, arg3: Internal.ArrayList_<string>)
        getRight(): Internal.ArrayList<string>;
        getListenerList(): Internal.ListenerList;
        getLeft(): Internal.ArrayList<string>;
        get right(): Internal.ArrayList<string>
        get listenerList(): Internal.ListenerList
        get left(): Internal.ArrayList<string>
    }
    type RenderGameOverlayEvent$Text_ = RenderGameOverlayEvent$Text;
    class PlayerEvent$BreakSpeed extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.BlockState_, arg2: number, arg3: BlockPos_)
        getPos(): BlockPos;
        isCancelable(): boolean;
        getOriginalSpeed(): number;
        getListenerList(): Internal.ListenerList;
        getNewSpeed(): number;
        getState(): Internal.BlockState;
        setNewSpeed(arg0: number): void;
        get pos(): BlockPos
        get cancelable(): boolean
        get originalSpeed(): number
        get listenerList(): Internal.ListenerList
        get newSpeed(): number
        get state(): Internal.BlockState
        set newSpeed(arg0: number)
    }
    type PlayerEvent$BreakSpeed_ = PlayerEvent$BreakSpeed;
    class ServerboundContainerClosePacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getContainerId(): number;
        isSkippable(): boolean;
        get containerId(): number
        get skippable(): boolean
    }
    type ServerboundContainerClosePacket_ = ServerboundContainerClosePacket;
    class AllOfPredicate extends Internal.CombiningPredicate {
        constructor(arg0: Internal.List_<net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_>)
        type(): Internal.BlockPredicateType<any>;
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: any, arg1: any): boolean;
        negate(): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: Internal.WorldGenLevel_, arg1: BlockPos_): boolean;
        readonly static "CODEC": Internal.Codec<Internal.AllOfPredicate>;
    }
    type AllOfPredicate_ = AllOfPredicate;
    interface TypeWrapperFactory <T> {
        wrap(arg0: any): T;
    }
    type TypeWrapperFactory_<T> = TypeWrapperFactory<T> | ((arg0: any)=>T);
    interface RegistrarOption {
    }
    type RegistrarOption_ = RegistrarOption;
    abstract class NumericTag implements Internal.Tag, Internal.SpecialEquality {
        getAsLong(): number;
        getAsFloat(): number;
        getAsString(): string;
        getAsInt(): number;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        getAsByte(): number;
        toString(): string;
        getAsNumber(): Internal.Number;
        specialEquals(o: any, shallow: boolean): boolean;
        getAsShort(): number;
        getAsDouble(): number;
        get asLong(): number
        get asFloat(): number
        get asString(): string
        get asInt(): number
        get asByte(): number
        get asNumber(): Internal.Number
        get asShort(): number
        get asDouble(): number
    }
    type NumericTag_ = NumericTag;
    class LevelSettings {
        constructor(arg0: string, arg1: Internal.GameType_, arg2: boolean, arg3: Internal.Difficulty_, arg4: boolean, arg5: Internal.GameRules_, arg6: Internal.DataPackConfig_, arg7: Internal.Lifecycle_)
        constructor(arg0: string, arg1: Internal.GameType_, arg2: boolean, arg3: Internal.Difficulty_, arg4: boolean, arg5: Internal.GameRules_, arg6: Internal.DataPackConfig_)
        difficulty(): Internal.Difficulty;
        getLifecycle(): Internal.Lifecycle;
        withDataPackConfig(arg0: Internal.DataPackConfig_): this;
        allowCommands(): boolean;
        static parse(arg0: Internal.Dynamic_<any>, arg1: Internal.DataPackConfig_): Internal.LevelSettings;
        withGameType(arg0: Internal.GameType_): this;
        levelName(): string;
        gameType(): Internal.GameType;
        gameRules(): Internal.GameRules;
        getDataPackConfig(): Internal.DataPackConfig;
        withLifecycle(arg0: Internal.Lifecycle_): this;
        hardcore(): boolean;
        withDifficulty(arg0: Internal.Difficulty_): this;
        copy(): this;
        get lifecycle(): Internal.Lifecycle
        get dataPackConfig(): Internal.DataPackConfig
    }
    type LevelSettings_ = LevelSettings;
    class ServerPlayerGameMode {
        constructor(arg0: Internal.ServerPlayer_)
        setLevel(arg0: Internal.ServerLevel_): void;
        getGameModeForPlayer(): Internal.GameType;
        isCreative(): boolean;
        useItemOn(arg0: Internal.ServerPlayer_, arg1: Internal.Level_, arg2: Internal.ItemStack_, arg3: Hand_, arg4: Internal.BlockHitResult_): Internal.InteractionResult;
        getPreviousGameModeForPlayer(): Internal.GameType;
        isSurvival(): boolean;
        changeGameModeForPlayer(arg0: Internal.GameType_): boolean;
        destroyBlock(arg0: BlockPos_): boolean;
        destroyAndAck(arg0: BlockPos_, arg1: Internal.ServerboundPlayerActionPacket$Action_, arg2: string): void;
        tick(): void;
        useItem(arg0: Internal.ServerPlayer_, arg1: Internal.Level_, arg2: Internal.ItemStack_, arg3: Hand_): Internal.InteractionResult;
        handleBlockBreakAction(arg0: BlockPos_, arg1: Internal.ServerboundPlayerActionPacket$Action_, arg2: Internal.Direction_, arg3: number): void;
        set level(arg0: Internal.ServerLevel_)
        get gameModeForPlayer(): Internal.GameType
        get creative(): boolean
        get previousGameModeForPlayer(): Internal.GameType
        get survival(): boolean
        "isDestroyingBlock": boolean;
    }
    type ServerPlayerGameMode_ = ServerPlayerGameMode;
    class ClientboundSetEntityDataPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: Internal.SynchedEntityData_, arg2: boolean)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getUnpackedData(): Internal.List<Internal.SynchedEntityData$DataItem<any>>;
        isSkippable(): boolean;
        getId(): number;
        get unpackedData(): Internal.List<Internal.SynchedEntityData$DataItem<any>>
        get skippable(): boolean
        get id(): number
    }
    type ClientboundSetEntityDataPacket_ = ClientboundSetEntityDataPacket;
    class CommandFunction {
        constructor(arg0: ResourceLocation_, arg1: any_[])
        getEntries(): any[];
        getId(): ResourceLocation;
        static fromLines(arg0: ResourceLocation_, arg1: Internal.CommandDispatcher_<Internal.CommandSourceStack_>, arg2: Internal.CommandSourceStack_, arg3: Internal.List_<string>): Internal.CommandFunction;
        get entries(): any[]
        get id(): ResourceLocation
    }
    type CommandFunction_ = CommandFunction;
    interface RegistryAccess$Writable extends Internal.RegistryAccess {
        ownedWritableRegistryOrThrow(arg0: Internal.ResourceKey_<any>): Internal.WritableRegistry<E>;
        registry(arg0: Internal.ResourceKey_<any>): Internal.Optional<any>;
        allElementsLifecycle(): Internal.Lifecycle;
        registryOrThrow(arg0: Internal.ResourceKey_<any>): Internal.Registry<E>;
        networkSafeRegistries(): Internal.Stream<Internal.RegistryAccess$RegistryEntry<any>>;
        ownedWritableRegistry(arg0: Internal.ResourceKey_<any>): Internal.Optional<Internal.WritableRegistry<E>>;
        freeze(): Internal.RegistryAccess$Frozen;
        registries(): Internal.Stream<Internal.RegistryAccess$RegistryEntry<any>>;
        ownedRegistryOrThrow(arg0: Internal.ResourceKey_<any>): Internal.Registry<E>;
    }
    type RegistryAccess$Writable_ = RegistryAccess$Writable;
    abstract class MappedByteBuffer extends Internal.ByteBuffer {
        slice(arg0: number, arg1: number): Internal.ByteBuffer;
        mark(): this;
        reset(): Internal.Buffer;
        compact(): this;
        isLoaded(): boolean;
        duplicate(): this;
        position(arg0: number): Internal.ByteBuffer;
        force(arg0: number, arg1: number): this;
        limit(arg0: number): Internal.Buffer;
        force(): this;
        load(): this;
        slice(): Internal.ByteBuffer;
        flip(): Internal.Buffer;
        clear(): Internal.Buffer;
        rewind(): this;
        get loaded(): boolean
    }
    type MappedByteBuffer_ = MappedByteBuffer;
    class MobEffect extends Internal.ForgeRegistryEntry<Internal.MobEffect> implements Internal.IForgeMobEffect {
        getDisplayName(): Internal.Component;
        getCategory(): Internal.MobEffectCategory;
        initializeClient(arg0: Internal.Consumer_<Internal.EffectRenderer_>): void;
        getCurativeItems(): Internal.List<Internal.ItemStack>;
        addAttributeModifier(arg0: Internal.Attribute_, arg1: string, arg2: number, arg3: Internal.AttributeModifier$Operation_): this;
        addAttributeModifiers(arg0: Internal.LivingEntity_, arg1: Internal.AttributeMap_, arg2: number): void;
        isInstantenous(): boolean;
        applyInstantenousEffect(arg0: Internal.Entity_, arg1: Internal.Entity_, arg2: Internal.LivingEntity_, arg3: number, arg4: number): void;
        isBeneficial(): boolean;
        static byId(arg0: number): Internal.MobEffect;
        getColor(): number;
        getEffectRendererInternal(): any;
        getAttributeModifiers(): Internal.Map<Internal.Attribute, Internal.AttributeModifier>;
        removeAttributeModifiers(arg0: Internal.LivingEntity_, arg1: Internal.AttributeMap_, arg2: number): void;
        applyEffectTick(arg0: Internal.LivingEntity_, arg1: number): void;
        getAttributeModifierValue(arg0: number, arg1: Internal.AttributeModifier_): number;
        getSortOrder(arg0: Internal.MobEffectInstance_): number;
        getDescriptionId(): string;
        isDurationEffectTick(arg0: number, arg1: number): boolean;
        static getId(arg0: Internal.MobEffect_): number;
        get displayName(): Internal.Component
        get category(): Internal.MobEffectCategory
        get curativeItems(): Internal.List<Internal.ItemStack>
        get instantenous(): boolean
        get beneficial(): boolean
        get color(): number
        get effectRendererInternal(): any
        get attributeModifiers(): Internal.Map<Internal.Attribute, Internal.AttributeModifier>
        get descriptionId(): string
    }
    type MobEffect_ = MobEffect | Special.MobEffect;
    class Font {
        constructor(arg0: Internal.Function_<ResourceLocation_, any_>)
        draw(arg0: Internal.PoseStack_, arg1: Internal.FormattedCharSequence_, arg2: number, arg3: number, arg4: number): number;
        width(arg0: Internal.FormattedText_): number;
        width(arg0: string): number;
        draw(arg0: Internal.PoseStack_, arg1: string, arg2: number, arg3: number, arg4: number): number;
        plainSubstrByWidth(arg0: string, arg1: number): string;
        drawShadow(arg0: Internal.PoseStack_, arg1: Internal.FormattedCharSequence_, arg2: number, arg3: number, arg4: number): number;
        draw(arg0: Internal.PoseStack_, arg1: Internal.Component_, arg2: number, arg3: number, arg4: number): number;
        split(arg0: Internal.FormattedText_, arg1: number): Internal.List<Internal.FormattedCharSequence>;
        getSplitter(): Internal.StringSplitter;
        wordWrapHeight(arg0: string, arg1: number): number;
        drawInBatch(arg0: Internal.Component_, arg1: number, arg2: number, arg3: number, arg4: boolean, arg5: Internal.Matrix4f_, arg6: Internal.MultiBufferSource_, arg7: boolean, arg8: number, arg9: number): number;
        substrByWidth(arg0: Internal.FormattedText_, arg1: number): Internal.FormattedText;
        drawInBatch(arg0: string, arg1: number, arg2: number, arg3: number, arg4: boolean, arg5: Internal.Matrix4f_, arg6: Internal.MultiBufferSource_, arg7: boolean, arg8: number, arg9: number): number;
        drawShadow(arg0: Internal.PoseStack_, arg1: string, arg2: number, arg3: number, arg4: number): number;
        drawInBatch(arg0: Internal.FormattedCharSequence_, arg1: number, arg2: number, arg3: number, arg4: boolean, arg5: Internal.Matrix4f_, arg6: Internal.MultiBufferSource_, arg7: boolean, arg8: number, arg9: number): number;
        width(arg0: Internal.FormattedCharSequence_): number;
        drawInBatch(arg0: string, arg1: number, arg2: number, arg3: number, arg4: boolean, arg5: Internal.Matrix4f_, arg6: Internal.MultiBufferSource_, arg7: boolean, arg8: number, arg9: number, arg10: boolean): number;
        isBidirectional(): boolean;
        drawShadow(arg0: Internal.PoseStack_, arg1: string, arg2: number, arg3: number, arg4: number, arg5: boolean): number;
        drawInBatch8xOutline(arg0: Internal.FormattedCharSequence_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.Matrix4f_, arg6: Internal.MultiBufferSource_, arg7: number): void;
        bidirectionalShaping(arg0: string): string;
        drawShadow(arg0: Internal.PoseStack_, arg1: Internal.Component_, arg2: number, arg3: number, arg4: number): number;
        drawWordWrap(arg0: Internal.FormattedText_, arg1: number, arg2: number, arg3: number, arg4: number): void;
        plainSubstrByWidth(arg0: string, arg1: number, arg2: boolean): string;
        get splitter(): Internal.StringSplitter
        get bidirectional(): boolean
        readonly "random": Internal.Random;
        readonly static "ALPHA_CUTOFF": 8;
        readonly "lineHeight": number;
    }
    type Font_ = Font;
    interface TutorialStepInstance {
        onMouse(arg0: number, arg1: number): void;
        clear(): void;
        onLookAt(arg0: Internal.ClientLevel_, arg1: Internal.HitResult_): void;
        onDestroyBlock(arg0: Internal.ClientLevel_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: number): void;
        onInput(arg0: Internal.Input_): void;
        onOpenInventory(): void;
        tick(): void;
        onGetItem(arg0: Internal.ItemStack_): void;
    }
    type TutorialStepInstance_ = TutorialStepInstance;
    interface StringRepresentable {
        keys(arg0: Internal.StringRepresentable_[]): Internal.Keyable;
        fromEnum(arg0: Internal.Supplier_<E[]>, arg1: Internal.Function_<string, E>): Internal.Codec<E>;
        getSerializedName(): string;
        get serializedName(): string
    }
    type StringRepresentable_ = StringRepresentable;
    class SimpleContainer implements Internal.Container, Internal.StackedContentsCompatible {
        constructor(...arg0: Internal.ItemStack_[])
        constructor(arg0: number)
        stopOpen(arg0: Internal.Player_): void;
        countItem(arg0: Internal.Item_): number;
        isEmpty(): boolean;
        addItem(arg0: Internal.ItemStack_): Internal.ItemStack;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        removeItem(arg0: number, arg1: number): Internal.ItemStack;
        setChanged(): void;
        fromTag(arg0: Internal.ListTag_): void;
        canAddItem(arg0: Internal.ItemStack_): boolean;
        getContainerSize(): number;
        removeListener(arg0: Internal.ContainerListener_): void;
        setItem(arg0: number, arg1: Internal.ItemStack_): void;
        createTag(): Internal.ListTag;
        toString(): string;
        getMaxStackSize(): number;
        removeAllItems(): Internal.List<Internal.ItemStack>;
        fillStackedContents(arg0: Internal.StackedContents_): void;
        removeItemNoUpdate(arg0: number): Internal.ItemStack;
        stillValid(arg0: Internal.Player_): boolean;
        getItem(arg0: number): Internal.ItemStack;
        removeItemType(arg0: Internal.Item_, arg1: number): Internal.ItemStack;
        addListener(arg0: Internal.ContainerListener_): void;
        clearContent(): void;
        get empty(): boolean
        get containerSize(): number
        get maxStackSize(): number
    }
    type SimpleContainer_ = SimpleContainer;
    class WorldGenRegion implements Internal.WorldGenLevel {
        constructor(arg0: Internal.ServerLevel_, arg1: Internal.List_<Internal.ChunkAccess_>, arg2: Internal.ChunkStatus_, arg3: number)
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_): Internal.Player;
        getSeed(): number;
        getShade(arg0: Internal.Direction_, arg1: boolean): number;
        dayTime(): number;
        isUnobstructed(arg0: Internal.Entity_, arg1: Internal.VoxelShape_): boolean;
        getMaxSection(): number;
        getLevelData(): Internal.LevelData;
        gameEvent(arg0: Internal.GameEvent_, arg1: Internal.Entity_): void;
        getBrightness(arg0: Internal.LightLayer_, arg1: BlockPos_): number;
        getSectionYFromSectionIndex(arg0: number): number;
        players(): Internal.List<Internal.Player>;
        getBiomeManager(): Internal.BiomeManager;
        isEmptyBlock(arg0: BlockPos_): boolean;
        removeBlock(arg0: BlockPos_, arg1: boolean): boolean;
        getMaxLocalRawBrightness(arg0: BlockPos_, arg1: number): number;
        getBlockCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        getTimeOfDay(arg0: number): number;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getHeightmapPos(arg0: Internal.Heightmap$Types_, arg1: BlockPos_): BlockPos;
        blockUpdated(arg0: BlockPos_, arg1: Internal.Block_): void;
        setBlock(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: number, arg3: number): boolean;
        isClientSide(): boolean;
        getEntities(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.Entity>;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_): Internal.List<T>;
        getBlockTicks(): Internal.LevelTickAccess<Internal.Block>;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getBrightness(arg0: BlockPos_): number;
        dimensionType(): Internal.DimensionType;
        getNearestEntity(arg0: Internal.List_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number): T;
        getSkyDarken(): number;
        getMinBuildHeight(): number;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Fluid_, arg2: number): void;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): Internal.Player;
        destroyBlock(arg0: BlockPos_, arg1: boolean, arg2: Internal.Entity_, arg3: number): boolean;
        getSeaLevel(): number;
        hasChunkAt(arg0: number, arg1: number): boolean;
        getFluidTicks(): Internal.LevelTickAccess<Internal.Fluid>;
        getSectionIndex(arg0: number): number;
        getRandom(): Internal.Random;
        ensureCanWrite(arg0: BlockPos_): boolean;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: number, arg2: number, arg3: number): Internal.Player;
        getMaxBuildHeight(): number;
        hasChunksAt(arg0: BlockPos_, arg1: BlockPos_): boolean;
        destroyBlock(arg0: BlockPos_, arg1: boolean): boolean;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Block_, arg2: number): void;
        addFreshEntity(arg0: Internal.Entity_): boolean;
        getChunk(arg0: number, arg1: number): Internal.ChunkAccess;
        getEntities(arg0: Internal.EntityTypeTest_<Internal.Entity_, T>, arg1: Internal.AABB_, arg2: Internal.Predicate_<any>): Internal.List<T>;
        getCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        destroyBlock(arg0: BlockPos_, arg1: boolean, arg2: Internal.Entity_): boolean;
        getHeight(): number;
        getChunk(arg0: BlockPos_): Internal.ChunkAccess;
        isFluidAtPosition(arg0: BlockPos_, arg1: Internal.Predicate_<Internal.FluidState_>): boolean;
        getWorldBorder(): Internal.WorldBorder;
        gameEvent(arg0: Internal.GameEvent_, arg1: BlockPos_): void;
        getMaxLocalRawBrightness(arg0: BlockPos_): number;
        isUnobstructed(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.CollisionContext_): boolean;
        hasChunkAt(arg0: BlockPos_): boolean;
        getBiome(arg0: BlockPos_): Internal.Holder<Internal.Biome>;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Block_, arg2: number, arg3: Internal.TickPriority_): void;
        hasNearbyAlivePlayer(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: number, arg3: number, arg4: number): Internal.Player;
        getBlockTint(arg0: BlockPos_, arg1: Internal.ColorResolver_): number;
        getMinSection(): number;
        getBlockState(arg0: BlockPos_): Internal.BlockState;
        findFreePosition(arg0: Internal.Entity_, arg1: Internal.VoxelShape_, arg2: Vec3_, arg3: number, arg4: number, arg5: number): Internal.Optional<Vec3>;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        playSound(arg0: Internal.Player_, arg1: BlockPos_, arg2: Internal.SoundEvent_, arg3: Internal.SoundSource_, arg4: number, arg5: number): void;
        getNearestPlayer(arg0: Internal.Entity_, arg1: number): Internal.Player;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getBlockStatesIfLoaded(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        getRawBrightness(arg0: BlockPos_, arg1: number): number;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        addParticle(arg0: Internal.ParticleOptions_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
        getCurrentDifficultyAt(arg0: BlockPos_): Internal.DifficultyInstance;
        getDifficulty(): Internal.Difficulty;
        canSeeSky(arg0: BlockPos_): boolean;
        getEntities(arg0: Internal.Entity_, arg1: Internal.AABB_, arg2: Internal.Predicate_<any>): Internal.List<Internal.Entity>;
        getMoonPhase(): number;
        isUnobstructed(arg0: Internal.Entity_): boolean;
        getUncachedNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        addFreshEntityWithPassengers(arg0: Internal.Entity_): void;
        getPlayerByUUID(arg0: Internal.UUID_): Internal.Player;
        canSeeSkyFromBelowWater(arg0: BlockPos_): boolean;
        getSectionsCount(): number;
        getHeight(arg0: Internal.Heightmap$Types_, arg1: number, arg2: number): number;
        isStateAtPosition(arg0: BlockPos_, arg1: Internal.Predicate_<Internal.BlockState_>): boolean;
        getSectionIndexFromSectionY(arg0: number): number;
        getNearbyPlayers(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: Internal.AABB_): Internal.List<Internal.Player>;
        getCenter(): Internal.ChunkPos;
        getServer(): Internal.MinecraftServer;
        levelEvent(arg0: Internal.Player_, arg1: number, arg2: BlockPos_, arg3: number): void;
        setBlock(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: number): boolean;
        noCollision(arg0: Internal.Entity_): boolean;
        getChunk(arg0: number, arg1: number, arg2: Internal.ChunkStatus_): Internal.ChunkAccess;
        getLevel(): Internal.ServerLevel;
        hasChunk(arg0: number, arg1: number): boolean;
        getNearbyEntities(arg0: Internal.Class_<T>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: Internal.AABB_): Internal.List<T>;
        getMoonBrightness(): number;
        noCollision(arg0: Internal.AABB_): boolean;
        isWaterAt(arg0: BlockPos_): boolean;
        getDirectSignal(arg0: BlockPos_, arg1: Internal.Direction_): number;
        getLightEngine(): Internal.LevelLightEngine;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        getEntityCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.VoxelShape>;
        collidesWithSuffocatingBlock(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        getNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        setCurrentlyGenerating(arg0: Internal.Supplier_<string>): void;
        noCollision(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        isOutsideBuildHeight(arg0: number): boolean;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Fluid_, arg2: number, arg3: Internal.TickPriority_): void;
        gameEvent(arg0: Internal.Entity_, arg1: Internal.GameEvent_, arg2: Internal.Entity_): void;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Predicate_<Internal.Entity_>): Internal.Player;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getNearestEntity(arg0: Internal.Class_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number, arg6: Internal.AABB_): T;
        getFluidState(arg0: BlockPos_): Internal.FluidState;
        getChunkSource(): Internal.ChunkSource;
        getChunk(arg0: number, arg1: number, arg2: Internal.ChunkStatus_, arg3: boolean): Internal.ChunkAccess;
        registryAccess(): Internal.RegistryAccess;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_, arg2: Internal.Predicate_<any>): Internal.List<T>;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        levelEvent(arg0: number, arg1: BlockPos_, arg2: number): void;
        nextSubTickCount(): number;
        getChunkForCollisions(arg0: number, arg1: number): Internal.BlockGetter;
        gameEvent(arg0: Internal.Entity_, arg1: Internal.GameEvent_, arg2: BlockPos_): void;
        containsAnyLiquid(arg0: Internal.AABB_): boolean;
        getMaxLightLevel(): number;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
        get seed(): number
        get maxSection(): number
        get levelData(): Internal.LevelData
        get biomeManager(): Internal.BiomeManager
        get clientSide(): boolean
        get blockTicks(): Internal.LevelTickAccess<Internal.Block>
        get skyDarken(): number
        get minBuildHeight(): number
        get seaLevel(): number
        get fluidTicks(): Internal.LevelTickAccess<Internal.Fluid>
        get random(): Internal.Random
        get maxBuildHeight(): number
        get height(): number
        get worldBorder(): Internal.WorldBorder
        get minSection(): number
        get difficulty(): Internal.Difficulty
        get moonPhase(): number
        get sectionsCount(): number
        get center(): Internal.ChunkPos
        get server(): Internal.MinecraftServer
        get level(): Internal.ServerLevel
        get moonBrightness(): number
        get lightEngine(): Internal.LevelLightEngine
        set currentlyGenerating(arg0: Internal.Supplier_<string>)
        get chunkSource(): Internal.ChunkSource
        get maxLightLevel(): number
    }
    type WorldGenRegion_ = WorldGenRegion;
    class VillagerTradesEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.Int2ObjectMap_<Internal.List_<Internal.VillagerTrades$ItemListing_>>, arg1: Internal.VillagerProfession_)
        getType(): Internal.VillagerProfession;
        getListenerList(): Internal.ListenerList;
        getTrades(): Internal.Int2ObjectMap<Internal.List<Internal.VillagerTrades$ItemListing>>;
        get type(): Internal.VillagerProfession
        get listenerList(): Internal.ListenerList
        get trades(): Internal.Int2ObjectMap<Internal.List<Internal.VillagerTrades$ItemListing>>
    }
    type VillagerTradesEvent_ = VillagerTradesEvent;
    class TagManager$LoadResult <T> extends Internal.Record {
        constructor(key: Internal.ResourceKey_<any>, tags: Internal.Map_<ResourceLocation_, net.minecraft.tags.Tag_<Internal.Holder_<T>>>)
        hashCode(): number;
        toString(): string;
        key(): Internal.ResourceKey<any>;
        equals(arg0: any): boolean;
        tags(): Internal.Map<ResourceLocation, net.minecraft.tags.Tag<Internal.Holder<T>>>;
    }
    type TagManager$LoadResult_<T> = TagManager$LoadResult<T>;
    interface WindowEventHandler {
        setWindowActive(arg0: boolean): void;
        cursorEntered(): void;
        resizeDisplay(): void;
        set windowActive(arg0: boolean)
    }
    type WindowEventHandler_ = WindowEventHandler;
    interface Future <V> {
        get(): V;
        get(arg0: number, arg1: Internal.TimeUnit_): V;
        isDone(): boolean;
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        get done(): boolean
        get cancelled(): boolean
    }
    type Future_<V> = Future<V>;
    class JumpControl implements Internal.Control {
        constructor(arg0: Internal.Mob_)
        jump(): void;
        tick(): void;
    }
    type JumpControl_ = JumpControl;
    interface Serializer <T> {
        serialize(arg0: Internal.JsonObject_, arg1: T, arg2: Internal.JsonSerializationContext_): void;
        deserialize(arg0: Internal.JsonObject_, arg1: Internal.JsonDeserializationContext_): T;
    }
    type Serializer_<T> = Serializer<T>;
    class Thread implements Internal.Runnable {
        constructor()
        constructor(arg0: Internal.ThreadGroup_, arg1: Internal.Runnable_, arg2: string)
        constructor(arg0: Internal.Runnable_)
        constructor(arg0: Internal.ThreadGroup_, arg1: Internal.Runnable_)
        constructor(arg0: Internal.ThreadGroup_, arg1: Internal.Runnable_, arg2: string, arg3: number, arg4: boolean)
        constructor(arg0: Internal.Runnable_, arg1: string)
        constructor(arg0: Internal.ThreadGroup_, arg1: string)
        constructor(arg0: Internal.ThreadGroup_, arg1: Internal.Runnable_, arg2: string, arg3: number)
        constructor(arg0: string)
        isDaemon(): boolean;
        suspend(): void;
        setUncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler_): void;
        static yield(): void;
        static dumpStack(): void;
        run(): void;
        checkAccess(): void;
        static sleep(arg0: number, arg1: number): void;
        static holdsLock(arg0: any): boolean;
        isInterrupted(): boolean;
        static onSpinWait(): void;
        join(arg0: number): void;
        static setDefaultUncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler_): void;
        setContextClassLoader(arg0: Internal.ClassLoader_): void;
        setName(arg0: string): void;
        getName(): string;
        getId(): number;
        isAlive(): boolean;
        getThreadGroup(): Internal.ThreadGroup;
        static sleep(arg0: number): void;
        toString(): string;
        getContextClassLoader(): Internal.ClassLoader;
        static getAllStackTraces(): Internal.Map<Internal.Thread, Internal.StackTraceElement[]>;
        resume(): void;
        getUncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler;
        static getDefaultUncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler;
        getState(): Internal.Thread$State;
        getStackTrace(): Internal.StackTraceElement[];
        static currentThread(): Internal.Thread;
        setDaemon(arg0: boolean): void;
        start(): void;
        setPriority(arg0: number): void;
        interrupt(): void;
        static interrupted(): boolean;
        getPriority(): number;
        stop(): void;
        static enumerate(arg0: Internal.Thread_[]): number;
        static activeCount(): number;
        join(arg0: number, arg1: number): void;
        join(): void;
        countStackFrames(): number;
        get daemon(): boolean
        set uncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler_)
        get interrupted(): boolean
        set defaultUncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler_)
        set contextClassLoader(arg0: Internal.ClassLoader_)
        set name(arg0: string)
        get name(): string
        get id(): number
        get alive(): boolean
        get threadGroup(): Internal.ThreadGroup
        get contextClassLoader(): Internal.ClassLoader
        get allStackTraces(): Internal.Map<Internal.Thread, Internal.StackTraceElement[]>
        get uncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler
        get defaultUncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler
        get state(): Internal.Thread$State
        get stackTrace(): Internal.StackTraceElement[]
        set daemon(arg0: boolean)
        set priority(arg0: number)
        get priority(): number
        readonly static "MAX_PRIORITY": 10;
        readonly static "NORM_PRIORITY": 5;
        readonly static "MIN_PRIORITY": 1;
    }
    type Thread_ = Thread;
    class SkullBlockEntity extends Internal.BlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        getOwnerProfile(): Internal.GameProfile;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getUpdateTag(): Internal.CompoundTag;
        getMouthAnimation(arg0: number): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        static updateGameprofile(arg0: Internal.GameProfile_, arg1: Internal.Consumer_<Internal.GameProfile_>): void;
        serializeNBT(): Internal.CompoundTag;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        load(arg0: Internal.CompoundTag_): void;
        getUpdatePacket(): Internal.Packet<any>;
        static clear(): void;
        onLoad(): void;
        static dragonHeadAnimation(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.SkullBlockEntity_): void;
        setOwner(arg0: Internal.GameProfile_): void;
        static setup(arg0: Internal.GameProfileCache_, arg1: Internal.MinecraftSessionService_, arg2: Internal.Executor_): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get ownerProfile(): Internal.GameProfile
        get modelData(): Internal.IModelData
        get updateTag(): Internal.CompoundTag
        get updatePacket(): Internal.Packet<any>
        set owner(arg0: Internal.GameProfile_)
        get renderBoundingBox(): Internal.AABB
        readonly static "TAG_SKULL_OWNER": "SkullOwner";
    }
    type SkullBlockEntity_ = SkullBlockEntity;
    interface ItemBuilder$UseCallback {
        use(arg0: Internal.LevelJS_, arg1: Internal.PlayerJS_<any>, arg2: Hand_): boolean;
    }
    type ItemBuilder$UseCallback_ = ItemBuilder$UseCallback | ((arg0: Internal.LevelJS, arg1: Internal.PlayerJS<any>, arg2: Hand)=>boolean);
    abstract class RenderLivingEvent <T, M> extends Internal.Event {
        constructor()
        constructor(arg0: Internal.LivingEntity_, arg1: Internal.LivingEntityRenderer_<T, M>, arg2: number, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number)
        getPartialTick(): number;
        getPoseStack(): Internal.PoseStack;
        getEntity(): Internal.LivingEntity;
        getRenderer(): Internal.LivingEntityRenderer<T, M>;
        getListenerList(): Internal.ListenerList;
        getPackedLight(): number;
        getMultiBufferSource(): Internal.MultiBufferSource;
        get partialTick(): number
        get poseStack(): Internal.PoseStack
        get entity(): Internal.LivingEntity
        get renderer(): Internal.LivingEntityRenderer<T, M>
        get listenerList(): Internal.ListenerList
        get packedLight(): number
        get multiBufferSource(): Internal.MultiBufferSource
    }
    type RenderLivingEvent_<T, M> = RenderLivingEvent<T, M>;
    abstract class Projectile extends Internal.Entity {
        mayInteract(arg0: Internal.Level_, arg1: BlockPos_): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        shoot(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        recreateFromPacket(arg0: Internal.ClientboundAddEntityPacket_): void;
        getEffectSource(): Internal.Entity;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        tick(): void;
        asKJS(): Internal.EntityJS;
        setOwner(arg0: Internal.Entity_): void;
        lerpMotion(arg0: number, arg1: number, arg2: number): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getAddEntityPacket(): Internal.Packet<any>;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getOwner(): Internal.Entity;
        shootFromRotation(arg0: Internal.Entity_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get effectSource(): Internal.Entity
        get stepHeight(): number
        set owner(arg0: Internal.Entity_)
        get addEntityPacket(): Internal.Packet<any>
        get multipartEntity(): boolean
        get owner(): Internal.Entity
        get parts(): Internal.PartEntity<any>[]
    }
    type Projectile_ = Projectile;
    class EntityRenderDispatcher implements Internal.ResourceManagerReloadListener {
        constructor(arg0: Internal.TextureManager_, arg1: Internal.ItemRenderer_, arg2: Internal.Font_, arg3: Internal.Options_, arg4: Internal.EntityModelSet_)
        overrideCameraOrientation(arg0: Internal.Quaternion_): void;
        render(arg0: E, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.PoseStack_, arg7: Internal.MultiBufferSource_, arg8: number): void;
        distanceToSqr(arg0: Internal.Entity_): number;
        onResourceManagerReload(arg0: Internal.ResourceManager_): void;
        setLevel(arg0: Internal.Level_): void;
        getPackedLightCoords(arg0: E, arg1: number): number;
        getRenderer(arg0: T): Internal.EntityRenderer<any>;
        getSkinMap(): Internal.Map<string, Internal.EntityRenderer<any>>;
        shouldRenderHitBoxes(): boolean;
        setRenderHitBoxes(arg0: boolean): void;
        setRenderShadow(arg0: boolean): void;
        cameraOrientation(): Internal.Quaternion;
        getName(): string;
        distanceToSqr(arg0: number, arg1: number, arg2: number): number;
        shouldRender(arg0: E, arg1: Internal.Frustum_, arg2: number, arg3: number, arg4: number): boolean;
        prepare(arg0: Internal.Level_, arg1: Internal.Camera_, arg2: Internal.Entity_): void;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        set level(arg0: Internal.Level_)
        get skinMap(): Internal.Map<string, Internal.EntityRenderer<any>>
        set renderHitBoxes(arg0: boolean)
        set renderShadow(arg0: boolean)
        get name(): string
        "crosshairPickEntity": Internal.Entity;
        "camera": Internal.Camera;
        readonly "textureManager": Internal.TextureManager;
        readonly "options": Internal.Options;
        "renderers": Internal.Map<Internal.EntityType<any>, Internal.EntityRenderer<any>>;
    }
    type EntityRenderDispatcher_ = EntityRenderDispatcher;
    class ChunkEvent extends Internal.WorldEvent {
        constructor()
        constructor(arg0: Internal.ChunkAccess_)
        constructor(arg0: Internal.ChunkAccess_, arg1: Internal.LevelAccessor_)
        getChunk(): Internal.ChunkAccess;
        getListenerList(): Internal.ListenerList;
        get chunk(): Internal.ChunkAccess
        get listenerList(): Internal.ListenerList
    }
    type ChunkEvent_ = ChunkEvent;
    class MemoryModuleType <U> extends Internal.ForgeRegistryEntry<Internal.MemoryModuleType<any>> {
        constructor(arg0: Internal.Optional_<Internal.Codec_<U>>)
        getCodec(): Internal.Optional<Internal.Codec<Internal.ExpirableValue<U>>>;
        toString(): string;
        get codec(): Internal.Optional<Internal.Codec<Internal.ExpirableValue<U>>>
        readonly static "HURT_BY_ENTITY": Internal.MemoryModuleType<any>;
        readonly static "HUNTED_RECENTLY": Internal.MemoryModuleType<any>;
        readonly static "INTERACTION_TARGET": Internal.MemoryModuleType<any>;
        readonly static "IS_TEMPTED": Internal.MemoryModuleType<any>;
        readonly static "ADMIRING_DISABLED": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_PLAYER_HOLDING_WANTED_ITEM": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_HOSTILE": Internal.MemoryModuleType<any>;
        readonly static "SECONDARY_JOB_SITE": Internal.MemoryModuleType<any>;
        readonly static "GOLEM_DETECTED_RECENTLY": Internal.MemoryModuleType<any>;
        readonly static "INTERACTABLE_DOORS": Internal.MemoryModuleType<any>;
        readonly static "LAST_WORKED_AT_POI": Internal.MemoryModuleType<any>;
        readonly static "LAST_SLEPT": Internal.MemoryModuleType<any>;
        readonly static "WALK_TARGET": Internal.MemoryModuleType<any>;
        readonly static "PATH": Internal.MemoryModuleType<any>;
        readonly static "RAM_TARGET": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_TARGETABLE_PLAYER_NOT_WEARING_GOLD": Internal.MemoryModuleType<any>;
        readonly static "HURT_BY": Internal.MemoryModuleType<any>;
        readonly static "HAS_HUNTING_COOLDOWN": Internal.MemoryModuleType<any>;
        readonly static "ATTACK_COOLING_DOWN": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_VISIBLE_ADULT_PIGLIN": Internal.MemoryModuleType<any>;
        readonly static "JOB_SITE": Internal.MemoryModuleType<any>;
        readonly static "DOORS_TO_CLOSE": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_VISIBLE_ATTACKABLE_PLAYER": Internal.MemoryModuleType<any>;
        readonly static "UNIVERSAL_ANGER": Internal.MemoryModuleType<any>;
        readonly static "RIDE_TARGET": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_VISIBLE_ADULT_HOGLINS": Internal.MemoryModuleType<any>;
        readonly static "ATTACK_TARGET": Internal.MemoryModuleType<any>;
        readonly static "MEETING_POINT": Internal.MemoryModuleType<any>;
        readonly static "ANGRY_AT": Internal.MemoryModuleType<any>;
        readonly static "LONG_JUMP_COOLDOWN_TICKS": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_PLAYERS": Internal.MemoryModuleType<any>;
        readonly static "BREED_TARGET": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_LIVING_ENTITIES": Internal.MemoryModuleType<any>;
        readonly static "DANCING": Internal.MemoryModuleType<any>;
        readonly static "RAM_COOLDOWN_TICKS": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_VISIBLE_WANTED_ITEM": Internal.MemoryModuleType<any>;
        readonly static "AVOID_TARGET": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_VISIBLE_NEMESIS": Internal.MemoryModuleType<any>;
        readonly static "VISIBLE_ADULT_HOGLIN_COUNT": Internal.MemoryModuleType<any>;
        readonly static "HOME": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_ATTACKABLE": Internal.MemoryModuleType<any>;
        readonly static "TIME_TRYING_TO_REACH_ADMIRE_ITEM": Internal.MemoryModuleType<any>;
        readonly static "HEARD_BELL_TIME": Internal.MemoryModuleType<any>;
        readonly static "LAST_WOKEN": Internal.MemoryModuleType<any>;
        readonly static "PLAY_DEAD_TICKS": Internal.MemoryModuleType<any>;
        readonly static "CANT_REACH_WALK_TARGET_SINCE": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_REPELLENT": Internal.MemoryModuleType<any>;
        readonly static "LOOK_TARGET": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_BED": Internal.MemoryModuleType<any>;
        readonly static "POTENTIAL_JOB_SITE": Internal.MemoryModuleType<any>;
        readonly static "HIDING_PLACE": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_VISIBLE_LIVING_ENTITIES": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_VISIBLE_ADULT": Internal.MemoryModuleType<any>;
        readonly static "TEMPTING_PLAYER": Internal.MemoryModuleType<any>;
        readonly static "DUMMY": Internal.MemoryModuleType<any>;
        readonly static "ADMIRING_ITEM": Internal.MemoryModuleType<any>;
        readonly static "VISIBLE_VILLAGER_BABIES": Internal.MemoryModuleType<any>;
        readonly static "TEMPTATION_COOLDOWN_TICKS": Internal.MemoryModuleType<any>;
        readonly static "ATE_RECENTLY": Internal.MemoryModuleType<any>;
        readonly static "PACIFIED": Internal.MemoryModuleType<any>;
        readonly static "VISIBLE_ADULT_PIGLIN_COUNT": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_VISIBLE_BABY_HOGLIN": Internal.MemoryModuleType<any>;
        readonly static "CELEBRATE_LOCATION": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_VISIBLE_ADULT_PIGLINS": Internal.MemoryModuleType<any>;
        readonly static "LONG_JUMP_MID_JUMP": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_VISIBLE_HUNTABLE_HOGLIN": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_VISIBLE_PLAYER": Internal.MemoryModuleType<any>;
        readonly static "NEARBY_ADULT_PIGLINS": Internal.MemoryModuleType<any>;
        readonly static "NEAREST_VISIBLE_ZOMBIFIED": Internal.MemoryModuleType<any>;
        readonly static "DISABLE_WALK_TO_ADMIRE_ITEM": Internal.MemoryModuleType<any>;
    }
    type MemoryModuleType_<U> = MemoryModuleType<U> | Special.MemoryModuleType;
    abstract class CharsetDecoder {
        reset(): this;
        isAutoDetecting(): boolean;
        replacement(): string;
        charset(): Internal.Charset;
        averageCharsPerByte(): number;
        maxCharsPerByte(): number;
        flush(arg0: Internal.CharBuffer_): Internal.CoderResult;
        onMalformedInput(arg0: Internal.CodingErrorAction_): this;
        unmappableCharacterAction(): Internal.CodingErrorAction;
        detectedCharset(): Internal.Charset;
        replaceWith(arg0: string): this;
        onUnmappableCharacter(arg0: Internal.CodingErrorAction_): this;
        decode(arg0: Internal.ByteBuffer_): Internal.CharBuffer;
        isCharsetDetected(): boolean;
        decode(arg0: Internal.ByteBuffer_, arg1: Internal.CharBuffer_, arg2: boolean): Internal.CoderResult;
        malformedInputAction(): Internal.CodingErrorAction;
        get autoDetecting(): boolean
        get charsetDetected(): boolean
    }
    type CharsetDecoder_ = CharsetDecoder;
    class RotatedBlockProvider extends Internal.BlockStateProvider {
        constructor(arg0: Internal.Block_)
        getState(arg0: Internal.Random_, arg1: BlockPos_): Internal.BlockState;
        readonly static "CODEC": any;
    }
    type RotatedBlockProvider_ = RotatedBlockProvider;
    interface ShortIterable extends Internal.Iterable<number> {
        iterator(): Internal.Iterator<any>;
        spliterator(): Internal.Spliterator<any>;
        forEach(arg0: Internal.Consumer_<any>): void;
        forEach(arg0: Internal.ShortConsumer_): void;
        forEach(arg0: Internal.IntConsumer_): void;
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
    }
    type ShortIterable_ = ShortIterable;
    class MappedRegistry <T> extends Internal.WritableRegistry<T> {
        constructor(arg0: Internal.ResourceKey_<any>, arg1: Internal.Lifecycle_, arg2: Internal.Function_<T, Internal.Holder$Reference_<T>>)
        elementsLifecycle(): Internal.Lifecycle;
        registerOrOverride(arg0: Internal.OptionalInt_, arg1: Internal.ResourceKey_<T>, arg2: T, arg3: Internal.Lifecycle_): Internal.Holder<T>;
        getResourceKey(arg0: T): Internal.Optional<Internal.ResourceKey<T>>;
        get(arg0: Internal.ResourceKey_<T>): T;
        getTagNames(): Internal.Stream<Internal.TagKey<T>>;
        keySet(): Internal.Set<ResourceLocation>;
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<T>;
        getOrCreateHolder(arg0: Internal.ResourceKey_<T>): Internal.Holder<T>;
        isEmpty(): boolean;
        get(arg0: ResourceLocation_): T;
        getHolder(arg0: Internal.ResourceKey_<T>): Internal.Optional<Internal.Holder<T>>;
        byIdOrThrow(arg0: number): T;
        containsKey(arg0: Internal.ResourceKey_<T>): boolean;
        iterator(): Internal.Iterator<T>;
        bindTags(arg0: Internal.Map_<Internal.TagKey_<T>, Internal.List_<Internal.Holder_<T>>>): void;
        containsKey(arg0: ResourceLocation_): boolean;
        getTags(): Internal.Stream<com.mojang.datafixers.util.Pair<Internal.TagKey<T>, Internal.HolderSet$Named<T>>>;
        getHolder(arg0: number): Internal.Optional<Internal.Holder<T>>;
        freeze(): Internal.Registry<T>;
        registerMapping(arg0: number, arg1: Internal.ResourceKey_<T>, arg2: T, arg3: Internal.Lifecycle_): Internal.Holder<T>;
        byId(arg0: number): T;
        lifecycle(arg0: T): Internal.Lifecycle;
        createIntrusiveHolder(arg0: T): Internal.Holder$Reference<T>;
        getOrCreateTag(arg0: Internal.TagKey_<T>): Internal.HolderSet$Named<T>;
        getTag(arg0: Internal.TagKey_<T>): Internal.Optional<Internal.HolderSet$Named<T>>;
        getId(arg0: T): number;
        unfreeze(): void;
        size(): number;
        register(arg0: Internal.ResourceKey_<T>, arg1: T, arg2: Internal.Lifecycle_): Internal.Holder<T>;
        isKnownTagName(arg0: Internal.TagKey_<T>): boolean;
        entrySet(): Internal.Set<Internal.Map$Entry<Internal.ResourceKey<T>, T>>;
        resetTags(): void;
        getRandom(arg0: Internal.Random_): Internal.Optional<Internal.Holder<T>>;
        getKey(arg0: T): ResourceLocation;
        holders(): Internal.Stream<Internal.Holder$Reference<T>>;
        get tagNames(): Internal.Stream<Internal.TagKey<T>>
        get empty(): boolean
        get tags(): Internal.Stream<com.mojang.datafixers.util.Pair<Internal.TagKey<T>, Internal.HolderSet$Named<T>>>
    }
    type MappedRegistry_<T> = MappedRegistry<T>;
    class RegistryObjectBuilderTypes <T> {
        static add(key: Internal.ResourceKey_<Internal.Registry_<T>>, baseClass: Internal.Class_<any>): Internal.RegistryObjectBuilderTypes<T>;
        bypassServerOnly(): this;
        getDefaultType(): Internal.RegistryObjectBuilderTypes$BuilderType<T>;
        addType(type: string, builderType: Internal.Class_<any>, factory: Internal.RegistryObjectBuilderTypes$BuilderFactory_<T>): void;
        addBuilder(builder: Internal.BuilderBase_<any>): void;
        addType(type: string, builderType: Internal.Class_<any>, factory: Internal.RegistryObjectBuilderTypes$BuilderFactory_<T>, isDefault: boolean): void;
        getCurrent(): Internal.BuilderBase<any>;
        get defaultType(): Internal.RegistryObjectBuilderTypes$BuilderType<T>
        get current(): Internal.BuilderBase<any>
        readonly "registryKey": Internal.ResourceKey<Internal.Registry<T>>;
        readonly "deferredRegister": Internal.DeferredRegister<T>;
        readonly static "POINT_OF_INTEREST_TYPE": Internal.RegistryObjectBuilderTypes<any>;
        "current": Internal.BuilderBase<any>;
        "bypassServerOnly": boolean;
        readonly static "ENCHANTMENT": Internal.RegistryObjectBuilderTypes<any>;
        readonly static "CUSTOM_STAT": Internal.RegistryObjectBuilderTypes<any>;
        readonly static "MOB_EFFECT": Internal.RegistryObjectBuilderTypes<any>;
        readonly "objectBaseClass": Internal.Class<T>;
        readonly static "ENTITY_TYPE": Internal.RegistryObjectBuilderTypes<any>;
        readonly static "MOTIVE": Internal.RegistryObjectBuilderTypes<any>;
        readonly static "ITEM": Internal.RegistryObjectBuilderTypes<any>;
        readonly static "POTION": Internal.RegistryObjectBuilderTypes<any>;
        readonly "types": Internal.Map<string, Internal.RegistryObjectBuilderTypes$BuilderType<T>>;
        readonly static "FLUID": Internal.RegistryObjectBuilderTypes<any>;
        readonly static "VILLAGER_PROFESSION": Internal.RegistryObjectBuilderTypes<any>;
        readonly static "PARTICLE_TYPE": Internal.RegistryObjectBuilderTypes<any>;
        readonly static "VILLAGER_TYPE": Internal.RegistryObjectBuilderTypes<any>;
        readonly static "ALL_BUILDERS": [];
        readonly static "BLOCK_ENTITY_TYPE": Internal.RegistryObjectBuilderTypes<any>;
        readonly "objects": Internal.Map<ResourceLocation, Internal.BuilderBase<any>>;
        readonly static "MAP": {[key: Internal.ResourceKey<any>]: Internal.RegistryObjectBuilderTypes<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryObjectBuilderTypes<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryObjectBuilderTypes<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryObjectBuilderTypes<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryObjectBuilderTypes<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryObjectBuilderTypes<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryObjectBuilderTypes<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryObjectBuilderTypes<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryObjectBuilderTypes<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryObjectBuilderTypes<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryObjectBuilderTypes<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryObjectBuilderTypes<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryObjectBuilderTypes<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryObjectBuilderTypes<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryObjectBuilderTypes<any>};
        readonly static "BLOCK": Internal.RegistryObjectBuilderTypes<any>;
        readonly static "SOUND_EVENT": Internal.RegistryObjectBuilderTypes<any>;
    }
    type RegistryObjectBuilderTypes_<T> = RegistryObjectBuilderTypes<T>;
    interface Pack$PackConstructor {
        create(arg0: string, arg1: Internal.Component_, arg2: boolean, arg3: Internal.Supplier_<Internal.PackResources_>, arg4: Internal.PackMetadataSection_, arg5: Internal.Pack$Position_, arg6: Internal.PackSource_, arg7: boolean): Internal.Pack;
        create(arg0: string, arg1: Internal.Component_, arg2: boolean, arg3: Internal.Supplier_<Internal.PackResources_>, arg4: Internal.PackMetadataSection_, arg5: Internal.Pack$Position_, arg6: Internal.PackSource_): Internal.Pack;
    }
    type Pack$PackConstructor_ = Pack$PackConstructor | ((arg0: string, arg1: Internal.Component, arg2: boolean, arg3: Internal.Supplier<Internal.PackResources>, arg4: Internal.PackMetadataSection, arg5: Internal.Pack$Position, arg6: Internal.PackSource, arg7: boolean)=>Internal.Pack_);
    class CrashReport {
        constructor(arg0: string, arg1: Internal.Throwable_)
        static preload(): void;
        getException(): Internal.Throwable;
        getTitle(): string;
        saveToFile(arg0: Internal.File_): boolean;
        static forThrowable(arg0: Internal.Throwable_, arg1: string): Internal.CrashReport;
        getSystemReport(): Internal.SystemReport;
        getDetails(arg0: Internal.StringBuilder_): void;
        getExceptionMessage(): string;
        getFriendlyReport(): string;
        addCategory(arg0: string): Internal.CrashReportCategory;
        getSaveFile(): Internal.File;
        addCategory(arg0: string, arg1: number): Internal.CrashReportCategory;
        getDetails(): string;
        get exception(): Internal.Throwable
        get title(): string
        get systemReport(): Internal.SystemReport
        get exceptionMessage(): string
        get friendlyReport(): string
        get saveFile(): Internal.File
        get details(): string
    }
    type CrashReport_ = CrashReport;
    interface StructurePieceAccessor {
        addPiece(arg0: Internal.StructurePiece_): void;
        findCollisionPiece(arg0: Internal.BoundingBox_): Internal.StructurePiece;
    }
    type StructurePieceAccessor_ = StructurePieceAccessor;
    interface RandomGenerator {
        nextFloat(arg0: number): number;
        ints(arg0: number, arg1: number): Internal.IntStream;
        getDefault(): this;
        nextLong(): number;
        nextDouble(): number;
        nextLong(arg0: number, arg1: number): number;
        nextGaussian(): number;
        doubles(arg0: number, arg1: number, arg2: number): Internal.DoubleStream;
        nextDouble(arg0: number): number;
        nextInt(arg0: number): number;
        nextFloat(): number;
        nextLong(arg0: number): number;
        ints(arg0: number, arg1: number, arg2: number): Internal.IntStream;
        nextFloat(arg0: number, arg1: number): number;
        of(arg0: string): this;
        doubles(): Internal.DoubleStream;
        nextBytes(arg0: number[]): void;
        nextInt(): number;
        longs(arg0: number): Internal.LongStream;
        longs(arg0: number, arg1: number, arg2: number): Internal.LongStream;
        nextBoolean(): boolean;
        nextDouble(arg0: number, arg1: number): number;
        nextExponential(): number;
        longs(arg0: number, arg1: number): Internal.LongStream;
        nextInt(arg0: number, arg1: number): number;
        longs(): Internal.LongStream;
        isDeprecated(): boolean;
        nextGaussian(arg0: number, arg1: number): number;
        doubles(arg0: number): Internal.DoubleStream;
        ints(): Internal.IntStream;
        ints(arg0: number): Internal.IntStream;
        doubles(arg0: number, arg1: number): Internal.DoubleStream;
        get default(): Internal.RandomGenerator
        get deprecated(): boolean
    }
    type RandomGenerator_ = RandomGenerator;
    abstract class MethodHandle implements Internal.Constable {
        toString(): string;
        invokeExact(...arg0: any[]): any;
        describeConstable(): Internal.Optional<Internal.MethodHandleDesc>;
        invokeWithArguments(...arg0: any[]): any;
        withVarargs(arg0: boolean): this;
        type(): Internal.MethodType;
        isVarargsCollector(): boolean;
        asSpreader(arg0: Internal.Class_<any>, arg1: number): this;
        asFixedArity(): this;
        asVarargsCollector(arg0: Internal.Class_<any>): this;
        asCollector(arg0: number, arg1: Internal.Class_<any>, arg2: number): this;
        invokeWithArguments(arg0: Internal.List_<any>): any;
        invoke(...arg0: any[]): any;
        asType(arg0: Internal.MethodType_): this;
        asSpreader(arg0: number, arg1: Internal.Class_<any>, arg2: number): this;
        asCollector(arg0: Internal.Class_<any>, arg1: number): this;
        bindTo(arg0: any): this;
        get varargsCollector(): boolean
    }
    type MethodHandle_ = MethodHandle;
    interface IdEnumerationIterator {
        enumerationIteratorNext(arg0: Internal.Context_, arg1: Internal.Consumer_<any>): boolean;
        enumerationIteratorHasNext(arg0: Internal.Context_, arg1: Internal.Consumer_<any>): boolean;
    }
    type IdEnumerationIterator_ = IdEnumerationIterator;
    class CriterionProgress {
        constructor()
        grant(): void;
        serializeToJson(): Internal.JsonElement;
        toString(): string;
        getObtained(): Internal.Date;
        static fromJson(arg0: string): Internal.CriterionProgress;
        revoke(): void;
        isDone(): boolean;
        static fromNetwork(arg0: Internal.FriendlyByteBuf_): Internal.CriterionProgress;
        serializeToNetwork(arg0: Internal.FriendlyByteBuf_): void;
        get obtained(): Internal.Date
        get done(): boolean
    }
    type CriterionProgress_ = CriterionProgress;
    interface ContextAction <T> {
        run(arg0: Internal.Context_): T;
    }
    type ContextAction_<T> = ContextAction<T>;
    class MobEffectTextureManager extends Internal.TextureAtlasHolder {
        constructor(arg0: Internal.TextureManager_)
        get(arg0: Internal.MobEffect_): Internal.TextureAtlasSprite;
        getName(): string;
        get name(): string
    }
    type MobEffectTextureManager_ = MobEffectTextureManager;
    class ZoneRules implements Internal.Serializable {
        isFixedOffset(): boolean;
        toString(): string;
        getOffset(arg0: Internal.LocalDateTime_): Internal.ZoneOffset;
        getStandardOffset(arg0: Internal.Instant_): Internal.ZoneOffset;
        isDaylightSavings(arg0: Internal.Instant_): boolean;
        static of(arg0: Internal.ZoneOffset_): Internal.ZoneRules;
        isValidOffset(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneOffset_): boolean;
        getTransitionRules(): Internal.List<Internal.ZoneOffsetTransitionRule>;
        nextTransition(arg0: Internal.Instant_): Internal.ZoneOffsetTransition;
        previousTransition(arg0: Internal.Instant_): Internal.ZoneOffsetTransition;
        hashCode(): number;
        getValidOffsets(arg0: Internal.LocalDateTime_): Internal.List<Internal.ZoneOffset>;
        static of(arg0: Internal.ZoneOffset_, arg1: Internal.ZoneOffset_, arg2: Internal.List_<Internal.ZoneOffsetTransition_>, arg3: Internal.List_<Internal.ZoneOffsetTransition_>, arg4: Internal.List_<Internal.ZoneOffsetTransitionRule_>): Internal.ZoneRules;
        getDaylightSavings(arg0: Internal.Instant_): Internal.Duration;
        getTransitions(): Internal.List<Internal.ZoneOffsetTransition>;
        equals(arg0: any): boolean;
        getTransition(arg0: Internal.LocalDateTime_): Internal.ZoneOffsetTransition;
        getOffset(arg0: Internal.Instant_): Internal.ZoneOffset;
        get fixedOffset(): boolean
        get transitionRules(): Internal.List<Internal.ZoneOffsetTransitionRule>
        get transitions(): Internal.List<Internal.ZoneOffsetTransition>
    }
    type ZoneRules_ = ZoneRules;
    interface DoubleIterator extends Internal.PrimitiveIterator$OfDouble {
        forEachRemaining(arg0: any): void;
        forEachRemaining(arg0: it.unimi.dsi.fastutil.doubles.DoubleConsumer_): void;
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): any;
        skip(arg0: number): number;
        forEachRemaining(arg0: Internal.DoubleConsumer_): void;
        nextDouble(): number;
    }
    type DoubleIterator_ = DoubleIterator;
    interface ProgressListener {
        progressStart(arg0: Internal.Component_): void;
        stop(): void;
        progressStartNoAbort(arg0: Internal.Component_): void;
        progressStagePercentage(arg0: number): void;
        progressStage(arg0: Internal.Component_): void;
    }
    type ProgressListener_ = ProgressListener;
    class ListenerList {
        constructor()
        constructor(arg0: Internal.ListenerList_)
        getListeners(arg0: number): Internal.IEventListener[];
        unregister(arg0: number, arg1: Internal.IEventListener_): void;
        register(arg0: number, arg1: Internal.EventPriority_, arg2: Internal.IEventListener_): void;
        static clearBusID(arg0: number): void;
        static unregisterAll(arg0: number, arg1: Internal.IEventListener_): void;
    }
    type ListenerList_ = ListenerList;
    class ClickAction extends Internal.Enum<Internal.ClickAction> {
        static valueOf(arg0: string): Internal.ClickAction;
        static values(): Internal.ClickAction[];
        readonly static "PRIMARY": Internal.ClickAction;
        readonly static "SECONDARY": Internal.ClickAction;
    }
    type ClickAction_ = ClickAction | "secondary" | "primary";
    class BeehiveBlockEntity$BeeReleaseStatus extends Internal.Enum<Internal.BeehiveBlockEntity$BeeReleaseStatus> {
        static values(): Internal.BeehiveBlockEntity$BeeReleaseStatus[];
        static valueOf(arg0: string): Internal.BeehiveBlockEntity$BeeReleaseStatus;
        readonly static "EMERGENCY": Internal.BeehiveBlockEntity$BeeReleaseStatus;
        readonly static "HONEY_DELIVERED": Internal.BeehiveBlockEntity$BeeReleaseStatus;
        readonly static "BEE_RELEASED": Internal.BeehiveBlockEntity$BeeReleaseStatus;
    }
    type BeehiveBlockEntity$BeeReleaseStatus_ = "bee_released" | "honey_delivered" | BeehiveBlockEntity$BeeReleaseStatus | "emergency";
    class SimpleRecipeSerializer <T> extends Internal.ForgeRegistryEntry<Internal.RecipeSerializer<any>> implements Internal.RecipeSerializer<T> {
        constructor(arg0: Internal.Function_<ResourceLocation_, T>)
        fromJson(arg0: ResourceLocation_, arg1: Internal.JsonObject_): T;
        fromNetwork(arg0: ResourceLocation_, arg1: Internal.FriendlyByteBuf_): T;
        toNetwork(arg0: Internal.FriendlyByteBuf_, arg1: T): void;
        fromJson(arg0: ResourceLocation_, arg1: Internal.JsonObject_, arg2: Internal.ICondition$IContext_): T;
    }
    type SimpleRecipeSerializer_<T> = SimpleRecipeSerializer<T>;
    interface DataFixer {
        update(arg0: Internal.DSL$TypeReference_, arg1: Internal.Dynamic_<T>, arg2: number, arg3: number): Internal.Dynamic<T>;
        getSchema(arg0: number): Internal.Schema;
    }
    type DataFixer_ = DataFixer;
    interface IContainerFactory <T> extends Internal.MenuType$MenuSupplier<T> {
        create(arg0: number, arg1: Internal.Inventory_, arg2: Internal.FriendlyByteBuf_): T;
        create(arg0: number, arg1: Internal.Inventory_): T;
    }
    type IContainerFactory_<T> = IContainerFactory<T>;
    class NarratedElementType extends Internal.Enum<Internal.NarratedElementType> {
        static valueOf(arg0: string): Internal.NarratedElementType;
        static values(): Internal.NarratedElementType[];
        readonly static "HINT": Internal.NarratedElementType;
        readonly static "POSITION": Internal.NarratedElementType;
        readonly static "TITLE": Internal.NarratedElementType;
        readonly static "USAGE": Internal.NarratedElementType;
    }
    type NarratedElementType_ = NarratedElementType | "hint" | "position" | "title" | "usage";
    class MutableToolTier implements Internal.Tier {
        constructor(p: Internal.Tier_)
        setRepairIngredient(in_: Internal.IngredientJS_): void;
        getLevel(): number;
        getVanillaRepairIngredient(): Internal.Ingredient;
        getAttackDamageBonus(): number;
        getEnchantmentValue(): number;
        setSpeed(f: number): void;
        getUses(): number;
        setEnchantmentValue(i: number): void;
        getSpeed(): number;
        getTag(): Internal.TagKey<Internal.Block>;
        setAttackDamageBonus(f: number): void;
        setUses(i: number): void;
        setLevel(i: number): void;
        set repairIngredient(in_: Internal.IngredientJS_)
        get level(): number
        get vanillaRepairIngredient(): Internal.Ingredient
        get attackDamageBonus(): number
        get enchantmentValue(): number
        set speed(f: number)
        get uses(): number
        set enchantmentValue(i: number)
        get speed(): number
        get tag(): Internal.TagKey<Internal.Block>
        set attackDamageBonus(f: number)
        set uses(i: number)
        set level(i: number)
        readonly "parent": Internal.Tier;
    }
    type MutableToolTier_ = MutableToolTier;
    abstract class SimpleChannelInboundHandler <I> extends Internal.ChannelInboundHandlerAdapter {
        acceptInboundMessage(arg0: any): boolean;
        channelRead(arg0: Internal.ChannelHandlerContext_, arg1: any): void;
    }
    type SimpleChannelInboundHandler_<I> = SimpleChannelInboundHandler<I>;
    class RenderPlayerEvent$Post extends Internal.RenderPlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.PlayerRenderer_, arg2: number, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type RenderPlayerEvent$Post_ = RenderPlayerEvent$Post;
    class LivingSpawnEvent$SpecialSpawn extends Internal.LivingSpawnEvent {
        constructor()
        constructor(arg0: Internal.Mob_, arg1: Internal.LevelAccessor_, arg2: number, arg3: number, arg4: number, arg5: Internal.BaseSpawner_, arg6: Internal.MobSpawnType_)
        constructor(arg0: Internal.Mob_, arg1: Internal.Level_, arg2: number, arg3: number, arg4: number, arg5: Internal.BaseSpawner_, arg6: Internal.MobSpawnType_)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        getSpawner(): Internal.BaseSpawner;
        getSpawnReason(): Internal.MobSpawnType;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
        get spawner(): Internal.BaseSpawner
        get spawnReason(): Internal.MobSpawnType
    }
    type LivingSpawnEvent$SpecialSpawn_ = LivingSpawnEvent$SpecialSpawn;
    abstract class ImmutableCollection <E> extends Internal.AbstractCollection<E> implements Internal.Serializable {
        add(arg0: E): boolean;
        forEach(arg0: Internal.Consumer_<any>): void;
        toArray(arg0: T[]): T[];
        remove(arg0: any): boolean;
        parallelStream(): Internal.Stream<E>;
        toArray(): any[];
        asList(): Internal.ImmutableList<E>;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        stream(): Internal.Stream<E>;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        clear(): void;
        addAll(arg0: Internal.Collection_<any>): boolean;
        spliterator(): Internal.Spliterator<E>;
        iterator(): Internal.UnmodifiableIterator<E>;
        contains(arg0: any): boolean;
    }
    type ImmutableCollection_<E> = ImmutableCollection<E>;
    abstract class CustomRecipe implements Internal.CraftingRecipe {
        constructor(arg0: ResourceLocation_)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        isSpecial(): boolean;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        getId(): ResourceLocation;
        isIncomplete(): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        getResultItem(): Internal.ItemStack;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get special(): boolean
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get id(): ResourceLocation
        get incomplete(): boolean
        get resultItem(): Internal.ItemStack
    }
    type CustomRecipe_ = CustomRecipe;
    interface ChannelProgressiveFuture extends Internal.ProgressiveFuture<void>, Internal.ChannelFuture {
        awaitUninterruptibly(): this;
        sync(): this;
        await(): this;
        addListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        addListener(arg0: Internal.GenericFutureListener_<any>): this;
        removeListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        removeListener(arg0: Internal.GenericFutureListener_<any>): this;
        syncUninterruptibly(): this;
    }
    type ChannelProgressiveFuture_ = ChannelProgressiveFuture;
    abstract class IntProvider {
        constructor()
        getMinValue(): number;
        getType(): Internal.IntProviderType<any>;
        getMaxValue(): number;
        sample(arg0: Internal.Random_): number;
        static codec(arg0: number, arg1: number): Internal.Codec<Internal.IntProvider>;
        get minValue(): number
        get type(): Internal.IntProviderType<any>
        get maxValue(): number
        readonly static "CODEC": any;
        readonly static "NON_NEGATIVE_CODEC": any;
        readonly static "POSITIVE_CODEC": any;
    }
    type IntProvider_ = IntProvider;
    class DragonLandingPhase extends Internal.AbstractDragonPhaseInstance {
        constructor(arg0: Internal.EnderDragon_)
        doClientTick(): void;
        getPhase(): Internal.EnderDragonPhase<Internal.DragonLandingPhase>;
        getFlyTargetLocation(): Vec3;
        getFlySpeed(): number;
        getTurnSpeed(): number;
        begin(): void;
        doServerTick(): void;
        get phase(): Internal.EnderDragonPhase<Internal.DragonLandingPhase>
        get flyTargetLocation(): Vec3
        get flySpeed(): number
        get turnSpeed(): number
    }
    type DragonLandingPhase_ = DragonLandingPhase;
    class BrainDebugRenderer$PoiInfo {
        constructor(arg0: BlockPos_, arg1: string, arg2: number)
        "type": string;
        readonly "pos": BlockPos;
        "freeTicketCount": number;
    }
    type BrainDebugRenderer$PoiInfo_ = BrainDebugRenderer$PoiInfo;
    class Sound$Type extends Internal.Enum<Internal.Sound$Type> {
        static getByName(arg0: string): Internal.Sound$Type;
        static values(): Internal.Sound$Type[];
        static valueOf(arg0: string): Internal.Sound$Type;
        readonly static "FILE": Internal.Sound$Type;
        readonly static "SOUND_EVENT": Internal.Sound$Type;
    }
    type Sound$Type_ = Sound$Type | "file" | "sound_event";
    class ConduitBlockEntity extends Internal.BlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        getActiveRotation(arg0: number): number;
        isHunting(): boolean;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getUpdateTag(): Internal.CompoundTag;
        static clientTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.ConduitBlockEntity_): void;
        isActive(): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        serializeNBT(): Internal.CompoundTag;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        load(arg0: Internal.CompoundTag_): void;
        getUpdatePacket(): Internal.Packet<any>;
        onLoad(): void;
        static serverTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.ConduitBlockEntity_): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get hunting(): boolean
        get modelData(): Internal.IModelData
        get updateTag(): Internal.CompoundTag
        get active(): boolean
        get updatePacket(): Internal.Packet<any>
        get renderBoundingBox(): Internal.AABB
        "tickCount": number;
    }
    type ConduitBlockEntity_ = ConduitBlockEntity;
    class Method extends Internal.Executable {
        isVarArgs(): boolean;
        getGenericExceptionTypes(): Internal.Type[];
        getModifiers(): number;
        getAnnotatedReturnType(): Internal.AnnotatedType;
        getDefaultValue(): any;
        getParameterTypes(): Internal.Class<any>[];
        getParameterAnnotations(): Internal.Annotation[][];
        getName(): string;
        getParameterCount(): number;
        invoke(arg0: any, ...arg1: any[]): any;
        getDeclaredAnnotations(): Internal.Annotation[];
        setAccessible(arg0: boolean): void;
        getGenericParameterTypes(): Internal.Type[];
        toString(): string;
        isSynthetic(): boolean;
        getAnnotation(arg0: Internal.Class_<T>): T;
        getTypeParameters(): any[];
        isDefault(): boolean;
        getDeclaringClass(): Internal.Class<any>;
        getExceptionTypes(): Internal.Class<any>[];
        hashCode(): number;
        getReturnType(): Internal.Class<any>;
        isBridge(): boolean;
        toGenericString(): string;
        getGenericReturnType(): Internal.Type;
        equals(arg0: any): boolean;
        get varArgs(): boolean
        get genericExceptionTypes(): Internal.Type[]
        get modifiers(): number
        get annotatedReturnType(): Internal.AnnotatedType
        get defaultValue(): any
        get parameterTypes(): Internal.Class<any>[]
        get parameterAnnotations(): Internal.Annotation[][]
        get name(): string
        get parameterCount(): number
        get declaredAnnotations(): Internal.Annotation[]
        set accessible(arg0: boolean)
        get genericParameterTypes(): Internal.Type[]
        get synthetic(): boolean
        get typeParameters(): any[]
        get default(): boolean
        get declaringClass(): Internal.Class<any>
        get exceptionTypes(): Internal.Class<any>[]
        get returnType(): Internal.Class<any>
        get bridge(): boolean
        get genericReturnType(): Internal.Type
    }
    type Method_ = Method;
    class SpectralArrow extends Internal.AbstractArrow {
        constructor(arg0: Internal.Level_, arg1: Internal.LivingEntity_)
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        tick(): void;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type SpectralArrow_ = SpectralArrow;
    class ConfiguredStructureFeature <FC, F> {
        constructor(arg0: F, arg1: FC, arg2: Internal.HolderSet_<Internal.Biome_>, arg3: boolean, arg4: Internal.Map_<Internal.MobCategory_, Internal.StructureSpawnOverride_>)
        biomes(): Internal.HolderSet<Internal.Biome>;
        generate(arg0: Internal.RegistryAccess_, arg1: Internal.ChunkGenerator_, arg2: Internal.BiomeSource_, arg3: Internal.StructureManager_, arg4: number, arg5: Internal.ChunkPos_, arg6: number, arg7: Internal.LevelHeightAccessor_, arg8: Internal.Predicate_<Internal.Holder_<Internal.Biome_>>): Internal.StructureStart;
        adjustBoundingBox(arg0: Internal.BoundingBox_): Internal.BoundingBox;
        readonly "biomes": Internal.HolderSet<Internal.Biome>;
        readonly static "LIST_CODEC": any;
        readonly "spawnOverrides": Internal.Map<Internal.MobCategory, Internal.StructureSpawnOverride>;
        readonly static "DIRECT_CODEC": any;
        readonly static "CODEC": any;
        readonly "config": FC;
        readonly "feature": F;
        readonly "adaptNoise": boolean;
    }
    type ConfiguredStructureFeature_<FC, F> = Special.ConfiguredStructureFeature | ConfiguredStructureFeature<FC, F>;
    class ItemToolTierEventJS extends Internal.StartupEventJS {
        constructor()
        add(id: string, tier: Internal.Consumer_<Internal.MutableToolTier_>): void;
    }
    type ItemToolTierEventJS_ = ItemToolTierEventJS;
    interface Decoder$Terminal <A> {
        decode(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<A>;
        decoder(): Internal.Decoder<A>;
    }
    type Decoder$Terminal_<A> = Decoder$Terminal<A>;
    interface CustomIngredientActionCallback {
        transform(arg0: Internal.ItemStackJS_, arg1: number, arg2: Internal.InventoryJS_): any;
    }
    type CustomIngredientActionCallback_ = CustomIngredientActionCallback | ((arg0: Internal.ItemStackJS, arg1: number, arg2: Internal.InventoryJS)=>any);
    class Locale$LanguageRange {
        constructor(arg0: string, arg1: number)
        constructor(arg0: string)
        getWeight(): number;
        hashCode(): number;
        toString(): string;
        static parse(arg0: string): Internal.List<Internal.Locale$LanguageRange>;
        static parse(arg0: string, arg1: Internal.Map_<string, Internal.List_<string>>): Internal.List<Internal.Locale$LanguageRange>;
        static mapEquivalents(arg0: Internal.List_<Internal.Locale$LanguageRange_>, arg1: Internal.Map_<string, Internal.List_<string>>): Internal.List<Internal.Locale$LanguageRange>;
        equals(arg0: any): boolean;
        getRange(): string;
        get weight(): number
        get range(): string
        readonly static "MAX_WEIGHT": 1.0;
        readonly static "MIN_WEIGHT": 0.0;
    }
    type Locale$LanguageRange_ = Locale$LanguageRange;
    interface ArgumentType <T> {
        parse(arg0: Internal.StringReader_): T;
        getExamples(): Internal.Collection<string>;
        listSuggestions(arg0: Internal.CommandContext_<S>, arg1: Internal.SuggestionsBuilder_): Internal.CompletableFuture<Internal.Suggestions>;
        get examples(): Internal.Collection<string>
    }
    type ArgumentType_<T> = ArgumentType<T>;
    class ItemCooldowns {
        constructor()
        addCooldown(arg0: Internal.Item_, arg1: number): void;
        getCooldownPercent(arg0: Internal.Item_, arg1: number): number;
        isOnCooldown(arg0: Internal.Item_): boolean;
        removeCooldown(arg0: Internal.Item_): void;
        tick(): void;
    }
    type ItemCooldowns_ = ItemCooldowns;
    class Capability <T> {
        addListener(arg0: Internal.Consumer_<Internal.Capability_<T>>): this;
        orEmpty(arg0: Internal.Capability_<R>, arg1: Internal.LazyOptional_<T>): Internal.LazyOptional<R>;
        getName(): string;
        isRegistered(): boolean;
        get name(): string
        get registered(): boolean
    }
    type Capability_<T> = Capability<T>;
    class StonecutterRecipe extends Internal.SingleItemRecipe {
        constructor(arg0: ResourceLocation_, arg1: string, arg2: Internal.Ingredient_, arg3: Internal.ItemStack_)
        isSpecial(): boolean;
        getToastSymbol(): Internal.ItemStack;
        isIncomplete(): boolean;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getRemainingItems(arg0: Internal.Container_): Internal.NonNullList<Internal.ItemStack>;
        get special(): boolean
        get toastSymbol(): Internal.ItemStack
        get incomplete(): boolean
    }
    type StonecutterRecipe_ = StonecutterRecipe;
    class DataPackEventJS extends Internal.ServerEventJS {
        constructor(d: any_, rm: any_)
        add(id: ResourceLocation_, content: string): void;
        addJson(id: ResourceLocation_, json: Internal.JsonElement_): void;
    }
    type DataPackEventJS_ = DataPackEventJS;
    class PiglinBrute extends Internal.AbstractPiglin {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        deserializeNBT(arg0: Internal.Tag_): void;
        getArmPose(): Internal.PiglinArmPose;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        wantsToPickUp(arg0: Internal.ItemStack_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getBrain(): Internal.Brain<Internal.PiglinBrute>;
        canHunt(): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get armPose(): Internal.PiglinArmPose
        get stepHeight(): number
        get multipartEntity(): boolean
        get brain(): Internal.Brain<Internal.PiglinBrute>
        get parts(): Internal.PartEntity<any>[]
    }
    type PiglinBrute_ = PiglinBrute;
    abstract class Level extends Internal.CapabilityProvider<Internal.Level> implements Internal.LevelKJS, Internal.IForgeLevel, Internal.LevelAccessor, Internal.AutoCloseable {
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_): Internal.Player;
        dayTime(): number;
        explode(arg0: Internal.Entity_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: boolean, arg6: Internal.Explosion$BlockInteraction_): Internal.Explosion;
        loadedAndEntityCanStandOn(arg0: BlockPos_, arg1: Internal.Entity_): boolean;
        playSound(arg0: Internal.Player_, arg1: Internal.Entity_, arg2: Internal.SoundEvent_, arg3: Internal.SoundSource_, arg4: number, arg5: number): void;
        isUnobstructed(arg0: Internal.Entity_, arg1: Internal.VoxelShape_): boolean;
        getMaxSection(): number;
        gameEvent(arg0: Internal.GameEvent_, arg1: Internal.Entity_): void;
        getLevelData(): Internal.LevelData;
        isRaining(): boolean;
        getSunAngle(arg0: number): number;
        updateNeighborsAt(arg0: BlockPos_, arg1: Internal.Block_): void;
        getSectionYFromSectionIndex(arg0: number): number;
        gatherChunkSourceStats(): string;
        isEmptyBlock(arg0: BlockPos_): boolean;
        removeBlock(arg0: BlockPos_, arg1: boolean): boolean;
        shouldTickDeath(arg0: Internal.Entity_): boolean;
        explode(arg0: Internal.Entity_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.Explosion$BlockInteraction_): Internal.Explosion;
        getTimeOfDay(arg0: number): number;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getChunkAt(arg0: BlockPos_): Internal.LevelChunk;
        isClientSide(): boolean;
        isThundering(): boolean;
        isDay(): boolean;
        disconnect(): void;
        blockEntityChanged(arg0: BlockPos_): void;
        static isInSpawnableBounds(arg0: BlockPos_): boolean;
        destroyBlock(arg0: BlockPos_, arg1: boolean, arg2: Internal.Entity_, arg3: number): boolean;
        getSeaLevel(): number;
        getSectionIndex(arg0: number): number;
        getRandom(): Internal.Random;
        setSpawnSettings(arg0: boolean, arg1: boolean): void;
        hasChunksAt(arg0: BlockPos_, arg1: BlockPos_): boolean;
        loadedAndEntityCanStandOnFace(arg0: BlockPos_, arg1: Internal.Entity_, arg2: Internal.Direction_): boolean;
        getEntities(arg0: Internal.EntityTypeTest_<Internal.Entity_, T>, arg1: Internal.AABB_, arg2: Internal.Predicate_<any>): Internal.List<T>;
        destroyBlock(arg0: BlockPos_, arg1: boolean, arg2: Internal.Entity_): boolean;
        getHeight(): number;
        hasChunkAt(arg0: BlockPos_): boolean;
        getBiome(arg0: BlockPos_): Internal.Holder<Internal.Biome>;
        addAlwaysVisibleParticle(arg0: Internal.ParticleOptions_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
        shouldTickBlocksAt(arg0: number): boolean;
        increaseMaxEntityRadius(arg0: number): number;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Block_, arg2: number, arg3: Internal.TickPriority_): void;
        isRainingAt(arg0: BlockPos_): boolean;
        getDayTime(): number;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: number, arg3: number, arg4: number): Internal.Player;
        getBlockState(arg0: BlockPos_): Internal.BlockState;
        findFreePosition(arg0: Internal.Entity_, arg1: Internal.VoxelShape_, arg2: Vec3_, arg3: number, arg4: number, arg5: number): Internal.Optional<Vec3>;
        playSound(arg0: Internal.Player_, arg1: BlockPos_, arg2: Internal.SoundEvent_, arg3: Internal.SoundSource_, arg4: number, arg5: number): void;
        isInWorldBounds(arg0: BlockPos_): boolean;
        hasNeighborSignal(arg0: BlockPos_): boolean;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getBlockRandomPos(arg0: number, arg1: number, arg2: number, arg3: number): BlockPos;
        sendPacketToServer(arg0: Internal.Packet_<any>): void;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        getRawBrightness(arg0: BlockPos_, arg1: number): number;
        addParticle(arg0: Internal.ParticleOptions_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
        getCurrentDifficultyAt(arg0: BlockPos_): Internal.DifficultyInstance;
        getDifficulty(): Internal.Difficulty;
        getEntities(arg0: Internal.Entity_, arg1: Internal.AABB_, arg2: Internal.Predicate_<any>): Internal.List<Internal.Entity>;
        addParticle(arg0: Internal.ParticleOptions_, arg1: boolean, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        guardEntityTick(arg0: Internal.Consumer_<T>, arg1: T): void;
        isHumidAt(arg0: BlockPos_): boolean;
        mayInteract(arg0: Internal.Player_, arg1: BlockPos_): boolean;
        canSeeSkyFromBelowWater(arg0: BlockPos_): boolean;
        getSectionsCount(): number;
        getHeight(arg0: Internal.Heightmap$Types_, arg1: number, arg2: number): number;
        getFreeMapId(): number;
        getChunk(arg0: number, arg1: number, arg2: Internal.ChunkStatus_): Internal.ChunkAccess;
        hasChunk(arg0: number, arg1: number): boolean;
        neighborChanged(arg0: BlockPos_, arg1: Internal.Block_, arg2: BlockPos_): void;
        updateNeighborsAtExceptFromFacing(arg0: BlockPos_, arg1: Internal.Block_, arg2: Internal.Direction_): void;
        destroyBlockProgress(arg0: number, arg1: BlockPos_, arg2: number): void;
        getProfiler(): Internal.ProfilerFiller;
        getMoonBrightness(): number;
        isLoaded(arg0: BlockPos_): boolean;
        isWaterAt(arg0: BlockPos_): boolean;
        explode(arg0: Internal.Entity_, arg1: Internal.DamageSource_, arg2: Internal.ExplosionDamageCalculator_, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean, arg8: Internal.Explosion$BlockInteraction_): Internal.Explosion;
        markAndNotifyBlock(arg0: BlockPos_, arg1: Internal.LevelChunk_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: number, arg5: number): void;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        getEntityCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.VoxelShape>;
        getNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getFluidState(arg0: BlockPos_): Internal.FluidState;
        getProfilerSupplier(): Internal.Supplier<Internal.ProfilerFiller>;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        getScoreboard(): Internal.Scoreboard;
        getRecipeManager(): Internal.RecipeManager;
        nextSubTickCount(): number;
        containsAnyLiquid(arg0: Internal.AABB_): boolean;
        getMaxLightLevel(): number;
        setThunderLevel(arg0: number): void;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
        isDebug(): boolean;
        getSignal(arg0: BlockPos_, arg1: Internal.Direction_): number;
        addAlwaysVisibleParticle(arg0: Internal.ParticleOptions_, arg1: boolean, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        dimensionTypeRegistration(): Internal.Holder<Internal.DimensionType>;
        broadcastEntityEvent(arg0: Internal.Entity_, arg1: number): void;
        getBrightness(arg0: Internal.LightLayer_, arg1: BlockPos_): number;
        isNight(): boolean;
        getThunderLevel(arg0: number): number;
        getBiomeManager(): Internal.BiomeManager;
        setBlockAndUpdate(arg0: BlockPos_, arg1: Internal.BlockState_): boolean;
        getMaxLocalRawBrightness(arg0: BlockPos_, arg1: number): number;
        getBlockCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        setBlockEntity(arg0: Internal.BlockEntity_): void;
        getHeightmapPos(arg0: Internal.Heightmap$Types_, arg1: BlockPos_): BlockPos;
        blockUpdated(arg0: BlockPos_, arg1: Internal.Block_): void;
        setBlock(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: number, arg3: number): boolean;
        getEntities(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.Entity>;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_): Internal.List<T>;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getBrightness(arg0: BlockPos_): number;
        dimensionType(): Internal.DimensionType;
        getNearestEntity(arg0: Internal.List_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number): T;
        getSkyDarken(): number;
        onBlockStateChange(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: Internal.BlockState_): void;
        getMinBuildHeight(): number;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Fluid_, arg2: number): void;
        addDestroyBlockEffect(arg0: BlockPos_, arg1: Internal.BlockState_): void;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): Internal.Player;
        playSound(arg0: Internal.Player_, arg1: number, arg2: number, arg3: number, arg4: Internal.SoundEvent_, arg5: Internal.SoundSource_, arg6: number, arg7: number): void;
        hasChunkAt(arg0: number, arg1: number): boolean;
        getDirectSignalTo(arg0: BlockPos_): number;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: number, arg2: number, arg3: number): Internal.Player;
        getMaxBuildHeight(): number;
        getGameRules(): Internal.GameRules;
        addBlockEntityTicker(arg0: Internal.TickingBlockEntity_): void;
        setMapData(arg0: string, arg1: Internal.MapItemSavedData_): void;
        destroyBlock(arg0: BlockPos_, arg1: boolean): boolean;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Block_, arg2: number): void;
        addFreshEntity(arg0: Internal.Entity_): boolean;
        getChunk(arg0: number, arg1: number): Internal.ChunkAccess;
        hasSignal(arg0: BlockPos_, arg1: Internal.Direction_): boolean;
        getCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        updateSkyBrightness(): void;
        getChunk(arg0: BlockPos_): Internal.ChunkAccess;
        isFluidAtPosition(arg0: BlockPos_, arg1: Internal.Predicate_<Internal.FluidState_>): boolean;
        getWorldBorder(): Internal.WorldBorder;
        gameEvent(arg0: Internal.GameEvent_, arg1: BlockPos_): void;
        getMaxLocalRawBrightness(arg0: BlockPos_): number;
        isUnobstructed(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.CollisionContext_): boolean;
        asKJS(): Internal.LevelJS;
        createFireworks(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.CompoundTag_): void;
        hasNearbyAlivePlayer(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        setRainLevel(arg0: number): void;
        noSave(): boolean;
        getBlockTint(arg0: BlockPos_, arg1: Internal.ColorResolver_): number;
        getMinSection(): number;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        getNearestPlayer(arg0: Internal.Entity_, arg1: number): Internal.Player;
        getBlockStatesIfLoaded(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        addFreshBlockEntities(arg0: Internal.Collection_<Internal.BlockEntity_>): void;
        getPartEntities(): Internal.Collection<Internal.PartEntity<any>>;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        dimension(): Internal.ResourceKey<Internal.Level>;
        canSeeSky(arg0: BlockPos_): boolean;
        getMoonPhase(): number;
        isUnobstructed(arg0: Internal.Entity_): boolean;
        playLocalSound(arg0: number, arg1: number, arg2: number, arg3: Internal.SoundEvent_, arg4: Internal.SoundSource_, arg5: number, arg6: number, arg7: boolean): void;
        blockEvent(arg0: BlockPos_, arg1: Internal.Block_, arg2: number, arg3: number): void;
        removeBlockEntity(arg0: BlockPos_): void;
        getPlayerByUUID(arg0: Internal.UUID_): Internal.Player;
        isStateAtPosition(arg0: BlockPos_, arg1: Internal.Predicate_<Internal.BlockState_>): boolean;
        getSectionIndexFromSectionY(arg0: number): number;
        getNearbyPlayers(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: Internal.AABB_): Internal.List<Internal.Player>;
        getServer(): Internal.MinecraftServer;
        fillReportDetails(arg0: Internal.CrashReport_): Internal.CrashReportCategory;
        setBlock(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: number): boolean;
        noCollision(arg0: Internal.Entity_): boolean;
        setSkyFlashTime(arg0: number): void;
        getBestNeighborSignal(arg0: BlockPos_): number;
        setBlocksDirty(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: Internal.BlockState_): void;
        getNearbyEntities(arg0: Internal.Class_<T>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: Internal.AABB_): Internal.List<T>;
        getMapData(arg0: string): Internal.MapItemSavedData;
        getMaxEntityRadius(): number;
        noCollision(arg0: Internal.AABB_): boolean;
        getDirectSignal(arg0: BlockPos_, arg1: Internal.Direction_): number;
        getLightEngine(): Internal.LevelLightEngine;
        getGameTime(): number;
        collidesWithSuffocatingBlock(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        noCollision(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getRainLevel(arg0: number): number;
        isOutsideBuildHeight(arg0: number): boolean;
        gameEvent(arg0: Internal.Entity_, arg1: Internal.GameEvent_, arg2: Internal.Entity_): void;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Fluid_, arg2: number, arg3: Internal.TickPriority_): void;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Predicate_<Internal.Entity_>): Internal.Player;
        getNearestEntity(arg0: Internal.Class_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number, arg6: Internal.AABB_): T;
        globalLevelEvent(arg0: number, arg1: BlockPos_, arg2: number): void;
        getChunk(arg0: number, arg1: number, arg2: Internal.ChunkStatus_, arg3: boolean): Internal.ChunkAccess;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_, arg2: Internal.Predicate_<any>): Internal.List<T>;
        sendBlockUpdated(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: Internal.BlockState_, arg3: number): void;
        levelEvent(arg0: number, arg1: BlockPos_, arg2: number): void;
        updateNeighbourForOutputSignal(arg0: BlockPos_, arg1: Internal.Block_): void;
        getChunkForCollisions(arg0: number, arg1: number): Internal.BlockGetter;
        close(): void;
        getEntity(arg0: number): Internal.Entity;
        get maxSection(): number
        get levelData(): Internal.LevelData
        get raining(): boolean
        get clientSide(): boolean
        get thundering(): boolean
        get day(): boolean
        get seaLevel(): number
        get random(): Internal.Random
        get height(): number
        get dayTime(): number
        get difficulty(): Internal.Difficulty
        get sectionsCount(): number
        get freeMapId(): number
        get profiler(): Internal.ProfilerFiller
        get moonBrightness(): number
        get profilerSupplier(): Internal.Supplier<Internal.ProfilerFiller>
        get scoreboard(): Internal.Scoreboard
        get recipeManager(): Internal.RecipeManager
        get maxLightLevel(): number
        set thunderLevel(arg0: number)
        get debug(): boolean
        get night(): boolean
        get biomeManager(): Internal.BiomeManager
        set blockEntity(arg0: Internal.BlockEntity_)
        get skyDarken(): number
        get minBuildHeight(): number
        get maxBuildHeight(): number
        get gameRules(): Internal.GameRules
        get worldBorder(): Internal.WorldBorder
        set rainLevel(arg0: number)
        get minSection(): number
        get partEntities(): Internal.Collection<Internal.PartEntity<any>>
        get moonPhase(): number
        get server(): Internal.MinecraftServer
        set skyFlashTime(arg0: number)
        get maxEntityRadius(): number
        get lightEngine(): Internal.LevelLightEngine
        get gameTime(): number
        readonly static "RESOURCE_KEY_CODEC": any;
        "thunderLevel": number;
        "restoringBlockSnapshots": boolean;
        readonly static "OVERWORLD": Internal.ResourceKey<any>;
        readonly static "MAX_LEVEL_SIZE": 30000000;
        readonly static "MIN_ENTITY_SPAWN_Y": -20000000;
        "oThunderLevel": number;
        readonly static "END": Internal.ResourceKey<any>;
        readonly static "MAX_ENTITY_SPAWN_Y": 20000000;
        "captureBlockSnapshots": boolean;
        readonly static "TICKS_PER_DAY": 24000;
        readonly "random": Internal.Random;
        "oRainLevel": number;
        readonly static "NETHER": Internal.ResourceKey<any>;
        readonly static "LONG_PARTICLE_CLIP_RANGE": 512;
        readonly "isClientSide": boolean;
        readonly static "SHORT_PARTICLE_CLIP_RANGE": 32;
        readonly static "MAX_BRIGHTNESS": 15;
        "rainLevel": number;
        "capturedBlockSnapshots": Internal.ArrayList<Internal.BlockSnapshot>;
    }
    type Level_ = Level;
    class Objective {
        constructor(arg0: Internal.Scoreboard_, arg1: string, arg2: Internal.ObjectiveCriteria_, arg3: Internal.Component_, arg4: Internal.ObjectiveCriteria$RenderType_)
        getDisplayName(): Internal.Component;
        setDisplayName(arg0: Internal.Component_): void;
        getFormattedDisplayName(): Internal.Component;
        getName(): string;
        getRenderType(): Internal.ObjectiveCriteria$RenderType;
        setRenderType(arg0: Internal.ObjectiveCriteria$RenderType_): void;
        getScoreboard(): Internal.Scoreboard;
        getCriteria(): Internal.ObjectiveCriteria;
        get displayName(): Internal.Component
        set displayName(arg0: Internal.Component_)
        get formattedDisplayName(): Internal.Component
        get name(): string
        get renderType(): Internal.ObjectiveCriteria$RenderType
        set renderType(arg0: Internal.ObjectiveCriteria$RenderType_)
        get scoreboard(): Internal.Scoreboard
        get criteria(): Internal.ObjectiveCriteria
    }
    type Objective_ = Objective;
    class ItemModificationProperties {
        constructor(i: Internal.ItemKJS_)
        setFireResistant(b: boolean): void;
        getAttributes(attribute: Internal.Attribute_): Internal.List<Internal.AttributeModifier>;
        setRarity(r: Rarity_): void;
        setArmorProtection(armorProtection: number): void;
        setArmorToughness(armorToughness: number): void;
        setDigSpeed(speed: number): void;
        setBurnTime(i: number): void;
        setMaxStackSize(i: number): void;
        setCraftingRemainder(i: Internal.Item_): void;
        setMaxDamage(i: number): void;
        setAttackSpeed(attackSpeed: number): void;
        addAttribute(attribute: Internal.Attribute_, uuid: Internal.UUID_, name: string, d: number, operation: Internal.AttributeModifier$Operation_): void;
        getDigSpeed(): number;
        setTier(c: Internal.Consumer_<Internal.MutableToolTier_>): void;
        setFoodProperties(consumer: Internal.Consumer_<Internal.FoodBuilder_>): void;
        setAttackDamage(attackDamage: number): void;
        removeAttribute(attribute: Internal.Attribute_, uuid: Internal.UUID_): void;
        setArmorKnockbackResistance(knockbackResistance: number): void;
        set fireResistant(b: boolean)
        set rarity(r: Rarity_)
        set armorProtection(armorProtection: number)
        set armorToughness(armorToughness: number)
        set digSpeed(speed: number)
        set burnTime(i: number)
        set maxStackSize(i: number)
        set craftingRemainder(i: Internal.Item_)
        set maxDamage(i: number)
        set attackSpeed(attackSpeed: number)
        get digSpeed(): number
        set tier(c: Internal.Consumer_<Internal.MutableToolTier_>)
        set foodProperties(consumer: Internal.Consumer_<Internal.FoodBuilder_>)
        set attackDamage(attackDamage: number)
        set armorKnockbackResistance(knockbackResistance: number)
        readonly "item": Internal.ItemKJS;
    }
    type ItemModificationProperties_ = ItemModificationProperties;
    interface Tier {
        getLevel(): number;
        getRepairIngredient(): Internal.Ingredient;
        getAttackDamageBonus(): number;
        getEnchantmentValue(): number;
        getUses(): number;
        getSpeed(): number;
        getTag(): Internal.TagKey<Internal.Block>;
        get level(): number
        get repairIngredient(): Internal.Ingredient
        get attackDamageBonus(): number
        get enchantmentValue(): number
        get uses(): number
        get speed(): number
        get tag(): Internal.TagKey<Internal.Block>
    }
    type Tier_ = Tier;
    class PostPass implements Internal.AutoCloseable {
        constructor(arg0: Internal.ResourceManager_, arg1: string, arg2: Internal.RenderTarget_, arg3: Internal.RenderTarget_)
        process(arg0: number): void;
        getName(): string;
        close(): void;
        getEffect(): Internal.EffectInstance;
        setOrthoMatrix(arg0: Internal.Matrix4f_): void;
        addAuxAsset(arg0: string, arg1: Internal.IntSupplier_, arg2: number, arg3: number): void;
        get name(): string
        get effect(): Internal.EffectInstance
        set orthoMatrix(arg0: Internal.Matrix4f_)
        readonly "outTarget": Internal.RenderTarget;
        readonly "inTarget": Internal.RenderTarget;
    }
    type PostPass_ = PostPass;
    class ClientboundTagQueryPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: Internal.CompoundTag_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getTransactionId(): number;
        getTag(): Internal.CompoundTag;
        isSkippable(): boolean;
        get transactionId(): number
        get tag(): Internal.CompoundTag
        get skippable(): boolean
    }
    type ClientboundTagQueryPacket_ = ClientboundTagQueryPacket;
    class ArgumentTypeWrapper extends Internal.Enum<Internal.ArgumentTypeWrapper> {
        static printAll(): void;
        getResult(context: Internal.CommandContext_<Internal.CommandSourceStack_>, input: string): any;
        create(): Internal.ArgumentType<any>;
        static values(): Internal.ArgumentTypeWrapper[];
        static valueOf(name: string): Internal.ArgumentTypeWrapper;
        static byName(name: ResourceLocation_): Internal.ClassWrapper<any>;
        create(event: Internal.CommandRegistryEventJS_): Internal.ArgumentType<any>;
        readonly static "VEC2": Internal.ArgumentTypeWrapper;
        readonly static "ITEM_PREDICATE": Internal.ArgumentTypeWrapper;
        readonly static "FLOAT_RANGE": Internal.ArgumentTypeWrapper;
        readonly static "ROTATION": Internal.ArgumentTypeWrapper;
        readonly static "NBT_COMPOUND": Internal.ArgumentTypeWrapper;
        readonly static "PLAYER": Internal.ArgumentTypeWrapper;
        readonly static "ITEM_SLOT": Internal.ArgumentTypeWrapper;
        readonly static "INT_RANGE": Internal.ArgumentTypeWrapper;
        readonly static "DIMENSION": Internal.ArgumentTypeWrapper;
        readonly static "VEC3_CENTERED": Internal.ArgumentTypeWrapper;
        readonly static "LONG": Internal.ArgumentTypeWrapper;
        readonly static "GAME_PROFILE": Internal.ArgumentTypeWrapper;
        readonly static "BLOCK_PREDICATE": Internal.ArgumentTypeWrapper;
        readonly static "ENTITY_SUMMON": Internal.ArgumentTypeWrapper;
        readonly static "ITEM_STACK": Internal.ArgumentTypeWrapper;
        readonly static "SWIZZLE": Internal.ArgumentTypeWrapper;
        readonly static "PARTICLE": Internal.ArgumentTypeWrapper;
        readonly static "TIME": Internal.ArgumentTypeWrapper;
        readonly static "MESSAGE": Internal.ArgumentTypeWrapper;
        readonly static "ANGLE": Internal.ArgumentTypeWrapper;
        readonly static "ITEM_ENCHANTMENT": Internal.ArgumentTypeWrapper;
        readonly static "ENTITIES": Internal.ArgumentTypeWrapper;
        readonly static "BLOCK_STATE": Internal.ArgumentTypeWrapper;
        readonly static "FLOAT": Internal.ArgumentTypeWrapper;
        readonly static "WORD": Internal.ArgumentTypeWrapper;
        readonly static "NBT_PATH": Internal.ArgumentTypeWrapper;
        readonly static "PLAYERS": Internal.ArgumentTypeWrapper;
        readonly static "VEC2_CENTERED": Internal.ArgumentTypeWrapper;
        readonly static "COMPONENT": Internal.ArgumentTypeWrapper;
        readonly static "BLOCK_POS": Internal.ArgumentTypeWrapper;
        readonly static "ENTITY_ANCHOR": Internal.ArgumentTypeWrapper;
        readonly static "DOUBLE": Internal.ArgumentTypeWrapper;
        readonly static "INTEGER": Internal.ArgumentTypeWrapper;
        readonly static "MOB_EFFECT": Internal.ArgumentTypeWrapper;
        readonly static "UUID": Internal.ArgumentTypeWrapper;
        readonly static "RESOURCE_LOCATION": Internal.ArgumentTypeWrapper;
        readonly static "VEC3": Internal.ArgumentTypeWrapper;
        readonly static "BLOCK_POS_LOADED": Internal.ArgumentTypeWrapper;
        readonly static "ENTITY": Internal.ArgumentTypeWrapper;
        readonly static "NBT_TAG": Internal.ArgumentTypeWrapper;
        readonly static "STRING": Internal.ArgumentTypeWrapper;
        readonly static "GREEDY_STRING": Internal.ArgumentTypeWrapper;
        readonly static "BOOLEAN": Internal.ArgumentTypeWrapper;
        readonly static "COLUMN_POS": Internal.ArgumentTypeWrapper;
        readonly static "COLOR": Internal.ArgumentTypeWrapper;
    }
    type ArgumentTypeWrapper_ = "nbt_compound" | "player" | "block_predicate" | "int_range" | "particle" | "players" | "uuid" | "angle" | "entities" | "rotation" | "block_state" | "time" | "greedy_string" | "vec2_centered" | "dimension" | "double" | "vec2" | "float_range" | "entity_anchor" | "mob_effect" | ArgumentTypeWrapper | "color" | "component" | "nbt_tag" | "entity_summon" | "message" | "integer" | "item_slot" | "game_profile" | "nbt_path" | "float" | "column_pos" | "swizzle" | "item_enchantment" | "item_predicate" | "item_stack" | "long" | "block_pos" | "resource_location" | "string" | "block_pos_loaded" | "vec3" | "word" | "boolean" | "vec3_centered" | "entity";
    class HitResult$Type extends Internal.Enum<Internal.HitResult$Type> {
        static valueOf(arg0: string): Internal.HitResult$Type;
        static values(): Internal.HitResult$Type[];
        readonly static "MISS": Internal.HitResult$Type;
        readonly static "ENTITY": Internal.HitResult$Type;
        readonly static "BLOCK": Internal.HitResult$Type;
    }
    type HitResult$Type_ = "miss" | "block" | HitResult$Type | "entity";
    abstract class RepeatingPlacement extends Internal.PlacementModifier {
        constructor()
        getPositions(arg0: Internal.PlacementContext_, arg1: Internal.Random_, arg2: BlockPos_): Internal.Stream<BlockPos>;
    }
    type RepeatingPlacement_ = RepeatingPlacement;
    class ClientboundSetBorderLerpSizePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.WorldBorder_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getLerpTime(): number;
        getOldSize(): number;
        getNewSize(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get lerpTime(): number
        get oldSize(): number
        get newSize(): number
        get skippable(): boolean
    }
    type ClientboundSetBorderLerpSizePacket_ = ClientboundSetBorderLerpSizePacket;
    interface ICapabilityProviderImpl <B> extends Internal.ICapabilityProvider {
        areCapsCompatible(arg0: Internal.CapabilityProvider_<B>): boolean;
        invalidateCaps(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        reviveCaps(): void;
    }
    type ICapabilityProviderImpl_<B> = ICapabilityProviderImpl<B>;
    abstract class ImmutableList <E> extends Internal.ImmutableCollection<E> implements Internal.RandomAccess, Internal.List<E> {
        static builder(): Internal.ImmutableList$Builder<E>;
        static of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): Internal.ImmutableList<E>;
        static copyOf(arg0: E[]): Internal.ImmutableList<E>;
        reverse(): this;
        forEach(arg0: Internal.Consumer_<any>): void;
        parallelStream(): Internal.Stream<E>;
        static of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): Internal.ImmutableList<E>;
        static sortedCopyOf(arg0: Internal.Comparator_<any>, arg1: Internal.Iterable_<any>): Internal.ImmutableList<E>;
        static sortedCopyOf(arg0: Internal.Iterable_<any>): Internal.ImmutableList<E>;
        set(arg0: number, arg1: E): E;
        listIterator(arg0: number): Internal.ListIterator<any>;
        static of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E, arg10: E, arg11: E, ...arg12: E[]): Internal.ImmutableList<E>;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        static of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): Internal.ImmutableList<E>;
        static copyOf(arg0: Internal.Iterable_<any>): Internal.ImmutableList<E>;
        static builderWithExpectedSize(arg0: number): Internal.ImmutableList$Builder<E>;
        addAll(arg0: number, arg1: Internal.Collection_<any>): boolean;
        static of(): Internal.ImmutableList<E>;
        remove(arg0: number): E;
        static of(arg0: E): Internal.ImmutableList<E>;
        static copyOf(arg0: Internal.Collection_<any>): Internal.ImmutableList<E>;
        contains(arg0: any): boolean;
        listIterator(): Internal.ListIterator<any>;
        static of(arg0: E, arg1: E, arg2: E, arg3: E): Internal.ImmutableList<E>;
        subList(arg0: number, arg1: number): this;
        static copyOf(arg0: Internal.Iterator_<any>): Internal.ImmutableList<E>;
        replaceAll(arg0: Internal.UnaryOperator_<E>): void;
        static of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): Internal.ImmutableList<E>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: E): void;
        static of(arg0: E, arg1: E, arg2: E): Internal.ImmutableList<E>;
        static of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E, arg10: E): Internal.ImmutableList<E>;
        asList(): this;
        sort(arg0: Internal.Comparator_<any>): void;
        hashCode(): number;
        static of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): Internal.ImmutableList<E>;
        static toImmutableList(): Internal.Collector<E, any, Internal.ImmutableList<E>>;
        stream(): Internal.Stream<E>;
        spliterator(): Internal.Spliterator<E>;
        static of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): Internal.ImmutableList<E>;
        equals(arg0: any): boolean;
        iterator(): Internal.UnmodifiableIterator<E>;
        static of(arg0: E, arg1: E): Internal.ImmutableList<E>;
        lastIndexOf(arg0: any): number;
    }
    type ImmutableList_<E> = ImmutableList<E>;
    class CodingErrorAction {
        toString(): string;
        readonly static "IGNORE": Internal.CodingErrorAction;
        readonly static "REPLACE": Internal.CodingErrorAction;
        readonly static "REPORT": Internal.CodingErrorAction;
    }
    type CodingErrorAction_ = CodingErrorAction;
    class UniformHeight extends Internal.HeightProvider {
        toString(): string;
        static of(arg0: Internal.VerticalAnchor_, arg1: Internal.VerticalAnchor_): Internal.UniformHeight;
        sample(arg0: Internal.Random_, arg1: Internal.WorldGenerationContext_): number;
        getType(): Internal.HeightProviderType<any>;
        get type(): Internal.HeightProviderType<any>
        readonly static "CODEC": any;
    }
    type UniformHeight_ = UniformHeight;
    interface PowerableMob {
        isPowered(): boolean;
        get powered(): boolean
    }
    type PowerableMob_ = PowerableMob;
    class ModelPart$Cube {
        constructor(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number, arg11: boolean, arg12: number, arg13: number)
        compile(arg0: Internal.PoseStack$Pose_, arg1: Internal.VertexConsumer_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        readonly "minY": number;
        readonly "minZ": number;
        readonly "maxX": number;
        readonly "minX": number;
        readonly "maxZ": number;
        readonly "maxY": number;
    }
    type ModelPart$Cube_ = ModelPart$Cube;
    interface ResourceManagerReloadListener extends Internal.PreparableReloadListener {
        getName(): string;
        onResourceManagerReload(arg0: Internal.ResourceManager_): void;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        get name(): string
    }
    type ResourceManagerReloadListener_ = ResourceManagerReloadListener;
    abstract class DoubleBuffer extends Internal.Buffer implements Internal.Comparable<Internal.DoubleBuffer> {
        put(arg0: Internal.DoubleBuffer_): this;
        position(arg0: number): this;
        put(arg0: number, arg1: number[]): this;
        reset(): Internal.Buffer;
        isDirect(): boolean;
        put(arg0: number, arg1: number): this;
        get(arg0: number, arg1: number[]): this;
        arrayOffset(): number;
        duplicate(): this;
        compareTo(arg0: any): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): this;
        flip(): Internal.Buffer;
        clear(): Internal.Buffer;
        order(): Internal.ByteOrder;
        put(arg0: number, arg1: Internal.DoubleBuffer_, arg2: number, arg3: number): this;
        array(): number[];
        get(): number;
        hasArray(): boolean;
        asReadOnlyBuffer(): this;
        get(arg0: number): number;
        static wrap(arg0: number[]): Internal.DoubleBuffer;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.DoubleBuffer;
        compact(): this;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): this;
        static allocate(arg0: number): Internal.DoubleBuffer;
        toString(): string;
        limit(arg0: number): this;
        rewind(): Internal.Buffer;
        mark(): Internal.Buffer;
        hashCode(): number;
        compareTo(arg0: Internal.DoubleBuffer_): number;
        slice(): Internal.Buffer;
        get(arg0: number[]): this;
        slice(arg0: number, arg1: number): Internal.Buffer;
        mismatch(arg0: Internal.DoubleBuffer_): number;
        put(arg0: number): this;
        equals(arg0: any): boolean;
        put(arg0: number[]): this;
        get(arg0: number[], arg1: number, arg2: number): this;
        put(arg0: number[], arg1: number, arg2: number): this;
        get direct(): boolean
    }
    type DoubleBuffer_ = DoubleBuffer;
    class DecimalFormat extends Internal.NumberFormat {
        constructor()
        constructor(arg0: string, arg1: Internal.DecimalFormatSymbols_)
        constructor(arg0: string)
        clone(): any;
        format(arg0: any, arg1: Internal.StringBuffer_, arg2: Internal.FieldPosition_): Internal.StringBuffer;
        setDecimalSeparatorAlwaysShown(arg0: boolean): void;
        parse(arg0: string, arg1: Internal.ParsePosition_): Internal.Number;
        setMaximumIntegerDigits(arg0: number): void;
        isParseBigDecimal(): boolean;
        getPositiveSuffix(): string;
        setNegativeSuffix(arg0: string): void;
        setGroupingUsed(arg0: boolean): void;
        setNegativePrefix(arg0: string): void;
        getGroupingSize(): number;
        formatToCharacterIterator(arg0: any): Internal.AttributedCharacterIterator;
        getMinimumIntegerDigits(): number;
        applyPattern(arg0: string): void;
        setMaximumFractionDigits(arg0: number): void;
        getCurrency(): Internal.Currency;
        applyLocalizedPattern(arg0: string): void;
        setPositiveSuffix(arg0: string): void;
        getMaximumFractionDigits(): number;
        setRoundingMode(arg0: Internal.RoundingMode_): void;
        getDecimalFormatSymbols(): Internal.DecimalFormatSymbols;
        setCurrency(arg0: Internal.Currency_): void;
        isDecimalSeparatorAlwaysShown(): boolean;
        getMaximumIntegerDigits(): number;
        toPattern(): string;
        toLocalizedPattern(): string;
        setPositivePrefix(arg0: string): void;
        setMinimumIntegerDigits(arg0: number): void;
        format(arg0: number, arg1: Internal.StringBuffer_, arg2: Internal.FieldPosition_): Internal.StringBuffer;
        setMultiplier(arg0: number): void;
        getNegativeSuffix(): string;
        setParseBigDecimal(arg0: boolean): void;
        getMultiplier(): number;
        hashCode(): number;
        getMinimumFractionDigits(): number;
        setMinimumFractionDigits(arg0: number): void;
        getNegativePrefix(): string;
        format(arg0: number, arg1: Internal.StringBuffer_, arg2: Internal.FieldPosition_): Internal.StringBuffer;
        equals(arg0: any): boolean;
        setGroupingSize(arg0: number): void;
        getPositivePrefix(): string;
        setDecimalFormatSymbols(arg0: Internal.DecimalFormatSymbols_): void;
        getRoundingMode(): Internal.RoundingMode;
        set decimalSeparatorAlwaysShown(arg0: boolean)
        set maximumIntegerDigits(arg0: number)
        get parseBigDecimal(): boolean
        get positiveSuffix(): string
        set negativeSuffix(arg0: string)
        set groupingUsed(arg0: boolean)
        set negativePrefix(arg0: string)
        get groupingSize(): number
        get minimumIntegerDigits(): number
        set maximumFractionDigits(arg0: number)
        get currency(): Internal.Currency
        set positiveSuffix(arg0: string)
        get maximumFractionDigits(): number
        set roundingMode(arg0: Internal.RoundingMode_)
        get decimalFormatSymbols(): Internal.DecimalFormatSymbols
        set currency(arg0: Internal.Currency_)
        get decimalSeparatorAlwaysShown(): boolean
        get maximumIntegerDigits(): number
        set positivePrefix(arg0: string)
        set minimumIntegerDigits(arg0: number)
        set multiplier(arg0: number)
        get negativeSuffix(): string
        set parseBigDecimal(arg0: boolean)
        get multiplier(): number
        get minimumFractionDigits(): number
        set minimumFractionDigits(arg0: number)
        get negativePrefix(): string
        set groupingSize(arg0: number)
        get positivePrefix(): string
        set decimalFormatSymbols(arg0: Internal.DecimalFormatSymbols_)
        get roundingMode(): Internal.RoundingMode
    }
    type DecimalFormat_ = DecimalFormat;
    class ModelResourceLocation extends ResourceLocation {
        constructor(arg0: string, arg1: string, arg2: string)
        constructor(arg0: ResourceLocation_, arg1: string)
        constructor(arg0: string, arg1: string)
        constructor(arg0: string)
        hashCode(): number;
        toString(): string;
        getVariant(): string;
        equals(arg0: any): boolean;
        get variant(): string
    }
    type ModelResourceLocation_ = ModelResourceLocation;
    class TwoLayersFeatureSize extends Internal.FeatureSize {
        constructor(arg0: number, arg1: number, arg2: number)
        constructor(arg0: number, arg1: number, arg2: number, arg3: Internal.OptionalInt_)
        getSizeAtHeight(arg0: number, arg1: number): number;
        readonly static "CODEC": any;
    }
    type TwoLayersFeatureSize_ = TwoLayersFeatureSize;
    class ConfiguredFeature <FC, F> extends Internal.Record {
        constructor(arg0: F, arg1: FC)
        config(): FC;
        hashCode(): number;
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        toString(): string;
        place(arg0: Internal.WorldGenLevel_, arg1: Internal.ChunkGenerator_, arg2: Internal.Random_, arg3: BlockPos_): boolean;
        feature(): F;
        equals(arg0: any): boolean;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
        readonly static "LIST_CODEC": any;
        readonly static "DIRECT_CODEC": any;
    }
    type ConfiguredFeature_<FC, F> = Special.ConfiguredFeature | ConfiguredFeature<FC, F>;
    class RegistryObjectBuilderTypes$RegistryEventJS <T> extends Internal.StartupEventJS {
        create(id: string): Internal.BuilderBase<any>;
        create(id: string, type: string): Internal.BuilderBase<any>;
    }
    type RegistryObjectBuilderTypes$RegistryEventJS_<T> = RegistryObjectBuilderTypes$RegistryEventJS<T>;
    class JigsawReplacementProcessor extends Internal.StructureProcessor {
        processBlock(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.StructureTemplate$StructureBlockInfo_, arg4: Internal.StructureTemplate$StructureBlockInfo_, arg5: Internal.StructurePlaceSettings_): Internal.StructureTemplate$StructureBlockInfo;
        readonly static "INSTANCE": Internal.JigsawReplacementProcessor;
        readonly static "CODEC": any;
    }
    type JigsawReplacementProcessor_ = JigsawReplacementProcessor;
    class Parrot extends Internal.ShoulderRidingEntity implements Internal.FlyingAnimal {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        isPartyParrot(): boolean;
        canMate(arg0: Internal.Animal_): boolean;
        setVariant(arg0: number): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        getVariant(): number;
        isFood(arg0: Internal.ItemStack_): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        getSoundSource(): Internal.SoundSource;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        static getAmbient(arg0: Internal.Level_, arg1: Internal.Random_): Internal.SoundEvent;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getAmbientSound(): Internal.SoundEvent;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        static checkParrotSpawnRules(arg0: Internal.EntityType_<Internal.Parrot_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isBaby(): boolean;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        getVoicePitch(): number;
        static imitateNearbyMobs(arg0: Internal.Level_, arg1: Internal.Entity_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        static getPitch(arg0: Internal.Random_): number;
        getLeashOffset(): Vec3;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getClassification(arg0: boolean): Internal.MobCategory;
        isPushable(): boolean;
        setRecordPlayingNearby(arg0: BlockPos_, arg1: boolean): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        isFlying(): boolean;
        get partyParrot(): boolean
        set variant(arg0: number)
        get stepHeight(): number
        get variant(): number
        get soundSource(): Internal.SoundSource
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get ambientSound(): Internal.SoundEvent
        get baby(): boolean
        get voicePitch(): number
        get leashOffset(): Vec3
        get pushable(): boolean
        get flying(): boolean
        "flapSpeed": number;
        "flap": number;
        "oFlapSpeed": number;
        "oFlap": number;
    }
    type Parrot_ = Parrot;
    class ParseResults <S> {
        constructor(arg0: Internal.CommandContextBuilder_<S>, arg1: Internal.ImmutableStringReader_, arg2: Internal.Map_<Internal.CommandNode_<S>, Internal.CommandSyntaxException_>)
        constructor(arg0: Internal.CommandContextBuilder_<S>)
        getContext(): Internal.CommandContextBuilder<S>;
        getReader(): Internal.ImmutableStringReader;
        getExceptions(): Internal.Map<Internal.CommandNode<S>, Internal.CommandSyntaxException>;
        get context(): Internal.CommandContextBuilder<S>
        get reader(): Internal.ImmutableStringReader
        get exceptions(): Internal.Map<Internal.CommandNode<S>, Internal.CommandSyntaxException>
    }
    type ParseResults_<S> = ParseResults<S>;
    class MinecraftServer$ReloadableResources extends Internal.Record implements Internal.AutoCloseable {
        constructor(resourceManager: Internal.CloseableResourceManager_, managers: Internal.ReloadableServerResources_)
        hashCode(): number;
        toString(): string;
        resourceManager(): Internal.CloseableResourceManager;
        close(): void;
        equals(arg0: any): boolean;
        managers(): Internal.ReloadableServerResources;
    }
    type MinecraftServer$ReloadableResources_ = MinecraftServer$ReloadableResources;
    class ItemTransforms$TransformType extends Internal.Enum<Internal.ItemTransforms$TransformType> implements Internal.IExtensibleEnum {
        static values(): Internal.ItemTransforms$TransformType[];
        getSerializeName(): string;
        fallback(): this;
        firstPerson(): boolean;
        init(): void;
        static create(arg0: string, arg1: ResourceLocation_): Internal.ItemTransforms$TransformType;
        static valueOf(arg0: string): Internal.ItemTransforms$TransformType;
        isModded(): boolean;
        static create(arg0: string, arg1: ResourceLocation_, arg2: Internal.ItemTransforms$TransformType_): Internal.ItemTransforms$TransformType;
        get serializeName(): string
        get modded(): boolean
        readonly static "THIRD_PERSON_LEFT_HAND": Internal.ItemTransforms$TransformType;
        readonly static "FIXED": Internal.ItemTransforms$TransformType;
        readonly static "THIRD_PERSON_RIGHT_HAND": Internal.ItemTransforms$TransformType;
        readonly static "HEAD": Internal.ItemTransforms$TransformType;
        readonly static "NONE": Internal.ItemTransforms$TransformType;
        readonly static "GROUND": Internal.ItemTransforms$TransformType;
        readonly static "GUI": Internal.ItemTransforms$TransformType;
        readonly static "FIRST_PERSON_LEFT_HAND": Internal.ItemTransforms$TransformType;
        readonly static "FIRST_PERSON_RIGHT_HAND": Internal.ItemTransforms$TransformType;
    }
    type ItemTransforms$TransformType_ = "fixed" | "first_person_right_hand" | "gui" | "third_person_left_hand" | ItemTransforms$TransformType | "ground" | "head" | "none" | "third_person_right_hand" | "first_person_left_hand";
    class Salmon extends Internal.AbstractSchoolingFish {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getBucketItemStack(): Internal.ItemStack;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getMaxSchoolSize(): number;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get bucketItemStack(): Internal.ItemStack
        get stepHeight(): number
        get multipartEntity(): boolean
        get maxSchoolSize(): number
        get parts(): Internal.PartEntity<any>[]
    }
    type Salmon_ = Salmon;
    interface RepositorySource {
        loadPacks(arg0: Internal.Consumer_<Internal.Pack_>, arg1: Internal.Pack$PackConstructor_): void;
    }
    type RepositorySource_ = RepositorySource;
    interface GameProfileRepository {
        findProfilesByNames(arg0: string[], arg1: Internal.Agent_, arg2: Internal.ProfileLookupCallback_): void;
    }
    type GameProfileRepository_ = GameProfileRepository;
    class FileChannel$MapMode {
        toString(): string;
        readonly static "PRIVATE": Internal.FileChannel$MapMode;
        readonly static "READ_ONLY": Internal.FileChannel$MapMode;
        readonly static "READ_WRITE": Internal.FileChannel$MapMode;
    }
    type FileChannel$MapMode_ = FileChannel$MapMode;
    class WeightedEntry$Wrapper <T> implements Internal.WeightedEntry {
        static codec(arg0: Internal.Codec_<E>): Internal.Codec<Internal.WeightedEntry$Wrapper<E>>;
        getWeight(): Internal.Weight;
        getData(): T;
        get weight(): Internal.Weight
        get data(): T
    }
    type WeightedEntry$Wrapper_<T> = WeightedEntry$Wrapper<T>;
    class RootCommandNode <S> extends Internal.CommandNode<S> {
        constructor()
        isValidInput(arg0: string): boolean;
        getExamples(): Internal.Collection<string>;
        toString(): string;
        parse(arg0: Internal.StringReader_, arg1: Internal.CommandContextBuilder_<S>): void;
        getName(): string;
        createBuilder(): Internal.ArgumentBuilder<S, any>;
        listSuggestions(arg0: Internal.CommandContext_<S>, arg1: Internal.SuggestionsBuilder_): Internal.CompletableFuture<Internal.Suggestions>;
        getUsageText(): string;
        equals(arg0: any): boolean;
        get examples(): Internal.Collection<string>
        get name(): string
        get usageText(): string
    }
    type RootCommandNode_<S> = RootCommandNode<S>;
    class EventsJS {
        constructor(t: Internal.ScriptManager_)
        listen(id: string, handler: Internal.IEventHandler_): void;
        clear(): void;
        postToHandlers(id: string, list: Internal.List_<Internal.EventsJS$ScriptEventHandler_>, event: Internal.EventJS_): boolean;
        handlers(id: string): Internal.List<Internal.EventsJS$ScriptEventHandler>;
        readonly "scriptManager": Internal.ScriptManager;
    }
    type EventsJS_ = EventsJS;
    abstract class ForgeRegistryEntry <V> implements Internal.IForgeRegistryEntry<V> {
        constructor()
        setRegistryName(arg0: string): V;
        getRegistryType(): Internal.Class<V>;
        setRegistryName(arg0: ResourceLocation_): any;
        setRegistryName(arg0: string, arg1: string): V;
        getRegistryName(): ResourceLocation;
        set registryName(arg0: string)
        get registryType(): Internal.Class<V>
        set registryName(arg0: ResourceLocation_)
        get registryName(): ResourceLocation
        readonly "delegate": Internal.IRegistryDelegate<V>;
    }
    type ForgeRegistryEntry_<V> = ForgeRegistryEntry<V>;
    class NumberFormat$Style extends Internal.Enum<Internal.NumberFormat$Style> {
        static values(): Internal.NumberFormat$Style[];
        static valueOf(arg0: string): Internal.NumberFormat$Style;
        readonly static "LONG": Internal.NumberFormat$Style;
        readonly static "SHORT": Internal.NumberFormat$Style;
    }
    type NumberFormat$Style_ = NumberFormat$Style | "short" | "long";
    class FogType extends Internal.Enum<Internal.FogType> {
        static values(): Internal.FogType[];
        static valueOf(arg0: string): Internal.FogType;
        readonly static "LAVA": Internal.FogType;
        readonly static "POWDER_SNOW": Internal.FogType;
        readonly static "WATER": Internal.FogType;
        readonly static "NONE": Internal.FogType;
    }
    type FogType_ = "powder_snow" | "lava" | FogType | "water" | "none";
    interface Scriptable extends Internal.IdEnumerationIterator {
        getParentScope(): this;
        hasInstance(arg0: Internal.Scriptable_): boolean;
        delete(arg0: string): void;
        put(arg0: number, arg1: Internal.Scriptable_, arg2: any): void;
        getClassName(): string;
        getDefaultValue(arg0: Internal.Class_<any>): any;
        has(arg0: string, arg1: Internal.Scriptable_): boolean;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getAllIds(): any[];
        setParentScope(arg0: Internal.Scriptable_): void;
        get(arg0: string, arg1: Internal.Scriptable_): any;
        get(arg0: number, arg1: Internal.Scriptable_): any;
        getIds(): any[];
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        has(arg0: number, arg1: Internal.Scriptable_): boolean;
        getPrototype(): this;
        delete(arg0: number): void;
        setPrototype(arg0: Internal.Scriptable_): void;
        getTypeOf(): Internal.MemberType;
        put(arg0: string, arg1: Internal.Scriptable_, arg2: any): void;
        get parentScope(): Internal.Scriptable
        get className(): string
        get allIds(): any[]
        set parentScope(arg0: Internal.Scriptable_)
        get ids(): any[]
        get prototype(): Internal.Scriptable
        set prototype(arg0: Internal.Scriptable_)
        get typeOf(): Internal.MemberType
        readonly static "NOT_FOUND": any;
    }
    type Scriptable_ = Scriptable;
    class GenericLootEventJS extends Internal.LootEventJS {
        constructor(c: Internal.Map_<ResourceLocation_, Internal.JsonElement_>)
        getType(): string;
        addGeneric(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        getDirectory(): string;
        get type(): string
        get directory(): string
    }
    type GenericLootEventJS_ = GenericLootEventJS;
    interface MapDecoder <A> extends Internal.Keyable {
        flatMap(arg0: Internal.Function_<any, any>): Internal.MapDecoder<B>;
        withLifecycle(arg0: Internal.Lifecycle_): this;
        decode(arg0: Internal.DynamicOps_<T>, arg1: Internal.MapLike_<T>): Internal.DataResult<A>;
        compressor(arg0: Internal.DynamicOps_<T>): Internal.KeyCompressor<T>;
        map(arg0: Internal.Function_<any, any>): Internal.MapDecoder<B>;
        ap(arg0: Internal.MapDecoder_<Internal.Function_<any, any>>): Internal.MapDecoder<E>;
        compressedDecode(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<A>;
        decoder(): Internal.Decoder<A>;
    }
    type MapDecoder_<A> = MapDecoder<A>;
    class ContainerScreenEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.AbstractContainerScreen_<any>)
        getContainerScreen(): Internal.AbstractContainerScreen<any>;
        getListenerList(): Internal.ListenerList;
        get containerScreen(): Internal.AbstractContainerScreen<any>
        get listenerList(): Internal.ListenerList
    }
    type ContainerScreenEvent_ = ContainerScreenEvent;
    class Exception extends Internal.Throwable {
        constructor()
        constructor(arg0: string, arg1: Internal.Throwable_)
        constructor(arg0: Internal.Throwable_)
        constructor(arg0: string)
    }
    type Exception_ = Exception;
    interface IGenericEvent <T> {
        getGenericType(): Internal.Type;
        get genericType(): Internal.Type
    }
    type IGenericEvent_<T> = IGenericEvent<T>;
    class NarrationThunk <T> {
        hashCode(): number;
        getText(arg0: Internal.Consumer_<string>): void;
        static from(arg0: string): Internal.NarrationThunk<any>;
        static from(arg0: Internal.Component_): Internal.NarrationThunk<any>;
        equals(arg0: any): boolean;
        static from(arg0: Internal.List_<Internal.Component_>): Internal.NarrationThunk<any>;
        readonly static "EMPTY": Internal.NarrationThunk<any>;
    }
    type NarrationThunk_<T> = NarrationThunk<T>;
    class JsonArray extends Internal.JsonElement implements Internal.Iterable<Internal.JsonElement> {
        constructor()
        constructor(arg0: number)
        iterator(): Internal.Iterator<Internal.JsonElement>;
        getAsBigDecimal(): Internal.BigDecimal;
        spliterator(): Internal.Spliterator<Internal.JsonElement>;
        forEach(arg0: Internal.Consumer_<any>): void;
        add(arg0: Internal.Number_): void;
        isEmpty(): boolean;
        contains(arg0: Internal.JsonElement_): boolean;
        getAsFloat(): number;
        getAsLong(): number;
        remove(arg0: Internal.JsonElement_): boolean;
        getAsBoolean(): boolean;
        add(arg0: Internal.JsonElement_): void;
        remove(arg0: number): Internal.JsonElement;
        add(arg0: string): void;
        getAsBigInteger(): Internal.BigInteger;
        set(arg0: number, arg1: Internal.JsonElement_): Internal.JsonElement;
        getAsDouble(): number;
        getAsCharacter(): string;
        getAsString(): string;
        getAsInt(): number;
        hashCode(): number;
        size(): number;
        getAsByte(): number;
        getAsNumber(): Internal.Number;
        addAll(arg0: Internal.JsonArray_): void;
        get(arg0: number): Internal.JsonElement;
        add(arg0: string): void;
        getAsShort(): number;
        equals(arg0: any): boolean;
        add(arg0: boolean): void;
        deepCopy(): this;
        get asBigDecimal(): Internal.BigDecimal
        get empty(): boolean
        get asFloat(): number
        get asLong(): number
        get asBoolean(): boolean
        get asBigInteger(): Internal.BigInteger
        get asDouble(): number
        get asCharacter(): string
        get asString(): string
        get asInt(): number
        get asByte(): number
        get asNumber(): Internal.Number
        get asShort(): number
    }
    type JsonArray_ = JsonArray;
    interface PropertyChangeListener extends Internal.EventListener {
        propertyChange(arg0: Internal.PropertyChangeEvent_): void;
    }
    type PropertyChangeListener_ = PropertyChangeListener;
    interface IForgeAdvancementBuilder {
        save(arg0: Internal.Consumer_<Internal.Advancement_>, arg1: ResourceLocation_, arg2: Internal.ExistingFileHelper_): Internal.Advancement;
    }
    type IForgeAdvancementBuilder_ = IForgeAdvancementBuilder;
    interface ProgressivePromise <V> extends Internal.Promise<V>, Internal.ProgressiveFuture<V> {
        addListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        await(): this;
        addListener(arg0: Internal.GenericFutureListener_<any>): this;
        setProgress(arg0: number, arg1: number): this;
        sync(): this;
        setSuccess(arg0: V): this;
        setFailure(arg0: Internal.Throwable_): this;
        awaitUninterruptibly(): this;
        tryProgress(arg0: number, arg1: number): boolean;
        syncUninterruptibly(): this;
        removeListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        removeListener(arg0: Internal.GenericFutureListener_<any>): this;
        set success(arg0: V)
        set failure(arg0: Internal.Throwable_)
    }
    type ProgressivePromise_<V> = ProgressivePromise<V>;
    interface MenuProvider extends Internal.MenuConstructor {
        getDisplayName(): Internal.Component;
        get displayName(): Internal.Component
    }
    type MenuProvider_ = MenuProvider | (()=>Internal.Component_);
    class ShapedRecipe implements Internal.CraftingRecipe, Internal.IShapedRecipe<Internal.CraftingContainer> {
        constructor(arg0: ResourceLocation_, arg1: string, arg2: number, arg3: number, arg4: Internal.NonNullList_<Internal.Ingredient_>, arg5: Internal.ItemStack_)
        static keyFromJson(arg0: Internal.JsonObject_): Internal.Map<string, Internal.Ingredient>;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getToastSymbol(): Internal.ItemStack;
        matches(arg0: Internal.CraftingContainer_, arg1: Internal.Level_): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        getSerializer(): Internal.RecipeSerializer<any>;
        getId(): ResourceLocation;
        assemble(arg0: Internal.CraftingContainer_): Internal.ItemStack;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getHeight(): number;
        getResultItem(): Internal.ItemStack;
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        isSpecial(): boolean;
        getType(): Internal.RecipeType<any>;
        getWidth(): number;
        getRecipeWidth(): number;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        static setCraftingSize(arg0: number, arg1: number): void;
        static itemStackFromJson(arg0: Internal.JsonObject_): Internal.ItemStack;
        static patternFromJson(arg0: Internal.JsonArray_): string[];
        static dissolvePattern(arg0: string[], arg1: Internal.Map_<string, Internal.Ingredient_>, arg2: number, arg3: number): Internal.NonNullList<Internal.Ingredient>;
        static shrink(...arg0: string[]): string[];
        static itemFromJson(arg0: Internal.JsonObject_): Internal.Item;
        getRecipeHeight(): number;
        isIncomplete(): boolean;
        matches(arg0: Internal.CraftingContainer_, arg1: number, arg2: number, arg3: boolean): boolean;
        get group(): string
        get toastSymbol(): Internal.ItemStack
        get serializer(): Internal.RecipeSerializer<any>
        get id(): ResourceLocation
        get height(): number
        get resultItem(): Internal.ItemStack
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get special(): boolean
        get type(): Internal.RecipeType<any>
        get width(): number
        get recipeWidth(): number
        get recipeHeight(): number
        get incomplete(): boolean
        readonly "width": number;
        readonly "height": number;
    }
    type ShapedRecipe_ = ShapedRecipe;
    class FeatureSizeType <P> {
        codec(): Internal.Codec<P>;
        readonly static "THREE_LAYERS_FEATURE_SIZE": Internal.FeatureSizeType<any>;
        readonly static "TWO_LAYERS_FEATURE_SIZE": Internal.FeatureSizeType<any>;
    }
    type FeatureSizeType_<P> = FeatureSizeType<P> | Special.FeatureSizeType;
    interface AnnotatedElement {
        getAnnotationsByType(arg0: Internal.Class_<T>): T[];
        getDeclaredAnnotation(arg0: Internal.Class_<T>): T;
        getDeclaredAnnotationsByType(arg0: Internal.Class_<T>): T[];
        getAnnotation(arg0: Internal.Class_<T>): T;
        getAnnotations(): Internal.Annotation[];
        isAnnotationPresent(arg0: Internal.Class_<any>): boolean;
        getDeclaredAnnotations(): Internal.Annotation[];
        get annotations(): Internal.Annotation[]
        get declaredAnnotations(): Internal.Annotation[]
    }
    type AnnotatedElement_ = AnnotatedElement;
    class MineshaftConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: number, arg1: Internal.MineshaftFeature$Type_)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
        readonly "probability": number;
        readonly "type": Internal.MineshaftFeature$Type;
    }
    type MineshaftConfiguration_ = MineshaftConfiguration;
    class BlockEntityPredicate implements Internal.BlockPredicate {
        constructor(i: ResourceLocation_)
        data(cd: Internal.BlockEntityPredicateDataCheck_): this;
        toString(): string;
        check(block: Internal.BlockContainerJS_): boolean;
    }
    type BlockEntityPredicate_ = BlockEntityPredicate;
    interface Callable <V> {
        call(): V;
    }
    type Callable_<V> = (()=>V) | Callable<V>;
    class ArrayList <E> extends Internal.AbstractList<E> implements Internal.RandomAccess, Internal.Cloneable, Internal.List<E>, Internal.Serializable {
        constructor()
        constructor(arg0: Internal.Collection_<any>)
        constructor(arg0: number)
        clone(): any;
        get(arg0: number): E;
        add(arg0: E): boolean;
        listIterator(): Internal.ListIterator<E>;
        forEach(arg0: Internal.Consumer_<any>): void;
        parallelStream(): Internal.Stream<E>;
        isEmpty(): boolean;
        set(arg0: number, arg1: E): E;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        addAll(arg0: Internal.Collection_<any>): boolean;
        addAll(arg0: number, arg1: Internal.Collection_<any>): boolean;
        remove(arg0: number): E;
        contains(arg0: any): boolean;
        replaceAll(arg0: Internal.UnaryOperator_<E>): void;
        subList(arg0: number, arg1: number): Internal.List<E>;
        indexOf(arg0: any): number;
        trimToSize(): void;
        add(arg0: number, arg1: E): void;
        toArray(arg0: T[]): T[];
        remove(arg0: any): boolean;
        toArray(): any[];
        sort(arg0: Internal.Comparator_<any>): void;
        listIterator(arg0: number): Internal.ListIterator<E>;
        iterator(): Internal.Iterator<E>;
        size(): number;
        hashCode(): number;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        stream(): Internal.Stream<E>;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        ensureCapacity(arg0: number): void;
        clear(): void;
        spliterator(): Internal.Spliterator<E>;
        equals(arg0: any): boolean;
        lastIndexOf(arg0: any): number;
        get empty(): boolean
    }
    type ArrayList_<E> = ArrayList<E>;
    class SoundBuffer {
        constructor(arg0: Internal.ByteBuffer_, arg1: Internal.AudioFormat_)
        discardAlBuffer(): void;
        releaseAlBuffer(): Internal.OptionalInt;
    }
    type SoundBuffer_ = SoundBuffer;
    class ResolvedModule {
        name(): string;
        hashCode(): number;
        toString(): string;
        configuration(): Internal.Configuration;
        reads(): Internal.Set<Internal.ResolvedModule>;
        equals(arg0: any): boolean;
        reference(): Internal.ModuleReference;
    }
    type ResolvedModule_ = ResolvedModule;
    class Rotations {
        constructor(arg0: Internal.ListTag_)
        constructor(arg0: number, arg1: number, arg2: number)
        getX(): number;
        getWrappedZ(): number;
        getWrappedY(): number;
        getZ(): number;
        getWrappedX(): number;
        getY(): number;
        save(): Internal.ListTag;
        equals(arg0: any): boolean;
        get x(): number
        get wrappedZ(): number
        get wrappedY(): number
        get z(): number
        get wrappedX(): number
        get y(): number
    }
    type Rotations_ = Rotations;
    interface IntIterable extends Internal.Iterable<number> {
        iterator(): Internal.Iterator<any>;
        spliterator(): Internal.Spliterator<any>;
        forEach(arg0: it.unimi.dsi.fastutil.ints.IntConsumer_): void;
        forEach(arg0: Internal.Consumer_<any>): void;
        forEach(arg0: Internal.IntConsumer_): void;
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
    }
    type IntIterable_ = IntIterable;
    class FluidBlockBuilder extends Internal.BlockBuilder {
        constructor(b: Internal.FluidBuilder_)
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        createObject(): any;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
    }
    type FluidBlockBuilder_ = FluidBlockBuilder;
    interface SpectatorMenuListener {
        onSpectatorMenuClosed(arg0: Internal.SpectatorMenu_): void;
    }
    type SpectatorMenuListener_ = SpectatorMenuListener;
    interface TickContainerAccess <T> extends Internal.TickAccess<T> {
    }
    type TickContainerAccess_<T> = TickContainerAccess<T>;
    interface ExistingFileHelper$IResourceType {
        getPrefix(): string;
        getPackType(): Internal.PackType;
        getSuffix(): string;
        get prefix(): string
        get packType(): Internal.PackType
        get suffix(): string
    }
    type ExistingFileHelper$IResourceType_ = ExistingFileHelper$IResourceType;
    class Painting extends Internal.HangingEntity {
        constructor(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Direction_, arg3: Internal.Motive_)
        constructor(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Direction_)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        moveTo(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        getWidth(): number;
        dropItem(arg0: Internal.Entity_): void;
        lerpTo(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: boolean): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        playPlacementSound(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getAddEntityPacket(): Internal.Packet<any>;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getPickResult(): Internal.ItemStack;
        shouldRiderSit(): boolean;
        getHeight(): number;
        getParts(): Internal.PartEntity<any>[];
        get width(): number
        get stepHeight(): number
        get addEntityPacket(): Internal.Packet<any>
        get multipartEntity(): boolean
        get pickResult(): Internal.ItemStack
        get height(): number
        get parts(): Internal.PartEntity<any>[]
        "motive": Internal.Motive;
    }
    type Painting_ = Painting;
    interface GeneratedClassLoader {
        linkClass(arg0: Internal.Class_<any>): void;
        defineClass(arg0: string, arg1: number[]): Internal.Class<any>;
    }
    type GeneratedClassLoader_ = GeneratedClassLoader;
    class NoiseColumn implements Internal.BlockColumn {
        constructor(arg0: number, arg1: Internal.BlockState_[])
        getBlock(arg0: number): Internal.BlockState;
        setBlock(arg0: number, arg1: Internal.BlockState_): void;
    }
    type NoiseColumn_ = NoiseColumn;
    interface Boolean2ReferenceFunction <V> extends it.unimi.dsi.fastutil.Function<boolean, V> {
        put(arg0: boolean, arg1: V): V;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Boolean2IntFunction;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2ReferenceFunction<V>;
        getOrDefault(arg0: any, arg1: V): V;
        andThenObject(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Boolean2ObjectFunction<T>;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Boolean2FloatFunction;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2ReferenceFunction<V>;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2ReferenceFunction<V>;
        containsKey(arg0: any): boolean;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2ReferenceFunction<V>;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2ReferenceFunction<V>;
        put(arg0: boolean, arg1: V): V;
        get(arg0: any): V;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Boolean2ShortFunction;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): V;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Boolean2DoubleFunction;
        composeReference(arg0: Internal.Reference2BooleanFunction_<any>): Internal.Reference2ReferenceFunction<T, V>;
        andThenReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Boolean2ReferenceFunction<T>;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Boolean2CharFunction;
        apply(arg0: boolean): V;
        get(arg0: boolean): V;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2ReferenceFunction<V>;
        containsKey(arg0: boolean): boolean;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<boolean, V>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        remove(arg0: boolean): V;
        size(): number;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Boolean2LongFunction;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Boolean2ByteFunction;
        clear(): void;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2ReferenceFunction<V>;
        composeObject(arg0: Internal.Object2BooleanFunction_<any>): Internal.Object2ReferenceFunction<T, V>;
        defaultReturnValue(): V;
        getOrDefault(arg0: boolean, arg1: V): V;
        defaultReturnValue(arg0: V): void;
    }
    type Boolean2ReferenceFunction_<V> = ((arg0: boolean)=>V) | Boolean2ReferenceFunction<V>;
    class ChunkPos {
        constructor(arg0: BlockPos_)
        constructor(arg0: number, arg1: number)
        constructor(arg0: number)
        getWorldPosition(): BlockPos;
        static getX(arg0: number): number;
        getMinBlockZ(): number;
        static getZ(arg0: number): number;
        getMinBlockX(): number;
        getRegionLocalX(): number;
        getMaxBlockX(): number;
        getMaxBlockZ(): number;
        getMiddleBlockX(): number;
        getMiddleBlockZ(): number;
        getRegionLocalZ(): number;
        getBlockAt(arg0: number, arg1: number, arg2: number): BlockPos;
        static rangeClosed(arg0: Internal.ChunkPos_, arg1: number): Internal.Stream<Internal.ChunkPos>;
        getRegionZ(): number;
        toString(): string;
        getChessboardDistance(arg0: Internal.ChunkPos_): number;
        getRegionX(): number;
        static asLong(arg0: number, arg1: number): number;
        getMiddleBlockPosition(arg0: number): BlockPos;
        hashCode(): number;
        getBlockX(arg0: number): number;
        static asLong(arg0: BlockPos_): number;
        getBlockZ(arg0: number): number;
        static rangeClosed(arg0: Internal.ChunkPos_, arg1: Internal.ChunkPos_): Internal.Stream<Internal.ChunkPos>;
        equals(arg0: any): boolean;
        toLong(): number;
        get worldPosition(): BlockPos
        get minBlockZ(): number
        get minBlockX(): number
        get regionLocalX(): number
        get maxBlockX(): number
        get maxBlockZ(): number
        get middleBlockX(): number
        get middleBlockZ(): number
        get regionLocalZ(): number
        get regionZ(): number
        get regionX(): number
        readonly static "ZERO": Internal.ChunkPos;
        readonly "z": number;
        readonly static "INVALID_CHUNK_POS": 8053347149716602;
        readonly "x": number;
    }
    type ChunkPos_ = ChunkPos;
    class RangeConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.HeightProvider_)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
        readonly "height": Internal.HeightProvider;
    }
    type RangeConfiguration_ = RangeConfiguration;
    class SearchRegistry implements Internal.ResourceManagerReloadListener {
        constructor()
        register(arg0: Internal.SearchRegistry$Key_<T>, arg1: Internal.MutableSearchTree_<T>): void;
        getName(): string;
        onResourceManagerReload(arg0: Internal.ResourceManager_): void;
        getTree(arg0: Internal.SearchRegistry$Key_<T>): Internal.MutableSearchTree<T>;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        get name(): string
        readonly static "CREATIVE_TAGS": Internal.SearchRegistry$Key<any>;
        readonly static "RECIPE_COLLECTIONS": Internal.SearchRegistry$Key<any>;
        readonly static "CREATIVE_NAMES": Internal.SearchRegistry$Key<any>;
    }
    type SearchRegistry_ = SearchRegistry;
    interface Object2IntMap <K> extends Internal.Map<K, number>, Internal.Object2IntFunction<K> {
        containsValue(arg0: any): boolean;
        defaultReturnValue(): number;
        removeInt(arg0: any): number;
        mergeInt(arg0: K, arg1: number, arg2: Internal.BiFunction_<any, any, any>): number;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2IntFunction;
        apply(arg0: K): number;
        computeIntIfPresent(arg0: K, arg1: Internal.BiFunction_<any, any, any>): number;
        values(): Internal.IntCollection;
        keySet(): Internal.Set<any>;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2IntFunction;
        putIfAbsent(arg0: K, arg1: number): number;
        replace(arg0: any, arg1: any, arg2: any): boolean;
        put(arg0: any, arg1: any): any;
        computeIntIfAbsent(arg0: K, arg1: Internal.ToIntFunction_<any>): number;
        computeIfAbsent(arg0: K, arg1: Internal.Object2IntFunction_<any>): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        replace(arg0: K, arg1: number, arg2: number): boolean;
        composeReference(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Reference2IntFunction<T>;
        andThenInt(arg0: Internal.Int2IntFunction_): Internal.Object2IntFunction<K>;
        computeInt(arg0: K, arg1: Internal.BiFunction_<any, any, any>): number;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2IntFunction;
        getOrDefault(arg0: any, arg1: number): number;
        computeIfAbsent(arg0: K, arg1: Internal.Function_<any, any>): number;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        replace(arg0: K, arg1: number): number;
        applyAsInt(arg0: K): number;
        computeIfAbsent(arg0: K, arg1: Internal.ToIntFunction_<any>): number;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Object2ByteFunction<K>;
        getOrDefault(arg0: any, arg1: number): number;
        remove(arg0: any): any;
        putIfAbsent(arg0: any, arg1: any): any;
        put(arg0: K, arg1: number): number;
        merge(arg0: K, arg1: number, arg2: Internal.BiFunction_<any, any, any>): number;
        andThenReference(arg0: Internal.Int2ReferenceFunction_<any>): Internal.Object2ReferenceFunction<K, T>;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Object2FloatFunction<K>;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Object2LongFunction<K>;
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        mergeInt(arg0: K, arg1: number, arg2: Internal.IntBinaryOperator_): number;
        replace(arg0: K, arg1: number): number;
        compute(arg0: K, arg1: Internal.BiFunction_<any, any, any>): number;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Object2ShortFunction<K>;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<any, any, any>): number;
        containsKey(arg0: any): boolean;
        replaceAll(arg0: Internal.BiFunction_<any, any, any>): void;
        computeIntIfAbsentPartial(arg0: K, arg1: Internal.Object2IntFunction_<any>): number;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<K, number>>;
        containsValue(arg0: number): boolean;
        replace(arg0: K, arg1: number, arg2: number): boolean;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        remove(arg0: any, arg1: number): boolean;
        put(arg0: K, arg1: number): number;
        composeObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Object2IntFunction<T>;
        remove(arg0: any, arg1: any): boolean;
        merge(arg0: K, arg1: number, arg2: Internal.BiFunction_<any, any, any>): number;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2IntFunction;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2IntFunction;
        mergeInt(arg0: K, arg1: number, arg2: it.unimi.dsi.fastutil.ints.IntBinaryOperator_): number;
        size(): number;
        putIfAbsent(arg0: K, arg1: number): number;
        defaultReturnValue(arg0: number): void;
        object2IntEntrySet(): Internal.ObjectSet<Internal.Object2IntMap$Entry<K>>;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2IntFunction;
        andThenObject(arg0: Internal.Int2ObjectFunction_<any>): Internal.Object2ObjectFunction<K, T>;
        clear(): void;
        replace(arg0: any, arg1: any): any;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Object2CharFunction<K>;
        merge(arg0: any, arg1: any, arg2: Internal.BiFunction_<any, any, any>): any;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2IntFunction;
    }
    type Object2IntMap_<K> = Object2IntMap<K>;
    interface DensityFunction$SimpleFunction extends Internal.DensityFunction {
        halfNegative(): Internal.DensityFunction;
        abs(): Internal.DensityFunction;
        quarterNegative(): Internal.DensityFunction;
        cube(): Internal.DensityFunction;
        fillArray(arg0: number[], arg1: Internal.DensityFunction$ContextProvider_): void;
        squeeze(): Internal.DensityFunction;
        square(): Internal.DensityFunction;
        mapAll(arg0: Internal.DensityFunction$Visitor_): Internal.DensityFunction;
        clamp(arg0: number, arg1: number): Internal.DensityFunction;
    }
    type DensityFunction$SimpleFunction_ = DensityFunction$SimpleFunction;
    class PosAlwaysTrueTest extends Internal.PosRuleTest {
        test(arg0: BlockPos_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.Random_): boolean;
        readonly static "INSTANCE": Internal.PosAlwaysTrueTest;
        readonly static "CODEC": any;
    }
    type PosAlwaysTrueTest_ = PosAlwaysTrueTest;
    interface Boolean2ByteFunction extends it.unimi.dsi.fastutil.Function<boolean, number> {
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2ByteFunction;
        andThenObject(arg0: Internal.Byte2ObjectFunction_<any>): Internal.Boolean2ObjectFunction<T>;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Boolean2DoubleFunction;
        andThenReference(arg0: Internal.Byte2ReferenceFunction_<any>): Internal.Boolean2ReferenceFunction<T>;
        getOrDefault(arg0: any, arg1: any): any;
        remove(arg0: boolean): number;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2ByteFunction;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2ByteFunction;
        containsKey(arg0: any): boolean;
        defaultReturnValue(arg0: number): void;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Boolean2ShortFunction;
        remove(arg0: any): number;
        put(arg0: any, arg1: any): any;
        defaultReturnValue(): number;
        composeObject(arg0: Internal.Object2BooleanFunction_<any>): Internal.Object2ByteFunction<T>;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2ByteFunction;
        get(arg0: any): number;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2ByteFunction;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Boolean2IntFunction;
        andThenByte(arg0: Internal.Byte2ByteFunction_): this;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2ByteFunction;
        composeReference(arg0: Internal.Reference2BooleanFunction_<any>): Internal.Reference2ByteFunction<T>;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Boolean2LongFunction;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Boolean2FloatFunction;
        get(arg0: boolean): number;
        apply(arg0: boolean): number;
        getOrDefault(arg0: any, arg1: number): number;
        containsKey(arg0: boolean): boolean;
        getOrDefault(arg0: boolean, arg1: number): number;
        put(arg0: boolean, arg1: number): number;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Boolean2CharFunction;
        size(): number;
        put(arg0: boolean, arg1: number): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<boolean, T>;
        clear(): void;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2ByteFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
    }
    type Boolean2ByteFunction_ = Boolean2ByteFunction | ((arg0: boolean)=>number);
    class ClientboundChangeDifficultyPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.Difficulty_, arg1: boolean)
        handle(arg0: Internal.PacketListener_): void;
        isLocked(): boolean;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getDifficulty(): Internal.Difficulty;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get locked(): boolean
        get difficulty(): Internal.Difficulty
        get skippable(): boolean
    }
    type ClientboundChangeDifficultyPacket_ = ClientboundChangeDifficultyPacket;
    interface CrossbowAttackMob extends Internal.RangedAttackMob {
        getTarget(): Internal.LivingEntity;
        shootCrossbowProjectile(arg0: Internal.LivingEntity_, arg1: Internal.ItemStack_, arg2: Internal.Projectile_, arg3: number): void;
        shootCrossbowProjectile(arg0: Internal.LivingEntity_, arg1: Internal.LivingEntity_, arg2: Internal.Projectile_, arg3: number, arg4: number): void;
        getProjectileShotVector(arg0: Internal.LivingEntity_, arg1: Vec3_, arg2: number): Internal.Vector3f;
        performCrossbowAttack(arg0: Internal.LivingEntity_, arg1: number): void;
        setChargingCrossbow(arg0: boolean): void;
        onCrossbowAttackPerformed(): void;
        get target(): Internal.LivingEntity
        set chargingCrossbow(arg0: boolean)
    }
    type CrossbowAttackMob_ = CrossbowAttackMob;
    class PaintEventJS extends Internal.ClientEventJS {
        constructor(m: Internal.Minecraft_, p: Internal.PoseStack_, d: number, s: Internal.Screen_)
        setShaderTexture(tex: ResourceLocation_): void;
        multiply(q: Internal.Quaternion_): void;
        setPositionColorShader(): void;
        vertex(m: Internal.Matrix4f_, x: number, y: number, z: number, col: number, u: number, v: number): void;
        translate(x: number, y: number, z: number): void;
        begin(type: Internal.VertexFormat$Mode_, format: Internal.VertexFormat_): void;
        beginQuads(format: Internal.VertexFormat_): void;
        bindTextureForSetup(tex: ResourceLocation_): void;
        pop(): void;
        end(): void;
        push(): void;
        vertex(m: Internal.Matrix4f_, x: number, y: number, z: number, col: number): void;
        setPositionColorTextureShader(): void;
        multiplyWithMatrix(m: Internal.Matrix4f_): void;
        setShaderInstance(shader: Internal.Supplier_<Internal.ShaderInstance_>): void;
        beginQuads(texture: boolean): void;
        getMatrix(): Internal.Matrix4f;
        setShaderColor(r: number, g: number, b: number, a: number): void;
        scale(x: number, y: number, z: number): void;
        resetShaderColor(): void;
        set shaderTexture(tex: ResourceLocation_)
        set shaderInstance(shader: Internal.Supplier_<Internal.ShaderInstance_>)
        get matrix(): Internal.Matrix4f
        readonly "buffer": Internal.BufferBuilder;
        readonly "matrices": Internal.PoseStack;
        readonly "delta": number;
        readonly "font": Internal.Font;
        readonly "tesselator": Internal.Tesselator;
        readonly "screen": Internal.Screen;
        readonly "mc": Internal.Minecraft;
    }
    type PaintEventJS_ = PaintEventJS;
    class ParticleEngine implements Internal.PreparableReloadListener {
        constructor(arg0: Internal.ClientLevel_, arg1: Internal.TextureManager_)
        countParticles(): string;
        createTrackingEmitter(arg0: Internal.Entity_, arg1: Internal.ParticleOptions_): void;
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource$BufferSource_, arg2: Internal.LightTexture_, arg3: Internal.Camera_, arg4: number): void;
        crack(arg0: BlockPos_, arg1: Internal.Direction_): void;
        destroy(arg0: BlockPos_, arg1: Internal.BlockState_): void;
        createParticle(arg0: Internal.ParticleOptions_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Internal.Particle;
        tick(): void;
        add(arg0: Internal.Particle_): void;
        createTrackingEmitter(arg0: Internal.Entity_, arg1: Internal.ParticleOptions_, arg2: number): void;
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource$BufferSource_, arg2: Internal.LightTexture_, arg3: Internal.Camera_, arg4: number, arg5: Internal.Frustum_): void;
        register(arg0: Internal.ParticleType_<T>, arg1: Internal.ParticleEngine$SpriteParticleRegistration_<T>): void;
        getName(): string;
        close(): void;
        addBlockHitEffects(arg0: BlockPos_, arg1: Internal.BlockHitResult_): void;
        setLevel(arg0: Internal.ClientLevel_): void;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        register(arg0: Internal.ParticleType_<T>, arg1: Internal.ParticleProvider_<T>): void;
        get name(): string
        set level(arg0: Internal.ClientLevel_)
        readonly "textureAtlas": Internal.TextureAtlas;
    }
    type ParticleEngine_ = ParticleEngine;
    interface Kind1 <F, Mu> extends Internal.App<Mu, F> {
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>): Internal.Products$P11<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>, arg13: Internal.App_<F, T14>, arg14: Internal.App_<F, T15>): Internal.Products$P15<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>;
        unbox(arg0: Internal.App_<Proof, F>): Internal.Kind1<F, Proof>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>): Internal.Products$P2<F, T1, T2>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>): Internal.Products$P10<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>): Internal.Products$P13<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>): Internal.Products$P9<F, T1, T2, T3, T4, T5, T6, T7, T8, T9>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>): Internal.Products$P4<F, T1, T2, T3, T4>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>;
        group(arg0: Internal.App_<F, T1>): Internal.Products$P1<F, T1>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>, arg13: Internal.App_<F, T14>): Internal.Products$P14<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>): Internal.Products$P12<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>, arg13: Internal.App_<F, T14>, arg14: Internal.App_<F, T15>, arg15: Internal.App_<F, T16>): Internal.Products$P16<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>): Internal.Products$P3<F, T1, T2, T3>;
    }
    type Kind1_<F, Mu> = Kind1<F, Mu>;
    abstract class LivingEntity extends Internal.Entity implements Internal.LivingEntityKJS {
        push(arg0: Internal.Entity_): void;
        getProjectile(arg0: Internal.ItemStack_): Internal.ItemStack;
        isBlocking(): boolean;
        isInWall(): boolean;
        isAffectedByPotions(): boolean;
        knockback(arg0: number, arg1: number, arg2: number): void;
        setAbsorptionAmount(arg0: number): void;
        getScale(): number;
        canAttack(arg0: Internal.LivingEntity_): boolean;
        isSuppressingSlidingDownLadder(): boolean;
        getVisibilityPercent(arg0: Internal.Entity_): number;
        getAddEntityPacket(): Internal.Packet<any>;
        startUsingItem(arg0: Hand_): void;
        shouldRiderFaceForward(arg0: Internal.Player_): boolean;
        isAlive(): boolean;
        static getEquipmentSlotForItem(arg0: Internal.ItemStack_): EquipmentSlot;
        getArmorCoverPercentage(): number;
        handleRelativeFrictionAndCalculateMovement(arg0: Vec3_, arg1: number): Vec3;
        startSleeping(arg0: BlockPos_): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getUseItem(): Internal.ItemStack;
        getFallFlyingTicks(): number;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        onLeaveCombat(): void;
        getAttributeValue(arg0: Internal.Attribute_): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isPickable(): boolean;
        isBaby(): boolean;
        setYHeadRot(arg0: number): void;
        getSwimAmount(arg0: number): number;
        canBreatheUnderwater(): boolean;
        baseTick(): void;
        alwaysAccepts(): boolean;
        die(arg0: Internal.DamageSource_): void;
        setJumping(arg0: boolean): void;
        removeAllEffects(): boolean;
        hasLineOfSight(arg0: Internal.Entity_): boolean;
        getJumpBoostPower(): number;
        getSleepingPos(): Internal.Optional<BlockPos>;
        getNoActionTime(): number;
        onClimbable(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        getAbsorptionAmount(): number;
        isVisuallySwimming(): boolean;
        getMobType(): Internal.MobType;
        travel(arg0: Vec3_): void;
        addEffect(arg0: Internal.MobEffectInstance_): boolean;
        getSlot(arg0: number): Internal.SlotAccess;
        getRandom(): Internal.Random;
        getItemInHand(arg0: Hand_): Internal.ItemStack;
        asKJS(): Internal.EntityJS;
        canFreeze(): boolean;
        setItemInHand(arg0: Hand_, arg1: Internal.ItemStack_): void;
        animateHurt(): void;
        setStingerCount(arg0: number): void;
        getAttributes(): Internal.AttributeMap;
        canRiderInteract(): boolean;
        stopRiding(): void;
        getLastHurtByMob(): this;
        getDimensions(arg0: Internal.Pose_): Internal.EntityDimensions;
        shouldRiderSit(): boolean;
        lookAt(arg0: Internal.EntityAnchorArgument$Anchor_, arg1: Vec3_): void;
        removeEffectNoUpdate(arg0: Internal.MobEffect_): Internal.MobEffectInstance;
        getBoundingBoxForCulling(): Internal.AABB;
        canSpawnSoulSpeedParticle(): boolean;
        canTakeItem(arg0: Internal.ItemStack_): boolean;
        setSprinting(arg0: boolean): void;
        getHealth(): number;
        getMaxHealth(): number;
        getAttackAnim(arg0: number): number;
        aiStep(): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getLootTable(): ResourceLocation;
        getTicksUsingItem(): number;
        releaseUsingItem(): void;
        setLastHurtByPlayer(arg0: Internal.Player_): void;
        getArrowCount(): number;
        getItemBySlot(arg0: EquipmentSlot_): Internal.ItemStack;
        broadcastBreakEvent(arg0: Hand_): void;
        rideableUnderWater(): boolean;
        setYBodyRot(arg0: number): void;
        isPushable(): boolean;
        setRecordPlayingNearby(arg0: BlockPos_, arg1: boolean): void;
        hasItemInSlot(arg0: EquipmentSlot_): boolean;
        getStingerCount(): number;
        hasEffect(arg0: Internal.MobEffect_): boolean;
        swing(arg0: Hand_): void;
        reviveCaps(): void;
        stopSleeping(): void;
        getFallSounds(): Internal.LivingEntity$Fallsounds;
        setOnGround(arg0: boolean): void;
        getUseItemRemainingTicks(): number;
        addEffect(arg0: Internal.MobEffectInstance_, arg1: Internal.Entity_): boolean;
        static createLivingAttributes(): Internal.AttributeSupplier$Builder;
        attackable(): boolean;
        getStepHeight(): number;
        getLocalBoundsForPose(arg0: Internal.Pose_): Internal.AABB;
        curePotionEffects(arg0: Internal.ItemStack_): boolean;
        getLastHurtByMobTimestamp(): number;
        isEffectiveAi(): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        stopUsingItem(): void;
        isSleeping(): boolean;
        onItemPickup(arg0: Internal.ItemEntity_): void;
        isFallFlying(): boolean;
        getLastClimbablePos(): Internal.Optional<BlockPos>;
        getEatingSound(arg0: Internal.ItemStack_): Internal.SoundEvent;
        getMainArm(): Internal.HumanoidArm;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        forceAddEffect(arg0: Internal.MobEffectInstance_, arg1: Internal.Entity_): void;
        isDamageSourceBlocked(arg0: Internal.DamageSource_): boolean;
        getFluidFallingAdjustedMovement(arg0: number, arg1: boolean, arg2: Vec3_): Vec3;
        getActiveEffectsMap(): Internal.Map<Internal.MobEffect, Internal.MobEffectInstance>;
        getOffhandItem(): Internal.ItemStack;
        randomTeleport(arg0: number, arg1: number, arg2: number, arg3: boolean): boolean;
        invalidateCaps(): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        getEffect(arg0: Internal.MobEffect_): Internal.MobEffectInstance;
        getDismountPoses(): Internal.ImmutableList<Internal.Pose>;
        getLastHurtMobTimestamp(): number;
        isHolding(arg0: Internal.Predicate_<Internal.ItemStack_>): boolean;
        setHealth(arg0: number): void;
        getSpeed(): number;
        getArmorValue(): number;
        tick(): void;
        isSensitiveToWater(): boolean;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        rideTick(): void;
        setDiscardFriction(arg0: boolean): void;
        clearSleepingPos(): void;
        lerpHeadTo(arg0: number, arg1: number): void;
        getKillCredit(): this;
        recreateFromPacket(arg0: Internal.ClientboundAddMobPacket_): void;
        swing(arg0: Hand_, arg1: boolean): void;
        getUsedItemHand(): Hand;
        getMainHandItem(): Internal.ItemStack;
        getLastHurtMob(): this;
        canAttackType(arg0: Internal.EntityType_<any>): boolean;
        heal(arg0: number): void;
        shouldShowName(): boolean;
        getCapability(arg0: Internal.Capability_<T>, arg1: Internal.Direction_): Internal.LazyOptional<T>;
        getArmorSlots(): Internal.Iterable<Internal.ItemStack>;
        setLastHurtMob(arg0: Internal.Entity_): void;
        isCurrentlyGlowing(): boolean;
        setLastHurtByMob(arg0: Internal.LivingEntity_): void;
        getBrain(): Internal.Brain<any>;
        canBeSeenAsEnemy(): boolean;
        kill(): void;
        onEnterCombat(): void;
        setSpeed(arg0: number): void;
        getActiveEffects(): Internal.Collection<Internal.MobEffectInstance>;
        isAutoSpinAttack(): boolean;
        canAttack(arg0: Internal.LivingEntity_, arg1: Internal.TargetingConditions_): boolean;
        static resetForwardDirectionOfRelativePortalPosition(arg0: Vec3_): Vec3;
        getCombatTracker(): Internal.CombatTracker;
        shouldDiscardFriction(): boolean;
        canStandOnFluid(arg0: Internal.FluidState_): boolean;
        getLastDamageSource(): Internal.DamageSource;
        isMultipartEntity(): boolean;
        setNoActionTime(arg0: number): void;
        serializeNBT(): Internal.Tag;
        getAttribute(arg0: Internal.Attribute_): Internal.AttributeInstance;
        isHolding(arg0: Internal.Item_): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        canBeAffected(arg0: Internal.MobEffectInstance_): boolean;
        isUsingItem(): boolean;
        calculateEntityAnimation(arg0: Internal.LivingEntity_, arg1: boolean): void;
        static areAllEffectsAmbient(arg0: Internal.Collection_<Internal.MobEffectInstance_>): boolean;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        setArrowCount(arg0: number): void;
        lerpTo(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: boolean): void;
        isInvertedHealAndHarm(): boolean;
        getBedOrientation(): Internal.Direction;
        getVoicePitch(): number;
        removeEffect(arg0: Internal.MobEffect_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        setSleepingPos(arg0: BlockPos_): void;
        canBeSeenByAnyone(): boolean;
        eat(arg0: Internal.Level_, arg1: Internal.ItemStack_): Internal.ItemStack;
        getAttributeBaseValue(arg0: Internal.Attribute_): number;
        getClassification(arg0: boolean): Internal.MobCategory;
        isDeadOrDying(): boolean;
        take(arg0: Internal.Entity_, arg1: number): void;
        setItemSlot(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): void;
        getYHeadRot(): number;
        broadcastBreakEvent(arg0: EquipmentSlot_): void;
        getViewYRot(arg0: number): number;
        get blocking(): boolean
        get inWall(): boolean
        get affectedByPotions(): boolean
        set absorptionAmount(arg0: number)
        get scale(): number
        get suppressingSlidingDownLadder(): boolean
        get addEntityPacket(): Internal.Packet<any>
        get alive(): boolean
        get armorCoverPercentage(): number
        get useItem(): Internal.ItemStack
        get fallFlyingTicks(): number
        get pickable(): boolean
        get baby(): boolean
        set YHeadRot(arg0: number)
        set jumping(arg0: boolean)
        get jumpBoostPower(): number
        get sleepingPos(): Internal.Optional<BlockPos>
        get noActionTime(): number
        get absorptionAmount(): number
        get visuallySwimming(): boolean
        get mobType(): Internal.MobType
        get random(): Internal.Random
        set stingerCount(arg0: number)
        get attributes(): Internal.AttributeMap
        get lastHurtByMob(): Internal.LivingEntity
        get boundingBoxForCulling(): Internal.AABB
        set sprinting(arg0: boolean)
        get health(): number
        get maxHealth(): number
        get lootTable(): ResourceLocation
        get ticksUsingItem(): number
        set lastHurtByPlayer(arg0: Internal.Player_)
        get arrowCount(): number
        set YBodyRot(arg0: number)
        get pushable(): boolean
        get stingerCount(): number
        get fallSounds(): Internal.LivingEntity$Fallsounds
        set onGround(arg0: boolean)
        get useItemRemainingTicks(): number
        get stepHeight(): number
        get lastHurtByMobTimestamp(): number
        get effectiveAi(): boolean
        get sleeping(): boolean
        get fallFlying(): boolean
        get lastClimbablePos(): Internal.Optional<BlockPos>
        get mainArm(): Internal.HumanoidArm
        get activeEffectsMap(): Internal.Map<Internal.MobEffect, Internal.MobEffectInstance>
        get offhandItem(): Internal.ItemStack
        get dismountPoses(): Internal.ImmutableList<Internal.Pose>
        get lastHurtMobTimestamp(): number
        set health(arg0: number)
        get speed(): number
        get armorValue(): number
        get sensitiveToWater(): boolean
        set discardFriction(arg0: boolean)
        get killCredit(): Internal.LivingEntity
        get usedItemHand(): Hand
        get mainHandItem(): Internal.ItemStack
        get lastHurtMob(): Internal.LivingEntity
        get armorSlots(): Internal.Iterable<Internal.ItemStack>
        set lastHurtMob(arg0: Internal.Entity_)
        get currentlyGlowing(): boolean
        set lastHurtByMob(arg0: Internal.LivingEntity_)
        get brain(): Internal.Brain<any>
        set speed(arg0: number)
        get activeEffects(): Internal.Collection<Internal.MobEffectInstance>
        get autoSpinAttack(): boolean
        get combatTracker(): Internal.CombatTracker
        get lastDamageSource(): Internal.DamageSource
        get multipartEntity(): boolean
        set noActionTime(arg0: number)
        get parts(): Internal.PartEntity<any>[]
        get usingItem(): boolean
        set arrowCount(arg0: number)
        get invertedHealAndHarm(): boolean
        get bedOrientation(): Internal.Direction
        get voicePitch(): number
        set sleepingPos(arg0: BlockPos_)
        get deadOrDying(): boolean
        get YHeadRot(): number
        readonly static "DEATH_DURATION": 20;
        "removeArrowTime": number;
        "yBodyRotO": number;
        "swingingArm": Hand;
        "animationPosition": number;
        "deathTime": number;
        "hurtTime": number;
        "yya": number;
        "animationSpeed": number;
        readonly static "SWING_DURATION": 6;
        "attackAnim": number;
        readonly static "ARMOR_SLOT_OFFSET": 100;
        readonly static "PLAYER_HURT_EXPERIENCE_TIME": 100;
        readonly "timeOffs": number;
        readonly static "DEFAULT_BASE_GRAVITY": 0.08;
        "oAttackAnim": number;
        "yBodyRot": number;
        "yHeadRot": number;
        "yHeadRotO": number;
        "swinging": boolean;
        "animationSpeedOld": number;
        readonly static "HAND_SLOTS": 2;
        readonly static "ARMOR_SLOTS": 4;
        "swingTime": number;
        "removeStingerTime": number;
        readonly static "USE_ITEM_INTERVAL": 4;
        readonly static "MIN_MOVEMENT_DISTANCE": 0.003;
        "hurtDuration": number;
        "hurtDir": number;
        readonly "invulnerableDuration": number;
        "zza": number;
        "xxa": number;
        readonly "rotA": number;
        readonly static "EXTRA_RENDER_CULLING_SIZE_WITH_BIG_HAT": 0.5;
        readonly static "EQUIPMENT_SLOT_OFFSET": 98;
        "flyingSpeed": number;
    }
    type LivingEntity_ = LivingEntity;
    class BlockModificationProperties {
        constructor(i: Internal.BlockKJS_)
        setExplosionResistance(v: number): void;
        setMaterial(v: Internal.MaterialJS_): void;
        setRequiresTool(v: boolean): void;
        setSpeedFactor(v: number): void;
        setDestroySpeed(v: number): void;
        setRandomlyTicking(v: boolean): void;
        setSoundType(v: Internal.SoundType_): void;
        setFriction(v: number): void;
        setHasCollision(v: boolean): void;
        setLightEmission(v: number): void;
        setJumpFactor(v: number): void;
        set explosionResistance(v: number)
        set material(v: Internal.MaterialJS_)
        set requiresTool(v: boolean)
        set speedFactor(v: number)
        set destroySpeed(v: number)
        set randomlyTicking(v: boolean)
        set soundType(v: Internal.SoundType_)
        set friction(v: number)
        set hasCollision(v: boolean)
        set lightEmission(v: number)
        set jumpFactor(v: number)
        readonly "block": Internal.BlockKJS;
    }
    type BlockModificationProperties_ = BlockModificationProperties;
    class ItemStackJS implements Internal.NBTSerializable, Internal.IngredientJS, Internal.ChangeListener<Internal.Tag>, Internal.SpecialEquality {
        constructor(s: Internal.ItemStack_)
        getTags(): Internal.Collection<ResourceLocation>;
        static clearListCache(): void;
        x(c: number): Internal.IngredientJS;
        removeChance(): void;
        getStacks(): Internal.Set<Internal.ItemStackJS>;
        asIngredientStack(): Internal.IngredientStackJS;
        withChance(c: number): this;
        withNBT(nbt: Internal.CompoundTag_): this;
        ignoreNBT(): Internal.IngredientJS;
        isBlock(): boolean;
        toJson(): Internal.JsonElement;
        getHarvestSpeed(block: Internal.BlockContainerJS_): number;
        filter(filter: Internal.IngredientJS_): Internal.IngredientJS;
        static getList(): Internal.List<Internal.ItemStackJS>;
        static getListJS(): Internal.ListJS;
        not(): Internal.IngredientJS;
        copy(): this;
        weakNBT(): Internal.IngredientJS;
        withCount(c: number): this;
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>;
        getNbt(): Internal.CompoundTag;
        getVanillaItems(): Internal.Set<Internal.Item>;
        static of(o: any): Internal.ItemStackJS;
        getName(): Internal.Component;
        areItemsEqual(other: Internal.ItemStackJS_): boolean;
        static getTypeList(): Internal.ListJS;
        specialEquals(o: any, shallow: boolean): boolean;
        hasTag(tag: ResourceLocation_): boolean;
        getChance(): number;
        toRawResultJson(): Internal.JsonElement;
        toResultJson(): Internal.JsonElement;
        getTypeData(): Internal.CompoundTag;
        getNbtString(): string;
        hasNBT(): boolean;
        static findGroup(id: string): Internal.CreativeModeTab;
        getEnchantments(): Internal.MapJS;
        removeNBT(): this;
        getItem(): Internal.Item;
        hasChance(): boolean;
        getHarvestSpeed(): number;
        onChanged(o: Internal.Tag_): void;
        testVanilla(other: Internal.ItemStack_): boolean;
        getCount(): number;
        static getRawItem(o: any): Internal.Item;
        getItemGroup(): string;
        getItemIds(): Internal.Set<string>;
        isEmpty(): boolean;
        withName(displayName: Internal.Component_): this;
        setNbt(tag: Internal.CompoundTag_): void;
        onChanged(arg0: any): void;
        createVanillaIngredient(): Internal.Ingredient;
        anyStackMatches(ingredient: Internal.IngredientJS_): boolean;
        areItemsEqual(other: Internal.ItemStack_): boolean;
        hasEnchantment(enchantment: Internal.Enchantment_, level: number): boolean;
        getFirst(): this;
        getMod(): string;
        static resultFromRecipeJson(json: Internal.JsonElement_): Internal.ItemStackJS;
        enchant(enchantment: Internal.Enchantment_, level: number): this;
        isInvalidRecipeIngredient(): boolean;
        toString(): string;
        isNBTEqual(other: Internal.ItemStackJS_): boolean;
        test(other: Internal.ItemStackJS_): boolean;
        setCount(count: number): void;
        getId(): string;
        strongEquals(o: any): boolean;
        isNBTEqual(other: Internal.ItemStack_): boolean;
        testVanillaItem(item: Internal.Item_): boolean;
        hashCode(): number;
        getFluidStack(): Internal.FluidStackJS;
        enchant(enchantments: Internal.MapJS_): this;
        getVanillaPredicate(): Internal.Predicate<Internal.ItemStack>;
        setChance(c: number): void;
        toNBT(): Internal.Tag;
        equals(o: any): boolean;
        getItemStack(): Internal.ItemStack;
        get tags(): Internal.Collection<ResourceLocation>
        get stacks(): Internal.Set<Internal.ItemStackJS>
        get block(): boolean
        get list(): Internal.List<Internal.ItemStackJS>
        get listJS(): Internal.ListJS
        get nbt(): Internal.CompoundTag
        get vanillaItems(): Internal.Set<Internal.Item>
        get name(): Internal.Component
        get typeList(): Internal.ListJS
        get chance(): number
        get typeData(): Internal.CompoundTag
        get nbtString(): string
        get enchantments(): Internal.MapJS
        get item(): Internal.Item
        get harvestSpeed(): number
        get count(): number
        get itemGroup(): string
        get itemIds(): Internal.Set<string>
        get empty(): boolean
        set nbt(tag: Internal.CompoundTag_)
        get first(): Internal.ItemStackJS
        get mod(): string
        get invalidRecipeIngredient(): boolean
        set count(count: number)
        get id(): string
        get fluidStack(): Internal.FluidStackJS
        get vanillaPredicate(): Internal.Predicate<Internal.ItemStack>
        set chance(c: number)
        get itemStack(): Internal.ItemStack
        readonly static "EMPTY": any;
    }
    type ItemStackJS_ = ItemStackJS;
    class AmbientAdditionsSettings {
        constructor(arg0: Internal.SoundEvent_, arg1: number)
        getTickChance(): number;
        getSoundEvent(): Internal.SoundEvent;
        get tickChance(): number
        get soundEvent(): Internal.SoundEvent
        readonly static "CODEC": any;
    }
    type AmbientAdditionsSettings_ = AmbientAdditionsSettings;
    class ClientboundExplodePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.List_<BlockPos_>, arg5: Vec3_)
        handle(arg0: Internal.PacketListener_): void;
        getX(): number;
        getToBlow(): Internal.List<BlockPos>;
        getY(): number;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getZ(): number;
        getPower(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getKnockbackZ(): number;
        isSkippable(): boolean;
        getKnockbackX(): number;
        getKnockbackY(): number;
        get x(): number
        get toBlow(): Internal.List<BlockPos>
        get y(): number
        get z(): number
        get power(): number
        get knockbackZ(): number
        get skippable(): boolean
        get knockbackX(): number
        get knockbackY(): number
    }
    type ClientboundExplodePacket_ = ClientboundExplodePacket;
    class ListPoolElement extends Internal.StructurePoolElement {
        constructor(arg0: Internal.List_<Internal.StructurePoolElement_>, arg1: Internal.StructureTemplatePool$Projection_)
        setProjection(arg0: Internal.StructureTemplatePool$Projection_): Internal.StructurePoolElement;
        getType(): Internal.StructurePoolElementType<any>;
        getSize(arg0: Internal.StructureManager_, arg1: Internal.Rotation_): Vec3i;
        toString(): string;
        place(arg0: Internal.StructureManager_, arg1: Internal.WorldGenLevel_, arg2: Internal.StructureFeatureManager_, arg3: Internal.ChunkGenerator_, arg4: BlockPos_, arg5: BlockPos_, arg6: Internal.Rotation_, arg7: Internal.BoundingBox_, arg8: Internal.Random_, arg9: boolean): boolean;
        getShuffledJigsawBlocks(arg0: Internal.StructureManager_, arg1: BlockPos_, arg2: Internal.Rotation_, arg3: Internal.Random_): Internal.List<Internal.StructureTemplate$StructureBlockInfo>;
        getBoundingBox(arg0: Internal.StructureManager_, arg1: BlockPos_, arg2: Internal.Rotation_): Internal.BoundingBox;
        set projection(arg0: Internal.StructureTemplatePool$Projection_)
        get type(): Internal.StructurePoolElementType<any>
        readonly static "CODEC": any;
    }
    type ListPoolElement_ = ListPoolElement;
    class DragonStrafePlayerPhase extends Internal.AbstractDragonPhaseInstance {
        constructor(arg0: Internal.EnderDragon_)
        setTarget(arg0: Internal.LivingEntity_): void;
        getFlyTargetLocation(): Vec3;
        begin(): void;
        doServerTick(): void;
        getPhase(): Internal.EnderDragonPhase<Internal.DragonStrafePlayerPhase>;
        set target(arg0: Internal.LivingEntity_)
        get flyTargetLocation(): Vec3
        get phase(): Internal.EnderDragonPhase<Internal.DragonStrafePlayerPhase>
    }
    type DragonStrafePlayerPhase_ = DragonStrafePlayerPhase;
    interface ChannelPromise extends Internal.Promise<void>, Internal.ChannelFuture {
        unvoid(): this;
        setSuccess(arg0: void): this;
        trySuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener_<any>): this;
        channel(): io.netty.channel.Channel;
        addListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        removeListener(arg0: Internal.GenericFutureListener_<any>): this;
        sync(): this;
        syncUninterruptibly(): this;
        await(): this;
        awaitUninterruptibly(): this;
        setFailure(arg0: Internal.Throwable_): this;
        removeListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        setSuccess(): this;
        set success(arg0: void)
        set failure(arg0: Internal.Throwable_)
    }
    type ChannelPromise_ = ChannelPromise;
    class ScreenEvent$DrawScreenEvent$Pre extends Internal.ScreenEvent$DrawScreenEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: Internal.PoseStack_, arg2: number, arg3: number, arg4: number)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$DrawScreenEvent$Pre_ = ScreenEvent$DrawScreenEvent$Pre;
    class AlternativesEntry$Builder extends Internal.LootPoolEntryContainer$Builder<Internal.AlternativesEntry$Builder> {
        constructor(...arg0: Internal.LootPoolEntryContainer$Builder_<any>[])
        build(): Internal.LootPoolEntryContainer;
        otherwise(arg0: Internal.LootPoolEntryContainer$Builder_<any>): this;
    }
    type AlternativesEntry$Builder_ = AlternativesEntry$Builder;
    interface MethodHandleInfo {
        isVarArgs(): boolean;
        getMethodType(): Internal.MethodType;
        getModifiers(): number;
        toString(arg0: number, arg1: Internal.Class_<any>, arg2: string, arg3: Internal.MethodType_): string;
        getName(): string;
        getReferenceKind(): number;
        referenceKindToString(arg0: number): string;
        getDeclaringClass(): Internal.Class<any>;
        reflectAs(arg0: Internal.Class_<T>, arg1: Internal.MethodHandles$Lookup_): T;
        get varArgs(): boolean
        get methodType(): Internal.MethodType
        get modifiers(): number
        get name(): string
        get referenceKind(): number
        get declaringClass(): Internal.Class<any>
        readonly static "REF_getStatic": 2;
        readonly static "REF_newInvokeSpecial": 8;
        readonly static "REF_invokeVirtual": 5;
        readonly static "REF_putField": 3;
        readonly static "REF_invokeSpecial": 7;
        readonly static "REF_invokeInterface": 9;
        readonly static "REF_putStatic": 4;
        readonly static "REF_getField": 1;
        readonly static "REF_invokeStatic": 6;
    }
    type MethodHandleInfo_ = MethodHandleInfo;
    class LightTexture implements Internal.AutoCloseable {
        constructor(arg0: Internal.GameRenderer_, arg1: Internal.Minecraft_)
        static pack(arg0: number, arg1: number): number;
        static block(arg0: number): number;
        turnOffLightLayer(): void;
        close(): void;
        static sky(arg0: number): number;
        updateLightTexture(arg0: number): void;
        turnOnLightLayer(): void;
        tick(): void;
        readonly static "FULL_BRIGHT": 15728880;
        readonly static "FULL_SKY": 15728640;
        readonly static "FULL_BLOCK": 240;
    }
    type LightTexture_ = LightTexture;
    abstract class DateFormat extends Internal.Format {
        static getDateInstance(arg0: number): Internal.DateFormat;
        clone(): any;
        static getTimeInstance(arg0: number, arg1: Internal.Locale_): Internal.DateFormat;
        format(arg0: any, arg1: Internal.StringBuffer_, arg2: Internal.FieldPosition_): Internal.StringBuffer;
        format(arg0: Internal.Date_): string;
        static getDateInstance(arg0: number, arg1: Internal.Locale_): Internal.DateFormat;
        static getDateTimeInstance(arg0: number, arg1: number, arg2: Internal.Locale_): Internal.DateFormat;
        parseObject(arg0: string, arg1: Internal.ParsePosition_): any;
        static getInstance(): Internal.DateFormat;
        static getAvailableLocales(): Internal.Locale[];
        setNumberFormat(arg0: Internal.NumberFormat_): void;
        static getDateTimeInstance(arg0: number, arg1: number): Internal.DateFormat;
        isLenient(): boolean;
        format(arg0: Internal.Date_, arg1: Internal.StringBuffer_, arg2: Internal.FieldPosition_): Internal.StringBuffer;
        static getTimeInstance(): Internal.DateFormat;
        setCalendar(arg0: Internal.Calendar_): void;
        static getDateInstance(): Internal.DateFormat;
        static getDateTimeInstance(): Internal.DateFormat;
        getNumberFormat(): Internal.NumberFormat;
        parse(arg0: string): Internal.Date;
        hashCode(): number;
        getCalendar(): Internal.Calendar;
        parse(arg0: string, arg1: Internal.ParsePosition_): Internal.Date;
        getTimeZone(): Internal.TimeZone;
        setTimeZone(arg0: Internal.TimeZone_): void;
        static getTimeInstance(arg0: number): Internal.DateFormat;
        equals(arg0: any): boolean;
        setLenient(arg0: boolean): void;
        get instance(): Internal.DateFormat
        get availableLocales(): Internal.Locale[]
        set numberFormat(arg0: Internal.NumberFormat_)
        get lenient(): boolean
        get timeInstance(): Internal.DateFormat
        set calendar(arg0: Internal.Calendar_)
        get dateInstance(): Internal.DateFormat
        get dateTimeInstance(): Internal.DateFormat
        get numberFormat(): Internal.NumberFormat
        get calendar(): Internal.Calendar
        get timeZone(): Internal.TimeZone
        set timeZone(arg0: Internal.TimeZone_)
        set lenient(arg0: boolean)
        readonly static "DEFAULT": 2;
        readonly static "MONTH_FIELD": 2;
        readonly static "WEEK_OF_MONTH_FIELD": 13;
        readonly static "FULL": 0;
        readonly static "MILLISECOND_FIELD": 8;
        readonly static "LONG": 1;
        readonly static "AM_PM_FIELD": 14;
        readonly static "SHORT": 3;
        readonly static "ERA_FIELD": 0;
        readonly static "WEEK_OF_YEAR_FIELD": 12;
        readonly static "YEAR_FIELD": 1;
        readonly static "MINUTE_FIELD": 6;
        readonly static "DATE_FIELD": 3;
        readonly static "HOUR0_FIELD": 16;
        readonly static "HOUR_OF_DAY1_FIELD": 4;
        readonly static "HOUR_OF_DAY0_FIELD": 5;
        readonly static "SECOND_FIELD": 7;
        readonly static "DAY_OF_WEEK_FIELD": 9;
        readonly static "TIMEZONE_FIELD": 17;
        readonly static "MEDIUM": 2;
        readonly static "DAY_OF_WEEK_IN_MONTH_FIELD": 11;
        readonly static "HOUR1_FIELD": 15;
        readonly static "DAY_OF_YEAR_FIELD": 10;
    }
    type DateFormat_ = DateFormat;
    class ModuleDescriptor$Opens implements Internal.Comparable<Internal.ModuleDescriptor$Opens> {
        hashCode(): number;
        isQualified(): boolean;
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Opens$Modifier>;
        toString(): string;
        targets(): Internal.Set<string>;
        compareTo(arg0: Internal.ModuleDescriptor$Opens_): number;
        source(): string;
        equals(arg0: any): boolean;
        compareTo(arg0: any): number;
        get qualified(): boolean
    }
    type ModuleDescriptor$Opens_ = ModuleDescriptor$Opens;
    interface RequirementsStrategy {
        createRequirements(arg0: Internal.Collection_<string>): string[][];
        readonly static "OR": any;
        readonly static "AND": any;
    }
    type RequirementsStrategy_ = RequirementsStrategy;
    abstract class TreeDecorator {
        constructor()
        place(arg0: Internal.LevelSimulatedReader_, arg1: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>, arg2: Internal.Random_, arg3: Internal.List_<BlockPos_>, arg4: Internal.List_<BlockPos_>): void;
        readonly static "CODEC": any;
    }
    type TreeDecorator_ = TreeDecorator;
    class BarrelBlockEntity extends Internal.RandomizableContainerBlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        stopOpen(arg0: Internal.Player_): void;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getMaxStackSize(): number;
        countItem(arg0: Internal.Item_): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        load(arg0: Internal.CompoundTag_): void;
        recheckOpen(): void;
        onLoad(): void;
        getContainerSize(): number;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get modelData(): Internal.IModelData
        get maxStackSize(): number
        get containerSize(): number
        get renderBoundingBox(): Internal.AABB
    }
    type BarrelBlockEntity_ = BarrelBlockEntity;
    class SmeltingRecipe extends Internal.AbstractCookingRecipe {
        constructor(arg0: ResourceLocation_, arg1: string, arg2: Internal.Ingredient_, arg3: Internal.ItemStack_, arg4: number, arg5: number)
        isSpecial(): boolean;
        getSerializer(): Internal.RecipeSerializer<any>;
        getToastSymbol(): Internal.ItemStack;
        isIncomplete(): boolean;
        getRemainingItems(arg0: Internal.Container_): Internal.NonNullList<Internal.ItemStack>;
        get special(): boolean
        get serializer(): Internal.RecipeSerializer<any>
        get toastSymbol(): Internal.ItemStack
        get incomplete(): boolean
    }
    type SmeltingRecipe_ = SmeltingRecipe;
    class BlockHitResult extends Internal.HitResult {
        constructor(arg0: Vec3_, arg1: Internal.Direction_, arg2: BlockPos_, arg3: boolean)
        getBlockPos(): BlockPos;
        withPosition(arg0: BlockPos_): this;
        withDirection(arg0: Internal.Direction_): this;
        static miss(arg0: Vec3_, arg1: Internal.Direction_, arg2: BlockPos_): Internal.BlockHitResult;
        isInside(): boolean;
        getType(): Internal.HitResult$Type;
        getDirection(): Internal.Direction;
        get blockPos(): BlockPos
        get inside(): boolean
        get type(): Internal.HitResult$Type
        get direction(): Internal.Direction
    }
    type BlockHitResult_ = BlockHitResult;
    interface IVertexConsumer {
        setTexture(arg0: Internal.TextureAtlasSprite_): void;
        setQuadOrientation(arg0: Internal.Direction_): void;
        setApplyDiffuseLighting(arg0: boolean): void;
        getVertexFormat(): Internal.VertexFormat;
        setQuadTint(arg0: number): void;
        put(arg0: number, ...arg1: number[]): void;
        set texture(arg0: Internal.TextureAtlasSprite_)
        set quadOrientation(arg0: Internal.Direction_)
        set applyDiffuseLighting(arg0: boolean)
        get vertexFormat(): Internal.VertexFormat
        set quadTint(arg0: number)
    }
    type IVertexConsumer_ = IVertexConsumer;
    interface IntBidirectionalIterator extends Internal.IntIterator, Internal.ObjectBidirectionalIterator<number> {
        forEachRemaining(arg0: any): void;
        remove(): void;
        previousInt(): number;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): any;
        skip(arg0: number): number;
        previous(): number;
        forEachRemaining(arg0: it.unimi.dsi.fastutil.ints.IntConsumer_): void;
        forEachRemaining(arg0: Internal.IntConsumer_): void;
        back(arg0: number): number;
    }
    type IntBidirectionalIterator_ = IntBidirectionalIterator;
    class GossipContainer {
        constructor()
        getGossipEntries(): Internal.Map<Internal.UUID, Internal.Object2IntMap<Internal.GossipType>>;
        remove(arg0: Internal.UUID_, arg1: Internal.GossipType_, arg2: number): void;
        getCountForType(arg0: Internal.GossipType_, arg1: Internal.DoublePredicate_): number;
        remove(arg0: Internal.UUID_, arg1: Internal.GossipType_): void;
        add(arg0: Internal.UUID_, arg1: Internal.GossipType_, arg2: number): void;
        transferFrom(arg0: Internal.GossipContainer_, arg1: Internal.Random_, arg2: number): void;
        store(arg0: Internal.DynamicOps_<T>): Internal.Dynamic<T>;
        update(arg0: Internal.Dynamic_<any>): void;
        decay(): void;
        remove(arg0: Internal.GossipType_): void;
        getReputation(arg0: Internal.UUID_, arg1: Internal.Predicate_<Internal.GossipType_>): number;
        get gossipEntries(): Internal.Map<Internal.UUID, Internal.Object2IntMap<Internal.GossipType>>
        readonly static "DISCARD_THRESHOLD": 2;
    }
    type GossipContainer_ = GossipContainer;
    interface IntListIterator extends Internal.ListIterator<number>, Internal.IntBidirectionalIterator {
        add(arg0: any): void;
        forEachRemaining(arg0: any): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): any;
        set(arg0: any): void;
        set(arg0: number): void;
        skip(arg0: number): number;
        add(arg0: number): void;
        add(arg0: number): void;
        forEachRemaining(arg0: it.unimi.dsi.fastutil.ints.IntConsumer_): void;
        forEachRemaining(arg0: Internal.IntConsumer_): void;
        set(arg0: number): void;
        remove(): void;
        back(arg0: number): number;
        previous(): any;
    }
    type IntListIterator_ = IntListIterator;
    class IsoEra extends Internal.Enum<Internal.IsoEra> implements Internal.Era {
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        get(arg0: Internal.TemporalField_): number;
        static valueOf(arg0: string): Internal.IsoEra;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        getLong(arg0: Internal.TemporalField_): number;
        query(arg0: Internal.TemporalQuery_<R>): R;
        getValue(): number;
        static values(): Internal.IsoEra[];
        static of(arg0: number): Internal.IsoEra;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        isSupported(arg0: Internal.TemporalField_): boolean;
        get value(): number
        readonly static "BCE": Internal.IsoEra;
        readonly static "CE": Internal.IsoEra;
    }
    type IsoEra_ = IsoEra | "bce" | "ce";
    interface LivingEntityKJS {
        foodEatenKJS(is: Internal.ItemStack_): void;
    }
    type LivingEntityKJS_ = LivingEntityKJS;
    class Pattern implements Internal.Serializable {
        flags(): number;
        toString(): string;
        split(arg0: Internal.CharSequence_, arg1: number): string[];
        static compile(arg0: string, arg1: number): Internal.Pattern;
        matcher(arg0: Internal.CharSequence_): Internal.Matcher;
        asMatchPredicate(): Internal.Predicate<string>;
        static compile(arg0: string): Internal.Pattern;
        splitAsStream(arg0: Internal.CharSequence_): Internal.Stream<string>;
        asPredicate(): Internal.Predicate<string>;
        pattern(): string;
        split(arg0: Internal.CharSequence_): string[];
        static matches(arg0: string, arg1: Internal.CharSequence_): boolean;
        static quote(arg0: string): string;
        readonly static "CANON_EQ": 128;
        readonly static "UNIX_LINES": 1;
        readonly static "DOTALL": 32;
        readonly static "UNICODE_CHARACTER_CLASS": 256;
        readonly static "COMMENTS": 4;
        readonly static "UNICODE_CASE": 64;
        readonly static "CASE_INSENSITIVE": 2;
        readonly static "MULTILINE": 8;
        readonly static "LITERAL": 16;
    }
    type Pattern_ = Pattern;
    class ClientboundRemoveMobEffectPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: Internal.MobEffect_)
        handle(arg0: Internal.PacketListener_): void;
        getEffect(): Internal.MobEffect;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getEntity(arg0: Internal.Level_): Internal.Entity;
        isSkippable(): boolean;
        get effect(): Internal.MobEffect
        get skippable(): boolean
    }
    type ClientboundRemoveMobEffectPacket_ = ClientboundRemoveMobEffectPacket;
    interface IForgeKeyMapping {
        setToDefault(): void;
        setKeyConflictContext(arg0: Internal.IKeyConflictContext_): void;
        setKeyModifierAndCode(arg0: Internal.KeyModifier_, arg1: Internal.InputConstants$Key_): void;
        getKeyConflictContext(): Internal.IKeyConflictContext;
        getKey(): Internal.InputConstants$Key;
        getDefaultKeyModifier(): Internal.KeyModifier;
        isConflictContextAndModifierActive(): boolean;
        hasKeyModifierConflict(arg0: Internal.KeyMapping_): boolean;
        isActiveAndMatches(arg0: Internal.InputConstants$Key_): boolean;
        getKeyModifier(): Internal.KeyModifier;
        set keyConflictContext(arg0: Internal.IKeyConflictContext_)
        get keyConflictContext(): Internal.IKeyConflictContext
        get key(): Internal.InputConstants$Key
        get defaultKeyModifier(): Internal.KeyModifier
        get conflictContextAndModifierActive(): boolean
        get keyModifier(): Internal.KeyModifier
    }
    type IForgeKeyMapping_ = IForgeKeyMapping;
    class BrainDebugRenderer$BrainDump {
        constructor(arg0: Internal.UUID_, arg1: number, arg2: string, arg3: string, arg4: number, arg5: number, arg6: number, arg7: Internal.Position_, arg8: string, arg9: net.minecraft.world.level.pathfinder.Path_, arg10: boolean)
        getUuid(): Internal.UUID;
        get uuid(): Internal.UUID
        readonly "name": string;
        readonly "path": net.minecraft.world.level.pathfinder.Path;
        readonly "pos": Internal.Position;
        readonly "maxHealth": number;
        readonly "memories": Internal.List<string>;
        readonly "potentialPois": Internal.Set<BlockPos>;
        readonly "wantsGolem": boolean;
        readonly "activities": Internal.List<string>;
        readonly "profession": string;
        readonly "xp": number;
        readonly "pois": Internal.Set<BlockPos>;
        readonly "uuid": Internal.UUID;
        readonly "id": number;
        readonly "inventory": string;
        readonly "health": number;
        readonly "behaviors": Internal.List<string>;
        readonly "gossips": Internal.List<string>;
    }
    type BrainDebugRenderer$BrainDump_ = BrainDebugRenderer$BrainDump;
    interface BlockPredicateType <P> {
        codec(): Internal.Codec<P>;
        readonly static "REPLACEABLE": any;
        readonly static "MATCHING_FLUIDS": any;
        readonly static "HAS_STURDY_FACE": any;
        readonly static "MATCHING_BLOCK_TAG": any;
        readonly static "SOLID": any;
        readonly static "TRUE": any;
        readonly static "WOULD_SURVIVE": any;
        readonly static "INSIDE_WORLD_BOUNDS": any;
        readonly static "ANY_OF": any;
        readonly static "ALL_OF": any;
        readonly static "MATCHING_BLOCKS": any;
        readonly static "NOT": any;
    }
    type BlockPredicateType_<P> = BlockPredicateType<P> | Special.BlockPredicateType;
    interface SkinManager$SkinTextureCallback {
        onSkinTextureAvailable(arg0: Internal.MinecraftProfileTexture$Type_, arg1: ResourceLocation_, arg2: Internal.MinecraftProfileTexture_): void;
    }
    type SkinManager$SkinTextureCallback_ = SkinManager$SkinTextureCallback;
    class HeightmapPlacement extends Internal.PlacementModifier {
        type(): Internal.PlacementModifierType<any>;
        static onHeightmap(arg0: Internal.Heightmap$Types_): Internal.HeightmapPlacement;
        getPositions(arg0: Internal.PlacementContext_, arg1: Internal.Random_, arg2: BlockPos_): Internal.Stream<BlockPos>;
        readonly static "CODEC": any;
    }
    type HeightmapPlacement_ = HeightmapPlacement;
    abstract class Fluid extends Internal.ForgeRegistryEntry<Internal.Fluid> implements Internal.IForgeFluid, Internal.InjectedFluidExtension {
        getStateDefinition(): Internal.StateDefinition<Internal.Fluid, Internal.FluidState>;
        getAmount(arg0: Internal.FluidState_): number;
        getAttributes(): Internal.FluidAttributes;
        getHeight(arg0: Internal.FluidState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): number;
        getExplosionResistance(arg0: Internal.FluidState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        isSource(arg0: Internal.FluidState_): boolean;
        isEntityInside(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_, arg4: number, arg5: Internal.HolderSet_<Internal.Fluid_>, arg6: boolean): boolean;
        getOwnHeight(arg0: Internal.FluidState_): number;
        getBucket(): Internal.Item;
        isAABBInsideMaterial(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.AABB_, arg4: Internal.Material_): boolean;
        isSame(arg0: Internal.Fluid_): boolean;
        builtInRegistryHolder(): Internal.Holder$Reference<Internal.Fluid>;
        getPickupSound(): Internal.Optional<Internal.SoundEvent>;
        getShape(arg0: Internal.FluidState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): Internal.VoxelShape;
        defaultFluidState(): Internal.FluidState;
        getTickDelay(arg0: Internal.LevelReader_): number;
        isAABBInsideLiquid(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.AABB_): boolean;
        arch$holder(): Internal.Holder<Internal.Fluid>;
        arch$registryName(): ResourceLocation;
        is(arg0: Internal.TagKey_<Internal.Fluid_>): boolean;
        get stateDefinition(): Internal.StateDefinition<Internal.Fluid, Internal.FluidState>
        get attributes(): Internal.FluidAttributes
        get bucket(): Internal.Item
        get pickupSound(): Internal.Optional<Internal.SoundEvent>
        readonly static "FLUID_STATE_REGISTRY": Internal.IdMapper<any>;
    }
    type Fluid_ = Special.Fluid | Fluid;
    class ItemBasedSteering {
        constructor(arg0: Internal.SynchedEntityData_, arg1: Internal.EntityDataAccessor_<number>, arg2: Internal.EntityDataAccessor_<boolean>)
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        onSynced(): void;
        hasSaddle(): boolean;
        boost(arg0: Internal.Random_): boolean;
        setSaddle(arg0: boolean): void;
        set saddle(arg0: boolean)
        "boostTime": number;
        "boostTimeTotal": number;
        "boosting": boolean;
    }
    type ItemBasedSteering_ = ItemBasedSteering;
    class LongSummaryStatistics implements Internal.LongConsumer, Internal.IntConsumer {
        constructor()
        constructor(arg0: number, arg1: number, arg2: number, arg3: number)
        getSum(): number;
        andThen(arg0: Internal.LongConsumer_): Internal.LongConsumer;
        toString(): string;
        getCount(): number;
        getAverage(): number;
        getMin(): number;
        combine(arg0: Internal.LongSummaryStatistics_): void;
        getMax(): number;
        accept(arg0: number): void;
        accept(arg0: number): void;
        andThen(arg0: Internal.IntConsumer_): Internal.IntConsumer;
        get sum(): number
        get count(): number
        get average(): number
        get min(): number
        get max(): number
    }
    type LongSummaryStatistics_ = LongSummaryStatistics;
    class ClientboundClearTitlesPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: boolean)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        shouldResetTimes(): boolean;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get skippable(): boolean
    }
    type ClientboundClearTitlesPacket_ = ClientboundClearTitlesPacket;
    class TagMatchTest extends Internal.RuleTest {
        constructor(arg0: Internal.TagKey_<Internal.Block_>)
        test(arg0: Internal.BlockState_, arg1: Internal.Random_): boolean;
        readonly static "CODEC": any;
    }
    type TagMatchTest_ = TagMatchTest;
    interface IItemRenderProperties {
        renderHelmetOverlay(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: number, arg3: number, arg4: number): void;
        getFont(arg0: Internal.ItemStack_): Internal.Font;
        getItemStackRenderer(): Internal.BlockEntityWithoutLevelRenderer;
        getBaseArmorModel(arg0: Internal.LivingEntity_, arg1: Internal.ItemStack_, arg2: EquipmentSlot_, arg3: Internal.HumanoidModel_<any>): Internal.Model;
        getArmorModel(arg0: Internal.LivingEntity_, arg1: Internal.ItemStack_, arg2: EquipmentSlot_, arg3: Internal.HumanoidModel_<any>): Internal.HumanoidModel<any>;
        get itemStackRenderer(): Internal.BlockEntityWithoutLevelRenderer
        readonly static "DUMMY": any;
    }
    type IItemRenderProperties_ = IItemRenderProperties;
    class ResourceKey <T> implements Internal.Comparable<Internal.ResourceKey<any>>, Internal.SpecialEquality {
        toString(): string;
        specialEquals(o: any, shallow: boolean): boolean;
        compareTo(arg0: Internal.ResourceKey_<any>): number;
        static elementKey(arg0: Internal.ResourceKey_<any>): Internal.Function<ResourceLocation, Internal.ResourceKey<T>>;
        isFor(arg0: Internal.ResourceKey_<any>): boolean;
        compareTo(arg0: any): number;
        cast(arg0: Internal.ResourceKey_<any>): Internal.Optional<Internal.ResourceKey<E>>;
        static createRegistryKey(arg0: ResourceLocation_): Internal.ResourceKey<Internal.Registry<T>>;
        location(): ResourceLocation;
        getRegistryName(): ResourceLocation;
        registry(): ResourceLocation;
        static codec(arg0: Internal.ResourceKey_<any>): Internal.Codec<Internal.ResourceKey<T>>;
        static create(arg0: Internal.ResourceKey_<any>, arg1: ResourceLocation_): Internal.ResourceKey<T>;
        getPath(): string;
        equals(arg0: any): boolean;
        getNamespace(): string;
        get registryName(): ResourceLocation
        get path(): string
        get namespace(): string
    }
    type ResourceKey_<T> = ResourceKey<T>;
    class BiomeGenerationSettings$Builder {
        constructor()
        addFeature(arg0: DecorationGenerationStep_, arg1: Internal.Holder_<Internal.PlacedFeature_>): this;
        build(): Internal.BiomeGenerationSettings;
        addCarver(arg0: CarvingGenerationStep_, arg1: Internal.Holder_<any>): this;
        addFeature(arg0: number, arg1: Internal.Holder_<Internal.PlacedFeature_>): this;
        readonly "features": Internal.List<Internal.List<Internal.Holder<Internal.PlacedFeature>>>;
    }
    type BiomeGenerationSettings$Builder_ = BiomeGenerationSettings$Builder;
    interface Recipe <C> {
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        assemble(arg0: C): Internal.ItemStack;
        isSpecial(): boolean;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        matches(arg0: C, arg1: Internal.Level_): boolean;
        getSerializer(): Internal.RecipeSerializer<any>;
        getId(): ResourceLocation;
        isIncomplete(): boolean;
        getResultItem(): Internal.ItemStack;
        getRemainingItems(arg0: C): Internal.NonNullList<Internal.ItemStack>;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get special(): boolean
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get serializer(): Internal.RecipeSerializer<any>
        get id(): ResourceLocation
        get incomplete(): boolean
        get resultItem(): Internal.ItemStack
    }
    type Recipe_<C> = Recipe<C>;
    interface LootTablesKJS {
        applyKJS0(map: Internal.Map_<ResourceLocation_, Internal.JsonElement_>, action: Internal.BiConsumer_<ResourceLocation_, Internal.JsonElement_>): void;
    }
    type LootTablesKJS_ = LootTablesKJS;
    interface Keyable {
        keys(arg0: Internal.DynamicOps_<T>): Internal.Stream<T>;
        forStrings(arg0: Internal.Supplier_<Internal.Stream_<string>>): this;
    }
    type Keyable_ = Keyable;
    interface ServerboundInteractPacket$Handler {
        onInteraction(arg0: Hand_): void;
        onAttack(): void;
        onInteraction(arg0: Hand_, arg1: Vec3_): void;
    }
    type ServerboundInteractPacket$Handler_ = ServerboundInteractPacket$Handler;
    abstract class InputStream implements Internal.Closeable {
        constructor()
        skipNBytes(arg0: number): void;
        readNBytes(arg0: number[], arg1: number, arg2: number): number;
        read(arg0: number[], arg1: number, arg2: number): number;
        read(): number;
        markSupported(): boolean;
        readNBytes(arg0: number): number[];
        static nullInputStream(): Internal.InputStream;
        mark(arg0: number): void;
        skip(arg0: number): number;
        readAllBytes(): number[];
        close(): void;
        available(): number;
        read(arg0: number[]): number;
        transferTo(arg0: Internal.OutputStream_): number;
        reset(): void;
    }
    type InputStream_ = InputStream;
    class ScheduledTick <T> extends Internal.Record {
        constructor(arg0: T, arg1: BlockPos_, arg2: number, arg3: number)
        constructor(arg0: T, arg1: BlockPos_, arg2: number, arg3: Internal.TickPriority_, arg4: number)
        hashCode(): number;
        triggerTick(): number;
        toString(): string;
        pos(): BlockPos;
        subTickOrder(): number;
        static probe(arg0: T, arg1: BlockPos_): Internal.ScheduledTick<T>;
        type(): T;
        equals(arg0: any): boolean;
        priority(): Internal.TickPriority;
        readonly static "DRAIN_ORDER": any;
        readonly static "UNIQUE_TICK_HASH": any;
        readonly static "INTRA_TICK_DRAIN_ORDER": any;
    }
    type ScheduledTick_<T> = ScheduledTick<T>;
    interface LevelHeightAccessor {
        getSectionYFromSectionIndex(arg0: number): number;
        getSectionsCount(): number;
        getMinBuildHeight(): number;
        isOutsideBuildHeight(arg0: number): boolean;
        getMinSection(): number;
        create(arg0: number, arg1: number): this;
        getSectionIndex(arg0: number): number;
        getMaxSection(): number;
        getSectionIndexFromSectionY(arg0: number): number;
        getHeight(): number;
        getMaxBuildHeight(): number;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        get sectionsCount(): number
        get minBuildHeight(): number
        get minSection(): number
        get maxSection(): number
        get height(): number
        get maxBuildHeight(): number
    }
    type LevelHeightAccessor_ = LevelHeightAccessor;
    class AABB {
        constructor(arg0: BlockPos_)
        constructor(arg0: Vec3_, arg1: Vec3_)
        constructor(arg0: BlockPos_, arg1: BlockPos_)
        constructor(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number)
        expandTowards(arg0: number, arg1: number, arg2: number): this;
        max(arg0: Internal.Direction$Axis_): number;
        getZsize(): number;
        inflate(arg0: number): this;
        static unitCubeFromLowerCorner(arg0: Vec3_): Internal.AABB;
        expandTowards(arg0: Vec3_): this;
        hasNaN(): boolean;
        static ofSize(arg0: Vec3_, arg1: number, arg2: number, arg3: number): Internal.AABB;
        contains(arg0: Vec3_): boolean;
        intersect(arg0: Internal.AABB_): this;
        inflate(arg0: number, arg1: number, arg2: number): this;
        contains(arg0: number, arg1: number, arg2: number): boolean;
        intersects(arg0: Vec3_, arg1: Vec3_): boolean;
        min(arg0: Internal.Direction$Axis_): number;
        move(arg0: Vec3_): this;
        getXsize(): number;
        minmax(arg0: Internal.AABB_): this;
        static of(arg0: Internal.BoundingBox_): Internal.AABB;
        intersects(arg0: Internal.AABB_): boolean;
        toString(): string;
        deflate(arg0: number): this;
        setMinZ(arg0: number): this;
        getYsize(): number;
        getSize(): number;
        setMinY(arg0: number): this;
        setMinX(arg0: number): this;
        static clip(arg0: Internal.Iterable_<Internal.AABB_>, arg1: Vec3_, arg2: Vec3_, arg3: BlockPos_): Internal.BlockHitResult;
        contract(arg0: number, arg1: number, arg2: number): this;
        move(arg0: number, arg1: number, arg2: number): this;
        hashCode(): number;
        setMaxY(arg0: number): this;
        intersects(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        setMaxX(arg0: number): this;
        getCenter(): Vec3;
        setMaxZ(arg0: number): this;
        deflate(arg0: number, arg1: number, arg2: number): this;
        move(arg0: BlockPos_): this;
        equals(arg0: any): boolean;
        clip(arg0: Vec3_, arg1: Vec3_): Internal.Optional<Vec3>;
        get zsize(): number
        get xsize(): number
        set minZ(arg0: number)
        get ysize(): number
        get size(): number
        set minY(arg0: number)
        set minX(arg0: number)
        set maxY(arg0: number)
        set maxX(arg0: number)
        get center(): Vec3
        set maxZ(arg0: number)
        readonly "minZ": number;
        readonly "minY": number;
        readonly "minX": number;
        readonly "maxX": number;
        readonly "maxY": number;
        readonly "maxZ": number;
    }
    type AABB_ = AABB;
    class ServerboundSwingPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Hand_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getHand(): Hand;
        isSkippable(): boolean;
        get hand(): Hand
        get skippable(): boolean
    }
    type ServerboundSwingPacket_ = ServerboundSwingPacket;
    class Goat extends Internal.Animal {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getStepHeight(): number;
        static checkGoatSpawnRules(arg0: Internal.EntityType_<any>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        getEatingSound(arg0: Internal.ItemStack_): Internal.SoundEvent;
        getMaxHeadYRot(): number;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getDimensions(arg0: Internal.Pose_): Internal.EntityDimensions;
        getRammingXHeadRot(): number;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        setScreamingGoat(arg0: boolean): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        setYHeadRot(arg0: number): void;
        getBrain(): Internal.Brain<Internal.Goat>;
        isScreamingGoat(): boolean;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get multipartEntity(): boolean
        get maxHeadYRot(): number
        get rammingXHeadRot(): number
        get parts(): Internal.PartEntity<any>[]
        set screamingGoat(arg0: boolean)
        set YHeadRot(arg0: number)
        get brain(): Internal.Brain<Internal.Goat>
        get screamingGoat(): boolean
        readonly static "LONG_JUMPING_DIMENSIONS": Internal.EntityDimensions;
        readonly static "GOAT_FALL_DAMAGE_REDUCTION": 10;
        readonly static "GOAT_SCREAMING_CHANCE": 0.02;
    }
    type Goat_ = Goat;
    class PlayerEvent$HarvestCheck extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.BlockState_, arg2: boolean)
        getTargetBlock(): Internal.BlockState;
        canHarvest(): boolean;
        getListenerList(): Internal.ListenerList;
        setCanHarvest(arg0: boolean): void;
        get targetBlock(): Internal.BlockState
        get listenerList(): Internal.ListenerList
        set canHarvest(arg0: boolean)
    }
    type PlayerEvent$HarvestCheck_ = PlayerEvent$HarvestCheck;
    class LavaSubmergedBlockProcessor extends Internal.StructureProcessor {
        constructor()
        processBlock(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.StructureTemplate$StructureBlockInfo_, arg4: Internal.StructureTemplate$StructureBlockInfo_, arg5: Internal.StructurePlaceSettings_): Internal.StructureTemplate$StructureBlockInfo;
        readonly static "CODEC": any;
        readonly static "INSTANCE": Internal.LavaSubmergedBlockProcessor;
    }
    type LavaSubmergedBlockProcessor_ = LavaSubmergedBlockProcessor;
    interface DoubleConsumer {
        accept(arg0: number): void;
        andThen(arg0: Internal.DoubleConsumer_): this;
    }
    type DoubleConsumer_ = DoubleConsumer | ((arg0: number)=>void);
    interface Map <K, V> {
        replace(arg0: K, arg1: V): V;
        ofEntries(...arg0: Internal.Map$Entry_<any, any>[]): this;
        containsValue(arg0: any): boolean;
        of(): this;
        getOrDefault(arg0: any, arg1: V): V;
        putAll(arg0: Internal.Map_<any, any>): void;
        isEmpty(): boolean;
        entry(arg0: K, arg1: V): Internal.Map$Entry<K, V>;
        of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): this;
        containsKey(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        replaceAll(arg0: Internal.BiFunction_<any, any, any>): void;
        get(arg0: any): V;
        copyOf(arg0: Internal.Map_<any, any>): this;
        remove(arg0: any): V;
        compute(arg0: K, arg1: Internal.BiFunction_<any, any, any>): V;
        merge(arg0: K, arg1: V, arg2: Internal.BiFunction_<any, any, any>): V;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<any, any, any>): V;
        keySet(): Internal.Set<K>;
        putIfAbsent(arg0: K, arg1: V): V;
        of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): this;
        values(): Internal.Collection<V>;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        of(arg0: K, arg1: V, arg2: K, arg3: V): this;
        of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): this;
        remove(arg0: any, arg1: any): boolean;
        computeIfAbsent(arg0: K, arg1: Internal.Function_<any, any>): V;
        of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): this;
        hashCode(): number;
        of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): this;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        size(): number;
        of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): this;
        of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): this;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        clear(): void;
        of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): this;
        equals(arg0: any): boolean;
        of(arg0: K, arg1: V): this;
        get empty(): boolean
    }
    type Map_<K, V> = Map<K, V>;
    class ConcentricRingsStructurePlacement extends Internal.Record implements Internal.StructurePlacement {
        constructor(arg0: number, arg1: number, arg2: number)
        distance(): number;
        count(): number;
        hashCode(): number;
        isFeatureChunk(arg0: Internal.ChunkGenerator_, arg1: number, arg2: number, arg3: number): boolean;
        toString(): string;
        spread(): number;
        equals(arg0: any): boolean;
        type(): Internal.StructurePlacementType<any>;
        readonly static "CODEC": any;
    }
    type ConcentricRingsStructurePlacement_ = ConcentricRingsStructurePlacement;
    class ColumnFeatureConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.IntProvider_, arg1: Internal.IntProvider_)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        reach(): Internal.IntProvider;
        height(): Internal.IntProvider;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
    }
    type ColumnFeatureConfiguration_ = ColumnFeatureConfiguration;
    abstract class EntityRenderer <T> {
        getFont(): Internal.Font;
        getRenderOffset(arg0: T, arg1: number): Vec3;
        getTextureLocation(arg0: T): ResourceLocation;
        render(arg0: T, arg1: number, arg2: number, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number): void;
        getPackedLightCoords(arg0: T, arg1: number): number;
        shouldRender(arg0: T, arg1: Internal.Frustum_, arg2: number, arg3: number, arg4: number): boolean;
        get font(): Internal.Font
    }
    type EntityRenderer_<T> = EntityRenderer<T>;
    abstract class PosRuleTest {
        constructor()
        test(arg0: BlockPos_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.Random_): boolean;
        readonly static "CODEC": any;
    }
    type PosRuleTest_ = PosRuleTest;
    class ClientboundPlayerInfoPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.ClientboundPlayerInfoPacket$Action_, arg1: Internal.Collection_<Internal.ServerPlayer_>)
        constructor(arg0: Internal.ClientboundPlayerInfoPacket$Action_, ...arg1: Internal.ServerPlayer_[])
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        toString(): string;
        getAction(): Internal.ClientboundPlayerInfoPacket$Action;
        getEntries(): Internal.List<Internal.ClientboundPlayerInfoPacket$PlayerUpdate>;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get action(): Internal.ClientboundPlayerInfoPacket$Action
        get entries(): Internal.List<Internal.ClientboundPlayerInfoPacket$PlayerUpdate>
        get skippable(): boolean
    }
    type ClientboundPlayerInfoPacket_ = ClientboundPlayerInfoPacket;
    class RecipeBookType extends Internal.Enum<Internal.RecipeBookType> implements Internal.IExtensibleEnum {
        init(): void;
        static values(): Internal.RecipeBookType[];
        static create(arg0: string): Internal.RecipeBookType;
        static valueOf(arg0: string): Internal.RecipeBookType;
        readonly static "SMOKER": Internal.RecipeBookType;
        readonly static "BLAST_FURNACE": Internal.RecipeBookType;
        readonly static "CRAFTING": Internal.RecipeBookType;
        readonly static "FURNACE": Internal.RecipeBookType;
    }
    type RecipeBookType_ = "crafting" | RecipeBookType | "furnace" | "blast_furnace" | "smoker";
    class ServerboundPlayerActionPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.ServerboundPlayerActionPacket$Action_, arg1: BlockPos_, arg2: Internal.Direction_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getPos(): BlockPos;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getAction(): Internal.ServerboundPlayerActionPacket$Action;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        isSkippable(): boolean;
        getDirection(): Internal.Direction;
        get pos(): BlockPos
        get action(): Internal.ServerboundPlayerActionPacket$Action
        get skippable(): boolean
        get direction(): Internal.Direction
    }
    type ServerboundPlayerActionPacket_ = ServerboundPlayerActionPacket;
    interface InjectedGameEventExtension extends Internal.InjectedRegistryEntryExtension<Internal.GameEvent> {
        arch$registryName(): ResourceLocation;
        arch$holder(): Internal.Holder<Internal.GameEvent>;
    }
    type InjectedGameEventExtension_ = InjectedGameEventExtension;
    interface Stream <T> extends Internal.BaseStream<T, Internal.Stream<T>> {
        mapToDouble(arg0: Internal.ToDoubleFunction_<any>): Internal.DoubleStream;
        collect(arg0: Internal.Supplier_<R>, arg1: Internal.BiConsumer_<R, any>, arg2: Internal.BiConsumer_<R, R>): R;
        reduce(arg0: U, arg1: Internal.BiFunction_<U, any, U>, arg2: Internal.BinaryOperator_<U>): U;
        allMatch(arg0: Internal.Predicate_<any>): boolean;
        concat(arg0: Internal.Stream_<any>, arg1: Internal.Stream_<any>): this;
        flatMapToDouble(arg0: Internal.Function_<any, any>): Internal.DoubleStream;
        iterate(arg0: T, arg1: Internal.UnaryOperator_<T>): this;
        sorted(): this;
        forEach(arg0: Internal.Consumer_<any>): void;
        ofNullable(arg0: T): this;
        reduce(arg0: T, arg1: Internal.BinaryOperator_<T>): T;
        findAny(): Internal.Optional<T>;
        flatMapToLong(arg0: Internal.Function_<any, any>): Internal.LongStream;
        empty(): this;
        flatMapToInt(arg0: Internal.Function_<any, any>): Internal.IntStream;
        mapMulti(arg0: Internal.BiConsumer_<any, any>): Internal.Stream<R>;
        toList(): Internal.List<T>;
        min(arg0: Internal.Comparator_<any>): Internal.Optional<T>;
        mapMultiToInt(arg0: Internal.BiConsumer_<any, any>): Internal.IntStream;
        limit(arg0: number): this;
        mapMultiToDouble(arg0: Internal.BiConsumer_<any, any>): Internal.DoubleStream;
        forEachOrdered(arg0: Internal.Consumer_<any>): void;
        count(): number;
        mapToInt(arg0: Internal.ToIntFunction_<any>): Internal.IntStream;
        sorted(arg0: Internal.Comparator_<any>): this;
        mapMultiToLong(arg0: Internal.BiConsumer_<any, any>): Internal.LongStream;
        anyMatch(arg0: Internal.Predicate_<any>): boolean;
        max(arg0: Internal.Comparator_<any>): Internal.Optional<T>;
        peek(arg0: Internal.Consumer_<any>): this;
        generate(arg0: Internal.Supplier_<any>): this;
        noneMatch(arg0: Internal.Predicate_<any>): boolean;
        dropWhile(arg0: Internal.Predicate_<any>): this;
        toArray(): any[];
        toArray(arg0: Internal.IntFunction_<A[]>): A[];
        collect(arg0: Internal.Collector_<any, A, R>): R;
        reduce(arg0: Internal.BinaryOperator_<T>): Internal.Optional<T>;
        of(arg0: T): this;
        findFirst(): Internal.Optional<T>;
        of(...arg0: T[]): this;
        iterate(arg0: T, arg1: Internal.Predicate_<any>, arg2: Internal.UnaryOperator_<T>): this;
        distinct(): this;
        flatMap(arg0: Internal.Function_<any, any>): Internal.Stream<R>;
        skip(arg0: number): this;
        takeWhile(arg0: Internal.Predicate_<any>): this;
        filter(arg0: Internal.Predicate_<any>): this;
        map(arg0: Internal.Function_<any, any>): Internal.Stream<R>;
        builder(): Internal.Stream$Builder<T>;
        mapToLong(arg0: Internal.ToLongFunction_<any>): Internal.LongStream;
    }
    type Stream_<T> = Stream<T>;
    class Marker extends Internal.Entity {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        tick(): void;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getAddEntityPacket(): Internal.Packet<any>;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getPistonPushReaction(): Internal.PushReaction;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        get addEntityPacket(): Internal.Packet<any>
        get multipartEntity(): boolean
        get pistonPushReaction(): Internal.PushReaction
        get parts(): Internal.PartEntity<any>[]
    }
    type Marker_ = Marker;
    abstract class ClassLoader {
        getUnnamedModule(): Internal.Module;
        static getSystemResource(arg0: string): Internal.URL;
        getParent(): this;
        getResources(arg0: string): Internal.Enumeration<Internal.URL>;
        static getSystemResources(arg0: string): Internal.Enumeration<Internal.URL>;
        getDefinedPackages(): Internal.Package[];
        resources(arg0: string): Internal.Stream<Internal.URL>;
        setDefaultAssertionStatus(arg0: boolean): void;
        setPackageAssertionStatus(arg0: string, arg1: boolean): void;
        clearAssertionStatus(): void;
        setClassAssertionStatus(arg0: string, arg1: boolean): void;
        static getSystemResourceAsStream(arg0: string): Internal.InputStream;
        getName(): string;
        getDefinedPackage(arg0: string): Internal.Package;
        getResource(arg0: string): Internal.URL;
        loadClass(arg0: string): Internal.Class<any>;
        getResourceAsStream(arg0: string): Internal.InputStream;
        isRegisteredAsParallelCapable(): boolean;
        static getPlatformClassLoader(): Internal.ClassLoader;
        static getSystemClassLoader(): Internal.ClassLoader;
        get unnamedModule(): Internal.Module
        get parent(): Internal.ClassLoader
        get definedPackages(): Internal.Package[]
        set defaultAssertionStatus(arg0: boolean)
        get name(): string
        get registeredAsParallelCapable(): boolean
        get platformClassLoader(): Internal.ClassLoader
        get systemClassLoader(): Internal.ClassLoader
    }
    type ClassLoader_ = ClassLoader;
    interface Function8 <T1, T2, T3, T4, T5, T6, T7, T8, R> {
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function<T8, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function3<T6, T7, T8, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function6<T3, T4, T5, T6, T7, T8, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.BiFunction<T7, T8, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8): R;
        curry(): Internal.Function<T1, Internal.Function7<T2, T3, T4, T5, T6, T7, T8, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function4<T5, T6, T7, T8, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function5<T4, T5, T6, T7, T8, R>>;
    }
    type Function8_<T1, T2, T3, T4, T5, T6, T7, T8, R> = Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>;
    class CommandSourceStack implements Internal.IForgeCommandSourceStack, Internal.SharedSuggestionProvider {
        constructor(arg0: Internal.CommandSource_, arg1: Vec3_, arg2: Internal.Vec2_, arg3: Internal.ServerLevel_, arg4: number, arg5: string, arg6: Internal.Component_, arg7: Internal.MinecraftServer_, arg8: Internal.Entity_)
        getDisplayName(): Internal.Component;
        sendFailure(arg0: Internal.Component_): void;
        getSelectedEntities(): Internal.Collection<string>;
        getPosition(): Vec3;
        getLevel(): Internal.ServerLevel;
        getAdvancement(arg0: ResourceLocation_): Internal.Advancement;
        onCommandComplete(arg0: Internal.CommandContext_<Internal.CommandSourceStack_>, arg1: boolean, arg2: number): void;
        withCallback(arg0: Internal.ResultConsumer_<Internal.CommandSourceStack_>, arg1: Internal.BinaryOperator_<Internal.ResultConsumer_<Internal.CommandSourceStack_>>): this;
        withPosition(arg0: Vec3_): this;
        getAvailableSoundEvents(): Internal.Collection<ResourceLocation>;
        withSuppressedOutput(): this;
        hasPermission(arg0: number): boolean;
        getRecipeNames(): Internal.Stream<ResourceLocation>;
        withMaximumPermission(arg0: number): this;
        getRotation(): Internal.Vec2;
        sendSuccess(arg0: Internal.Component_, arg1: boolean): void;
        getAnchor(): Internal.EntityAnchorArgument$Anchor;
        getEntityOrException(): Internal.Entity;
        getTextName(): string;
        getUnsidedLevel(): Internal.Level;
        withLevel(arg0: Internal.ServerLevel_): this;
        withPermission(arg0: number): this;
        withAnchor(arg0: Internal.EntityAnchorArgument$Anchor_): this;
        suggestRegistryElements(arg0: Internal.Registry_<any>, arg1: Internal.SharedSuggestionProvider$ElementSuggestionType_, arg2: Internal.SuggestionsBuilder_): void;
        customSuggestion(arg0: Internal.CommandContext_<any>): Internal.CompletableFuture<Internal.Suggestions>;
        getAllTeams(): Internal.Collection<string>;
        facing(arg0: Internal.Entity_, arg1: Internal.EntityAnchorArgument$Anchor_): this;
        withEntity(arg0: Internal.Entity_): this;
        getPlayerOrException(): Internal.ServerPlayer;
        registryAccess(): Internal.RegistryAccess;
        getRelevantCoordinates(): Internal.Collection<Internal.SharedSuggestionProvider$TextCoordinates>;
        getAbsoluteCoordinates(): Internal.Collection<Internal.SharedSuggestionProvider$TextCoordinates>;
        withRotation(arg0: Internal.Vec2_): this;
        getScoreboard(): Internal.Scoreboard;
        getRecipeManager(): Internal.RecipeManager;
        getEntity(): Internal.Entity;
        suggestRegistryElements(arg0: Internal.ResourceKey_<any>, arg1: Internal.SharedSuggestionProvider$ElementSuggestionType_, arg2: Internal.SuggestionsBuilder_, arg3: Internal.CommandContext_<any>): Internal.CompletableFuture<Internal.Suggestions>;
        facing(arg0: Vec3_): this;
        levels(): Internal.Set<Internal.ResourceKey<Internal.Level>>;
        getOnlinePlayerNames(): Internal.Collection<string>;
        withCallback(arg0: Internal.ResultConsumer_<Internal.CommandSourceStack_>): this;
        getServer(): Internal.MinecraftServer;
        withSource(arg0: Internal.CommandSource_): this;
        get displayName(): Internal.Component
        get selectedEntities(): Internal.Collection<string>
        get position(): Vec3
        get level(): Internal.ServerLevel
        get availableSoundEvents(): Internal.Collection<ResourceLocation>
        get recipeNames(): Internal.Stream<ResourceLocation>
        get rotation(): Internal.Vec2
        get anchor(): Internal.EntityAnchorArgument$Anchor
        get entityOrException(): Internal.Entity
        get textName(): string
        get unsidedLevel(): Internal.Level
        get allTeams(): Internal.Collection<string>
        get playerOrException(): Internal.ServerPlayer
        get relevantCoordinates(): Internal.Collection<Internal.SharedSuggestionProvider$TextCoordinates>
        get absoluteCoordinates(): Internal.Collection<Internal.SharedSuggestionProvider$TextCoordinates>
        get scoreboard(): Internal.Scoreboard
        get recipeManager(): Internal.RecipeManager
        get entity(): Internal.Entity
        get onlinePlayerNames(): Internal.Collection<string>
        get server(): Internal.MinecraftServer
        readonly static "ERROR_NOT_PLAYER": Internal.SimpleCommandExceptionType;
        readonly static "ERROR_NOT_ENTITY": Internal.SimpleCommandExceptionType;
    }
    type CommandSourceStack_ = CommandSourceStack;
    interface Function9 <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> {
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function<T9, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function6<T4, T5, T6, T7, T8, T9, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function4<T6, T7, T8, T9, R>>;
        curry(): Internal.Function<T1, Internal.Function8<T2, T3, T4, T5, T6, T7, T8, T9, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function5<T5, T6, T7, T8, T9, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function7<T3, T4, T5, T6, T7, T8, T9, R>>;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.BiFunction<T8, T9, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9): R;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function3<T7, T8, T9, R>>;
    }
    type Function9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> = Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>;
    interface Function4 <T1, T2, T3, T4, R> {
        curry2(): Internal.BiFunction<T1, T2, Internal.BiFunction<T3, T4, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4): R;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function<T4, R>>;
        curry(): Internal.Function<T1, Internal.Function3<T2, T3, T4, R>>;
    }
    type Function4_<T1, T2, T3, T4, R> = Function4<T1, T2, T3, T4, R>;
    interface Function5 <T1, T2, T3, T4, T5, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5): R;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function<T5, R>>;
        curry(): Internal.Function<T1, Internal.Function4<T2, T3, T4, T5, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.BiFunction<T4, T5, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function3<T3, T4, T5, R>>;
    }
    type Function5_<T1, T2, T3, T4, T5, R> = Function5<T1, T2, T3, T4, T5, R>;
    interface Function6 <T1, T2, T3, T4, T5, T6, R> {
        curry(): Internal.Function<T1, Internal.Function5<T2, T3, T4, T5, T6, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function4<T3, T4, T5, T6, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function<T6, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function3<T4, T5, T6, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.BiFunction<T5, T6, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6): R;
    }
    type Function6_<T1, T2, T3, T4, T5, T6, R> = Function6<T1, T2, T3, T4, T5, T6, R>;
    interface Function7 <T1, T2, T3, T4, T5, T6, T7, R> {
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function<T7, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.BiFunction<T6, T7, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function3<T5, T6, T7, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function4<T4, T5, T6, T7, R>>;
        curry(): Internal.Function<T1, Internal.Function6<T2, T3, T4, T5, T6, T7, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7): R;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function5<T3, T4, T5, T6, T7, R>>;
    }
    type Function7_<T1, T2, T3, T4, T5, T6, T7, R> = Function7<T1, T2, T3, T4, T5, T6, T7, R>;
    interface Object2ObjectFunction <K, V> extends it.unimi.dsi.fastutil.Function<K, V> {
        composeObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Object2ObjectFunction<T, V>;
        getOrDefault(arg0: any, arg1: V): V;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2ObjectFunction<V>;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2ObjectFunction<V>;
        containsKey(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Object2FloatFunction<K>;
        get(arg0: any): V;
        remove(arg0: any): V;
        composeReference(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Reference2ObjectFunction<T, V>;
        andThenReference(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Object2ReferenceFunction<K, T>;
        andThenObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Object2ObjectFunction<K, T>;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2ObjectFunction<V>;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Object2LongFunction<K>;
        apply(arg0: K): V;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2ObjectFunction<V>;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Object2ShortFunction<K>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Object2IntFunction<K>;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Object2DoubleFunction<K>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, V>;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Object2ByteFunction<K>;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2ObjectFunction<V>;
        size(): number;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Object2CharFunction<K>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, V>;
        clear(): void;
        defaultReturnValue(): V;
        defaultReturnValue(arg0: V): void;
    }
    type Object2ObjectFunction_<K, V> = Object2ObjectFunction<K, V> | ((arg0: any)=>V);
    interface Function3 <T1, T2, T3, R> {
        apply(arg0: T1, arg1: T2, arg2: T3): R;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function<T3, R>>;
        curry(): Internal.Function<T1, Internal.BiFunction<T2, T3, R>>;
    }
    type Function3_<T1, T2, T3, R> = Function3<T1, T2, T3, R>;
    interface LevelData {
        getDifficulty(): Internal.Difficulty;
        isThundering(): boolean;
        fillCrashReportCategory(arg0: Internal.CrashReportCategory_, arg1: Internal.LevelHeightAccessor_): void;
        isDifficultyLocked(): boolean;
        isRaining(): boolean;
        getSpawnAngle(): number;
        setRaining(arg0: boolean): void;
        getGameRules(): Internal.GameRules;
        isHardcore(): boolean;
        getYSpawn(): number;
        getGameTime(): number;
        getDayTime(): number;
        getZSpawn(): number;
        getXSpawn(): number;
        get difficulty(): Internal.Difficulty
        get thundering(): boolean
        get difficultyLocked(): boolean
        get raining(): boolean
        get spawnAngle(): number
        set raining(arg0: boolean)
        get gameRules(): Internal.GameRules
        get hardcore(): boolean
        get YSpawn(): number
        get gameTime(): number
        get dayTime(): number
        get ZSpawn(): number
        get XSpawn(): number
    }
    type LevelData_ = LevelData;
    interface NativeResource extends Internal.AutoCloseable {
        free(): void;
        close(): void;
    }
    type NativeResource_ = NativeResource;
    class MetricSampler {
        triggersThreshold(): boolean;
        hashCode(): number;
        static builder(arg0: string, arg1: Internal.MetricCategory_, arg2: Internal.ToDoubleFunction_<T>, arg3: T): Internal.MetricSampler$MetricSamplerBuilder<T>;
        static create(arg0: string, arg1: Internal.MetricCategory_, arg2: T, arg3: Internal.ToDoubleFunction_<T>): Internal.MetricSampler;
        result(): Internal.MetricSampler$SamplerResult;
        static create(arg0: string, arg1: Internal.MetricCategory_, arg2: Internal.DoubleSupplier_): Internal.MetricSampler;
        getName(): string;
        getCategory(): Internal.MetricCategory;
        equals(arg0: any): boolean;
        onFinished(): void;
        onStartTick(): void;
        onEndTick(arg0: number): void;
        get name(): string
        get category(): Internal.MetricCategory
    }
    type MetricSampler_ = MetricSampler;
    interface Aquifer$FluidPicker {
        computeFluid(arg0: number, arg1: number, arg2: number): Internal.Aquifer$FluidStatus;
    }
    type Aquifer$FluidPicker_ = Aquifer$FluidPicker;
    class StructureSet$StructureSelectionEntry extends Internal.Record {
        constructor(arg0: Internal.Holder_<Internal.ConfiguredStructureFeature_<any, any>>, arg1: number)
        hashCode(): number;
        toString(): string;
        structure(): Internal.Holder<Internal.ConfiguredStructureFeature<any, any>>;
        weight(): number;
        equals(arg0: any): boolean;
        generatesInMatchingBiome(arg0: Internal.Predicate_<Internal.Holder_<Internal.Biome_>>): boolean;
        readonly static "CODEC": any;
    }
    type StructureSet$StructureSelectionEntry_ = StructureSet$StructureSelectionEntry;
    class ClientboundSetDisplayObjectivePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: Internal.Objective_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getSlot(): number;
        isSkippable(): boolean;
        getObjectiveName(): string;
        get slot(): number
        get skippable(): boolean
        get objectiveName(): string
    }
    type ClientboundSetDisplayObjectivePacket_ = ClientboundSetDisplayObjectivePacket;
    class ScreenOpenEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.Screen_)
        setScreen(arg0: Internal.Screen_): void;
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        getScreen(): Internal.Screen;
        set screen(arg0: Internal.Screen_)
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
        get screen(): Internal.Screen
    }
    type ScreenOpenEvent_ = ScreenOpenEvent;
    class ClickType extends Internal.Enum<Internal.ClickType> {
        static values(): Internal.ClickType[];
        static valueOf(arg0: string): Internal.ClickType;
        readonly static "QUICK_CRAFT": Internal.ClickType;
        readonly static "PICKUP_ALL": Internal.ClickType;
        readonly static "QUICK_MOVE": Internal.ClickType;
        readonly static "CLONE": Internal.ClickType;
        readonly static "THROW": Internal.ClickType;
        readonly static "PICKUP": Internal.ClickType;
        readonly static "SWAP": Internal.ClickType;
    }
    type ClickType_ = "pickup" | "quick_move" | ClickType | "quick_craft" | "pickup_all" | "throw" | "swap" | "clone";
    class CommandContext <S> {
        constructor(arg0: S, arg1: string, arg2: Internal.Map_<string, Internal.ParsedArgument_<S, any>>, arg3: Internal.Command_<S>, arg4: Internal.CommandNode_<S>, arg5: Internal.List_<Internal.ParsedCommandNode_<S>>, arg6: Internal.StringRange_, arg7: Internal.CommandContext_<S>, arg8: Internal.RedirectModifier_<S>, arg9: boolean)
        getNodes(): Internal.List<Internal.ParsedCommandNode<S>>;
        getInput(): string;
        getLastChild(): this;
        getChild(): this;
        isForked(): boolean;
        getRedirectModifier(): Internal.RedirectModifier<S>;
        getArgument(arg0: string, arg1: Internal.Class_<V>): V;
        getSource(): S;
        hashCode(): number;
        getRootNode(): Internal.CommandNode<S>;
        copyFor(arg0: S): this;
        hasNodes(): boolean;
        getCommand(): Internal.Command<S>;
        equals(arg0: any): boolean;
        getRange(): Internal.StringRange;
        get nodes(): Internal.List<Internal.ParsedCommandNode<S>>
        get input(): string
        get lastChild(): Internal.CommandContext<S>
        get child(): Internal.CommandContext<S>
        get forked(): boolean
        get redirectModifier(): Internal.RedirectModifier<S>
        get source(): S
        get rootNode(): Internal.CommandNode<S>
        get command(): Internal.Command<S>
        get range(): Internal.StringRange
    }
    type CommandContext_<S> = CommandContext<S>;
    class RandomizedIntStateProvider extends Internal.BlockStateProvider {
        constructor(arg0: Internal.BlockStateProvider_, arg1: string, arg2: Internal.IntProvider_)
        constructor(arg0: Internal.BlockStateProvider_, arg1: Internal.IntegerProperty_, arg2: Internal.IntProvider_)
        getState(arg0: Internal.Random_, arg1: BlockPos_): Internal.BlockState;
        readonly static "CODEC": any;
    }
    type RandomizedIntStateProvider_ = RandomizedIntStateProvider;
    abstract class TextureAtlasHolder extends Internal.SimplePreparableReloadListener<Internal.TextureAtlas$Preparations> implements Internal.AutoCloseable {
        constructor(arg0: Internal.TextureManager_, arg1: ResourceLocation_, arg2: string)
        close(): void;
        getName(): string;
        get name(): string
    }
    type TextureAtlasHolder_ = TextureAtlasHolder;
    class Lifecycle {
        static experimental(): Internal.Lifecycle;
        static deprecated(arg0: number): Internal.Lifecycle;
        add(arg0: Internal.Lifecycle_): this;
        static stable(): Internal.Lifecycle;
    }
    type Lifecycle_ = Lifecycle;
    class DedicatedServerProperties$WorldGenProperties extends Internal.Record {
        constructor(arg0: string, arg1: Internal.JsonObject_, arg2: boolean, arg3: string)
        levelSeed(): string;
        hashCode(): number;
        toString(): string;
        levelType(): string;
        equals(arg0: any): boolean;
        generateStructures(): boolean;
        generatorSettings(): Internal.JsonObject;
    }
    type DedicatedServerProperties$WorldGenProperties_ = DedicatedServerProperties$WorldGenProperties;
    class RayTraceResultJS {
        constructor(from: Internal.EntityJS_, result: Internal.HitResult_, d: number)
        readonly "fromEntity": Internal.EntityJS;
        readonly "type": string;
        "facing": Internal.Direction;
        "block": Internal.BlockContainerJS;
        "hitZ": number;
        "hitY": number;
        readonly "distance": number;
        "entity": Internal.EntityJS;
        "hitX": number;
    }
    type RayTraceResultJS_ = RayTraceResultJS;
    class BrewingStandBlockEntity extends Internal.BaseContainerBlockEntity implements Internal.WorldlyContainer {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        stopOpen(arg0: Internal.Player_): void;
        getCapability(arg0: Internal.Capability_<T>, arg1: Internal.Direction_): Internal.LazyOptional<T>;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        countItem(arg0: Internal.Item_): number;
        isEmpty(): boolean;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        removeItem(arg0: number, arg1: number): Internal.ItemStack;
        load(arg0: Internal.CompoundTag_): void;
        canPlaceItemThroughFace(arg0: number, arg1: Internal.ItemStack_, arg2: Internal.Direction_): boolean;
        onLoad(): void;
        getContainerSize(): number;
        getSlotsForFace(arg0: Internal.Direction_): number[];
        setItem(arg0: number, arg1: Internal.ItemStack_): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        invalidateCaps(): void;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMaxStackSize(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        removeItemNoUpdate(arg0: number): Internal.ItemStack;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        stillValid(arg0: Internal.Player_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getItem(arg0: number): Internal.ItemStack;
        static serverTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BrewingStandBlockEntity_): void;
        clearContent(): void;
        reviveCaps(): void;
        canTakeItemThroughFace(arg0: number, arg1: Internal.ItemStack_, arg2: Internal.Direction_): boolean;
        getRenderBoundingBox(): Internal.AABB;
        get empty(): boolean
        get containerSize(): number
        get modelData(): Internal.IModelData
        get maxStackSize(): number
        get renderBoundingBox(): Internal.AABB
        readonly static "FUEL_USES": 20;
        readonly static "DATA_BREW_TIME": 0;
        readonly static "DATA_FUEL_USES": 1;
        readonly static "NUM_DATA_VALUES": 2;
    }
    type BrewingStandBlockEntity_ = BrewingStandBlockEntity;
    abstract class ShapedBlockBuilder extends Internal.BlockBuilder {
        constructor(i: ResourceLocation_, ...suffixes: string[])
        textureAll(tex: string): Internal.BlockBuilder;
    }
    type ShapedBlockBuilder_ = ShapedBlockBuilder;
    class ProtectionDomain {
        constructor(arg0: Internal.CodeSource_, arg1: Internal.PermissionCollection_)
        constructor(arg0: Internal.CodeSource_, arg1: Internal.PermissionCollection_, arg2: Internal.ClassLoader_, arg3: Internal.Principal_[])
        getPermissions(): Internal.PermissionCollection;
        toString(): string;
        getPrincipals(): Internal.Principal[];
        getCodeSource(): Internal.CodeSource;
        getClassLoader(): Internal.ClassLoader;
        implies(arg0: Internal.Permission_): boolean;
        staticPermissionsOnly(): boolean;
        get permissions(): Internal.PermissionCollection
        get principals(): Internal.Principal[]
        get codeSource(): Internal.CodeSource
        get classLoader(): Internal.ClassLoader
    }
    type ProtectionDomain_ = ProtectionDomain;
    interface Int2ObjectMap <V> extends Internal.Int2ObjectFunction<V>, Internal.Map<number, V> {
        compute(arg0: number, arg1: Internal.BiFunction_<any, any, any>): V;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2ObjectFunction<V>;
        put(arg0: number, arg1: V): V;
        containsKey(arg0: number): boolean;
        keySet(): Internal.Set<any>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Int2ByteFunction;
        putIfAbsent(arg0: number, arg1: V): V;
        replace(arg0: number, arg1: V): V;
        get(arg0: any): V;
        apply(arg0: number): V;
        put(arg0: any, arg1: any): any;
        apply(arg0: number): V;
        values(): Internal.Collection<any>;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<any, any, any>): V;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2ObjectFunction<V>;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Int2DoubleFunction;
        merge(arg0: number, arg1: V, arg2: Internal.BiFunction_<any, any, any>): V;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Int2IntFunction;
        remove(arg0: number): V;
        getOrDefault(arg0: number, arg1: V): V;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Int2FloatFunction;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2ObjectFunction<V>;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2ObjectFunction<V>;
        defaultReturnValue(): V;
        composeObject(arg0: Internal.Object2IntFunction_<any>): Internal.Object2ObjectFunction<T, V>;
        andThenReference(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Int2ReferenceFunction<T>;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<any, any, any>): V;
        defaultReturnValue(arg0: V): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Int2CharFunction;
        replace(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        replace(arg0: number, arg1: V, arg2: V): boolean;
        remove(arg0: number, arg1: any): boolean;
        int2ObjectEntrySet(): Internal.ObjectSet<Internal.Int2ObjectMap$Entry<V>>;
        containsKey(arg0: any): boolean;
        replaceAll(arg0: Internal.BiFunction_<any, any, any>): void;
        put(arg0: number, arg1: V): V;
        merge(arg0: number, arg1: V, arg2: Internal.BiFunction_<any, any, any>): V;
        computeIfAbsent(arg0: number, arg1: Internal.Int2ObjectFunction_<any>): V;
        replace(arg0: number, arg1: V, arg2: V): boolean;
        remove(arg0: any): V;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, V>>;
        andThenObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Int2ObjectFunction<T>;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2ObjectFunction<V>;
        putIfAbsent(arg0: number, arg1: V): V;
        remove(arg0: any, arg1: any): boolean;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Int2ShortFunction;
        computeIfAbsent(arg0: number, arg1: Internal.IntFunction_<any>): V;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2ObjectFunction<V>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        size(): number;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Int2LongFunction;
        computeIfAbsent(arg0: number, arg1: Internal.Function_<any, any>): V;
        clear(): void;
        computeIfAbsentPartial(arg0: number, arg1: Internal.Int2ObjectFunction_<any>): V;
        compute(arg0: number, arg1: Internal.BiFunction_<any, any, any>): V;
        composeReference(arg0: Internal.Reference2IntFunction_<any>): Internal.Reference2ObjectFunction<T, V>;
    }
    type Int2ObjectMap_<V> = Int2ObjectMap<V>;
    interface WritableByteChannel extends Internal.Channel {
        write(arg0: Internal.ByteBuffer_): number;
    }
    type WritableByteChannel_ = WritableByteChannel;
    class LivingDropsEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.LivingEntity_, arg1: Internal.DamageSource_, arg2: Internal.Collection_<Internal.ItemEntity_>, arg3: number, arg4: boolean)
        isCancelable(): boolean;
        getDrops(): Internal.Collection<Internal.ItemEntity>;
        getListenerList(): Internal.ListenerList;
        getSource(): Internal.DamageSource;
        isRecentlyHit(): boolean;
        getLootingLevel(): number;
        get cancelable(): boolean
        get drops(): Internal.Collection<Internal.ItemEntity>
        get listenerList(): Internal.ListenerList
        get source(): Internal.DamageSource
        get recentlyHit(): boolean
        get lootingLevel(): number
    }
    type LivingDropsEvent_ = LivingDropsEvent;
    interface DoubleCollection extends Internal.DoubleIterable, Internal.Collection<number> {
        add(arg0: number): boolean;
        addAll(arg0: Internal.DoubleCollection_): boolean;
        containsAll(arg0: Internal.DoubleCollection_): boolean;
        retainAll(arg0: Internal.DoubleCollection_): boolean;
        forEach(arg0: Internal.Consumer_<any>): void;
        removeIf(arg0: Internal.DoublePredicate_): boolean;
        stream(): Internal.Stream<number>;
        add(arg0: number): boolean;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        doubleParallelStream(): Internal.DoubleStream;
        doubleStream(): Internal.DoubleStream;
        toArray(arg0: number[]): number[];
        rem(arg0: number): boolean;
        contains(arg0: any): boolean;
        forEach(arg0: it.unimi.dsi.fastutil.doubles.DoubleConsumer_): void;
        removeIf(arg0: it.unimi.dsi.fastutil.doubles.DoublePredicate_): boolean;
        removeAll(arg0: Internal.DoubleCollection_): boolean;
        remove(arg0: any): boolean;
        contains(arg0: number): boolean;
        toDoubleArray(arg0: number[]): number[];
        doubleIterator(): Internal.DoubleIterator;
        add(arg0: any): boolean;
        parallelStream(): Internal.Stream<number>;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        doubleSpliterator(): Internal.DoubleSpliterator;
        spliterator(): Internal.Spliterator<any>;
        forEach(arg0: Internal.DoubleConsumer_): void;
        toDoubleArray(): number[];
        iterator(): Internal.DoubleIterator;
    }
    type DoubleCollection_ = DoubleCollection;
    abstract class FloatBuffer extends Internal.Buffer implements Internal.Comparable<Internal.FloatBuffer> {
        put(arg0: number[], arg1: number, arg2: number): this;
        compareTo(arg0: Internal.FloatBuffer_): number;
        reset(): Internal.Buffer;
        isDirect(): boolean;
        limit(arg0: number): this;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): this;
        arrayOffset(): number;
        static wrap(arg0: number[]): Internal.FloatBuffer;
        static allocate(arg0: number): Internal.FloatBuffer;
        compareTo(arg0: any): number;
        compact(): this;
        get(arg0: number[], arg1: number, arg2: number): this;
        flip(): Internal.Buffer;
        clear(): Internal.Buffer;
        order(): Internal.ByteOrder;
        put(arg0: number, arg1: Internal.FloatBuffer_, arg2: number, arg3: number): this;
        hasArray(): boolean;
        put(arg0: number[]): this;
        mismatch(arg0: Internal.FloatBuffer_): number;
        put(arg0: number): this;
        get(): number;
        toString(): string;
        position(arg0: number): this;
        rewind(): Internal.Buffer;
        duplicate(): this;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.FloatBuffer;
        mark(): Internal.Buffer;
        put(arg0: number, arg1: number[]): this;
        put(arg0: Internal.FloatBuffer_): this;
        get(arg0: number[]): this;
        hashCode(): number;
        put(arg0: number, arg1: number): this;
        slice(): Internal.Buffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): this;
        array(): number[];
        get(arg0: number): number;
        slice(arg0: number, arg1: number): Internal.Buffer;
        equals(arg0: any): boolean;
        get(arg0: number, arg1: number[]): this;
        asReadOnlyBuffer(): this;
        get direct(): boolean
    }
    type FloatBuffer_ = FloatBuffer;
    class StructureBlockEntity$UpdateType extends Internal.Enum<Internal.StructureBlockEntity$UpdateType> {
        static values(): Internal.StructureBlockEntity$UpdateType[];
        static valueOf(arg0: string): Internal.StructureBlockEntity$UpdateType;
        readonly static "SAVE_AREA": Internal.StructureBlockEntity$UpdateType;
        readonly static "UPDATE_DATA": Internal.StructureBlockEntity$UpdateType;
        readonly static "LOAD_AREA": Internal.StructureBlockEntity$UpdateType;
        readonly static "SCAN_AREA": Internal.StructureBlockEntity$UpdateType;
    }
    type StructureBlockEntity$UpdateType_ = "save_area" | StructureBlockEntity$UpdateType | "scan_area" | "update_data" | "load_area";
    class ScreenEvent$MouseDragEvent$Pre extends Internal.ScreenEvent$MouseDragEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$MouseDragEvent$Pre_ = ScreenEvent$MouseDragEvent$Pre;
    class Activity extends Internal.ForgeRegistryEntry<Internal.Activity> {
        constructor(arg0: string)
        hashCode(): number;
        toString(): string;
        getName(): string;
        equals(arg0: any): boolean;
        get name(): string
        readonly static "MEET": Internal.Activity;
        readonly static "PLAY": Internal.Activity;
        readonly static "FIGHT": Internal.Activity;
        readonly static "AVOID": Internal.Activity;
        readonly static "PLAY_DEAD": Internal.Activity;
        readonly static "LONG_JUMP": Internal.Activity;
        readonly static "RAM": Internal.Activity;
        readonly static "WORK": Internal.Activity;
        readonly static "PANIC": Internal.Activity;
        readonly static "CORE": Internal.Activity;
        readonly static "PRE_RAID": Internal.Activity;
        readonly static "RAID": Internal.Activity;
        readonly static "HIDE": Internal.Activity;
        readonly static "CELEBRATE": Internal.Activity;
        readonly static "ADMIRE_ITEM": Internal.Activity;
        readonly static "RIDE": Internal.Activity;
        readonly static "IDLE": Internal.Activity;
        readonly static "REST": Internal.Activity;
    }
    type Activity_ = Activity | Special.Activity;
    abstract class AbstractConstant <T> implements Internal.Constant<T> {
        name(): string;
        compareTo(arg0: T): number;
        hashCode(): number;
        toString(): string;
        id(): number;
        equals(arg0: any): boolean;
        compareTo(arg0: any): number;
    }
    type AbstractConstant_<T> = AbstractConstant<T>;
    interface Short2DoubleFunction extends Internal.IntToDoubleFunction, it.unimi.dsi.fastutil.Function<number, number> {
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2DoubleFunction;
        put(arg0: number, arg1: number): number;
        andThenReference(arg0: Internal.Double2ReferenceFunction_<any>): Internal.Short2ReferenceFunction<T>;
        apply(arg0: number): number;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2DoubleFunction;
        applyAsDouble(arg0: number): number;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2DoubleFunction;
        getOrDefault(arg0: any, arg1: any): any;
        get(arg0: any): number;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Short2CharFunction;
        remove(arg0: number): number;
        get(arg0: number): number;
        containsKey(arg0: any): boolean;
        andThenObject(arg0: Internal.Double2ObjectFunction_<any>): Internal.Short2ObjectFunction<T>;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2DoubleFunction;
        put(arg0: any, arg1: any): any;
        defaultReturnValue(arg0: number): void;
        put(arg0: number, arg1: number): number;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Short2FloatFunction;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Short2IntFunction;
        containsKey(arg0: number): boolean;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        composeReference(arg0: Internal.Reference2ShortFunction_<any>): Internal.Reference2DoubleFunction<T>;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Short2LongFunction;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2DoubleFunction;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2DoubleFunction;
        defaultReturnValue(): number;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Short2ShortFunction;
        size(): number;
        composeShort(arg0: Internal.Short2ShortFunction_): this;
        clear(): void;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): this;
        remove(arg0: any): any;
        composeObject(arg0: Internal.Object2ShortFunction_<any>): Internal.Object2DoubleFunction<T>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Short2ByteFunction;
    }
    type Short2DoubleFunction_ = ((arg0: number)=>number) | Short2DoubleFunction;
    class ClientboundPlayerCombatEnterPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor()
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get skippable(): boolean
    }
    type ClientboundPlayerCombatEnterPacket_ = ClientboundPlayerCombatEnterPacket;
    class Either$Mu <R> implements Internal.K1 {
        constructor()
    }
    type Either$Mu_<R> = Either$Mu<R>;
    class BlockLootEventJS extends Internal.LootEventJS {
        constructor(c: Internal.Map_<ResourceLocation_, Internal.JsonElement_>)
        addSimpleBlock(blocks: BlockStatePredicate_, item: Internal.ItemStack_): void;
        addBlock(blocks: BlockStatePredicate_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        modifyBlock(blocks: BlockStatePredicate_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        getType(): string;
        addSimpleBlock(blocks: BlockStatePredicate_): void;
        getDirectory(): string;
        build(blocks: BlockStatePredicate_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        get type(): string
        get directory(): string
    }
    type BlockLootEventJS_ = BlockLootEventJS;
    class HopperBlockEntity extends Internal.RandomizableContainerBlockEntity implements Internal.Hopper {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        stopOpen(arg0: Internal.Player_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        countItem(arg0: Internal.Item_): number;
        static pushItemsTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.HopperBlockEntity_): void;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        isOnCustomCooldown(): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        removeItem(arg0: number, arg1: number): Internal.ItemStack;
        load(arg0: Internal.CompoundTag_): void;
        static entityInside(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.Entity_, arg4: Internal.HopperBlockEntity_): void;
        onLoad(): void;
        getContainerSize(): number;
        setItem(arg0: number, arg1: Internal.ItemStack_): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        static suckInItems(arg0: Internal.Level_, arg1: Internal.Hopper_): boolean;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMaxStackSize(): number;
        static addItem(arg0: Internal.Container_, arg1: Internal.Container_, arg2: Internal.ItemStack_, arg3: Internal.Direction_): Internal.ItemStack;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getLastUpdateTime(): number;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        setCooldown(arg0: number): void;
        static addItem(arg0: Internal.Container_, arg1: Internal.ItemEntity_): boolean;
        static getItemsAtAndAbove(arg0: Internal.Level_, arg1: Internal.Hopper_): Internal.List<Internal.ItemEntity>;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getSuckShape(): Internal.VoxelShape;
        getLevelX(): number;
        static getContainerAt(arg0: Internal.Level_, arg1: BlockPos_): Internal.Container;
        getLevelY(): number;
        getLevelZ(): number;
        getRenderBoundingBox(): Internal.AABB;
        get onCustomCooldown(): boolean
        get containerSize(): number
        get modelData(): Internal.IModelData
        get maxStackSize(): number
        get lastUpdateTime(): number
        set cooldown(arg0: number)
        get suckShape(): Internal.VoxelShape
        get levelX(): number
        get levelY(): number
        get levelZ(): number
        get renderBoundingBox(): Internal.AABB
        readonly static "HOPPER_CONTAINER_SIZE": 5;
        readonly static "MOVE_ITEM_SPEED": 8;
    }
    type HopperBlockEntity_ = HopperBlockEntity;
    class Raid {
        constructor(arg0: Internal.ServerLevel_, arg1: Internal.CompoundTag_)
        constructor(arg0: number, arg1: Internal.ServerLevel_, arg2: BlockPos_)
        isVictory(): boolean;
        isOver(): boolean;
        getTotalHealth(): number;
        addHeroOfTheVillage(arg0: Internal.Entity_): void;
        removeFromRaid(arg0: Internal.Raider_, arg1: boolean): void;
        getGroupsSpawned(): number;
        getMaxBadOmenLevel(): number;
        updateBossbar(): void;
        isActive(): boolean;
        isStarted(): boolean;
        save(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        getAllRaiders(): Internal.Set<Internal.Raider>;
        getLevel(): Internal.Level;
        static getLeaderBannerInstance(): Internal.ItemStack;
        getCenter(): BlockPos;
        isLoss(): boolean;
        getHealthOfLivingRaiders(): number;
        removeLeader(arg0: number): void;
        getNumGroups(arg0: Internal.Difficulty_): number;
        isBetweenWaves(): boolean;
        setLeader(arg0: number, arg1: Internal.Raider_): void;
        getEnchantOdds(): number;
        getId(): number;
        setBadOmenLevel(arg0: number): void;
        isStopped(): boolean;
        addWaveMob(arg0: number, arg1: Internal.Raider_, arg2: boolean): boolean;
        getLeader(arg0: number): Internal.Raider;
        tick(): void;
        absorbBadOmen(arg0: Internal.Player_): void;
        stop(): void;
        hasFirstWaveSpawned(): boolean;
        getTotalRaidersAlive(): number;
        joinRaid(arg0: number, arg1: Internal.Raider_, arg2: BlockPos_, arg3: boolean): void;
        getBadOmenLevel(): number;
        get victory(): boolean
        get over(): boolean
        get totalHealth(): number
        get groupsSpawned(): number
        get maxBadOmenLevel(): number
        get active(): boolean
        get started(): boolean
        get allRaiders(): Internal.Set<Internal.Raider>
        get level(): Internal.Level
        get leaderBannerInstance(): Internal.ItemStack
        get center(): BlockPos
        get loss(): boolean
        get healthOfLivingRaiders(): number
        get betweenWaves(): boolean
        get enchantOdds(): number
        get id(): number
        set badOmenLevel(arg0: number)
        get stopped(): boolean
        get totalRaidersAlive(): number
        get badOmenLevel(): number
        readonly static "VALID_RAID_RADIUS_SQR": 9216;
        readonly static "TICKS_PER_DAY": 24000;
        readonly static "MAX_NO_ACTION_TIME": 2400;
        readonly static "VILLAGE_RADIUS_BUFFER": 16;
        readonly static "DEFAULT_MAX_BAD_OMEN_LEVEL": 5;
        readonly static "MAX_CELEBRATION_TICKS": 600;
        readonly static "RAID_REMOVAL_THRESHOLD_SQR": 12544;
    }
    type Raid_ = Raid;
    interface Object2ByteFunction <K> extends Internal.ToIntFunction<K>, it.unimi.dsi.fastutil.Function<K, number> {
        getOrDefault(arg0: any, arg1: number): number;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Object2IntFunction<K>;
        getOrDefault(arg0: any, arg1: any): any;
        put(arg0: K, arg1: number): number;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2ByteFunction;
        composeObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Object2ByteFunction<T>;
        put(arg0: K, arg1: number): number;
        composeReference(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Reference2ByteFunction<T>;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Object2CharFunction<K>;
        containsKey(arg0: any): boolean;
        defaultReturnValue(arg0: number): void;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2ByteFunction;
        andThenByte(arg0: Internal.Byte2ByteFunction_): this;
        removeByte(arg0: any): number;
        apply(arg0: K): number;
        remove(arg0: any): number;
        put(arg0: any, arg1: any): any;
        defaultReturnValue(): number;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2ByteFunction;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Object2FloatFunction<K>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2ByteFunction;
        applyAsInt(arg0: K): number;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Object2LongFunction<K>;
        andThenReference(arg0: Internal.Byte2ReferenceFunction_<any>): Internal.Object2ReferenceFunction<K, T>;
        getOrDefault(arg0: any, arg1: number): number;
        getByte(arg0: any): number;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Object2ShortFunction<K>;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2ByteFunction;
        size(): number;
        clear(): void;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        andThenObject(arg0: Internal.Byte2ObjectFunction_<any>): Internal.Object2ObjectFunction<K, T>;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2ByteFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2ByteFunction;
        get(arg0: any): any;
    }
    type Object2ByteFunction_<K> = Object2ByteFunction<K> | ((arg0: any)=>number);
    class LootContext$EntityTarget extends Internal.Enum<Internal.LootContext$EntityTarget> implements Internal.EntityTargetKJS {
        static getByName(arg0: string): Internal.LootContext$EntityTarget;
        getName(): string;
        static values(): Internal.LootContext$EntityTarget[];
        getParam(): Internal.LootContextParam<any>;
        static valueOf(arg0: string): Internal.LootContext$EntityTarget;
        getNameKJS(): string;
        get name(): string
        get param(): Internal.LootContextParam<any>
        get nameKJS(): string
        readonly static "KILLER": Internal.LootContext$EntityTarget;
        readonly static "THIS": Internal.LootContext$EntityTarget;
        readonly static "DIRECT_KILLER": Internal.LootContext$EntityTarget;
        readonly static "KILLER_PLAYER": Internal.LootContext$EntityTarget;
    }
    type LootContext$EntityTarget_ = "killer" | LootContext$EntityTarget | "killer_player" | "this" | "direct_killer";
    class AttributeSupplier {
        constructor(arg0: Internal.Map_<Internal.Attribute_, Internal.AttributeInstance_>)
        hasAttribute(arg0: Internal.Attribute_): boolean;
        getBaseValue(arg0: Internal.Attribute_): number;
        getValue(arg0: Internal.Attribute_): number;
        hasModifier(arg0: Internal.Attribute_, arg1: Internal.UUID_): boolean;
        createInstance(arg0: Internal.Consumer_<Internal.AttributeInstance_>, arg1: Internal.Attribute_): Internal.AttributeInstance;
        getModifierValue(arg0: Internal.Attribute_, arg1: Internal.UUID_): number;
        static builder(): Internal.AttributeSupplier$Builder;
    }
    type AttributeSupplier_ = AttributeSupplier;
    class PlayerEvent$StartTracking extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.Entity_)
        getTarget(): Internal.Entity;
        getListenerList(): Internal.ListenerList;
        get target(): Internal.Entity
        get listenerList(): Internal.ListenerList
    }
    type PlayerEvent$StartTracking_ = PlayerEvent$StartTracking;
    class ResultField implements Internal.Comparable<Internal.ResultField> {
        constructor(arg0: string, arg1: number, arg2: number, arg3: number)
        getColor(): number;
        compareTo(arg0: Internal.ResultField_): number;
        compareTo(arg0: any): number;
        get color(): number
        readonly "percentage": number;
        readonly "globalPercentage": number;
        readonly "name": string;
        readonly "count": number;
    }
    type ResultField_ = ResultField;
    abstract class KeyModifier extends Internal.Enum<Internal.KeyModifier> {
        static values(): Internal.KeyModifier[];
        static isKeyCodeModifier(arg0: Internal.InputConstants$Key_): boolean;
        static valueOf(arg0: string): Internal.KeyModifier;
        matches(arg0: Internal.InputConstants$Key_): boolean;
        isActive(arg0: Internal.IKeyConflictContext_): boolean;
        getCombinedName(arg0: Internal.InputConstants$Key_, arg1: Internal.Supplier_<Internal.Component_>): Internal.Component;
        static valueFromString(arg0: string): Internal.KeyModifier;
        static getActiveModifier(): Internal.KeyModifier;
        get activeModifier(): Internal.KeyModifier
        readonly static "NONE": any;
        readonly static "ALT": any;
        readonly static "SHIFT": any;
        readonly static "MODIFIER_VALUES": any;
        readonly static "CONTROL": any;
    }
    type KeyModifier_ = "alt" | KeyModifier | "control" | "shift" | "none";
    class Cow extends Internal.Animal {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type Cow_ = Cow;
    class Slot {
        constructor(arg0: Internal.Container_, arg1: number, arg2: number, arg3: number)
        onTake(arg0: Internal.Player_, arg1: Internal.ItemStack_): void;
        allowModification(arg0: Internal.Player_): boolean;
        set(arg0: Internal.ItemStack_): void;
        safeInsert(arg0: Internal.ItemStack_): Internal.ItemStack;
        tryRemove(arg0: number, arg1: number, arg2: Internal.Player_): Internal.Optional<Internal.ItemStack>;
        getMaxStackSize(): number;
        isSameInventory(arg0: Internal.Slot_): boolean;
        getItem(): Internal.ItemStack;
        isActive(): boolean;
        mayPickup(arg0: Internal.Player_): boolean;
        remove(arg0: number): Internal.ItemStack;
        getMaxStackSize(arg0: Internal.ItemStack_): number;
        mayPlace(arg0: Internal.ItemStack_): boolean;
        setChanged(): void;
        getNoItemIcon(): com.mojang.datafixers.util.Pair<ResourceLocation, ResourceLocation>;
        onQuickCraft(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): void;
        safeInsert(arg0: Internal.ItemStack_, arg1: number): Internal.ItemStack;
        hasItem(): boolean;
        safeTake(arg0: number, arg1: number, arg2: Internal.Player_): Internal.ItemStack;
        getSlotIndex(): number;
        getContainerSlot(): number;
        setBackground(arg0: ResourceLocation_, arg1: ResourceLocation_): this;
        get maxStackSize(): number
        get item(): Internal.ItemStack
        get active(): boolean
        get noItemIcon(): com.mojang.datafixers.util.Pair<ResourceLocation, ResourceLocation>
        get slotIndex(): number
        get containerSlot(): number
        "index": number;
        readonly "x": number;
        readonly "y": number;
        readonly "container": Internal.Container;
    }
    type Slot_ = Slot;
    class Blender {
        getBiomeResolver(arg0: Internal.BiomeResolver_): Internal.BiomeResolver;
        blendOffsetAndFactor(arg0: number, arg1: number): Internal.Blender$BlendingOutput;
        static generateBorderTicks(arg0: Internal.WorldGenRegion_, arg1: Internal.ChunkAccess_): void;
        blendDensity(arg0: Internal.DensityFunction$FunctionContext_, arg1: number): number;
        static empty(): Internal.Blender;
        static makeOldChunkDistanceGetter(arg0: boolean, arg1: Internal.Set_<Internal.Direction8_>): Internal.Blender$DistanceGetter;
        static addAroundOldChunksCarvingMaskFilter(arg0: Internal.WorldGenLevel_, arg1: Internal.ProtoChunk_): void;
        static of(arg0: Internal.WorldGenRegion_): Internal.Blender;
    }
    type Blender_ = Blender;
    interface FloatProviderType <P> {
        codec(): Internal.Codec<P>;
        register(arg0: string, arg1: Internal.Codec_<P>): this;
        readonly static "UNIFORM": any;
        readonly static "CLAMPED_NORMAL": any;
        readonly static "TRAPEZOID": any;
        readonly static "CONSTANT": any;
    }
    type FloatProviderType_<P> = FloatProviderType<P> | Special.FloatProviderType;
    class Cod extends Internal.AbstractSchoolingFish {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getBucketItemStack(): Internal.ItemStack;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get bucketItemStack(): Internal.ItemStack
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type Cod_ = Cod;
    class BoundingBox {
        constructor(arg0: BlockPos_)
        constructor(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number)
        forAllCorners(arg0: Internal.Consumer_<BlockPos_>): void;
        static encapsulatingPositions(arg0: Internal.Iterable_<BlockPos_>): Internal.Optional<Internal.BoundingBox>;
        getXSpan(): number;
        maxY(): number;
        maxX(): number;
        static fromCorners(arg0: Vec3i_, arg1: Vec3i_): Internal.BoundingBox;
        getCenter(): BlockPos;
        maxZ(): number;
        isInside(arg0: Vec3i_): boolean;
        static encapsulatingBoxes(arg0: Internal.Iterable_<Internal.BoundingBox_>): Internal.Optional<Internal.BoundingBox>;
        intersects(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getYSpan(): number;
        intersects(arg0: Internal.BoundingBox_): boolean;
        moved(arg0: number, arg1: number, arg2: number): this;
        encapsulate(arg0: BlockPos_): this;
        toString(): string;
        static orientBox(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: Internal.Direction_): Internal.BoundingBox;
        getLength(): Vec3i;
        minZ(): number;
        minY(): number;
        minX(): number;
        static infinite(): Internal.BoundingBox;
        move(arg0: number, arg1: number, arg2: number): this;
        hashCode(): number;
        inflatedBy(arg0: number): this;
        move(arg0: Vec3i_): this;
        getZSpan(): number;
        equals(arg0: any): boolean;
        encapsulate(arg0: Internal.BoundingBox_): this;
        get XSpan(): number
        get center(): BlockPos
        get YSpan(): number
        get length(): Vec3i
        get ZSpan(): number
        readonly static "CODEC": any;
    }
    type BoundingBox_ = BoundingBox;
    class ServerboundRecipeBookChangeSettingsPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.RecipeBookType_, arg1: boolean, arg2: boolean)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getBookType(): Internal.RecipeBookType;
        isOpen(): boolean;
        isFiltering(): boolean;
        isSkippable(): boolean;
        get bookType(): Internal.RecipeBookType
        get open(): boolean
        get filtering(): boolean
        get skippable(): boolean
    }
    type ServerboundRecipeBookChangeSettingsPacket_ = ServerboundRecipeBookChangeSettingsPacket;
    class GossipType extends Internal.Enum<Internal.GossipType> {
        static valueOf(arg0: string): Internal.GossipType;
        static values(): Internal.GossipType[];
        static byId(arg0: string): Internal.GossipType;
        readonly "decayPerDay": number;
        readonly static "MINOR_POSITIVE": Internal.GossipType;
        readonly static "REPUTATION_CHANGE_PER_EVENT": 25;
        readonly "weight": number;
        readonly static "TRADING": Internal.GossipType;
        readonly static "REPUTATION_CHANGE_PER_EVERLASTING_MEMORY": 20;
        readonly static "MINOR_NEGATIVE": Internal.GossipType;
        readonly static "MAJOR_NEGATIVE": Internal.GossipType;
        readonly static "REPUTATION_CHANGE_PER_TRADE": 2;
        readonly "id": string;
        readonly "decayPerTransfer": number;
        readonly static "MAJOR_POSITIVE": Internal.GossipType;
        readonly "max": number;
    }
    type GossipType_ = GossipType | "major_positive" | "minor_negative" | "major_negative" | "trading" | "minor_positive";
    class BelowZeroRetrogen {
        applyBedrockMask(arg0: Internal.ProtoChunk_): void;
        hasBedrockHole(arg0: number, arg1: number): boolean;
        static getBiomeResolver(arg0: Internal.BiomeResolver_, arg1: Internal.ChunkAccess_): Internal.BiomeResolver;
        hasBedrockHoles(): boolean;
        targetStatus(): Internal.ChunkStatus;
        static read(arg0: Internal.CompoundTag_): Internal.BelowZeroRetrogen;
        static replaceOldBedrock(arg0: Internal.ProtoChunk_): void;
        readonly static "UPGRADE_HEIGHT_ACCESSOR": any;
        readonly static "CODEC": any;
    }
    type BelowZeroRetrogen_ = BelowZeroRetrogen;
    interface ChronoPeriod extends Internal.TemporalAmount {
        addTo(arg0: Internal.Temporal_): Internal.Temporal;
        getChronology(): Internal.Chronology;
        negated(): this;
        toString(): string;
        multipliedBy(arg0: number): this;
        isZero(): boolean;
        normalized(): this;
        subtractFrom(arg0: Internal.Temporal_): Internal.Temporal;
        hashCode(): number;
        between(arg0: Internal.ChronoLocalDate_, arg1: Internal.ChronoLocalDate_): this;
        plus(arg0: Internal.TemporalAmount_): this;
        getUnits(): Internal.List<Internal.TemporalUnit>;
        minus(arg0: Internal.TemporalAmount_): this;
        get(arg0: Internal.TemporalUnit_): number;
        equals(arg0: any): boolean;
        isNegative(): boolean;
        get chronology(): Internal.Chronology
        get zero(): boolean
        get units(): Internal.List<Internal.TemporalUnit>
        get negative(): boolean
    }
    type ChronoPeriod_ = ChronoPeriod;
    class ClientLevelJS extends Internal.LevelJS {
        constructor(mc: Internal.Minecraft_, e: Internal.LocalPlayer_)
        getMinecraftLevel(): Internal.ClientLevel;
        toString(): string;
        getEntities(): Internal.EntityArrayList;
        static getInstance(): Internal.ClientLevelJS;
        static setInstance(instance: Internal.ClientLevelJS_): void;
        getMinecraft(): Internal.Minecraft;
        getMinecraftPlayer(): Internal.LocalPlayer;
        getPlayerData(player: Internal.Player_): Internal.ClientPlayerDataJS;
        getSide(): Internal.ScriptType;
        get minecraftLevel(): Internal.ClientLevel
        get entities(): Internal.EntityArrayList
        get instance(): Internal.ClientLevelJS
        set instance(instance: Internal.ClientLevelJS_)
        get minecraft(): Internal.Minecraft
        get minecraftPlayer(): Internal.LocalPlayer
        get side(): Internal.ScriptType
        readonly "clientPlayerData": Internal.ClientPlayerDataJS;
    }
    type ClientLevelJS_ = ClientLevelJS;
    interface Int2ObjectMap$Entry <V> extends Internal.Map$Entry<number, V> {
        getIntKey(): number;
        getKey(): number;
        get intKey(): number
        get key(): number
    }
    type Int2ObjectMap$Entry_<V> = Int2ObjectMap$Entry<V>;
    class BufferBuilder extends Internal.DefaultedVertexConsumer implements Internal.BufferVertexConsumer {
        constructor(arg0: number)
        uv2(arg0: number): Internal.VertexConsumer;
        color(arg0: number, arg1: number, arg2: number, arg3: number): Internal.VertexConsumer;
        endVertex(): void;
        color(arg0: number): Internal.VertexConsumer;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void;
        normal(arg0: number, arg1: number, arg2: number): Internal.VertexConsumer;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void;
        restoreSortState(arg0: Internal.BufferBuilder$SortState_): void;
        begin(arg0: Internal.VertexFormat$Mode_, arg1: Internal.VertexFormat_): void;
        overlayCoords(arg0: number): Internal.VertexConsumer;
        vertex(arg0: number, arg1: number, arg2: number): Internal.VertexConsumer;
        popNextBuffer(): com.mojang.datafixers.util.Pair<Internal.BufferBuilder$DrawState, Internal.ByteBuffer>;
        getSortState(): Internal.BufferBuilder$SortState;
        color(arg0: number, arg1: number, arg2: number, arg3: number): Internal.VertexConsumer;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number[], arg7: number, arg8: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
        currentElement(): Internal.VertexFormatElement;
        overlayCoords(arg0: number, arg1: number): Internal.VertexConsumer;
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer_): number;
        applyBakedNormals(arg0: Internal.Vector3f_, arg1: Internal.ByteBuffer_, arg2: Internal.Matrix3f_): void;
        nextElement(): void;
        building(): boolean;
        normal(arg0: Internal.Matrix3f_, arg1: number, arg2: number, arg3: number): Internal.VertexConsumer;
        putBulkData(arg0: Internal.ByteBuffer_): void;
        uvShort(arg0: number, arg1: number, arg2: number): Internal.VertexConsumer;
        putShort(arg0: number, arg1: number): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        uv2(arg0: number, arg1: number): Internal.VertexConsumer;
        putByte(arg0: number, arg1: number): void;
        putFloat(arg0: number, arg1: number): void;
        setQuadSortOrigin(arg0: number, arg1: number, arg2: number): void;
        vertex(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number, arg11: number, arg12: number, arg13: number): void;
        end(): void;
        getVertexFormat(): Internal.VertexFormat;
        clear(): void;
        discard(): void;
        vertex(arg0: Internal.Matrix4f_, arg1: number, arg2: number, arg3: number): Internal.VertexConsumer;
        uv(arg0: number, arg1: number): Internal.VertexConsumer;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void;
        get sortState(): Internal.BufferBuilder$SortState
        get vertexFormat(): Internal.VertexFormat
    }
    type BufferBuilder_ = BufferBuilder;
    class CompletableFuture <T> implements Internal.Future<T>, Internal.CompletionStage<T> {
        constructor()
        getNow(arg0: T): T;
        thenAcceptAsync(arg0: Internal.Consumer_<any>, arg1: Internal.Executor_): Internal.CompletionStage<any>;
        thenComposeAsync(arg0: Internal.Function_<any, any>): Internal.CompletableFuture<U>;
        static delayedExecutor(arg0: number, arg1: Internal.TimeUnit_): Internal.Executor;
        exceptionallyCompose(arg0: Internal.Function_<Internal.Throwable_, any>): this;
        thenAcceptAsync(arg0: Internal.Consumer_<any>): Internal.CompletableFuture<void>;
        applyToEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Function_<any, any>, arg2: Internal.Executor_): Internal.CompletionStage<any>;
        thenApplyAsync(arg0: Internal.Function_<any, any>): Internal.CompletionStage<any>;
        whenComplete(arg0: Internal.BiConsumer_<any, any>): this;
        exceptionallyComposeAsync(arg0: Internal.Function_<Internal.Throwable_, any>, arg1: Internal.Executor_): this;
        complete(arg0: T): boolean;
        thenComposeAsync(arg0: Internal.Function_<any, any>, arg1: Internal.Executor_): Internal.CompletionStage<any>;
        exceptionallyComposeAsync(arg0: Internal.Function_<Internal.Throwable_, any>): this;
        thenCombine(arg0: Internal.CompletionStage_<any>, arg1: Internal.BiFunction_<any, any, any>): Internal.CompletableFuture<V>;
        acceptEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Consumer_<any>): Internal.CompletableFuture<void>;
        get(): T;
        thenRun(arg0: Internal.Runnable_): Internal.CompletableFuture<void>;
        thenCompose(arg0: Internal.Function_<any, any>): Internal.CompletionStage<any>;
        isCancelled(): boolean;
        completeAsync(arg0: Internal.Supplier_<any>): this;
        thenRunAsync(arg0: Internal.Runnable_, arg1: Internal.Executor_): Internal.CompletionStage<any>;
        whenCompleteAsync(arg0: Internal.BiConsumer_<any, any>, arg1: Internal.Executor_): Internal.CompletionStage<any>;
        exceptionally(arg0: Internal.Function_<any, any>): Internal.CompletionStage<any>;
        thenAccept(arg0: Internal.Consumer_<any>): Internal.CompletionStage<any>;
        static failedFuture(arg0: Internal.Throwable_): Internal.CompletableFuture<U>;
        static delayedExecutor(arg0: number, arg1: Internal.TimeUnit_, arg2: Internal.Executor_): Internal.Executor;
        static runAsync(arg0: Internal.Runnable_, arg1: Internal.Executor_): Internal.CompletableFuture<void>;
        cancel(arg0: boolean): boolean;
        static runAsync(arg0: Internal.Runnable_): Internal.CompletableFuture<void>;
        runAfterBoth(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletionStage<any>;
        runAfterBothAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletableFuture<void>;
        join(): T;
        orTimeout(arg0: number, arg1: Internal.TimeUnit_): this;
        runAfterBothAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_, arg2: Internal.Executor_): Internal.CompletableFuture<void>;
        thenAcceptBothAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.BiConsumer_<any, any>, arg2: Internal.Executor_): Internal.CompletableFuture<void>;
        thenAcceptBothAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.BiConsumer_<any, any>): Internal.CompletionStage<any>;
        static supplyAsync(arg0: Internal.Supplier_<U>, arg1: Internal.Executor_): Internal.CompletableFuture<U>;
        minimalCompletionStage(): Internal.CompletionStage<T>;
        get(arg0: number, arg1: Internal.TimeUnit_): T;
        handle(arg0: Internal.BiFunction_<any, Internal.Throwable_, any>): Internal.CompletableFuture<U>;
        exceptionallyAsync(arg0: Internal.Function_<Internal.Throwable_, any>, arg1: Internal.Executor_): this;
        runAfterEither(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletableFuture<void>;
        isCompletedExceptionally(): boolean;
        static supplyAsync(arg0: Internal.Supplier_<U>): Internal.CompletableFuture<U>;
        copy(): this;
        thenRunAsync(arg0: Internal.Runnable_): Internal.CompletableFuture<void>;
        handleAsync(arg0: Internal.BiFunction_<any, any, any>): Internal.CompletionStage<any>;
        static completedFuture(arg0: U): Internal.CompletableFuture<U>;
        applyToEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Function_<any, U>): Internal.CompletableFuture<U>;
        completeExceptionally(arg0: Internal.Throwable_): boolean;
        obtrudeException(arg0: Internal.Throwable_): void;
        static completedStage(arg0: U): Internal.CompletionStage<U>;
        exceptionallyAsync(arg0: Internal.Function_<Internal.Throwable_, any>): this;
        handleAsync(arg0: Internal.BiFunction_<any, Internal.Throwable_, any>, arg1: Internal.Executor_): Internal.CompletableFuture<U>;
        completeAsync(arg0: Internal.Supplier_<any>, arg1: Internal.Executor_): this;
        static anyOf(...arg0: Internal.CompletableFuture_<any>[]): Internal.CompletableFuture<any>;
        completeOnTimeout(arg0: T, arg1: number, arg2: Internal.TimeUnit_): this;
        static failedStage(arg0: Internal.Throwable_): Internal.CompletionStage<U>;
        newIncompleteFuture(): Internal.CompletableFuture<U>;
        toString(): string;
        defaultExecutor(): Internal.Executor;
        obtrudeValue(arg0: T): void;
        acceptEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Consumer_<any>, arg2: Internal.Executor_): Internal.CompletableFuture<void>;
        runAfterEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletableFuture<void>;
        thenCombineAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.BiFunction_<any, any, any>, arg2: Internal.Executor_): Internal.CompletableFuture<V>;
        getNumberOfDependents(): number;
        thenAcceptBoth(arg0: Internal.CompletionStage_<any>, arg1: Internal.BiConsumer_<any, any>): Internal.CompletableFuture<void>;
        isDone(): boolean;
        thenApply(arg0: Internal.Function_<any, any>): Internal.CompletionStage<any>;
        static allOf(...arg0: Internal.CompletableFuture_<any>[]): Internal.CompletableFuture<void>;
        toCompletableFuture(): this;
        acceptEither(arg0: Internal.CompletionStage_<any>, arg1: Internal.Consumer_<any>): Internal.CompletionStage<any>;
        applyToEither(arg0: Internal.CompletionStage_<any>, arg1: Internal.Function_<any, U>): Internal.CompletableFuture<U>;
        whenCompleteAsync(arg0: Internal.BiConsumer_<any, any>): this;
        runAfterEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_, arg2: Internal.Executor_): Internal.CompletableFuture<void>;
        thenCombineAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.BiFunction_<any, any, any>): Internal.CompletableFuture<V>;
        thenApplyAsync(arg0: Internal.Function_<any, any>, arg1: Internal.Executor_): Internal.CompletionStage<any>;
        get cancelled(): boolean
        get completedExceptionally(): boolean
        get numberOfDependents(): number
        get done(): boolean
    }
    type CompletableFuture_<T> = CompletableFuture<T>;
    class Cipher {
        wrap(arg0: Internal.Key_): number[];
        update(arg0: number[], arg1: number, arg2: number, arg3: number[]): number;
        doFinal(arg0: number[], arg1: number): number;
        doFinal(): number[];
        update(arg0: number[]): number[];
        doFinal(arg0: number[], arg1: number, arg2: number, arg3: number[]): number;
        doFinal(arg0: number[]): number[];
        getParameters(): Internal.AlgorithmParameters;
        doFinal(arg0: number[], arg1: number, arg2: number): number[];
        getAlgorithm(): string;
        init(arg0: number, arg1: Internal.Key_): void;
        init(arg0: number, arg1: Internal.Certificate_, arg2: Internal.SecureRandom_): void;
        getExemptionMechanism(): Internal.ExemptionMechanism;
        updateAAD(arg0: Internal.ByteBuffer_): void;
        static getInstance(arg0: string): Internal.Cipher;
        update(arg0: number[], arg1: number, arg2: number): number[];
        init(arg0: number, arg1: Internal.Key_, arg2: Internal.SecureRandom_): void;
        updateAAD(arg0: number[]): void;
        toString(): string;
        static getInstance(arg0: string, arg1: Internal.Provider_): Internal.Cipher;
        doFinal(arg0: number[], arg1: number, arg2: number, arg3: number[], arg4: number): number;
        getIV(): number[];
        doFinal(arg0: Internal.ByteBuffer_, arg1: Internal.ByteBuffer_): number;
        update(arg0: Internal.ByteBuffer_, arg1: Internal.ByteBuffer_): number;
        init(arg0: number, arg1: Internal.Certificate_): void;
        update(arg0: number[], arg1: number, arg2: number, arg3: number[], arg4: number): number;
        getProvider(): Internal.Provider;
        static getInstance(arg0: string, arg1: string): Internal.Cipher;
        getOutputSize(arg0: number): number;
        static getMaxAllowedParameterSpec(arg0: string): Internal.AlgorithmParameterSpec;
        init(arg0: number, arg1: Internal.Key_, arg2: Internal.AlgorithmParameters_): void;
        init(arg0: number, arg1: Internal.Key_, arg2: Internal.AlgorithmParameters_, arg3: Internal.SecureRandom_): void;
        init(arg0: number, arg1: Internal.Key_, arg2: Internal.AlgorithmParameterSpec_, arg3: Internal.SecureRandom_): void;
        updateAAD(arg0: number[], arg1: number, arg2: number): void;
        static getMaxAllowedKeyLength(arg0: string): number;
        getBlockSize(): number;
        unwrap(arg0: number[], arg1: string, arg2: number): Internal.Key;
        init(arg0: number, arg1: Internal.Key_, arg2: Internal.AlgorithmParameterSpec_): void;
        get parameters(): Internal.AlgorithmParameters
        get algorithm(): string
        get exemptionMechanism(): Internal.ExemptionMechanism
        get IV(): number[]
        get provider(): Internal.Provider
        get blockSize(): number
        readonly static "SECRET_KEY": 3;
        readonly static "ENCRYPT_MODE": 1;
        readonly static "PUBLIC_KEY": 1;
        readonly static "PRIVATE_KEY": 2;
        readonly static "WRAP_MODE": 3;
        readonly static "UNWRAP_MODE": 4;
        readonly static "DECRYPT_MODE": 2;
    }
    type Cipher_ = Cipher;
    interface PrimitiveIterator$OfDouble extends Internal.PrimitiveIterator<number, Internal.DoubleConsumer> {
        forEachRemaining(arg0: any): void;
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): any;
        forEachRemaining(arg0: Internal.DoubleConsumer_): void;
        nextDouble(): number;
    }
    type PrimitiveIterator$OfDouble_ = PrimitiveIterator$OfDouble;
    class VeryBiasedToBottomHeight extends Internal.HeightProvider {
        toString(): string;
        sample(arg0: Internal.Random_, arg1: Internal.WorldGenerationContext_): number;
        static of(arg0: Internal.VerticalAnchor_, arg1: Internal.VerticalAnchor_, arg2: number): Internal.VeryBiasedToBottomHeight;
        getType(): Internal.HeightProviderType<any>;
        get type(): Internal.HeightProviderType<any>
        readonly static "CODEC": any;
    }
    type VeryBiasedToBottomHeight_ = VeryBiasedToBottomHeight;
    class SharedContextData {
        constructor(scope: Internal.Scriptable_)
        getTypeWrappers(): Internal.TypeWrappers;
        hasTypeWrappers(): boolean;
        static get(cx: Internal.Context_, scope: Internal.Scriptable_): Internal.SharedContextData;
        newClassSerialNumber(): number;
        getExtraProperty(key: string): any;
        getWrapFactory(): Internal.WrapFactory;
        getClassDataCache(): Internal.ClassDataCache;
        addCustomJavaToJsWrapper(predicate: Internal.Predicate_<T>, provider: Internal.CustomJavaToJsWrapperProvider_<T>): void;
        static get(scope: Internal.Scriptable_): Internal.SharedContextData;
        getClassShutter(): Internal.ClassShutter;
        setExtraProperty(key: string, value: any): void;
        setClassShutter(shutter: Internal.ClassShutter_): void;
        setWrapFactory(wrapFactory: Internal.WrapFactory_): void;
        getRemapper(): Internal.Remapper;
        addToTopLevelScope(name: string, value: any): void;
        addCustomJavaToJsWrapper(type: Internal.Class_<T>, provider: Internal.CustomJavaToJsWrapperProvider_<T>): void;
        setRemapper(remapper: Internal.Remapper_): void;
        wrapCustomJavaToJs(javaObject: any): Internal.CustomJavaToJsWrapper;
        get typeWrappers(): Internal.TypeWrappers
        get wrapFactory(): Internal.WrapFactory
        get classDataCache(): Internal.ClassDataCache
        get classShutter(): Internal.ClassShutter
        set classShutter(shutter: Internal.ClassShutter_)
        set wrapFactory(wrapFactory: Internal.WrapFactory_)
        get remapper(): Internal.Remapper
        set remapper(remapper: Internal.Remapper_)
        readonly static "AKEY": "ClassCache";
        readonly "topLevelScope": Internal.Scriptable;
    }
    type SharedContextData_ = SharedContextData;
    interface IntSupplier {
        getAsInt(): number;
        get asInt(): number
    }
    type IntSupplier_ = IntSupplier | (()=>number);
    class EyeOfEnder extends Internal.Entity implements Internal.ItemSupplier {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getBrightness(): number;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getAddEntityPacket(): Internal.Packet<any>;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        setItem(arg0: Internal.ItemStack_): void;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRenderAtSqrDistance(arg0: number): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        signalTo(arg0: BlockPos_): void;
        getItem(): Internal.ItemStack;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        lerpMotion(arg0: number, arg1: number, arg2: number): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        isAttackable(): boolean;
        get brightness(): number
        get stepHeight(): number
        get addEntityPacket(): Internal.Packet<any>
        get multipartEntity(): boolean
        set item(arg0: Internal.ItemStack_)
        get parts(): Internal.PartEntity<any>[]
        get item(): Internal.ItemStack
        get attackable(): boolean
    }
    type EyeOfEnder_ = EyeOfEnder;
    class PathNavigationRegion implements Internal.CollisionGetter, Internal.BlockGetter {
        constructor(arg0: Internal.Level_, arg1: BlockPos_, arg2: BlockPos_)
        noCollision(arg0: Internal.Entity_): boolean;
        getMinSection(): number;
        getBlockState(arg0: BlockPos_): Internal.BlockState;
        findFreePosition(arg0: Internal.Entity_, arg1: Internal.VoxelShape_, arg2: Vec3_, arg3: number, arg4: number, arg5: number): Internal.Optional<Vec3>;
        getSectionIndex(arg0: number): number;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        isUnobstructed(arg0: Internal.Entity_, arg1: Internal.VoxelShape_): boolean;
        getMaxSection(): number;
        getMaxBuildHeight(): number;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getProfiler(): Internal.ProfilerFiller;
        getSectionYFromSectionIndex(arg0: number): number;
        noCollision(arg0: Internal.AABB_): boolean;
        getCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        getEntityCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.VoxelShape>;
        collidesWithSuffocatingBlock(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        getHeight(): number;
        getBlockCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        noCollision(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getWorldBorder(): Internal.WorldBorder;
        isOutsideBuildHeight(arg0: number): boolean;
        isUnobstructed(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.CollisionContext_): boolean;
        isUnobstructed(arg0: Internal.Entity_): boolean;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getFluidState(arg0: BlockPos_): Internal.FluidState;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        getSectionsCount(): number;
        getMinBuildHeight(): number;
        getChunkForCollisions(arg0: number, arg1: number): Internal.BlockGetter;
        getSectionIndexFromSectionY(arg0: number): number;
        getMaxLightLevel(): number;
        get minSection(): number
        get maxSection(): number
        get maxBuildHeight(): number
        get profiler(): Internal.ProfilerFiller
        get height(): number
        get worldBorder(): Internal.WorldBorder
        get sectionsCount(): number
        get minBuildHeight(): number
        get maxLightLevel(): number
    }
    type PathNavigationRegion_ = PathNavigationRegion;
    interface Logger {
        error(arg0: string): void;
        trace(arg0: string, ...arg1: any[]): void;
        warn(arg0: string, arg1: any, arg2: any): void;
        isTraceEnabled(arg0: org.slf4j.Marker_): boolean;
        info(arg0: string, arg1: Internal.Throwable_): void;
        warn(arg0: org.slf4j.Marker_, arg1: string, arg2: any, arg3: any): void;
        debug(arg0: string): void;
        error(arg0: org.slf4j.Marker_, arg1: string): void;
        error(arg0: string, ...arg1: any[]): void;
        trace(arg0: org.slf4j.Marker_, arg1: string, arg2: any): void;
        warn(arg0: string, arg1: any): void;
        trace(arg0: org.slf4j.Marker_, arg1: string): void;
        warn(arg0: org.slf4j.Marker_, arg1: string, ...arg2: any[]): void;
        info(arg0: string): void;
        debug(arg0: string, ...arg1: any[]): void;
        debug(arg0: org.slf4j.Marker_, arg1: string): void;
        info(arg0: org.slf4j.Marker_, arg1: string, ...arg2: any[]): void;
        warn(arg0: org.slf4j.Marker_, arg1: string, arg2: Internal.Throwable_): void;
        warn(arg0: string, arg1: Internal.Throwable_): void;
        info(arg0: string, arg1: any): void;
        error(arg0: org.slf4j.Marker_, arg1: string, arg2: any): void;
        isWarnEnabled(arg0: org.slf4j.Marker_): boolean;
        isTraceEnabled(): boolean;
        trace(arg0: string): void;
        info(arg0: org.slf4j.Marker_, arg1: string): void;
        debug(arg0: string, arg1: any, arg2: any): void;
        info(arg0: org.slf4j.Marker_, arg1: string, arg2: any, arg3: any): void;
        debug(arg0: org.slf4j.Marker_, arg1: string, arg2: any): void;
        trace(arg0: string, arg1: any): void;
        error(arg0: org.slf4j.Marker_, arg1: string, arg2: any, arg3: any): void;
        trace(arg0: string, arg1: any, arg2: any): void;
        debug(arg0: org.slf4j.Marker_, arg1: string, arg2: any, arg3: any): void;
        isDebugEnabled(): boolean;
        error(arg0: string, arg1: any): void;
        trace(arg0: org.slf4j.Marker_, arg1: string, arg2: any, arg3: any): void;
        info(arg0: org.slf4j.Marker_, arg1: string, arg2: Internal.Throwable_): void;
        warn(arg0: string): void;
        warn(arg0: string, ...arg1: any[]): void;
        debug(arg0: org.slf4j.Marker_, arg1: string, arg2: Internal.Throwable_): void;
        isErrorEnabled(): boolean;
        trace(arg0: org.slf4j.Marker_, arg1: string, ...arg2: any[]): void;
        warn(arg0: org.slf4j.Marker_, arg1: string): void;
        warn(arg0: org.slf4j.Marker_, arg1: string, arg2: any): void;
        isWarnEnabled(): boolean;
        error(arg0: org.slf4j.Marker_, arg1: string, arg2: Internal.Throwable_): void;
        error(arg0: string, arg1: any, arg2: any): void;
        getName(): string;
        trace(arg0: org.slf4j.Marker_, arg1: string, arg2: Internal.Throwable_): void;
        isErrorEnabled(arg0: org.slf4j.Marker_): boolean;
        debug(arg0: string, arg1: any): void;
        info(arg0: org.slf4j.Marker_, arg1: string, arg2: any): void;
        info(arg0: string, arg1: any, arg2: any): void;
        isInfoEnabled(): boolean;
        debug(arg0: string, arg1: Internal.Throwable_): void;
        info(arg0: string, ...arg1: any[]): void;
        isDebugEnabled(arg0: org.slf4j.Marker_): boolean;
        error(arg0: org.slf4j.Marker_, arg1: string, ...arg2: any[]): void;
        isInfoEnabled(arg0: org.slf4j.Marker_): boolean;
        debug(arg0: org.slf4j.Marker_, arg1: string, ...arg2: any[]): void;
        trace(arg0: string, arg1: Internal.Throwable_): void;
        error(arg0: string, arg1: Internal.Throwable_): void;
        get traceEnabled(): boolean
        get debugEnabled(): boolean
        get errorEnabled(): boolean
        get warnEnabled(): boolean
        get name(): string
        get infoEnabled(): boolean
        readonly static "ROOT_LOGGER_NAME": "ROOT";
    }
    type Logger_ = Logger;
    class ClientboundUpdateTagsPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.Map_<Internal.ResourceKey_<any>, Internal.TagNetworkSerialization$NetworkPayload_>)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getTags(): Internal.Map<Internal.ResourceKey<any>, Internal.TagNetworkSerialization$NetworkPayload>;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get tags(): Internal.Map<Internal.ResourceKey<any>, Internal.TagNetworkSerialization$NetworkPayload>
        get skippable(): boolean
    }
    type ClientboundUpdateTagsPacket_ = ClientboundUpdateTagsPacket;
    interface RecipeSerializer <T> extends Internal.IForgeRegistryEntry<Internal.RecipeSerializer<any>>, Internal.IForgeRecipeSerializer<T> {
        register(arg0: string, arg1: S): S;
        fromJson(arg0: ResourceLocation_, arg1: Internal.JsonObject_): T;
        fromNetwork(arg0: ResourceLocation_, arg1: Internal.FriendlyByteBuf_): T;
        toNetwork(arg0: Internal.FriendlyByteBuf_, arg1: T): void;
        fromJson(arg0: ResourceLocation_, arg1: Internal.JsonObject_, arg2: Internal.ICondition$IContext_): T;
        readonly static "FIREWORK_STAR_FADE": Internal.SimpleRecipeSerializer<any>;
        readonly static "SHIELD_DECORATION": Internal.SimpleRecipeSerializer<any>;
        readonly static "SHULKER_BOX_COLORING": Internal.SimpleRecipeSerializer<any>;
        readonly static "SMELTING_RECIPE": Internal.SimpleCookingSerializer<any>;
        readonly static "FIREWORK_ROCKET": Internal.SimpleRecipeSerializer<any>;
        readonly static "MAP_CLONING": Internal.SimpleRecipeSerializer<any>;
        readonly static "BOOK_CLONING": Internal.SimpleRecipeSerializer<any>;
        readonly static "BANNER_DUPLICATE": Internal.SimpleRecipeSerializer<any>;
        readonly static "SHAPELESS_RECIPE": any;
        readonly static "REPAIR_ITEM": Internal.SimpleRecipeSerializer<any>;
        readonly static "STONECUTTER": any;
        readonly static "CAMPFIRE_COOKING_RECIPE": Internal.SimpleCookingSerializer<any>;
        readonly static "SMITHING": any;
        readonly static "MAP_EXTENDING": Internal.SimpleRecipeSerializer<any>;
        readonly static "ARMOR_DYE": Internal.SimpleRecipeSerializer<any>;
        readonly static "SMOKING_RECIPE": Internal.SimpleCookingSerializer<any>;
        readonly static "TIPPED_ARROW": Internal.SimpleRecipeSerializer<any>;
        readonly static "SUSPICIOUS_STEW": Internal.SimpleRecipeSerializer<any>;
        readonly static "BLASTING_RECIPE": Internal.SimpleCookingSerializer<any>;
        readonly static "SHAPED_RECIPE": any;
        readonly static "FIREWORK_STAR": Internal.SimpleRecipeSerializer<any>;
    }
    type RecipeSerializer_<T> = Special.RecipeSerializer | RecipeSerializer<T>;
    abstract class PartEntity <T> extends Internal.Entity {
        constructor(arg0: T)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getAddEntityPacket(): Internal.Packet<any>;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        getParent(): T;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        get addEntityPacket(): Internal.Packet<any>
        get multipartEntity(): boolean
        get parent(): T
        get parts(): Internal.PartEntity<any>[]
    }
    type PartEntity_<T> = PartEntity<T>;
    class WorldgenRandom extends Internal.Random implements Internal.RandomSource {
        constructor(arg0: Internal.RandomSource_)
        nextFloat(arg0: number): number;
        getCount(): number;
        next(arg0: number): number;
        setLargeFeatureSeed(arg0: number, arg1: number, arg2: number): void;
        setLargeFeatureWithSalt(arg0: number, arg1: number, arg2: number, arg3: number): void;
        nextDouble(arg0: number, arg1: number): number;
        nextExponential(): number;
        setSeed(arg0: number): void;
        fork(): Internal.RandomSource;
        nextInt(arg0: number, arg1: number): number;
        nextLong(arg0: number, arg1: number): number;
        isDeprecated(): boolean;
        nextGaussian(arg0: number, arg1: number): number;
        consumeCount(arg0: number): void;
        forkPositional(): Internal.PositionalRandomFactory;
        setDecorationSeed(arg0: number, arg1: number, arg2: number): number;
        setFeatureSeed(arg0: number, arg1: number, arg2: number): void;
        nextDouble(arg0: number): number;
        nextLong(arg0: number): number;
        nextFloat(arg0: number, arg1: number): number;
        static seedSlimeChunk(arg0: number, arg1: number, arg2: number, arg3: number): Internal.Random;
        nextIntBetweenInclusive(arg0: number, arg1: number): number;
        get count(): number
        set seed(arg0: number)
        get deprecated(): boolean
    }
    type WorldgenRandom_ = WorldgenRandom;
    class AdvancementRewards$Builder {
        constructor()
        static loot(arg0: ResourceLocation_): Internal.AdvancementRewards$Builder;
        addExperience(arg0: number): this;
        static experience(arg0: number): Internal.AdvancementRewards$Builder;
        addLootTable(arg0: ResourceLocation_): this;
        build(): Internal.AdvancementRewards;
        static function(arg0: ResourceLocation_): Internal.AdvancementRewards$Builder;
        addRecipe(arg0: ResourceLocation_): this;
        runs(arg0: ResourceLocation_): this;
        static recipe(arg0: ResourceLocation_): Internal.AdvancementRewards$Builder;
    }
    type AdvancementRewards$Builder_ = AdvancementRewards$Builder;
    abstract class FeatureSize {
        constructor(arg0: Internal.OptionalInt_)
        minClippedHeight(): Internal.OptionalInt;
        getSizeAtHeight(arg0: number, arg1: number): number;
        readonly static "CODEC": any;
    }
    type FeatureSize_ = FeatureSize;
    class ImmutableMap$Builder <K, V> {
        constructor()
        put(arg0: K, arg1: V): this;
        put(arg0: Internal.Map$Entry_<any, any>): this;
        buildOrThrow(): Internal.ImmutableMap<K, V>;
        putAll(arg0: Internal.Map_<any, any>): this;
        putAll(arg0: Internal.Iterable_<any>): this;
        orderEntriesByValue(arg0: Internal.Comparator_<any>): this;
        build(): Internal.ImmutableMap<K, V>;
    }
    type ImmutableMap$Builder_<K, V> = ImmutableMap$Builder<K, V>;
    class VibrationPath {
        constructor(arg0: BlockPos_, arg1: Internal.PositionSource_, arg2: number)
        getOrigin(): BlockPos;
        getArrivalInTicks(): number;
        getDestination(): Internal.PositionSource;
        static read(arg0: Internal.FriendlyByteBuf_): Internal.VibrationPath;
        static write(arg0: Internal.FriendlyByteBuf_, arg1: Internal.VibrationPath_): void;
        get origin(): BlockPos
        get arrivalInTicks(): number
        get destination(): Internal.PositionSource
        readonly static "CODEC": any;
    }
    type VibrationPath_ = VibrationPath;
    interface PlayerRideable {
    }
    type PlayerRideable_ = PlayerRideable;
    class ItemStack$TooltipPart extends Internal.Enum<Internal.ItemStack$TooltipPart> {
        static values(): Internal.ItemStack$TooltipPart[];
        getMask(): number;
        static valueOf(arg0: string): Internal.ItemStack$TooltipPart;
        get mask(): number
        readonly static "ENCHANTMENTS": Internal.ItemStack$TooltipPart;
        readonly static "CAN_PLACE": Internal.ItemStack$TooltipPart;
        readonly static "CAN_DESTROY": Internal.ItemStack$TooltipPart;
        readonly static "DYE": Internal.ItemStack$TooltipPart;
        readonly static "MODIFIERS": Internal.ItemStack$TooltipPart;
        readonly static "ADDITIONAL": Internal.ItemStack$TooltipPart;
        readonly static "UNBREAKABLE": Internal.ItemStack$TooltipPart;
    }
    type ItemStack$TooltipPart_ = "modifiers" | "enchantments" | "unbreakable" | "can_place" | "dye" | "can_destroy" | ItemStack$TooltipPart | "additional";
    class NarratableEntry$NarrationPriority extends Internal.Enum<Internal.NarratableEntry$NarrationPriority> {
        static values(): Internal.NarratableEntry$NarrationPriority[];
        static valueOf(arg0: string): Internal.NarratableEntry$NarrationPriority;
        isTerminal(): boolean;
        get terminal(): boolean
        readonly static "NONE": Internal.NarratableEntry$NarrationPriority;
        readonly static "HOVERED": Internal.NarratableEntry$NarrationPriority;
        readonly static "FOCUSED": Internal.NarratableEntry$NarrationPriority;
    }
    type NarratableEntry$NarrationPriority_ = "focused" | "hovered" | NarratableEntry$NarrationPriority | "none";
    class MinecraftProfileTexture {
        constructor(arg0: string, arg1: Internal.Map_<string, string>)
        toString(): string;
        getMetadata(arg0: string): string;
        getUrl(): string;
        getHash(): string;
        get url(): string
        get hash(): string
        readonly static "PROFILE_TEXTURE_COUNT": 3;
    }
    type MinecraftProfileTexture_ = MinecraftProfileTexture;
    class InputConstants$Key {
        getDisplayName(): Internal.Component;
        hashCode(): number;
        toString(): string;
        getName(): string;
        getType(): Internal.InputConstants$Type;
        getValue(): number;
        equals(arg0: any): boolean;
        getNumericKeyValue(): Internal.OptionalInt;
        get displayName(): Internal.Component
        get name(): string
        get type(): Internal.InputConstants$Type
        get value(): number
        get numericKeyValue(): Internal.OptionalInt
    }
    type InputConstants$Key_ = InputConstants$Key;
    interface WithAttachedData {
        getData(): Internal.AttachedData;
        get data(): Internal.AttachedData
    }
    type WithAttachedData_ = WithAttachedData;
    class MultiBufferSource$BufferSource implements Internal.MultiBufferSource {
        endBatch(arg0: Internal.RenderType_): void;
        endBatch(): void;
        endLastBatch(): void;
        getBuffer(arg0: Internal.RenderType_): Internal.VertexConsumer;
    }
    type MultiBufferSource$BufferSource_ = MultiBufferSource$BufferSource;
    abstract class LevelJS implements Internal.WithAttachedData {
        constructor(w: Internal.Level_)
        createEntity(id: ResourceLocation_): Internal.EntityJS;
        isDaytime(): boolean;
        getGameRules(): Internal.GameRulesJS;
        createExplosion(x: number, y: number, z: number): Internal.ExplosionJS;
        isRaining(): boolean;
        getPlayer(entity: Internal.Entity_): Internal.PlayerJS<any>;
        createEntityList(entities: Internal.Collection_<any>): Internal.EntityArrayList;
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean): void;
        getMoonBrightness(): number;
        getEntitiesWithin(aabb: Internal.AABB_): Internal.EntityArrayList;
        getMinecraftLevel(): Internal.Level;
        getLivingEntity(entity: Internal.Entity_): Internal.LivingEntityJS;
        getSide(): Internal.ScriptType;
        getBlock(x: number, y: number, z: number): Internal.BlockContainerJS;
        getServer(): Internal.ServerJS;
        getDimension(): ResourceLocation;
        getLocalTime(): number;
        getDifficulty(): Internal.Difficulty;
        getWorldBorder(): Internal.WorldBorder;
        isThundering(): boolean;
        getMoonPhase(): number;
        getEntities(): Internal.EntityArrayList;
        getTime(): number;
        getData(): Internal.AttachedData;
        spawnFireworks(x: number, y: number, z: number, f: Internal.FireworksJS_): void;
        getPlayerData(arg0: Internal.Player_): Internal.PlayerDataJS<any, any>;
        getEntity(e: Internal.Entity_): Internal.EntityJS;
        getPlayers(): Internal.EntityArrayList;
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean, player: Internal.EntityJS_): void;
        setRainStrength(strength: number): void;
        getBlock(pos: BlockPos_): Internal.BlockContainerJS;
        isOverworld(): boolean;
        getBlock(blockEntity: Internal.BlockEntity_): Internal.BlockContainerJS;
        get daytime(): boolean
        get gameRules(): Internal.GameRulesJS
        get raining(): boolean
        get moonBrightness(): number
        get minecraftLevel(): Internal.Level
        get side(): Internal.ScriptType
        get server(): Internal.ServerJS
        get dimension(): ResourceLocation
        get localTime(): number
        get difficulty(): Internal.Difficulty
        get worldBorder(): Internal.WorldBorder
        get thundering(): boolean
        get moonPhase(): number
        get entities(): Internal.EntityArrayList
        get time(): number
        get data(): Internal.AttachedData
        get players(): Internal.EntityArrayList
        set rainStrength(strength: number)
        get overworld(): boolean
        readonly "minecraftLevel": Internal.Level;
    }
    type LevelJS_ = LevelJS;
    class PackType extends Internal.Enum<Internal.PackType> {
        static values(): Internal.PackType[];
        getVersion(arg0: Internal.GameVersion_): number;
        static valueOf(arg0: string): Internal.PackType;
        getDirectory(): string;
        get directory(): string
        readonly "bridgeType": com.mojang.bridge.game.PackType;
        readonly static "CLIENT_RESOURCES": Internal.PackType;
        readonly static "SERVER_DATA": Internal.PackType;
    }
    type PackType_ = "client_resources" | PackType | "server_data";
    class PainterObjectStorage {
        constructor()
        createScreenObjects(): any[];
        getObject(key: string): Internal.PainterObject;
        clear(): void;
        getObjects(): Internal.Collection<Internal.PainterObject>;
        remove(id: string): void;
        handle(root: Internal.CompoundTag_): void;
        get objects(): Internal.Collection<Internal.PainterObject>
    }
    type PainterObjectStorage_ = PainterObjectStorage;
    abstract class MinecraftServer extends Internal.ReentrantBlockableEventLoop<Internal.TickTask> implements Internal.MinecraftServerKJS, Internal.CommandSource, Internal.AutoCloseable {
        constructor(arg0: Internal.Thread_, arg1: Internal.LevelStorageSource$LevelStorageAccess_, arg2: Internal.PackRepository_, arg3: Internal.WorldStem_, arg4: Internal.Proxy_, arg5: Internal.DataFixer_, arg6: Internal.MinecraftSessionService_, arg7: Internal.GameProfileRepository_, arg8: Internal.GameProfileCache_, arg9: any_)
        getConnection(): Internal.ServerConnectionListener;
        pollTask(): boolean;
        getCompressionThreshold(): number;
        getPlayerIdleTimeout(): number;
        fillServerSystemReport(arg0: Internal.SystemReport_): Internal.SystemReport;
        isTimeProfilerRunning(): boolean;
        getProxy(): Internal.Proxy;
        getResourceManager(): Internal.ResourceManager;
        setDefaultGameType(arg0: Internal.GameType_): void;
        saveEverything(arg0: boolean, arg1: boolean, arg2: boolean): boolean;
        getPredicateManager(): Internal.PredicateManager;
        askEither(arg0: Internal.Function_<any, any>): Internal.CompletableFuture<Source>;
        markWorldsDirty(): void;
        usesAuthentication(): boolean;
        getFunctions(): Internal.ServerFunctionManager;
        setEnforceWhitelist(arg0: boolean): void;
        isShutdown(): boolean;
        getSingleplayerName(): string;
        getScaledTrackingDistance(arg0: number): number;
        publishServer(arg0: Internal.GameType_, arg1: boolean, arg2: number): boolean;
        getFrameTimer(): Internal.FrameTimer;
        static configurePackRepository(arg0: Internal.PackRepository_, arg1: Internal.DataPackConfig_, arg2: boolean): Internal.DataPackConfig;
        hasGui(): boolean;
        stopTimeProfiler(): Internal.ProfileResults;
        getDefaultGameType(): Internal.GameType;
        setDemo(arg0: boolean): void;
        alwaysAccepts(): boolean;
        getTickCount(): number;
        asKJS(): Internal.ServerJS;
        dumpServerProperties(arg0: Internal.Path_): void;
        isUnderSpawnProtection(arg0: Internal.ServerLevel_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        getPackRepository(): Internal.PackRepository;
        forgeGetWorldMap(): Internal.Map<Internal.ResourceKey<Internal.Level>, Internal.ServerLevel>;
        getPlayerList(): Internal.PlayerList;
        getWorldPath(arg0: Internal.LevelResource_): Internal.Path;
        executeIfPossible(arg0: Internal.Runnable_): void;
        getResourcePack(): string;
        getStructureManager(): Internal.StructureManager;
        finishRecordingMetrics(): void;
        getReloadableResourcesKJS(): Internal.MinecraftServer$ReloadableResources;
        getLevel(arg0: Internal.ResourceKey_<Internal.Level_>): Internal.ServerLevel;
        ask(arg0: Internal.Function_<any, any>): Internal.CompletableFuture<Source>;
        isSingleplayer(): boolean;
        getServerResources(): Internal.MinecraftServer$ReloadableResources;
        setPreventProxyConnections(arg0: boolean): void;
        getPort(): number;
        getGameRules(): Internal.GameRules;
        isRecordingMetrics(): boolean;
        tickChildren(arg0: Internal.BooleanSupplier_): void;
        getCommands(): Internal.Commands;
        isSpawningAnimals(): boolean;
        getServerDirectory(): Internal.File;
        setUsesAuthentication(arg0: boolean): void;
        getAllLevels(): Internal.Iterable<Internal.ServerLevel>;
        isStopped(): boolean;
        setPlayerList(arg0: Internal.PlayerList_): void;
        setLocalIp(arg0: string): void;
        createGameModeForPlayer(arg0: Internal.ServerPlayer_): Internal.ServerPlayerGameMode;
        isNetherEnabled(): boolean;
        getLocalIp(): string;
        getCustomBossEvents(): Internal.CustomBossEvents;
        reloadResources(arg0: Internal.Collection_<string>): Internal.CompletableFuture<void>;
        isEnforceWhitelist(): boolean;
        saveAllChunks(arg0: boolean, arg1: boolean, arg2: boolean): boolean;
        getLootTables(): Internal.LootTables;
        isCurrentlySaving(): boolean;
        hidesOnlinePlayers(): boolean;
        areNpcsEnabled(): boolean;
        getProfileRepository(): Internal.GameProfileRepository;
        getProfileCache(): Internal.GameProfileCache;
        getCommandStorage(): Internal.CommandStorage;
        getAbsoluteMaxWorldSize(): number;
        getForcedGameType(): Internal.GameType;
        setDifficulty(arg0: Internal.Difficulty_, arg1: boolean): void;
        acceptsSuccess(): boolean;
        getItemModifierManager(): Internal.ItemModifierManager;
        invalidateStatus(): void;
        overworld(): Internal.ServerLevel;
        getStatus(): Internal.ServerStatus;
        static spin(arg0: Internal.Function_<Internal.Thread_, S>): S;
        setPlayerIdleTimeout(arg0: number): void;
        getScoreboard(): Internal.ServerScoreboard;
        tickServer(arg0: Internal.BooleanSupplier_): void;
        localvar$zzj000$wrapResourceManager(original: Internal.CloseableResourceManager_): Internal.CloseableResourceManager;
        addTickable(arg0: Internal.Runnable_): void;
        createCommandSourceStack(): Internal.CommandSourceStack;
        setFlightAllowed(arg0: boolean): void;
        getServerModName(): string;
        acceptsFailure(): boolean;
        isCommandBlockEnabled(): boolean;
        getNextTickTime(): number;
        sendMessage(arg0: Internal.Component_, arg1: Internal.UUID_): void;
        isHardcore(): boolean;
        getFile(arg0: string): Internal.File;
        getSpawnRadius(arg0: Internal.ServerLevel_): number;
        isPublished(): boolean;
        startTimeProfiler(): void;
        stopRecordingMetrics(): void;
        repliesToStatus(): boolean;
        getPlayerCount(): number;
        getAdvancements(): Internal.ServerAdvancementManager;
        getMotd(): string;
        isRunning(): boolean;
        getSessionService(): Internal.MinecraftSessionService;
        getRateLimitPacketsPerSecond(): number;
        getOperatorUserPermissionLevel(): number;
        stopServer(): void;
        fillSystemReport(arg0: Internal.SystemReport_): Internal.SystemReport;
        isReady(): boolean;
        setPort(arg0: number): void;
        shouldInformAdmins(): boolean;
        registryAccess(): Internal.RegistryAccess$Frozen;
        isDedicatedServer(): boolean;
        scheduleExecutables(): boolean;
        setDifficultyLocked(arg0: boolean): void;
        getMaxPlayers(): number;
        isSpawningMonsters(): boolean;
        setPvpAllowed(arg0: boolean): void;
        getResourcePackPrompt(): Internal.Component;
        getKeyPair(): Internal.KeyPair;
        forceSynchronousWrites(): boolean;
        isPvpAllowed(): boolean;
        getTickTime(arg0: Internal.ResourceKey_<Internal.Level_>): number[];
        getFunctionCompilationLevel(): number;
        isResourcePackRequired(): boolean;
        getServerVersion(): string;
        getResourcePackHash(): string;
        getProfiler(): Internal.ProfilerFiller;
        getAverageTickTime(): number;
        isSingleplayerOwner(arg0: Internal.GameProfile_): boolean;
        onServerExit(): void;
        doRunTask(arg0: Internal.TickTask_): void;
        kickUnlistedPlayers(arg0: Internal.CommandSourceStack_): void;
        setResourcePack(arg0: string, arg1: string): void;
        getRunningThread(): Internal.Thread;
        createTextFilterForPlayer(arg0: Internal.ServerPlayer_): Internal.TextFilter;
        isDemo(): boolean;
        startRecordingMetrics(arg0: Internal.Consumer_<Internal.ProfileResults_>, arg1: Internal.Consumer_<Internal.Path_>): void;
        getProfilePermissions(arg0: Internal.GameProfile_): number;
        getWorldScreenshotFile(): Internal.Optional<Internal.Path>;
        halt(arg0: boolean): void;
        isEpollEnabled(): boolean;
        shouldRconBroadcast(): boolean;
        getSpawnProtectionRadius(): number;
        levelKeys(): Internal.Set<Internal.ResourceKey<Internal.Level>>;
        getModdedStatus(): Internal.ModCheck;
        getPlayerNames(): string[];
        getRecipeManager(): Internal.RecipeManager;
        setSingleplayerName(arg0: string): void;
        doRunTask(arg0: Internal.Runnable_): void;
        close(): void;
        getFixerUpper(): Internal.DataFixer;
        getWorldData(): Internal.WorldData;
        setMotd(arg0: string): void;
        getPreventProxyConnections(): boolean;
        isFlightAllowed(): boolean;
        get connection(): Internal.ServerConnectionListener
        get compressionThreshold(): number
        get playerIdleTimeout(): number
        get timeProfilerRunning(): boolean
        get proxy(): Internal.Proxy
        get resourceManager(): Internal.ResourceManager
        set defaultGameType(arg0: Internal.GameType_)
        get predicateManager(): Internal.PredicateManager
        get functions(): Internal.ServerFunctionManager
        set enforceWhitelist(arg0: boolean)
        get shutdown(): boolean
        get singleplayerName(): string
        get frameTimer(): Internal.FrameTimer
        get defaultGameType(): Internal.GameType
        set demo(arg0: boolean)
        get tickCount(): number
        get packRepository(): Internal.PackRepository
        get playerList(): Internal.PlayerList
        get resourcePack(): string
        get structureManager(): Internal.StructureManager
        get reloadableResourcesKJS(): Internal.MinecraftServer$ReloadableResources
        get singleplayer(): boolean
        get serverResources(): Internal.MinecraftServer$ReloadableResources
        set preventProxyConnections(arg0: boolean)
        get port(): number
        get gameRules(): Internal.GameRules
        get recordingMetrics(): boolean
        get commands(): Internal.Commands
        get spawningAnimals(): boolean
        get serverDirectory(): Internal.File
        set usesAuthentication(arg0: boolean)
        get allLevels(): Internal.Iterable<Internal.ServerLevel>
        get stopped(): boolean
        set playerList(arg0: Internal.PlayerList_)
        set localIp(arg0: string)
        get netherEnabled(): boolean
        get localIp(): string
        get customBossEvents(): Internal.CustomBossEvents
        get enforceWhitelist(): boolean
        get lootTables(): Internal.LootTables
        get currentlySaving(): boolean
        get profileRepository(): Internal.GameProfileRepository
        get profileCache(): Internal.GameProfileCache
        get commandStorage(): Internal.CommandStorage
        get absoluteMaxWorldSize(): number
        get forcedGameType(): Internal.GameType
        get itemModifierManager(): Internal.ItemModifierManager
        get status(): Internal.ServerStatus
        set playerIdleTimeout(arg0: number)
        get scoreboard(): Internal.ServerScoreboard
        set flightAllowed(arg0: boolean)
        get serverModName(): string
        get commandBlockEnabled(): boolean
        get nextTickTime(): number
        get hardcore(): boolean
        get published(): boolean
        get playerCount(): number
        get advancements(): Internal.ServerAdvancementManager
        get motd(): string
        get running(): boolean
        get sessionService(): Internal.MinecraftSessionService
        get rateLimitPacketsPerSecond(): number
        get operatorUserPermissionLevel(): number
        get ready(): boolean
        set port(arg0: number)
        get dedicatedServer(): boolean
        set difficultyLocked(arg0: boolean)
        get maxPlayers(): number
        get spawningMonsters(): boolean
        set pvpAllowed(arg0: boolean)
        get resourcePackPrompt(): Internal.Component
        get keyPair(): Internal.KeyPair
        get pvpAllowed(): boolean
        get functionCompilationLevel(): number
        get resourcePackRequired(): boolean
        get serverVersion(): string
        get resourcePackHash(): string
        get profiler(): Internal.ProfilerFiller
        get averageTickTime(): number
        get runningThread(): Internal.Thread
        get demo(): boolean
        get worldScreenshotFile(): Internal.Optional<Internal.Path>
        get epollEnabled(): boolean
        get spawnProtectionRadius(): number
        get moddedStatus(): Internal.ModCheck
        get playerNames(): string[]
        get recipeManager(): Internal.RecipeManager
        set singleplayerName(arg0: string)
        get fixerUpper(): Internal.DataFixer
        get worldData(): Internal.WorldData
        set motd(arg0: string)
        get preventProxyConnections(): boolean
        get flightAllowed(): boolean
        readonly static "LEVEL_STORAGE_SCHEMA": "level://";
        readonly static "START_CHUNK_RADIUS": 11;
        readonly static "LEVEL_STORAGE_PROTOCOL": "level";
        readonly static "ABSOLUTE_MAX_WORLD_SIZE": 29999984;
        readonly static "MAP_RESOURCE_FILE": "resources.zip";
        readonly static "USERID_CACHE_FILE": Internal.File;
        readonly static "DEMO_SETTINGS": Internal.LevelSettings;
        readonly static "VANILLA_BRAND": "vanilla";
        readonly static "ANONYMOUS_PLAYER_PROFILE": Internal.GameProfile;
        readonly "tickTimes": number[];
        readonly static "MS_PER_TICK": 50;
    }
    type MinecraftServer_ = MinecraftServer;
    class Matcher implements Internal.MatchResult {
        start(): number;
        matches(): boolean;
        find(arg0: number): boolean;
        pattern(): Internal.Pattern;
        appendReplacement(arg0: Internal.StringBuffer_, arg1: string): this;
        end(arg0: number): number;
        end(arg0: string): number;
        reset(): this;
        results(): Internal.Stream<Internal.MatchResult>;
        reset(arg0: Internal.CharSequence_): this;
        replaceFirst(arg0: string): string;
        appendTail(arg0: Internal.StringBuilder_): Internal.StringBuilder;
        groupCount(): number;
        find(): boolean;
        replaceFirst(arg0: Internal.Function_<Internal.MatchResult_, string>): string;
        lookingAt(): boolean;
        region(arg0: number, arg1: number): this;
        start(arg0: number): number;
        hasTransparentBounds(): boolean;
        appendReplacement(arg0: Internal.StringBuilder_, arg1: string): this;
        end(): number;
        replaceAll(arg0: Internal.Function_<Internal.MatchResult_, string>): string;
        group(arg0: string): string;
        toString(): string;
        requireEnd(): boolean;
        hasAnchoringBounds(): boolean;
        useTransparentBounds(arg0: boolean): this;
        appendTail(arg0: Internal.StringBuffer_): Internal.StringBuffer;
        regionEnd(): number;
        useAnchoringBounds(arg0: boolean): this;
        toMatchResult(): Internal.MatchResult;
        usePattern(arg0: Internal.Pattern_): this;
        replaceAll(arg0: string): string;
        start(arg0: string): number;
        static quoteReplacement(arg0: string): string;
        group(): string;
        group(arg0: number): string;
        hitEnd(): boolean;
        regionStart(): number;
    }
    type Matcher_ = Matcher;
    class FieldPosition {
        constructor(arg0: Internal.Format$Field_)
        constructor(arg0: Internal.Format$Field_, arg1: number)
        constructor(arg0: number)
        hashCode(): number;
        toString(): string;
        getFieldAttribute(): Internal.Format$Field;
        getBeginIndex(): number;
        getField(): number;
        equals(arg0: any): boolean;
        setBeginIndex(arg0: number): void;
        setEndIndex(arg0: number): void;
        getEndIndex(): number;
        get fieldAttribute(): Internal.Format$Field
        get beginIndex(): number
        get field(): number
        set beginIndex(arg0: number)
        set endIndex(arg0: number)
        get endIndex(): number
    }
    type FieldPosition_ = FieldPosition;
    interface StructurePoolElementType <P> {
        codec(): Internal.Codec<P>;
        register(arg0: string, arg1: Internal.Codec_<P>): this;
        readonly static "LIST": any;
        readonly static "LEGACY": any;
        readonly static "FEATURE": any;
        readonly static "EMPTY": any;
        readonly static "SINGLE": any;
    }
    type StructurePoolElementType_<P> = Special.StructurePoolElementType | StructurePoolElementType<P>;
    class ContextFactory {
        constructor()
        addListener(listener: Internal.ContextFactory$Listener_): void;
        enterContext(): Internal.Context;
        static getGlobal(): Internal.ContextFactory;
        call(action: Internal.ContextAction_<T>): T;
        enterContext(cx: Internal.Context_): Internal.Context;
        isSealed(): boolean;
        seal(): void;
        getApplicationClassLoader(): Internal.ClassLoader;
        removeListener(listener: Internal.ContextFactory$Listener_): void;
        get global(): Internal.ContextFactory
        get sealed(): boolean
        get applicationClassLoader(): Internal.ClassLoader
    }
    type ContextFactory_ = ContextFactory;
    interface EnchantmentBuilder$PostFunction {
        apply(arg0: Internal.LivingEntityJS_, arg1: Internal.EntityJS_, arg2: number): void;
    }
    type EnchantmentBuilder$PostFunction_ = ((arg0: Internal.LivingEntityJS, arg1: Internal.EntityJS, arg2: number)=>void) | EnchantmentBuilder$PostFunction;
    class WorldStem$InitConfig extends Internal.Record {
        constructor(arg0: Internal.PackRepository_, arg1: Internal.Commands$CommandSelection_, arg2: number, arg3: boolean)
        safeMode(): boolean;
        hashCode(): number;
        toString(): string;
        commandSelection(): Internal.Commands$CommandSelection;
        functionCompilationLevel(): number;
        equals(arg0: any): boolean;
        packRepository(): Internal.PackRepository;
    }
    type WorldStem$InitConfig_ = WorldStem$InitConfig;
    class WoodenButtonBlockBuilder extends Internal.ShapedBlockBuilder {
        constructor(i: ResourceLocation_)
        createObject(): Internal.Block;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
    }
    type WoodenButtonBlockBuilder_ = WoodenButtonBlockBuilder;
    interface PositionalRandomFactory {
        fromHashOf(arg0: ResourceLocation_): Internal.RandomSource;
        at(arg0: BlockPos_): Internal.RandomSource;
        at(arg0: number, arg1: number, arg2: number): Internal.RandomSource;
        parityConfigString(arg0: Internal.StringBuilder_): void;
        fromHashOf(arg0: string): Internal.RandomSource;
    }
    type PositionalRandomFactory_ = PositionalRandomFactory;
    class BlockColumnConfiguration extends Internal.Record implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.List_<Internal.BlockColumnConfiguration$Layer_>, arg1: Internal.Direction_, arg2: net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_, arg3: boolean)
        static layer(arg0: Internal.IntProvider_, arg1: Internal.BlockStateProvider_): Internal.BlockColumnConfiguration$Layer;
        hashCode(): number;
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        allowedPlacement(): net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate;
        toString(): string;
        layers(): Internal.List<Internal.BlockColumnConfiguration$Layer>;
        static simple(arg0: Internal.IntProvider_, arg1: Internal.BlockStateProvider_): Internal.BlockColumnConfiguration;
        prioritizeTip(): boolean;
        equals(arg0: any): boolean;
        direction(): Internal.Direction;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
    }
    type BlockColumnConfiguration_ = BlockColumnConfiguration;
    class RenderType$CompositeRenderType extends Internal.RenderType {
        toString(): string;
        isOutline(): boolean;
        outline(): Internal.Optional<Internal.RenderType>;
        get outline(): boolean
    }
    type RenderType$CompositeRenderType_ = RenderType$CompositeRenderType;
    class LinearPosTest extends Internal.PosRuleTest {
        constructor(arg0: number, arg1: number, arg2: number, arg3: number)
        test(arg0: BlockPos_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.Random_): boolean;
        readonly static "CODEC": any;
    }
    type LinearPosTest_ = LinearPosTest;
    abstract class Type$TypeError {
        constructor(arg0: string)
        toString(): string;
    }
    type Type$TypeError_ = Type$TypeError;
    class LevelRenderer implements Internal.ResourceManagerReloadListener, Internal.AutoCloseable {
        constructor(arg0: Internal.Minecraft_, arg1: Internal.RenderBuffers_)
        getItemEntityTarget(): Internal.RenderTarget;
        needsUpdate(): void;
        entityTarget(): Internal.RenderTarget;
        updateGlobalBlockEntities(arg0: Internal.Collection_<Internal.BlockEntity_>, arg1: Internal.Collection_<Internal.BlockEntity_>): void;
        getCloudsTarget(): Internal.RenderTarget;
        static renderLineBox(arg0: Internal.PoseStack_, arg1: Internal.VertexConsumer_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number, arg11: number, arg12: number, arg13: number, arg14: number): void;
        prepareCullFrustum(arg0: Internal.PoseStack_, arg1: Vec3_, arg2: Internal.Matrix4f_): void;
        killFrustum(): void;
        getTranslucentTarget(): Internal.RenderTarget;
        renderLevel(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: boolean, arg4: Internal.Camera_, arg5: Internal.GameRenderer_, arg6: Internal.LightTexture_, arg7: Internal.Matrix4f_): void;
        countRenderedChunks(): number;
        addRecentlyCompiledChunk(arg0: Internal.ChunkRenderDispatcher$RenderChunk_): void;
        hasRenderedAllChunks(): boolean;
        tickRain(arg0: Internal.Camera_): void;
        setLevel(arg0: Internal.ClientLevel_): void;
        setBlocksDirty(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        static getLightColor(arg0: Internal.BlockAndTintGetter_, arg1: Internal.BlockState_, arg2: BlockPos_): number;
        addParticle(arg0: Internal.ParticleOptions_, arg1: boolean, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        static addChainedFilledBoxVertices(arg0: Internal.BufferBuilder_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number): void;
        getTotalChunks(): number;
        tick(): void;
        static renderLineBox(arg0: Internal.VertexConsumer_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number): void;
        doEntityOutline(): void;
        getEntityStatistics(): string;
        resize(arg0: number, arg1: number): void;
        levelEvent(arg0: Internal.Player_, arg1: number, arg2: BlockPos_, arg3: number): void;
        playStreamingMusic(arg0: Internal.SoundEvent_, arg1: BlockPos_): void;
        getChunkStatistics(): string;
        initOutline(): void;
        setSectionDirty(arg0: number, arg1: number, arg2: number): void;
        isChunkCompiled(arg0: BlockPos_): boolean;
        destroyBlockProgress(arg0: number, arg1: BlockPos_, arg2: number): void;
        static renderLineBox(arg0: Internal.PoseStack_, arg1: Internal.VertexConsumer_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number, arg11: number): void;
        addParticle(arg0: Internal.ParticleOptions_, arg1: boolean, arg2: boolean, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number): void;
        captureFrustum(): void;
        renderSky(arg0: Internal.PoseStack_, arg1: Internal.Matrix4f_, arg2: number, arg3: Internal.Camera_, arg4: boolean, arg5: Internal.Runnable_): void;
        getName(): string;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        blockChanged(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: number): void;
        getChunkRenderDispatcher(): Internal.ChunkRenderDispatcher;
        static renderLineBox(arg0: Internal.PoseStack_, arg1: Internal.VertexConsumer_, arg2: Internal.AABB_, arg3: number, arg4: number, arg5: number, arg6: number): void;
        globalLevelEvent(arg0: number, arg1: BlockPos_, arg2: number): void;
        onResourceManagerReload(arg0: Internal.ResourceManager_): void;
        playStreamingMusic(arg0: Internal.SoundEvent_, arg1: BlockPos_, arg2: Internal.RecordItem_): void;
        allChanged(): void;
        getParticlesTarget(): Internal.RenderTarget;
        setBlockDirty(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: Internal.BlockState_): void;
        setSectionDirtyWithNeighbors(arg0: number, arg1: number, arg2: number): void;
        getLastViewDistance(): number;
        static renderVoxelShape(arg0: Internal.PoseStack_, arg1: Internal.VertexConsumer_, arg2: Internal.VoxelShape_, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number): void;
        getWeatherTarget(): Internal.RenderTarget;
        clear(): void;
        close(): void;
        renderClouds(arg0: Internal.PoseStack_, arg1: Internal.Matrix4f_, arg2: number, arg3: number, arg4: number, arg5: number): void;
        static getLightColor(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): number;
        graphicsChanged(): void;
        get itemEntityTarget(): Internal.RenderTarget
        get cloudsTarget(): Internal.RenderTarget
        get translucentTarget(): Internal.RenderTarget
        set level(arg0: Internal.ClientLevel_)
        get totalChunks(): number
        get entityStatistics(): string
        get chunkStatistics(): string
        get name(): string
        get chunkRenderDispatcher(): Internal.ChunkRenderDispatcher
        get particlesTarget(): Internal.RenderTarget
        get lastViewDistance(): number
        get weatherTarget(): Internal.RenderTarget
        readonly static "CHUNK_SIZE": 16;
        readonly static "DIRECTIONS": any;
    }
    type LevelRenderer_ = LevelRenderer;
    abstract class Reader implements Internal.Closeable, Internal.Readable {
        static nullReader(): Internal.Reader;
        transferTo(arg0: Internal.Writer_): number;
        read(arg0: Internal.CharBuffer_): number;
        read(): number;
        markSupported(): boolean;
        mark(arg0: number): void;
        close(): void;
        read(arg0: string[], arg1: number, arg2: number): number;
        ready(): boolean;
        read(arg0: string[]): number;
        skip(arg0: number): number;
        reset(): void;
    }
    type Reader_ = Reader;
    interface DoubleListIterator extends Internal.DoubleBidirectionalIterator, Internal.ListIterator<number> {
        add(arg0: any): void;
        forEachRemaining(arg0: any): void;
        forEachRemaining(arg0: it.unimi.dsi.fastutil.doubles.DoubleConsumer_): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): any;
        set(arg0: any): void;
        skip(arg0: number): number;
        add(arg0: number): void;
        remove(): void;
        set(arg0: number): void;
        add(arg0: number): void;
        set(arg0: number): void;
        forEachRemaining(arg0: Internal.DoubleConsumer_): void;
        back(arg0: number): number;
        previous(): any;
    }
    type DoubleListIterator_ = DoubleListIterator;
    interface PrivateKey extends Internal.Key, Internal.Destroyable {
        destroy(): void;
        isDestroyed(): boolean;
        get destroyed(): boolean
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "serialVersionUID": 6034044314589513430;
    }
    type PrivateKey_ = PrivateKey;
    class NetworkEvent$Context {
        enqueueWork(arg0: Internal.Runnable_): Internal.CompletableFuture<void>;
        setPacketHandled(arg0: boolean): void;
        getPacketHandled(): boolean;
        getPacketDispatcher(): Internal.NetworkEvent$PacketDispatcher;
        getDirection(): Internal.NetworkDirection;
        attr(arg0: Internal.AttributeKey_<T>): io.netty.util.Attribute<T>;
        getSender(): Internal.ServerPlayer;
        getNetworkManager(): Internal.Connection;
        set packetHandled(arg0: boolean)
        get packetHandled(): boolean
        get packetDispatcher(): Internal.NetworkEvent$PacketDispatcher
        get direction(): Internal.NetworkDirection
        get sender(): Internal.ServerPlayer
        get networkManager(): Internal.Connection
    }
    type NetworkEvent$Context_ = NetworkEvent$Context;
    class ServerStatus$Version {
        constructor(arg0: string, arg1: number)
        getName(): string;
        getProtocol(): number;
        get name(): string
        get protocol(): number
    }
    type ServerStatus$Version_ = ServerStatus$Version;
    class EvokerFangs extends Internal.Entity {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.LivingEntity_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        setOwner(arg0: Internal.LivingEntity_): void;
        tick(): void;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getAddEntityPacket(): Internal.Packet<any>;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        getAnimationProgress(arg0: number): number;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getOwner(): Internal.LivingEntity;
        shouldRiderSit(): boolean;
        handleEntityEvent(arg0: number): void;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        set owner(arg0: Internal.LivingEntity_)
        get addEntityPacket(): Internal.Packet<any>
        get multipartEntity(): boolean
        get owner(): Internal.LivingEntity
        get parts(): Internal.PartEntity<any>[]
        readonly static "ATTACK_DURATION": 20;
        readonly static "LIFE_OFFSET": 2;
        readonly static "ATTACK_TRIGGER_TICKS": 14;
    }
    type EvokerFangs_ = EvokerFangs;
    class ZombieHorse extends Internal.AbstractHorse {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMobType(): Internal.MobType;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get mobType(): Internal.MobType
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type ZombieHorse_ = ZombieHorse;
    class BlockBehaviour$OffsetType extends Internal.Enum<Internal.BlockBehaviour$OffsetType> {
        static valueOf(arg0: string): Internal.BlockBehaviour$OffsetType;
        static values(): Internal.BlockBehaviour$OffsetType[];
        readonly static "NONE": Internal.BlockBehaviour$OffsetType;
        readonly static "XZ": Internal.BlockBehaviour$OffsetType;
        readonly static "XYZ": Internal.BlockBehaviour$OffsetType;
    }
    type BlockBehaviour$OffsetType_ = BlockBehaviour$OffsetType | "xyz" | "none" | "xz";
    class ChestBlockEntity extends Internal.RandomizableContainerBlockEntity implements Internal.LidBlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        stopOpen(arg0: Internal.Player_): void;
        getCapability(arg0: Internal.Capability_<T>, arg1: Internal.Direction_): Internal.LazyOptional<T>;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        countItem(arg0: Internal.Item_): number;
        getOpenNess(arg0: number): number;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        setBlockState(arg0: Internal.BlockState_): void;
        load(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        getContainerSize(): number;
        static lidAnimateTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.ChestBlockEntity_): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        invalidateCaps(): void;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        triggerEvent(arg0: number, arg1: number): boolean;
        getMaxStackSize(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        recheckOpen(): void;
        static swapContents(arg0: Internal.ChestBlockEntity_, arg1: Internal.ChestBlockEntity_): void;
        static getOpenCount(arg0: Internal.BlockGetter_, arg1: BlockPos_): number;
        getRenderBoundingBox(): Internal.AABB;
        set blockState(arg0: Internal.BlockState_)
        get containerSize(): number
        get modelData(): Internal.IModelData
        get maxStackSize(): number
        get renderBoundingBox(): Internal.AABB
    }
    type ChestBlockEntity_ = ChestBlockEntity;
    interface Hash$Strategy <K> {
        equals(arg0: K, arg1: K): boolean;
        hashCode(arg0: K): number;
    }
    type Hash$Strategy_<K> = Hash$Strategy<K>;
    interface WorldStem$WorldDataSupplier {
        get(arg0: Internal.ResourceManager_, arg1: Internal.DataPackConfig_): com.mojang.datafixers.util.Pair<Internal.WorldData, Internal.RegistryAccess$Frozen>;
        loadFromWorld(arg0: Internal.LevelStorageSource$LevelStorageAccess_): this;
    }
    type WorldStem$WorldDataSupplier_ = WorldStem$WorldDataSupplier | ((arg0: Internal.ResourceManager, arg1: Internal.DataPackConfig)=>com.mojang.datafixers.util.Pair_<Internal.WorldData_, Internal.RegistryAccess$Frozen_>);
    abstract class FileSystemProvider {
        readAttributes(arg0: Internal.Path_, arg1: Internal.Class_<A>, ...arg2: any_[]): A;
        move(arg0: Internal.Path_, arg1: Internal.Path_, ...arg2: any_[]): void;
        static installedProviders(): Internal.List<Internal.FileSystemProvider>;
        delete(arg0: Internal.Path_): void;
        createLink(arg0: Internal.Path_, arg1: Internal.Path_): void;
        newFileChannel(arg0: Internal.Path_, arg1: Internal.Set_<any>, ...arg2: any_<any>[]): Internal.FileChannel;
        newDirectoryStream(arg0: Internal.Path_, arg1: Internal.DirectoryStream$Filter_<any>): Internal.DirectoryStream<Internal.Path>;
        getFileStore(arg0: Internal.Path_): Internal.FileStore;
        newAsynchronousFileChannel(arg0: Internal.Path_, arg1: Internal.Set_<any>, arg2: Internal.ExecutorService_, ...arg3: any_<any>[]): Internal.AsynchronousFileChannel;
        newByteChannel(arg0: Internal.Path_, arg1: Internal.Set_<any>, ...arg2: any_<any>[]): Internal.SeekableByteChannel;
        getFileAttributeView(arg0: Internal.Path_, arg1: Internal.Class_<V>, ...arg2: any_[]): V;
        createDirectory(arg0: Internal.Path_, ...arg1: any_<any>[]): void;
        createSymbolicLink(arg0: Internal.Path_, arg1: Internal.Path_, ...arg2: any_<any>[]): void;
        getScheme(): string;
        newFileSystem(arg0: Internal.URI_, arg1: Internal.Map_<string, any>): Internal.FileSystem;
        isSameFile(arg0: Internal.Path_, arg1: Internal.Path_): boolean;
        readAttributes(arg0: Internal.Path_, arg1: string, ...arg2: any_[]): Internal.Map<string, any>;
        readSymbolicLink(arg0: Internal.Path_): Internal.Path;
        isHidden(arg0: Internal.Path_): boolean;
        newOutputStream(arg0: Internal.Path_, ...arg1: Internal.OpenOption_[]): Internal.OutputStream;
        newFileSystem(arg0: Internal.Path_, arg1: Internal.Map_<string, any>): Internal.FileSystem;
        checkAccess(arg0: Internal.Path_, ...arg1: any_[]): void;
        setAttribute(arg0: Internal.Path_, arg1: string, arg2: any, ...arg3: any_[]): void;
        copy(arg0: Internal.Path_, arg1: Internal.Path_, ...arg2: any_[]): void;
        deleteIfExists(arg0: Internal.Path_): boolean;
        newInputStream(arg0: Internal.Path_, ...arg1: Internal.OpenOption_[]): Internal.InputStream;
        getFileSystem(arg0: Internal.URI_): Internal.FileSystem;
        getPath(arg0: Internal.URI_): Internal.Path;
        get scheme(): string
    }
    type FileSystemProvider_ = FileSystemProvider;
    abstract class GameRules$Value <T> {
        constructor(arg0: Internal.GameRules$Type_<T>)
        setFromArgument(arg0: Internal.CommandContext_<Internal.CommandSourceStack_>, arg1: string): void;
        serialize(): string;
        getCommandResult(): number;
        toString(): string;
        deserialize(arg0: string): void;
        setFrom(arg0: T, arg1: Internal.MinecraftServer_): void;
        get commandResult(): number
    }
    type GameRules$Value_<T> = GameRules$Value<T>;
    class ServerScoreboard extends Internal.Scoreboard {
        constructor(arg0: Internal.MinecraftServer_)
        stopTrackingObjective(arg0: Internal.Objective_): void;
        createData(arg0: Internal.CompoundTag_): Internal.ScoreboardSaveData;
        onTeamChanged(arg0: Internal.PlayerTeam_): void;
        onPlayerScoreRemoved(arg0: string, arg1: Internal.Objective_): void;
        onTeamAdded(arg0: Internal.PlayerTeam_): void;
        addPlayerToTeam(arg0: string, arg1: Internal.PlayerTeam_): boolean;
        removePlayerFromTeam(arg0: string, arg1: Internal.PlayerTeam_): void;
        addDirtyListener(arg0: Internal.Runnable_): void;
        getObjectiveDisplaySlotCount(arg0: Internal.Objective_): number;
        onObjectiveChanged(arg0: Internal.Objective_): void;
        onScoreChanged(arg0: Internal.Score_): void;
        getStartTrackingPackets(arg0: Internal.Objective_): Internal.List<Internal.Packet<any>>;
        onObjectiveAdded(arg0: Internal.Objective_): void;
        onPlayerRemoved(arg0: string): void;
        createData(): Internal.ScoreboardSaveData;
        onObjectiveRemoved(arg0: Internal.Objective_): void;
        onTeamRemoved(arg0: Internal.PlayerTeam_): void;
        getStopTrackingPackets(arg0: Internal.Objective_): Internal.List<Internal.Packet<any>>;
        startTrackingObjective(arg0: Internal.Objective_): void;
        setDisplayObjective(arg0: number, arg1: Internal.Objective_): void;
    }
    type ServerScoreboard_ = ServerScoreboard;
    class LayerConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: number, arg1: Internal.BlockState_)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "height": number;
        readonly "state": Internal.BlockState;
        readonly static "CODEC": any;
    }
    type LayerConfiguration_ = LayerConfiguration;
    interface ReputationEventHandler {
        onReputationEventFrom(arg0: Internal.ReputationEventType_, arg1: Internal.Entity_): void;
    }
    type ReputationEventHandler_ = ReputationEventHandler;
    interface Reference2LongFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToLongFunction<K> {
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2LongFunction;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2LongFunction;
        getOrDefault(arg0: any, arg1: any): any;
        removeLong(arg0: any): number;
        put(arg0: K, arg1: number): number;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Reference2ByteFunction<K>;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2LongFunction;
        containsKey(arg0: any): boolean;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Reference2IntFunction<K>;
        getLong(arg0: any): number;
        remove(arg0: any): number;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Reference2CharFunction<K>;
        put(arg0: any, arg1: any): any;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2LongFunction;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Reference2FloatFunction<K>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        andThenReference(arg0: Internal.Long2ReferenceFunction_<any>): Internal.Reference2ReferenceFunction<K, T>;
        applyAsLong(arg0: K): number;
        composeObject(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Object2LongFunction<T>;
        defaultReturnValue(): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Reference2DoubleFunction<K>;
        apply(arg0: K): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Reference2ShortFunction<K>;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2LongFunction;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2LongFunction;
        getOrDefault(arg0: any, arg1: number): number;
        size(): number;
        clear(): void;
        andThenLong(arg0: Internal.Long2LongFunction_): this;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2LongFunction;
        get(arg0: any): any;
        composeReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Reference2LongFunction<T>;
        defaultReturnValue(arg0: number): void;
        put(arg0: K, arg1: number): number;
        andThenObject(arg0: Internal.Long2ObjectFunction_<any>): Internal.Reference2ObjectFunction<K, T>;
    }
    type Reference2LongFunction_<K> = ((arg0: any)=>number) | Reference2LongFunction<K>;
    interface StructurePlacement {
        isFeatureChunk(arg0: Internal.ChunkGenerator_, arg1: number, arg2: number, arg3: number): boolean;
        type(): Internal.StructurePlacementType<any>;
        readonly static "CODEC": any;
    }
    type StructurePlacement_ = StructurePlacement;
    abstract class Number implements Internal.Serializable {
        constructor()
        longValue(): number;
        doubleValue(): number;
        shortValue(): number;
        intValue(): number;
        floatValue(): number;
        byteValue(): number;
    }
    type Number_ = Number;
    class Sound implements Internal.Weighted<Internal.Sound> {
        constructor(arg0: string, arg1: number, arg2: number, arg3: number, arg4: Internal.Sound$Type_, arg5: boolean, arg6: boolean, arg7: number)
        getVolume(): number;
        getType(): Internal.Sound$Type;
        getLocation(): ResourceLocation;
        toString(): string;
        getPitch(): number;
        getPath(): ResourceLocation;
        getSound(): any;
        getAttenuationDistance(): number;
        getWeight(): number;
        shouldStream(): boolean;
        preloadIfRequired(arg0: Internal.SoundEngine_): void;
        shouldPreload(): boolean;
        get volume(): number
        get type(): Internal.Sound$Type
        get location(): ResourceLocation
        get pitch(): number
        get path(): ResourceLocation
        get sound(): any
        get attenuationDistance(): number
        get weight(): number
    }
    type Sound_ = Sound;
    class ServerboundClientCommandPacket$Action extends Internal.Enum<Internal.ServerboundClientCommandPacket$Action> {
        static valueOf(arg0: string): Internal.ServerboundClientCommandPacket$Action;
        static values(): Internal.ServerboundClientCommandPacket$Action[];
        readonly static "REQUEST_STATS": Internal.ServerboundClientCommandPacket$Action;
        readonly static "PERFORM_RESPAWN": Internal.ServerboundClientCommandPacket$Action;
    }
    type ServerboundClientCommandPacket$Action_ = "request_stats" | "perform_respawn" | ServerboundClientCommandPacket$Action;
    interface ItemModelPropertiesEventJS$ItemPropertiesCallback {
        accept(arg0: Internal.ItemStackJS_, arg1: Internal.LevelJS_, arg2: Internal.EntityJS_, arg3: number): number;
    }
    type ItemModelPropertiesEventJS$ItemPropertiesCallback_ = ItemModelPropertiesEventJS$ItemPropertiesCallback | ((arg0: Internal.ItemStackJS, arg1: Internal.LevelJS, arg2: Internal.EntityJS, arg3: number)=>number);
    interface Wrapper {
        unwrapped(o: any): any;
        unwrap(): any;
    }
    type Wrapper_ = Wrapper;
    interface Component extends Internal.Message, Internal.FormattedText {
        nullToEmpty(arg0: string): this;
        getVisualOrderText(): Internal.FormattedCharSequence;
        visitSelf(arg0: Internal.FormattedText$StyledContentConsumer_<T>, arg1: Internal.Style_): Internal.Optional<T>;
        visit(arg0: Internal.FormattedText$ContentConsumer_<T>): Internal.Optional<T>;
        plainCopy(): Internal.MutableComponent;
        getStyle(): Internal.Style;
        visit(arg0: Internal.FormattedText$StyledContentConsumer_<T>, arg1: Internal.Style_): Internal.Optional<T>;
        visitSelf(arg0: Internal.FormattedText$ContentConsumer_<T>): Internal.Optional<T>;
        getContents(): string;
        toFlatList(arg0: Internal.Style_): Internal.List<Internal.Component>;
        getString(arg0: number): string;
        getSiblings(): Internal.List<Internal.Component>;
        copy(): Internal.MutableComponent;
        getString(): string;
        get visualOrderText(): Internal.FormattedCharSequence
        get style(): Internal.Style
        get contents(): string
        get siblings(): Internal.List<Internal.Component>
        get string(): string
    }
    type Component_ = Component;
    interface Byte2ReferenceFunction <V> extends Internal.IntFunction<V>, it.unimi.dsi.fastutil.Function<number, V> {
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2ReferenceFunction<V>;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Byte2DoubleFunction;
        composeObject(arg0: Internal.Object2ByteFunction_<any>): Internal.Object2ReferenceFunction<T, V>;
        getOrDefault(arg0: any, arg1: V): V;
        put(arg0: number, arg1: V): V;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2ReferenceFunction<V>;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Byte2IntFunction;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Byte2LongFunction;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2ReferenceFunction<V>;
        containsKey(arg0: any): boolean;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2ReferenceFunction<V>;
        get(arg0: any): V;
        put(arg0: any, arg1: any): any;
        get(arg0: number): V;
        apply(arg0: number): V;
        remove(arg0: any): V;
        containsKey(arg0: number): boolean;
        remove(arg0: number): V;
        composeReference(arg0: Internal.Reference2ByteFunction_<any>): Internal.Reference2ReferenceFunction<T, V>;
        composeByte(arg0: Internal.Byte2ByteFunction_): this;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Byte2ShortFunction;
        apply(arg0: number): V;
        andThenObject(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Byte2ObjectFunction<T>;
        andThenReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Byte2ReferenceFunction<T>;
        put(arg0: number, arg1: V): V;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Byte2CharFunction;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Byte2FloatFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Byte2ByteFunction;
        size(): number;
        getOrDefault(arg0: number, arg1: V): V;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2ReferenceFunction<V>;
        clear(): void;
        defaultReturnValue(): V;
        defaultReturnValue(arg0: V): void;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2ReferenceFunction<V>;
    }
    type Byte2ReferenceFunction_<V> = ((arg0: number)=>V) | Byte2ReferenceFunction<V>;
    class VariantBlockStateGenerator$Variant {
        constructor()
        model(s: string): Internal.VariantBlockStateGenerator$Model;
        toJson(): Internal.JsonElement;
    }
    type VariantBlockStateGenerator$Variant_ = VariantBlockStateGenerator$Variant;
    class AudioFormat$Encoding {
        constructor(arg0: string)
        hashCode(): number;
        toString(): string;
        equals(arg0: any): boolean;
        readonly static "PCM_SIGNED": Internal.AudioFormat$Encoding;
        readonly static "ULAW": Internal.AudioFormat$Encoding;
        readonly static "PCM_UNSIGNED": Internal.AudioFormat$Encoding;
        readonly static "PCM_FLOAT": Internal.AudioFormat$Encoding;
        readonly static "ALAW": Internal.AudioFormat$Encoding;
    }
    type AudioFormat$Encoding_ = AudioFormat$Encoding;
    class AssetJsonGenerator extends Internal.JsonGenerator {
        constructor(m: Internal.Map_<ResourceLocation_, Internal.JsonElement_>)
        static asItemModelLocation(id: ResourceLocation_): ResourceLocation;
        itemModel(id: ResourceLocation_, consumer: Internal.Consumer_<Internal.ModelGenerator_>): void;
        blockModel(id: ResourceLocation_, consumer: Internal.Consumer_<Internal.ModelGenerator_>): void;
        blockState(id: ResourceLocation_, consumer: Internal.Consumer_<Internal.VariantBlockStateGenerator_>): void;
        multipartState(id: ResourceLocation_, consumer: Internal.Consumer_<Internal.MultipartBlockStateGenerator_>): void;
    }
    type AssetJsonGenerator_ = AssetJsonGenerator;
    class PlayerInteractEvent$LeftClickEmpty extends Internal.PlayerInteractEvent {
        constructor()
        constructor(arg0: Internal.Player_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type PlayerInteractEvent$LeftClickEmpty_ = PlayerInteractEvent$LeftClickEmpty;
    interface LevelKJS extends Internal.AsKJS<Internal.LevelJS> {
        asKJS(): Internal.LevelJS;
    }
    type LevelKJS_ = LevelKJS;
    interface ChronoZonedDateTime <D> extends Internal.Comparable<Internal.ChronoZonedDateTime<any>>, Internal.Temporal {
        toLocalTime(): Internal.LocalTime;
        isAfter(arg0: Internal.ChronoZonedDateTime_<any>): boolean;
        toInstant(): Internal.Instant;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Temporal;
        compareTo(arg0: any): number;
        toLocalDateTime(): Internal.ChronoLocalDateTime<D>;
        getZone(): Internal.ZoneId;
        with(arg0: Internal.TemporalAdjuster_): Internal.Temporal;
        getLong(arg0: Internal.TemporalField_): number;
        timeLineOrder(): Internal.Comparator<Internal.ChronoZonedDateTime<any>>;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Temporal;
        with(arg0: Internal.TemporalField_, arg1: number): this;
        compareTo(arg0: Internal.ChronoZonedDateTime_<any>): number;
        isSupported(arg0: Internal.TemporalField_): boolean;
        format(arg0: Internal.DateTimeFormatter_): string;
        getOffset(): Internal.ZoneOffset;
        getChronology(): Internal.Chronology;
        toString(): string;
        withZoneSameInstant(arg0: Internal.ZoneId_): this;
        isEqual(arg0: Internal.ChronoZonedDateTime_<any>): boolean;
        query(arg0: Internal.TemporalQuery_<R>): R;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        isBefore(arg0: Internal.ChronoZonedDateTime_<any>): boolean;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        from(arg0: Internal.TemporalAccessor_): Internal.ChronoZonedDateTime<any>;
        plus(arg0: Internal.TemporalAmount_): Internal.Temporal;
        hashCode(): number;
        withEarlierOffsetAtOverlap(): this;
        get(arg0: Internal.TemporalField_): number;
        withZoneSameLocal(arg0: Internal.ZoneId_): this;
        toLocalDate(): D;
        equals(arg0: any): boolean;
        minus(arg0: Internal.TemporalAmount_): Internal.Temporal;
        toEpochSecond(): number;
        withLaterOffsetAtOverlap(): this;
        get zone(): Internal.ZoneId
        get offset(): Internal.ZoneOffset
        get chronology(): Internal.Chronology
    }
    type ChronoZonedDateTime_<D> = ChronoZonedDateTime<D>;
    class BiomeSpecialEffects$GrassColorModifier extends Internal.Enum<Internal.BiomeSpecialEffects$GrassColorModifier> implements Internal.IExtensibleEnum, Internal.StringRepresentable {
        static byName(arg0: string): Internal.BiomeSpecialEffects$GrassColorModifier;
        static create(arg0: string, arg1: string, arg2: Internal.BiomeSpecialEffects$GrassColorModifier$ColorModifier_): Internal.BiomeSpecialEffects$GrassColorModifier;
        init(): void;
        getSerializedName(): string;
        static values(): Internal.BiomeSpecialEffects$GrassColorModifier[];
        getName(): string;
        modifyColor(arg0: number, arg1: number, arg2: number): number;
        static valueOf(arg0: string): Internal.BiomeSpecialEffects$GrassColorModifier;
        get serializedName(): string
        get name(): string
        readonly static "DARK_FOREST": any;
        readonly static "CODEC": any;
        readonly static "SWAMP": any;
        readonly static "NONE": any;
    }
    type BiomeSpecialEffects$GrassColorModifier_ = "dark_forest" | BiomeSpecialEffects$GrassColorModifier | "none" | "swamp";
    class CommandSyntaxException extends Internal.Exception {
        constructor(arg0: Internal.CommandExceptionType_, arg1: Internal.Message_, arg2: string, arg3: number)
        constructor(arg0: Internal.CommandExceptionType_, arg1: Internal.Message_)
        getRawMessage(): Internal.Message;
        getCursor(): number;
        getMessage(): string;
        getInput(): string;
        getContext(): string;
        getType(): Internal.CommandExceptionType;
        get rawMessage(): Internal.Message
        get cursor(): number
        get message(): string
        get input(): string
        get context(): string
        get type(): Internal.CommandExceptionType
        static "ENABLE_COMMAND_STACK_TRACES": false;
        static "BUILT_IN_EXCEPTIONS": any;
        readonly static "CONTEXT_AMOUNT": 10;
    }
    type CommandSyntaxException_ = CommandSyntaxException;
    abstract class FlyingMob extends Internal.Mob {
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        travel(arg0: Vec3_): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        onClimbable(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type FlyingMob_ = FlyingMob;
    class SuggestionContext <S> {
        constructor(arg0: Internal.CommandNode_<S>, arg1: number)
        readonly "startPos": number;
        readonly "parent": Internal.CommandNode<S>;
    }
    type SuggestionContext_<S> = SuggestionContext<S>;
    class SecondaryPoiSensor extends Internal.Sensor<Internal.Villager> {
        constructor()
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
    }
    type SecondaryPoiSensor_ = SecondaryPoiSensor;
    abstract class PlacementFilter extends Internal.PlacementModifier {
        constructor()
        getPositions(arg0: Internal.PlacementContext_, arg1: Internal.Random_, arg2: BlockPos_): Internal.Stream<BlockPos>;
    }
    type PlacementFilter_ = PlacementFilter;
    class GameRules$IntegerValue extends Internal.GameRules$Value<Internal.GameRules$IntegerValue> {
        constructor(arg0: Internal.GameRules$Type_<Internal.GameRules$IntegerValue_>, arg1: number)
        set(arg0: number, arg1: Internal.MinecraftServer_): void;
        setFrom(arg0: Internal.GameRules$Value_<any>, arg1: Internal.MinecraftServer_): void;
        serialize(): string;
        getCommandResult(): number;
        setFrom(arg0: Internal.GameRules$IntegerValue_, arg1: Internal.MinecraftServer_): void;
        tryDeserialize(arg0: string): boolean;
        static create(arg0: number): Internal.GameRules$Type<Internal.GameRules$IntegerValue>;
        static create(arg0: number, arg1: Internal.BiConsumer_<Internal.MinecraftServer_, Internal.GameRules$IntegerValue_>): Internal.GameRules$Type<Internal.GameRules$IntegerValue>;
        get(): number;
        get commandResult(): number
    }
    type GameRules$IntegerValue_ = GameRules$IntegerValue;
    class OptionalDynamic <T> extends Internal.DynamicLike<T> {
        constructor(arg0: Internal.DynamicOps_<T>, arg1: Internal.DataResult_<Internal.Dynamic_<T>>)
        getElementGeneric(arg0: T): Internal.DataResult<T>;
        decode(arg0: Internal.Decoder_<any>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>;
        asLongStreamOpt(): Internal.DataResult<Internal.LongStream>;
        map(arg0: Internal.Function_<any, U>): Internal.DataResult<U>;
        getGeneric(arg0: T): Internal.DataResult<T>;
        flatMap(arg0: Internal.Function_<any, any>): Internal.DataResult<U>;
        get(): Internal.DataResult<Internal.Dynamic<T>>;
        asNumber(): Internal.DataResult<Internal.Number>;
        asByteBufferOpt(): Internal.DataResult<Internal.ByteBuffer>;
        orElseEmptyMap(): Internal.Dynamic<T>;
        asString(): Internal.DataResult<string>;
        asIntStreamOpt(): Internal.DataResult<Internal.IntStream>;
        result(): Internal.Optional<Internal.Dynamic<T>>;
        asStreamOpt(): Internal.DataResult<Internal.Stream<Internal.Dynamic<T>>>;
        asMapOpt(): Internal.DataResult<Internal.Stream<com.mojang.datafixers.util.Pair<Internal.Dynamic<T>, Internal.Dynamic<T>>>>;
        getElement(arg0: string): Internal.DataResult<T>;
        orElseEmptyList(): Internal.Dynamic<T>;
        into(arg0: Internal.Function_<any, any>): Internal.DataResult<V>;
        get(arg0: string): this;
    }
    type OptionalDynamic_<T> = OptionalDynamic<T>;
    class RoundingMode extends Internal.Enum<Internal.RoundingMode> {
        static valueOf(arg0: number): Internal.RoundingMode;
        static valueOf(arg0: string): Internal.RoundingMode;
        static values(): Internal.RoundingMode[];
        readonly static "FLOOR": Internal.RoundingMode;
        readonly static "HALF_DOWN": Internal.RoundingMode;
        readonly static "UNNECESSARY": Internal.RoundingMode;
        readonly static "HALF_UP": Internal.RoundingMode;
        readonly static "UP": Internal.RoundingMode;
        readonly static "CEILING": Internal.RoundingMode;
        readonly static "DOWN": Internal.RoundingMode;
        readonly static "HALF_EVEN": Internal.RoundingMode;
    }
    type RoundingMode_ = "floor" | "up" | "down" | RoundingMode | "half_down" | "ceiling" | "unnecessary" | "half_up" | "half_even";
    class DarkOakTrunkPlacer extends Internal.TrunkPlacer {
        constructor(arg0: number, arg1: number, arg2: number)
        placeTrunk(arg0: Internal.LevelSimulatedReader_, arg1: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>, arg2: Internal.Random_, arg3: number, arg4: BlockPos_, arg5: Internal.TreeConfiguration_): Internal.List<Internal.FoliagePlacer$FoliageAttachment>;
        readonly static "CODEC": any;
    }
    type DarkOakTrunkPlacer_ = DarkOakTrunkPlacer;
    interface Effect extends Internal.Shader {
    }
    type Effect_ = Effect;
    class CraftingContainer implements Internal.Container, Internal.StackedContentsCompatible {
        constructor(arg0: Internal.AbstractContainerMenu_, arg1: number, arg2: number)
        stopOpen(arg0: Internal.Player_): void;
        getWidth(): number;
        getMaxStackSize(): number;
        countItem(arg0: Internal.Item_): number;
        fillStackedContents(arg0: Internal.StackedContents_): void;
        isEmpty(): boolean;
        removeItemNoUpdate(arg0: number): Internal.ItemStack;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        stillValid(arg0: Internal.Player_): boolean;
        removeItem(arg0: number, arg1: number): Internal.ItemStack;
        setChanged(): void;
        getItem(arg0: number): Internal.ItemStack;
        getContainerSize(): number;
        getHeight(): number;
        setItem(arg0: number, arg1: Internal.ItemStack_): void;
        clearContent(): void;
        get width(): number
        get maxStackSize(): number
        get empty(): boolean
        get containerSize(): number
        get height(): number
        readonly "menu": Internal.AbstractContainerMenu;
    }
    type CraftingContainer_ = CraftingContainer;
    class ClientTelemetryManager {
        constructor(arg0: Internal.Minecraft_, arg1: any_, arg2: Internal.Optional_<string>, arg3: Internal.Optional_<string>, arg4: Internal.UUID_)
        onPlayerInfoReceived(arg0: Internal.GameType_, arg1: boolean): void;
        onServerBrandReceived(arg0: string): void;
        onDisconnect(): void;
    }
    type ClientTelemetryManager_ = ClientTelemetryManager;
    abstract class CustomBuffer <SELF> extends Internal.Pointer$Default {
        compact(): SELF;
        capacity(): number;
        toString(): string;
        remaining(): number;
        mark(): SELF;
        limit(): number;
        free(): void;
        address(arg0: number): number;
        position(): number;
        put(arg0: SELF): SELF;
        rewind(): SELF;
        sizeof(): number;
        slice(): SELF;
        limit(arg0: number): SELF;
        flip(): SELF;
        clear(): SELF;
        position(arg0: number): SELF;
        reset(): SELF;
        address0(): number;
        hasRemaining(): boolean;
        slice(arg0: number, arg1: number): SELF;
        duplicate(): SELF;
        address(): number;
    }
    type CustomBuffer_<SELF> = CustomBuffer<SELF>;
    class RenderStateShard$TextureStateShard extends Internal.RenderStateShard$EmptyTextureStateShard {
        constructor(arg0: ResourceLocation_, arg1: boolean, arg2: boolean)
        toString(): string;
    }
    type RenderStateShard$TextureStateShard_ = RenderStateShard$TextureStateShard;
    class GrindstoneMenu extends Internal.AbstractContainerMenu {
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: any_)
        constructor(arg0: number, arg1: Internal.Inventory_)
        stillValid(arg0: Internal.Player_): boolean;
        slotsChanged(arg0: Internal.Container_): void;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        removed(arg0: Internal.Player_): void;
        readonly static "INPUT_SLOT": 0;
        readonly static "MAX_NAME_LENGTH": 35;
        readonly static "RESULT_SLOT": 2;
        readonly static "ADDITIONAL_SLOT": 1;
    }
    type GrindstoneMenu_ = GrindstoneMenu;
    abstract class ForwardingObject {
        toString(): string;
    }
    type ForwardingObject_ = ForwardingObject;
    class TextFilter$FilteredText {
        constructor(arg0: string, arg1: string)
        static passThrough(arg0: string): Internal.TextFilter$FilteredText;
        getRaw(): string;
        static fullyFiltered(arg0: string): Internal.TextFilter$FilteredText;
        getFiltered(): string;
        get raw(): string
        get filtered(): string
        readonly static "EMPTY": Internal.TextFilter$FilteredText;
    }
    type TextFilter$FilteredText_ = TextFilter$FilteredText;
    interface MenuType$MenuSupplier <T> {
        create(arg0: number, arg1: Internal.Inventory_): T;
    }
    type MenuType$MenuSupplier_<T> = MenuType$MenuSupplier<T>;
    class FenceBlockBuilder extends Internal.ShapedBlockBuilder {
        constructor(i: ResourceLocation_)
        createObject(): any;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
    }
    type FenceBlockBuilder_ = FenceBlockBuilder;
    class ClickEvent$Action extends Internal.Enum<Internal.ClickEvent$Action> {
        static values(): Internal.ClickEvent$Action[];
        static getByName(arg0: string): Internal.ClickEvent$Action;
        isAllowedFromServer(): boolean;
        getName(): string;
        static valueOf(arg0: string): Internal.ClickEvent$Action;
        get allowedFromServer(): boolean
        get name(): string
        readonly static "COPY_TO_CLIPBOARD": Internal.ClickEvent$Action;
        readonly static "CHANGE_PAGE": Internal.ClickEvent$Action;
        readonly static "OPEN_FILE": Internal.ClickEvent$Action;
        readonly static "RUN_COMMAND": Internal.ClickEvent$Action;
        readonly static "SUGGEST_COMMAND": Internal.ClickEvent$Action;
        readonly static "OPEN_URL": Internal.ClickEvent$Action;
    }
    type ClickEvent$Action_ = "copy_to_clipboard" | "suggest_command" | "open_file" | "change_page" | ClickEvent$Action | "open_url" | "run_command";
    class Parameter implements Internal.AnnotatedElement {
        toString(): string;
        getAnnotation(arg0: Internal.Class_<A>): A;
        hashCode(): number;
        getDeclaringInvokable(): Internal.Invokable<any, any>;
        getType(): Internal.TypeToken<any>;
        getAnnotations(): Internal.Annotation[];
        isAnnotationPresent(arg0: Internal.Class_<any>): boolean;
        getDeclaredAnnotation(arg0: Internal.Class_<A>): A;
        getAnnotatedType(): Internal.AnnotatedType;
        getAnnotationsByType(arg0: Internal.Class_<A>): A[];
        equals(arg0: any): boolean;
        getDeclaredAnnotations(): Internal.Annotation[];
        getDeclaredAnnotationsByType(arg0: Internal.Class_<A>): A[];
        get declaringInvokable(): Internal.Invokable<any, any>
        get type(): Internal.TypeToken<any>
        get annotations(): Internal.Annotation[]
        get annotatedType(): Internal.AnnotatedType
        get declaredAnnotations(): Internal.Annotation[]
    }
    type Parameter_ = Parameter;
    class LevelSummary implements Internal.Comparable<Internal.LevelSummary> {
        constructor(arg0: Internal.LevelSettings_, arg1: Internal.LevelVersion_, arg2: string, arg3: boolean, arg4: boolean, arg5: Internal.File_)
        isDisabled(): boolean;
        getIcon(): Internal.File;
        getLastPlayed(): number;
        getLevelId(): string;
        getSettings(): Internal.LevelSettings;
        compareTo(arg0: Internal.LevelSummary_): number;
        backupStatus(): Internal.LevelSummary$BackupStatus;
        getLevelName(): string;
        hasCheats(): boolean;
        requiresManualConversion(): boolean;
        compareTo(arg0: any): number;
        isLocked(): boolean;
        isExperimental(): boolean;
        isCompatible(): boolean;
        getGameMode(): Internal.GameType;
        markVersionInList(): boolean;
        getWorldVersionName(): Internal.MutableComponent;
        isHardcore(): boolean;
        askToOpenWorld(): boolean;
        getInfo(): Internal.Component;
        levelVersion(): Internal.LevelVersion;
        get disabled(): boolean
        get icon(): Internal.File
        get lastPlayed(): number
        get levelId(): string
        get settings(): Internal.LevelSettings
        get levelName(): string
        get locked(): boolean
        get experimental(): boolean
        get compatible(): boolean
        get gameMode(): Internal.GameType
        get worldVersionName(): Internal.MutableComponent
        get hardcore(): boolean
        get info(): Internal.Component
    }
    type LevelSummary_ = LevelSummary;
    class CopyNameFunction$NameSource extends Internal.Enum<Internal.CopyNameFunction$NameSource> {
        static valueOf(arg0: string): Internal.CopyNameFunction$NameSource;
        static values(): Internal.CopyNameFunction$NameSource[];
        static getByName(arg0: string): Internal.CopyNameFunction$NameSource;
        readonly "name": string;
        readonly static "BLOCK_ENTITY": Internal.CopyNameFunction$NameSource;
        readonly "param": Internal.LootContextParam<any>;
        readonly static "KILLER": Internal.CopyNameFunction$NameSource;
        readonly static "KILLER_PLAYER": Internal.CopyNameFunction$NameSource;
        readonly static "THIS": Internal.CopyNameFunction$NameSource;
    }
    type CopyNameFunction$NameSource_ = "killer" | CopyNameFunction$NameSource | "killer_player" | "this" | "block_entity";
    interface Iterator <E> {
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): E;
        hasNext(): boolean;
    }
    type Iterator_<E> = Iterator<E>;
    class ClientboundLightUpdatePacketData {
        constructor(arg0: Internal.ChunkPos_, arg1: Internal.LevelLightEngine_, arg2: Internal.BitSet_, arg3: Internal.BitSet_, arg4: boolean)
        constructor(arg0: Internal.FriendlyByteBuf_, arg1: number, arg2: number)
        getTrustEdges(): boolean;
        getEmptyBlockYMask(): Internal.BitSet;
        getEmptySkyYMask(): Internal.BitSet;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getBlockUpdates(): Internal.List<number[]>;
        getBlockYMask(): Internal.BitSet;
        getSkyUpdates(): Internal.List<number[]>;
        getSkyYMask(): Internal.BitSet;
        get trustEdges(): boolean
        get emptyBlockYMask(): Internal.BitSet
        get emptySkyYMask(): Internal.BitSet
        get blockUpdates(): Internal.List<number[]>
        get blockYMask(): Internal.BitSet
        get skyUpdates(): Internal.List<number[]>
        get skyYMask(): Internal.BitSet
    }
    type ClientboundLightUpdatePacketData_ = ClientboundLightUpdatePacketData;
    interface ContainerSynchronizer {
        sendDataChange(arg0: Internal.AbstractContainerMenu_, arg1: number, arg2: number): void;
        sendSlotChange(arg0: Internal.AbstractContainerMenu_, arg1: number, arg2: Internal.ItemStack_): void;
        sendInitialData(arg0: Internal.AbstractContainerMenu_, arg1: Internal.NonNullList_<Internal.ItemStack_>, arg2: Internal.ItemStack_, arg3: number[]): void;
        sendCarriedChange(arg0: Internal.AbstractContainerMenu_, arg1: Internal.ItemStack_): void;
    }
    type ContainerSynchronizer_ = ContainerSynchronizer;
    class MobEffectCategory extends Internal.Enum<Internal.MobEffectCategory> {
        static values(): Internal.MobEffectCategory[];
        getTooltipFormatting(): Internal.ChatFormatting;
        static valueOf(arg0: string): Internal.MobEffectCategory;
        get tooltipFormatting(): Internal.ChatFormatting
        readonly static "HARMFUL": Internal.MobEffectCategory;
        readonly static "BENEFICIAL": Internal.MobEffectCategory;
        readonly static "NEUTRAL": Internal.MobEffectCategory;
    }
    type MobEffectCategory_ = "neutral" | MobEffectCategory | "beneficial" | "harmful";
    class ClientboundSetObjectivePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.Objective_, arg1: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getDisplayName(): Internal.Component;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getMethod(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getRenderType(): Internal.ObjectiveCriteria$RenderType;
        isSkippable(): boolean;
        getObjectiveName(): string;
        get displayName(): Internal.Component
        get method(): number
        get renderType(): Internal.ObjectiveCriteria$RenderType
        get skippable(): boolean
        get objectiveName(): string
        readonly static "METHOD_ADD": 0;
        readonly static "METHOD_CHANGE": 2;
        readonly static "METHOD_REMOVE": 1;
    }
    type ClientboundSetObjectivePacket_ = ClientboundSetObjectivePacket;
    abstract class AbstractArrow extends Internal.Projectile {
        isCritArrow(): boolean;
        setEnchantmentEffectsFromEntity(arg0: Internal.LivingEntity_, arg1: number): void;
        setCritArrow(arg0: boolean): void;
        playerTouch(arg0: Internal.Player_): void;
        getStepHeight(): number;
        isNoPhysics(): boolean;
        asKJS(): Internal.EntityJS;
        setOwner(arg0: Internal.Entity_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        getPierceLevel(): number;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setShotFromCrossbow(arg0: boolean): void;
        shouldRenderAtSqrDistance(arg0: number): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getBaseDamage(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        shoot(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        setBaseDamage(arg0: number): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        lerpTo(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: boolean): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        move(arg0: Internal.MoverType_, arg1: Vec3_): void;
        getKnockback(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        lerpMotion(arg0: number, arg1: number, arg2: number): void;
        setSoundEvent(arg0: Internal.SoundEvent_): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        setNoPhysics(arg0: boolean): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        setKnockback(arg0: number): void;
        isAttackable(): boolean;
        shotFromCrossbow(): boolean;
        setPierceLevel(arg0: number): void;
        get critArrow(): boolean
        set critArrow(arg0: boolean)
        get stepHeight(): number
        get noPhysics(): boolean
        set owner(arg0: Internal.Entity_)
        get multipartEntity(): boolean
        get pierceLevel(): number
        set shotFromCrossbow(arg0: boolean)
        get parts(): Internal.PartEntity<any>[]
        get baseDamage(): number
        set baseDamage(arg0: number)
        get knockback(): number
        set soundEvent(arg0: Internal.SoundEvent_)
        set noPhysics(arg0: boolean)
        set knockback(arg0: number)
        get attackable(): boolean
        set pierceLevel(arg0: number)
        "pickup": Internal.AbstractArrow$Pickup;
        "shakeTime": number;
    }
    type AbstractArrow_ = AbstractArrow;
    abstract class PlayerDataJS <E, P> implements Internal.WithAttachedData {
        constructor()
        hasClientMod(): boolean;
        getProfile(): Internal.GameProfile;
        getOverworld(): Internal.LevelJS;
        getName(): string;
        getId(): Internal.UUID;
        getPlayer(): P;
        getData(): Internal.AttachedData;
        getMinecraftPlayer(): E;
        get profile(): Internal.GameProfile
        get overworld(): Internal.LevelJS
        get name(): string
        get id(): Internal.UUID
        get player(): P
        get data(): Internal.AttachedData
        get minecraftPlayer(): E
    }
    type PlayerDataJS_<E, P> = PlayerDataJS<E, P>;
    class ClampedNormalFloat extends Internal.FloatProvider {
        getMinValue(): number;
        static of(arg0: number, arg1: number, arg2: number, arg3: number): Internal.ClampedNormalFloat;
        toString(): string;
        getMaxValue(): number;
        static sample(arg0: Internal.Random_, arg1: number, arg2: number, arg3: number, arg4: number): number;
        sample(arg0: Internal.Random_): number;
        getType(): Internal.FloatProviderType<any>;
        get minValue(): number
        get maxValue(): number
        get type(): Internal.FloatProviderType<any>
        readonly static "CODEC": any;
    }
    type ClampedNormalFloat_ = ClampedNormalFloat;
    class SmokerMenu extends Internal.AbstractFurnaceMenu {
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Container_, arg3: any_)
        constructor(arg0: number, arg1: Internal.Inventory_)
    }
    type SmokerMenu_ = SmokerMenu;
    class StructureManager {
        constructor(arg0: Internal.ResourceManager_, arg1: Internal.LevelStorageSource$LevelStorageAccess_, arg2: Internal.DataFixer_)
        save(arg0: ResourceLocation_): boolean;
        remove(arg0: ResourceLocation_): void;
        onResourceManagerReload(arg0: Internal.ResourceManager_): void;
        getOrCreate(arg0: ResourceLocation_): Internal.StructureTemplate;
        readStructure(arg0: Internal.CompoundTag_): Internal.StructureTemplate;
        get(arg0: ResourceLocation_): Internal.Optional<Internal.StructureTemplate>;
        createPathToStructure(arg0: ResourceLocation_, arg1: string): Internal.Path;
    }
    type StructureManager_ = StructureManager;
    interface ICloudRenderHandler {
        render(arg0: number, arg1: number, arg2: Internal.PoseStack_, arg3: Internal.ClientLevel_, arg4: Internal.Minecraft_, arg5: number, arg6: number, arg7: number): void;
    }
    type ICloudRenderHandler_ = ((arg0: number, arg1: number, arg2: Internal.PoseStack, arg3: Internal.ClientLevel, arg4: Internal.Minecraft, arg5: number, arg6: number, arg7: number)=>void) | ICloudRenderHandler;
    class HoglinSpecificSensor extends Internal.Sensor<Internal.Hoglin> {
        constructor()
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
    }
    type HoglinSpecificSensor_ = HoglinSpecificSensor;
    interface Char2ObjectFunction <V> extends Internal.IntFunction<V>, it.unimi.dsi.fastutil.Function<string, V> {
        getOrDefault(arg0: any, arg1: V): V;
        composeChar(arg0: Internal.Char2CharFunction_): this;
        andThenObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Char2ObjectFunction<T>;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2ObjectFunction<V>;
        containsKey(arg0: string): boolean;
        containsKey(arg0: any): boolean;
        remove(arg0: string): V;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Char2ShortFunction;
        get(arg0: any): V;
        put(arg0: any, arg1: any): any;
        apply(arg0: number): V;
        remove(arg0: any): V;
        composeObject(arg0: Internal.Object2CharFunction_<any>): Internal.Object2ObjectFunction<T, V>;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Char2LongFunction;
        put(arg0: string, arg1: V): V;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2ObjectFunction<V>;
        andThenReference(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Char2ReferenceFunction<T>;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2ObjectFunction<V>;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2ObjectFunction<V>;
        get(arg0: string): V;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Char2FloatFunction;
        getOrDefault(arg0: string, arg1: V): V;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Char2ByteFunction;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2ObjectFunction<V>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        apply(arg0: string): V;
        size(): number;
        composeReference(arg0: Internal.Reference2CharFunction_<any>): Internal.Reference2ObjectFunction<T, V>;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Char2DoubleFunction;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Char2IntFunction;
        clear(): void;
        put(arg0: string, arg1: V): V;
        defaultReturnValue(): V;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2ObjectFunction<V>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<string, V>;
        defaultReturnValue(arg0: V): void;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Char2CharFunction;
    }
    type Char2ObjectFunction_<V> = ((arg0: string)=>V) | Char2ObjectFunction<V>;
    class ItemOverrides$BakedOverride {
    }
    type ItemOverrides$BakedOverride_ = ItemOverrides$BakedOverride;
    interface ReputationEventType {
        register(arg0: string): this;
        readonly static "VILLAGER_KILLED": any;
        readonly static "VILLAGER_HURT": any;
        readonly static "TRADE": any;
        readonly static "GOLEM_KILLED": any;
        readonly static "ZOMBIE_VILLAGER_CURED": any;
    }
    type ReputationEventType_ = ReputationEventType;
    class MineshaftFeature$Type extends Internal.Enum<Internal.MineshaftFeature$Type> implements Internal.StringRepresentable {
        static valueOf(arg0: string): Internal.MineshaftFeature$Type;
        getWoodState(): Internal.BlockState;
        getFenceState(): Internal.BlockState;
        getPlanksState(): Internal.BlockState;
        static byId(arg0: number): Internal.MineshaftFeature$Type;
        getSerializedName(): string;
        getName(): string;
        static values(): Internal.MineshaftFeature$Type[];
        get woodState(): Internal.BlockState
        get fenceState(): Internal.BlockState
        get planksState(): Internal.BlockState
        get serializedName(): string
        get name(): string
        readonly static "MESA": Internal.MineshaftFeature$Type;
        readonly static "NORMAL": Internal.MineshaftFeature$Type;
        readonly static "CODEC": any;
    }
    type MineshaftFeature$Type_ = "normal" | MineshaftFeature$Type | "mesa";
    interface IntUnaryOperator {
        compose(arg0: Internal.IntUnaryOperator_): this;
        applyAsInt(arg0: number): number;
        identity(): this;
        andThen(arg0: Internal.IntUnaryOperator_): this;
    }
    type IntUnaryOperator_ = ((arg0: number)=>number) | IntUnaryOperator;
    class EntityViewRenderEvent$FogColors extends Internal.EntityViewRenderEvent {
        constructor()
        constructor(arg0: Internal.Camera_, arg1: number, arg2: number, arg3: number, arg4: number)
        getRed(): number;
        getGreen(): number;
        getBlue(): number;
        setRed(arg0: number): void;
        getListenerList(): Internal.ListenerList;
        setGreen(arg0: number): void;
        setBlue(arg0: number): void;
        get red(): number
        get green(): number
        get blue(): number
        set red(arg0: number)
        get listenerList(): Internal.ListenerList
        set green(arg0: number)
        set blue(arg0: number)
    }
    type EntityViewRenderEvent$FogColors_ = EntityViewRenderEvent$FogColors;
    class ChannelInboundHandlerAdapter extends Internal.ChannelHandlerAdapter implements Internal.ChannelInboundHandler {
        constructor()
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext_): void;
        channelInactive(arg0: Internal.ChannelHandlerContext_): void;
        channelActive(arg0: Internal.ChannelHandlerContext_): void;
        channelUnregistered(arg0: Internal.ChannelHandlerContext_): void;
        userEventTriggered(arg0: Internal.ChannelHandlerContext_, arg1: any): void;
        exceptionCaught(arg0: Internal.ChannelHandlerContext_, arg1: Internal.Throwable_): void;
        channelReadComplete(arg0: Internal.ChannelHandlerContext_): void;
        channelRegistered(arg0: Internal.ChannelHandlerContext_): void;
        channelRead(arg0: Internal.ChannelHandlerContext_, arg1: any): void;
    }
    type ChannelInboundHandlerAdapter_ = ChannelInboundHandlerAdapter;
    interface NonNullSupplier <T> {
        get(): T;
    }
    type NonNullSupplier_<T> = NonNullSupplier<T> | (()=>T);
    class VertexBuffer implements Internal.AutoCloseable {
        constructor()
        static unbindVertexArray(): void;
        static unbind(): void;
        bind(): void;
        uploadLater(arg0: Internal.BufferBuilder_): Internal.CompletableFuture<void>;
        getFormat(): Internal.VertexFormat;
        draw(): void;
        _drawWithShader(arg0: Internal.Matrix4f_, arg1: Internal.Matrix4f_, arg2: Internal.ShaderInstance_): void;
        drawChunkLayer(): void;
        close(): void;
        upload(arg0: Internal.BufferBuilder_): void;
        drawWithShader(arg0: Internal.Matrix4f_, arg1: Internal.Matrix4f_, arg2: Internal.ShaderInstance_): void;
        get format(): Internal.VertexFormat
    }
    type VertexBuffer_ = VertexBuffer;
    interface IngredientKJS extends Internal.AsKJS<Internal.IngredientJS> {
        asKJS(): Internal.IngredientJS;
        getItemsKJS(): Internal.ItemStack[];
        get itemsKJS(): Internal.ItemStack[]
    }
    type IngredientKJS_ = IngredientKJS;
    class NoiseRouterWithOnlyNoises extends Internal.Record {
        constructor(arg0: Internal.DensityFunction_, arg1: Internal.DensityFunction_, arg2: Internal.DensityFunction_, arg3: Internal.DensityFunction_, arg4: Internal.DensityFunction_, arg5: Internal.DensityFunction_, arg6: Internal.DensityFunction_, arg7: Internal.DensityFunction_, arg8: Internal.DensityFunction_, arg9: Internal.DensityFunction_, arg10: Internal.DensityFunction_, arg11: Internal.DensityFunction_, arg12: Internal.DensityFunction_, arg13: Internal.DensityFunction_, arg14: Internal.DensityFunction_)
        barrierNoise(): Internal.DensityFunction;
        continents(): Internal.DensityFunction;
        toString(): string;
        veinToggle(): Internal.DensityFunction;
        finalDensity(): Internal.DensityFunction;
        veinGap(): Internal.DensityFunction;
        initialDensityWithoutJaggedness(): Internal.DensityFunction;
        ridges(): Internal.DensityFunction;
        fluidLevelSpreadNoise(): Internal.DensityFunction;
        mapAll(arg0: Internal.DensityFunction$Visitor_): this;
        lavaNoise(): Internal.DensityFunction;
        hashCode(): number;
        temperature(): Internal.DensityFunction;
        veinRidged(): Internal.DensityFunction;
        equals(arg0: any): boolean;
        depth(): Internal.DensityFunction;
        fluidLevelFloodednessNoise(): Internal.DensityFunction;
        erosion(): Internal.DensityFunction;
        vegetation(): Internal.DensityFunction;
        readonly static "CODEC": any;
    }
    type NoiseRouterWithOnlyNoises_ = NoiseRouterWithOnlyNoises;
    interface Reference2ByteFunction <K> extends Internal.ToIntFunction<K>, it.unimi.dsi.fastutil.Function<K, number> {
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Reference2FloatFunction<K>;
        composeObject(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Object2ByteFunction<T>;
        getOrDefault(arg0: any, arg1: number): number;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Reference2DoubleFunction<K>;
        getOrDefault(arg0: any, arg1: any): any;
        put(arg0: K, arg1: number): number;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Reference2IntFunction<K>;
        put(arg0: K, arg1: number): number;
        andThenObject(arg0: Internal.Byte2ObjectFunction_<any>): Internal.Reference2ObjectFunction<K, T>;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Reference2ShortFunction<K>;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2ByteFunction;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2ByteFunction;
        containsKey(arg0: any): boolean;
        defaultReturnValue(arg0: number): void;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Reference2CharFunction<K>;
        removeByte(arg0: any): number;
        apply(arg0: K): number;
        remove(arg0: any): number;
        put(arg0: any, arg1: any): any;
        defaultReturnValue(): number;
        andThenByte(arg0: Internal.Byte2ByteFunction_): this;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2ByteFunction;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Reference2LongFunction<K>;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2ByteFunction;
        applyAsInt(arg0: K): number;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2ByteFunction;
        getOrDefault(arg0: any, arg1: number): number;
        getByte(arg0: any): number;
        size(): number;
        composeReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Reference2ByteFunction<T>;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2ByteFunction;
        clear(): void;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2ByteFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        get(arg0: any): any;
        andThenReference(arg0: Internal.Byte2ReferenceFunction_<any>): Internal.Reference2ReferenceFunction<K, T>;
    }
    type Reference2ByteFunction_<K> = ((arg0: any)=>number) | Reference2ByteFunction<K>;
    class Vector <E> extends Internal.AbstractList<E> implements Internal.RandomAccess, Internal.Cloneable, Internal.List<E>, Internal.Serializable {
        constructor()
        constructor(arg0: number, arg1: number)
        constructor(arg0: Internal.Collection_<any>)
        constructor(arg0: number)
        insertElementAt(arg0: E, arg1: number): void;
        removeElementAt(arg0: number): void;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        addAll(arg0: number, arg1: Internal.Collection_<any>): boolean;
        removeElement(arg0: any): boolean;
        addElement(arg0: E): void;
        copyInto(arg0: any[]): void;
        subList(arg0: number, arg1: number): Internal.List<E>;
        indexOf(arg0: any): number;
        trimToSize(): void;
        add(arg0: number, arg1: E): void;
        toArray(arg0: T[]): T[];
        remove(arg0: any): boolean;
        sort(arg0: Internal.Comparator_<any>): void;
        listIterator(arg0: number): Internal.ListIterator<E>;
        elements(): Internal.Enumeration<E>;
        iterator(): Internal.Iterator<E>;
        stream(): Internal.Stream<E>;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        ensureCapacity(arg0: number): void;
        setElementAt(arg0: E, arg1: number): void;
        lastIndexOf(arg0: any): number;
        clone(): any;
        get(arg0: number): E;
        capacity(): number;
        add(arg0: E): boolean;
        listIterator(): Internal.ListIterator<E>;
        forEach(arg0: Internal.Consumer_<any>): void;
        parallelStream(): Internal.Stream<E>;
        firstElement(): E;
        lastElement(): E;
        isEmpty(): boolean;
        set(arg0: number, arg1: E): E;
        elementAt(arg0: number): E;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        addAll(arg0: Internal.Collection_<any>): boolean;
        indexOf(arg0: any, arg1: number): number;
        remove(arg0: number): E;
        contains(arg0: any): boolean;
        replaceAll(arg0: Internal.UnaryOperator_<E>): void;
        toString(): string;
        toArray(): any[];
        lastIndexOf(arg0: any, arg1: number): number;
        size(): number;
        hashCode(): number;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        removeAllElements(): void;
        clear(): void;
        spliterator(): Internal.Spliterator<E>;
        setSize(arg0: number): void;
        equals(arg0: any): boolean;
        get empty(): boolean
        set size(arg0: number)
    }
    type Vector_<E> = Vector<E>;
    class Target extends Internal.Node {
        constructor(arg0: number, arg1: number, arg2: number)
        constructor(arg0: Internal.Node_)
        updateBest(arg0: number, arg1: Internal.Node_): void;
        isReached(): boolean;
        getBestNode(): Internal.Node;
        static createFromStream(arg0: Internal.FriendlyByteBuf_): Internal.Target;
        setReached(): void;
        get reached(): boolean
        get bestNode(): Internal.Node
    }
    type Target_ = Target;
    class DaylightDetectorBlockEntity extends Internal.BlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        serializeNBT(): Internal.CompoundTag;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get modelData(): Internal.IModelData
        get renderBoundingBox(): Internal.AABB
    }
    type DaylightDetectorBlockEntity_ = DaylightDetectorBlockEntity;
    interface Short2IntFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntUnaryOperator {
        get(arg0: number): number;
        put(arg0: number, arg1: number): number;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Short2CharFunction;
        apply(arg0: number): number;
        composeShort(arg0: Internal.Short2ShortFunction_): this;
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        defaultReturnValue(): number;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Short2FloatFunction;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2IntFunction;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Short2DoubleFunction;
        containsKey(arg0: any): boolean;
        andThenInt(arg0: Internal.Int2IntFunction_): this;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        applyAsInt(arg0: number): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        put(arg0: any, arg1: any): any;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2IntFunction;
        remove(arg0: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Short2ShortFunction;
        containsKey(arg0: number): boolean;
        composeObject(arg0: Internal.Object2ShortFunction_<any>): Internal.Object2IntFunction<T>;
        getOrDefault(arg0: number, arg1: number): number;
        put(arg0: number, arg1: number): number;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Short2ByteFunction;
        andThenObject(arg0: Internal.Int2ObjectFunction_<any>): Internal.Short2ObjectFunction<T>;
        andThenReference(arg0: Internal.Int2ReferenceFunction_<any>): Internal.Short2ReferenceFunction<T>;
        size(): number;
        defaultReturnValue(arg0: number): void;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2IntFunction;
        clear(): void;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Short2LongFunction;
        composeReference(arg0: Internal.Reference2ShortFunction_<any>): Internal.Reference2IntFunction<T>;
        remove(arg0: any): any;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2IntFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2IntFunction;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2IntFunction;
    }
    type Short2IntFunction_ = ((arg0: number)=>number) | Short2IntFunction;
    class ConstantHeight extends Internal.HeightProvider {
        static of(arg0: Internal.VerticalAnchor_): Internal.ConstantHeight;
        toString(): string;
        getValue(): Internal.VerticalAnchor;
        sample(arg0: Internal.Random_, arg1: Internal.WorldGenerationContext_): number;
        getType(): Internal.HeightProviderType<any>;
        get value(): Internal.VerticalAnchor
        get type(): Internal.HeightProviderType<any>
        readonly static "CODEC": any;
        readonly static "ZERO": Internal.ConstantHeight;
    }
    type ConstantHeight_ = ConstantHeight;
    class BlockColumnConfiguration$Layer extends Internal.Record {
        constructor(arg0: Internal.IntProvider_, arg1: Internal.BlockStateProvider_)
        state(): Internal.BlockStateProvider;
        hashCode(): number;
        height(): Internal.IntProvider;
        toString(): string;
        equals(arg0: any): boolean;
        readonly static "CODEC": any;
    }
    type BlockColumnConfiguration$Layer_ = BlockColumnConfiguration$Layer;
    interface Char2ByteFunction extends it.unimi.dsi.fastutil.Function<string, number>, Internal.IntUnaryOperator {
        composeObject(arg0: Internal.Object2CharFunction_<any>): Internal.Object2ByteFunction<T>;
        put(arg0: string, arg1: number): number;
        getOrDefault(arg0: any, arg1: any): any;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Char2IntFunction;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        containsKey(arg0: string): boolean;
        containsKey(arg0: any): boolean;
        defaultReturnValue(arg0: number): void;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2ByteFunction;
        andThenReference(arg0: Internal.Byte2ReferenceFunction_<any>): Internal.Char2ReferenceFunction<T>;
        getOrDefault(arg0: string, arg1: number): number;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2ByteFunction;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        applyAsInt(arg0: number): number;
        put(arg0: any, arg1: any): any;
        defaultReturnValue(): number;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2ByteFunction;
        get(arg0: any): number;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2ByteFunction;
        get(arg0: string): number;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Char2ShortFunction;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2ByteFunction;
        andThenByte(arg0: Internal.Byte2ByteFunction_): this;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Char2CharFunction;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Char2LongFunction;
        andThenObject(arg0: Internal.Byte2ObjectFunction_<any>): Internal.Char2ObjectFunction<T>;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2ByteFunction;
        getOrDefault(arg0: any, arg1: number): number;
        size(): number;
        composeChar(arg0: Internal.Char2CharFunction_): this;
        apply(arg0: string): number;
        composeReference(arg0: Internal.Reference2CharFunction_<any>): Internal.Reference2ByteFunction<T>;
        remove(arg0: string): number;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Char2FloatFunction;
        clear(): void;
        put(arg0: string, arg1: number): number;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Char2DoubleFunction;
        remove(arg0: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<string, T>;
    }
    type Char2ByteFunction_ = Char2ByteFunction | ((arg0: string)=>number);
    interface ChannelOutboundBuffer$MessageProcessor {
        processMessage(arg0: any): boolean;
    }
    type ChannelOutboundBuffer$MessageProcessor_ = ChannelOutboundBuffer$MessageProcessor;
    interface ResourceManager extends Internal.ResourceProvider {
        hasResource(arg0: ResourceLocation_): boolean;
        getNamespaces(): Internal.Set<string>;
        listResources(arg0: string, arg1: Internal.Predicate_<string>): Internal.Collection<ResourceLocation>;
        getResources(arg0: ResourceLocation_): Internal.List<Internal.Resource>;
        listPacks(): Internal.Stream<Internal.PackResources>;
        get namespaces(): Internal.Set<string>
    }
    type ResourceManager_ = ResourceManager;
    class ClientboundSetEntityMotionPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: Vec3_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.Entity_)
        handle(arg0: Internal.PacketListener_): void;
        getXa(): number;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getYa(): number;
        getZa(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        getId(): number;
        get xa(): number
        get ya(): number
        get za(): number
        get skippable(): boolean
        get id(): number
    }
    type ClientboundSetEntityMotionPacket_ = ClientboundSetEntityMotionPacket;
    class Piglin extends Internal.AbstractPiglin implements Internal.InventoryCarrier, Internal.CrossbowAttackMob {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getArmPose(): Internal.PiglinArmPose;
        performCrossbowAttack(arg0: Internal.LivingEntity_, arg1: number): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        onCrossbowAttackPerformed(): void;
        performRangedAttack(arg0: Internal.LivingEntity_, arg1: number): void;
        canFireProjectileWeapon(arg0: Internal.ProjectileWeaponItem_): boolean;
        getInventory(): Internal.Container;
        startRiding(arg0: Internal.Entity_, arg1: boolean): boolean;
        shootCrossbowProjectile(arg0: Internal.LivingEntity_, arg1: Internal.ItemStack_, arg2: Internal.Projectile_, arg3: number): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setBaby(arg0: boolean): void;
        canRiderInteract(): boolean;
        isDancing(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static checkPiglinSpawnRules(arg0: Internal.EntityType_<Internal.Piglin_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        getProjectileShotVector(arg0: Internal.LivingEntity_, arg1: Vec3_, arg2: number): Internal.Vector3f;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setChargingCrossbow(arg0: boolean): void;
        getPassengersRidingOffset(): number;
        setDancing(arg0: boolean): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isBaby(): boolean;
        getBrain(): Internal.Brain<Internal.Piglin>;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        wantsToPickUp(arg0: Internal.ItemStack_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        shootCrossbowProjectile(arg0: Internal.LivingEntity_, arg1: Internal.LivingEntity_, arg2: Internal.Projectile_, arg3: number, arg4: number): void;
        alwaysAccepts(): boolean;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getClassification(arg0: boolean): Internal.MobCategory;
        removeWhenFarAway(arg0: number): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get armPose(): Internal.PiglinArmPose
        get stepHeight(): number
        get inventory(): Internal.Container
        set baby(arg0: boolean)
        get dancing(): boolean
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        set chargingCrossbow(arg0: boolean)
        get passengersRidingOffset(): number
        set dancing(arg0: boolean)
        get baby(): boolean
        get brain(): Internal.Brain<Internal.Piglin>
    }
    type Piglin_ = Piglin;
    interface Short2FloatFunction extends Internal.IntToDoubleFunction, it.unimi.dsi.fastutil.Function<number, number> {
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2FloatFunction;
        applyAsDouble(arg0: number): number;
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Short2ShortFunction;
        andThenReference(arg0: Internal.Float2ReferenceFunction_<any>): Internal.Short2ReferenceFunction<T>;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2FloatFunction;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Short2IntFunction;
        defaultReturnValue(arg0: number): void;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2FloatFunction;
        remove(arg0: number): number;
        containsKey(arg0: any): boolean;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Short2ByteFunction;
        apply(arg0: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2FloatFunction;
        put(arg0: any, arg1: any): any;
        andThenFloat(arg0: Internal.Float2FloatFunction_): this;
        get(arg0: number): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        defaultReturnValue(): number;
        put(arg0: number, arg1: number): number;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Short2DoubleFunction;
        containsKey(arg0: number): boolean;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Short2CharFunction;
        composeShort(arg0: Internal.Short2ShortFunction_): this;
        composeReference(arg0: Internal.Reference2ShortFunction_<any>): Internal.Reference2FloatFunction<T>;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2FloatFunction;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Short2LongFunction;
        getOrDefault(arg0: any, arg1: number): number;
        composeObject(arg0: Internal.Object2ShortFunction_<any>): Internal.Object2FloatFunction<T>;
        size(): number;
        put(arg0: number, arg1: number): number;
        clear(): void;
        remove(arg0: any): any;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2FloatFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        andThenObject(arg0: Internal.Float2ObjectFunction_<any>): Internal.Short2ObjectFunction<T>;
    }
    type Short2FloatFunction_ = Short2FloatFunction | ((arg0: number)=>number);
    interface Serializable {
    }
    type Serializable_ = Serializable;
    class Object2LongEntry implements Internal.Comparable<Internal.Object2LongEntry> {
        constructor(k: any, v: number)
        constructor(entry: any_<any>)
        compareTo(o: Internal.Object2LongEntry_): number;
        compareTo(arg0: any): number;
        readonly "value": number;
        readonly "key": any;
    }
    type Object2LongEntry_ = Object2LongEntry;
    class NoiseThresholdCountPlacement extends Internal.RepeatingPlacement {
        type(): Internal.PlacementModifierType<any>;
        static of(arg0: number, arg1: number, arg2: number): Internal.NoiseThresholdCountPlacement;
        readonly static "CODEC": any;
    }
    type NoiseThresholdCountPlacement_ = NoiseThresholdCountPlacement;
    class EntityViewRenderEvent$RenderFogEvent extends Internal.EntityViewRenderEvent$FogEvent {
        constructor()
        constructor(arg0: Internal.FogRenderer$FogMode_, arg1: Internal.Camera_, arg2: number, arg3: number)
        constructor(arg0: Internal.FogRenderer$FogMode_, arg1: Internal.Camera_, arg2: number, arg3: number, arg4: number, arg5: Internal.FogShape_)
        hasResult(): boolean;
        scaleFarPlaneDistance(arg0: number): void;
        getNearPlaneDistance(): number;
        getFogShape(): Internal.FogShape;
        getMode(): Internal.FogRenderer$FogMode;
        isCancelable(): boolean;
        setFogShape(arg0: Internal.FogShape_): void;
        scaleNearPlaneDistance(arg0: number): void;
        getListenerList(): Internal.ListenerList;
        setFarPlaneDistance(arg0: number): void;
        setNearPlaneDistance(arg0: number): void;
        getFarPlaneDistance(): number;
        get nearPlaneDistance(): number
        get fogShape(): Internal.FogShape
        get mode(): Internal.FogRenderer$FogMode
        get cancelable(): boolean
        set fogShape(arg0: Internal.FogShape_)
        get listenerList(): Internal.ListenerList
        set farPlaneDistance(arg0: number)
        set nearPlaneDistance(arg0: number)
        get farPlaneDistance(): number
    }
    type EntityViewRenderEvent$RenderFogEvent_ = EntityViewRenderEvent$RenderFogEvent;
    class Panda$Gene extends Internal.Enum<Internal.Panda$Gene> {
        static byName(arg0: string): Internal.Panda$Gene;
        static byId(arg0: number): Internal.Panda$Gene;
        static values(): Internal.Panda$Gene[];
        isRecessive(): boolean;
        getName(): string;
        static getRandom(arg0: Internal.Random_): Internal.Panda$Gene;
        static valueOf(arg0: string): Internal.Panda$Gene;
        getId(): number;
        get recessive(): boolean
        get name(): string
        get id(): number
        readonly static "NORMAL": Internal.Panda$Gene;
        readonly static "AGGRESSIVE": Internal.Panda$Gene;
        readonly static "PLAYFUL": Internal.Panda$Gene;
        readonly static "WORRIED": Internal.Panda$Gene;
        readonly static "BROWN": Internal.Panda$Gene;
        readonly static "WEAK": Internal.Panda$Gene;
        readonly static "LAZY": Internal.Panda$Gene;
    }
    type Panda$Gene_ = "normal" | "playful" | "worried" | "brown" | "lazy" | "weak" | Panda$Gene | "aggressive";
    interface ShortIterator extends Internal.PrimitiveIterator<number, Internal.ShortConsumer> {
        forEachRemaining(arg0: Internal.ShortConsumer_): void;
        forEachRemaining(arg0: any): void;
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): any;
        skip(arg0: number): number;
        forEachRemaining(arg0: Internal.IntConsumer_): void;
        nextShort(): number;
    }
    type ShortIterator_ = ShortIterator;
    class WoodenPressurePlateBlockBuilder extends Internal.ShapedBlockBuilder {
        constructor(i: ResourceLocation_)
        createObject(): any;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
    }
    type WoodenPressurePlateBlockBuilder_ = WoodenPressurePlateBlockBuilder;
    abstract class BuilderBase <T> implements Internal.Supplier<T> {
        constructor(i: ResourceLocation_)
        createAdditionalObjects(): void;
        generateLang(lang: Internal.Map_<string, string>): void;
        type(type: string): this;
        displayName(name: string): this;
        getTranslationKeyGroup(): string;
        transformObject(obj: T): T;
        createObject(): T;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        clientRegistry(minecraft: Internal.Supplier_<Internal.Minecraft_>): void;
        tag(tag: ResourceLocation_): this;
        translationKey(key: string): this;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        get(): T;
        newID(pre: string, post: string): ResourceLocation;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<any>;
        get translationKeyGroup(): string
        get registryType(): Internal.RegistryObjectBuilderTypes<any>
        "displayName": string;
        "translationKey": string;
        readonly "id": ResourceLocation;
    }
    type BuilderBase_<T> = BuilderBase<T>;
    class Team$Visibility extends Internal.Enum<Internal.Team$Visibility> {
        static byName(arg0: string): Internal.Team$Visibility;
        getDisplayName(): Internal.Component;
        static values(): Internal.Team$Visibility[];
        static getAllNames(): string[];
        static valueOf(arg0: string): Internal.Team$Visibility;
        get displayName(): Internal.Component
        get allNames(): string[]
        readonly "name": string;
        readonly "id": number;
        readonly static "NEVER": Internal.Team$Visibility;
        readonly static "HIDE_FOR_OTHER_TEAMS": Internal.Team$Visibility;
        readonly static "HIDE_FOR_OWN_TEAM": Internal.Team$Visibility;
        readonly static "ALWAYS": Internal.Team$Visibility;
    }
    type Team$Visibility_ = Team$Visibility | "never" | "hide_for_other_teams" | "hide_for_own_team" | "always";
    abstract class VoxelShape {
        max(arg0: Internal.Direction$Axis_, arg1: number, arg2: number): number;
        max(arg0: Internal.Direction$Axis_): number;
        toString(): string;
        closestPointTo(arg0: Vec3_): Internal.Optional<Vec3>;
        isEmpty(): boolean;
        forAllEdges(arg0: Internal.Shapes$DoubleLineConsumer_): void;
        forAllBoxes(arg0: Internal.Shapes$DoubleLineConsumer_): void;
        move(arg0: number, arg1: number, arg2: number): this;
        getFaceShape(arg0: Internal.Direction_): this;
        min(arg0: Internal.Direction$Axis_, arg1: number, arg2: number): number;
        optimize(): this;
        bounds(): Internal.AABB;
        toAabbs(): Internal.List<Internal.AABB>;
        clip(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_): Internal.BlockHitResult;
        min(arg0: Internal.Direction$Axis_): number;
        collide(arg0: Internal.Direction$Axis_, arg1: Internal.AABB_, arg2: number): number;
        get empty(): boolean
    }
    type VoxelShape_ = VoxelShape;
    class PlayerContainerEvent extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.AbstractContainerMenu_)
        getContainer(): Internal.AbstractContainerMenu;
        getListenerList(): Internal.ListenerList;
        get container(): Internal.AbstractContainerMenu
        get listenerList(): Internal.ListenerList
    }
    type PlayerContainerEvent_ = PlayerContainerEvent;
    class LootItemFunctionType extends Internal.SerializerType<Internal.LootItemFunction> {
        constructor(arg0: Internal.Serializer_<any>)
    }
    type LootItemFunctionType_ = LootItemFunctionType | Special.LootItemFunctionType;
    abstract class AbstractContainerMenu {
        static isValidQuickcraftType(arg0: number, arg1: Internal.Player_): boolean;
        findSlot(arg0: Internal.Container_, arg1: number): Internal.OptionalInt;
        static getRedstoneSignalFromBlockEntity(arg0: Internal.BlockEntity_): number;
        canTakeItemForPickAll(arg0: Internal.ItemStack_, arg1: Internal.Slot_): boolean;
        getItems(): Internal.NonNullList<Internal.ItemStack>;
        setItem(arg0: number, arg1: number, arg2: Internal.ItemStack_): void;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        static getRedstoneSignalFromContainer(arg0: Internal.Container_): number;
        sendAllDataToRemote(): void;
        broadcastFullState(): void;
        setRemoteCarried(arg0: Internal.ItemStack_): void;
        setCarried(arg0: Internal.ItemStack_): void;
        incrementStateId(): number;
        resumeRemoteUpdates(): void;
        isValidSlotIndex(arg0: number): boolean;
        static getQuickCraftSlotCount(arg0: Internal.Set_<Internal.Slot_>, arg1: number, arg2: Internal.ItemStack_, arg3: number): void;
        broadcastChanges(): void;
        static getQuickcraftHeader(arg0: number): number;
        setData(arg0: number, arg1: number): void;
        static canItemQuickReplace(arg0: Internal.Slot_, arg1: Internal.ItemStack_, arg2: boolean): boolean;
        addSlotListener(arg0: net.minecraft.world.inventory.ContainerListener_): void;
        getSlot(arg0: number): Internal.Slot;
        slotsChanged(arg0: Internal.Container_): void;
        clickMenuButton(arg0: Internal.Player_, arg1: number): boolean;
        static getQuickcraftMask(arg0: number, arg1: number): number;
        static getQuickcraftType(arg0: number): number;
        removeSlotListener(arg0: net.minecraft.world.inventory.ContainerListener_): void;
        clicked(arg0: number, arg1: number, arg2: Internal.ClickType_, arg3: Internal.Player_): void;
        setRemoteSlotNoCopy(arg0: number, arg1: Internal.ItemStack_): void;
        setRemoteSlot(arg0: number, arg1: Internal.ItemStack_): void;
        stillValid(arg0: Internal.Player_): boolean;
        suppressRemoteUpdates(): void;
        initializeContents(arg0: number, arg1: Internal.List_<Internal.ItemStack_>, arg2: Internal.ItemStack_): void;
        getStateId(): number;
        getCarried(): Internal.ItemStack;
        getType(): Internal.MenuType<any>;
        setSynchronizer(arg0: Internal.ContainerSynchronizer_): void;
        transferState(arg0: Internal.AbstractContainerMenu_): void;
        canDragTo(arg0: Internal.Slot_): boolean;
        removed(arg0: Internal.Player_): void;
        get items(): Internal.NonNullList<Internal.ItemStack>
        set remoteCarried(arg0: Internal.ItemStack_)
        set carried(arg0: Internal.ItemStack_)
        get stateId(): number
        get carried(): Internal.ItemStack
        get type(): Internal.MenuType<any>
        set synchronizer(arg0: Internal.ContainerSynchronizer_)
        readonly static "QUICKCRAFT_HEADER_CONTINUE": 1;
        readonly static "QUICKCRAFT_TYPE_CLONE": 2;
        readonly static "QUICKCRAFT_HEADER_START": 0;
        readonly static "QUICKCRAFT_HEADER_END": 2;
        readonly static "SLOT_CLICKED_OUTSIDE": -999;
        readonly "slots": Internal.NonNullList<Internal.Slot>;
        readonly static "QUICKCRAFT_TYPE_CHARITABLE": 0;
        readonly static "CARRIED_SLOT_SIZE": 2147483647;
        readonly "containerId": number;
        readonly static "QUICKCRAFT_TYPE_GREEDY": 1;
    }
    type AbstractContainerMenu_ = AbstractContainerMenu;
    class MapCloningRecipe extends Internal.CustomRecipe {
        constructor(arg0: ResourceLocation_)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        getSerializer(): Internal.RecipeSerializer<any>;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        matches(arg0: Internal.CraftingContainer_, arg1: Internal.Level_): boolean;
        isIncomplete(): boolean;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        assemble(arg0: Internal.CraftingContainer_): Internal.ItemStack;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get serializer(): Internal.RecipeSerializer<any>
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get incomplete(): boolean
    }
    type MapCloningRecipe_ = MapCloningRecipe;
    class LocalDateTime implements Internal.ChronoLocalDateTime<Internal.LocalDate>, Internal.Temporal, Internal.TemporalAdjuster, Internal.Serializable {
        getHour(): number;
        getMonth(): Internal.Month;
        toLocalTime(): Internal.LocalTime;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Temporal;
        minusMonths(arg0: number): this;
        withSecond(arg0: number): this;
        getDayOfWeek(): Internal.DayOfWeek;
        withHour(arg0: number): this;
        compareTo(arg0: any): number;
        getMinute(): number;
        static of(arg0: number, arg1: Internal.Month_, arg2: number, arg3: number, arg4: number, arg5: number): Internal.LocalDateTime;
        getDayOfMonth(): number;
        static of(arg0: Internal.LocalDate_, arg1: Internal.LocalTime_): Internal.LocalDateTime;
        with(arg0: Internal.TemporalAdjuster_): Internal.Temporal;
        static now(): Internal.LocalDateTime;
        plusMonths(arg0: number): this;
        static ofInstant(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.LocalDateTime;
        with(arg0: Internal.TemporalField_, arg1: number): Internal.Temporal;
        minusNanos(arg0: number): this;
        isSupported(arg0: Internal.TemporalField_): boolean;
        format(arg0: Internal.DateTimeFormatter_): string;
        getChronology(): Internal.Chronology;
        plusHours(arg0: number): this;
        plusSeconds(arg0: number): this;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.ChronoLocalDateTime<any>;
        isBefore(arg0: Internal.ChronoLocalDateTime_<any>): boolean;
        static now(arg0: Internal.Clock_): Internal.LocalDateTime;
        atOffset(arg0: Internal.ZoneOffset_): Internal.OffsetDateTime;
        truncatedTo(arg0: Internal.TemporalUnit_): this;
        getYear(): number;
        minus(arg0: Internal.TemporalAmount_): Internal.ChronoLocalDateTime<any>;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        withDayOfMonth(arg0: number): this;
        isAfter(arg0: Internal.ChronoLocalDateTime_<any>): boolean;
        get(arg0: Internal.TemporalField_): number;
        static of(arg0: number, arg1: Internal.Month_, arg2: number, arg3: number, arg4: number): Internal.LocalDateTime;
        withMonth(arg0: number): this;
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Internal.LocalDateTime;
        minusMinutes(arg0: number): this;
        compareTo(arg0: Internal.ChronoLocalDateTime_<any>): number;
        plus(arg0: Internal.TemporalAmount_): Internal.ChronoLocalDateTime<any>;
        getMonthValue(): number;
        minusYears(arg0: number): this;
        withDayOfYear(arg0: number): this;
        minusWeeks(arg0: number): this;
        static ofEpochSecond(arg0: number, arg1: number, arg2: Internal.ZoneOffset_): Internal.LocalDateTime;
        static parse(arg0: Internal.CharSequence_, arg1: Internal.DateTimeFormatter_): Internal.LocalDateTime;
        plusDays(arg0: number): this;
        toLocalDate(): Internal.LocalDate;
        withYear(arg0: number): this;
        plusWeeks(arg0: number): this;
        static parse(arg0: Internal.CharSequence_): Internal.LocalDateTime;
        static of(arg0: number, arg1: Internal.Month_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Internal.LocalDateTime;
        getLong(arg0: Internal.TemporalField_): number;
        plusYears(arg0: number): this;
        static now(arg0: Internal.ZoneId_): Internal.LocalDateTime;
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): Internal.LocalDateTime;
        isEqual(arg0: Internal.ChronoLocalDateTime_<any>): boolean;
        plusMinutes(arg0: number): this;
        toString(): string;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        minusHours(arg0: number): this;
        withNano(arg0: number): this;
        getDayOfYear(): number;
        query(arg0: Internal.TemporalQuery_<R>): R;
        toInstant(arg0: Internal.ZoneOffset_): Internal.Instant;
        minusDays(arg0: number): this;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        getNano(): number;
        getSecond(): number;
        hashCode(): number;
        static from(arg0: Internal.TemporalAccessor_): Internal.LocalDateTime;
        atZone(arg0: Internal.ZoneId_): Internal.ZonedDateTime;
        withMinute(arg0: number): this;
        toEpochSecond(arg0: Internal.ZoneOffset_): number;
        equals(arg0: any): boolean;
        plusNanos(arg0: number): this;
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): Internal.LocalDateTime;
        minusSeconds(arg0: number): this;
        get hour(): number
        get month(): Internal.Month
        get dayOfWeek(): Internal.DayOfWeek
        get minute(): number
        get dayOfMonth(): number
        get chronology(): Internal.Chronology
        get year(): number
        get monthValue(): number
        get dayOfYear(): number
        get nano(): number
        get second(): number
        readonly static "MAX": Internal.LocalDateTime;
        readonly static "MIN": Internal.LocalDateTime;
    }
    type LocalDateTime_ = LocalDateTime;
    class Behavior$Status extends Internal.Enum<Internal.Behavior$Status> {
        static values(): Internal.Behavior$Status[];
        static valueOf(arg0: string): Internal.Behavior$Status;
        readonly static "RUNNING": Internal.Behavior$Status;
        readonly static "STOPPED": Internal.Behavior$Status;
    }
    type Behavior$Status_ = "stopped" | Behavior$Status | "running";
    class PlayerInteractEvent$LeftClickBlock extends Internal.PlayerInteractEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: BlockPos_, arg2: Internal.Direction_)
        setUseItem(arg0: Internal.Event$Result_): void;
        setCanceled(arg0: boolean): void;
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        getUseBlock(): Internal.Event$Result;
        setUseBlock(arg0: Internal.Event$Result_): void;
        getUseItem(): Internal.Event$Result;
        set useItem(arg0: Internal.Event$Result_)
        set canceled(arg0: boolean)
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
        get useBlock(): Internal.Event$Result
        set useBlock(arg0: Internal.Event$Result_)
        get useItem(): Internal.Event$Result
    }
    type PlayerInteractEvent$LeftClickBlock_ = PlayerInteractEvent$LeftClickBlock;
    class ClientboundSetSubtitleTextPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.Component_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getText(): Internal.Component;
        isSkippable(): boolean;
        get text(): Internal.Component
        get skippable(): boolean
    }
    type ClientboundSetSubtitleTextPacket_ = ClientboundSetSubtitleTextPacket;
    class LiquidBlock extends Internal.Block implements Internal.BucketPickup, Internal.InjectedLiquidBlockExtension {
        constructor(arg0: Internal.FlowingFluid_, arg1: Internal.BlockBehaviour$Properties_)
        constructor(arg0: Internal.Supplier_<any>, arg1: Internal.BlockBehaviour$Properties_)
        isFlammable(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getRespawnPosition(arg0: Internal.BlockState_, arg1: Internal.EntityType_<any>, arg2: Internal.LevelReader_, arg3: BlockPos_, arg4: number, arg5: Internal.LivingEntity_): Internal.Optional<Vec3>;
        supportsExternalFaceHiding(arg0: Internal.BlockState_): boolean;
        isFertile(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        collisionExtendsVertically(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        onBlockStateChange(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BlockState_): void;
        getPickupSound(): Internal.Optional<Internal.SoundEvent>;
        getWeakChanges(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): boolean;
        neighborChanged(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Block_, arg4: BlockPos_, arg5: boolean): void;
        getBlockStatesKJS(): Internal.List<Internal.BlockState>;
        getExpDrop(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: number, arg4: number): number;
        getFriction(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): number;
        canConnectRedstone(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        isFireSource(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        isStickyBlock(arg0: Internal.BlockState_): boolean;
        getFluid(): Internal.FlowingFluid;
        shouldCheckWeakPower(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getBeaconColorMultiplier(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): number[];
        onBlockExploded(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Explosion_): void;
        isSlimeBlock(arg0: Internal.BlockState_): boolean;
        getCollisionShape(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.CollisionContext_): Internal.VoxelShape;
        shouldDisplayFluidOverlay(arg0: Internal.BlockState_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_, arg3: Internal.FluidState_): boolean;
        canEntityDestroy(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        rotate(arg0: Internal.BlockState_, arg1: Internal.LevelAccessor_, arg2: BlockPos_, arg3: Internal.Rotation_): Internal.BlockState;
        canHarvestBlock(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        getRenderShape(arg0: Internal.BlockState_): Internal.RenderShape;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.UseOnContext_, arg2: Internal.ToolAction_, arg3: boolean): Internal.BlockState;
        isValidSpawn(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.SpawnPlacements$Type_, arg4: Internal.EntityType_<any>): boolean;
        getFlammability(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        arch$holder(): Internal.Holder<Internal.Block>;
        skipRendering(arg0: Internal.BlockState_, arg1: Internal.BlockState_, arg2: Internal.Direction_): boolean;
        isLadder(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        getCloneItemStack(arg0: Internal.BlockState_, arg1: Internal.HitResult_, arg2: Internal.BlockGetter_, arg3: BlockPos_, arg4: Internal.Player_): Internal.ItemStack;
        getAiPathNodeType(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Mob_): Internal.BlockPathTypes;
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.BlockState_): boolean;
        onDestroyedByPlayer(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: boolean, arg5: Internal.FluidState_): boolean;
        onNeighborChange(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): void;
        updateShape(arg0: Internal.BlockState_, arg1: Internal.Direction_, arg2: Internal.BlockState_, arg3: Internal.LevelAccessor_, arg4: BlockPos_, arg5: BlockPos_): Internal.BlockState;
        isRandomlyTicking(arg0: Internal.BlockState_): boolean;
        getPickupSound(arg0: Internal.BlockState_): Internal.Optional<Internal.SoundEvent>;
        randomTick(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.Random_): void;
        isPortalFrame(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        onCaughtFire(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.LivingEntity_): void;
        isScaffolding(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        hidesNeighborFace(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: Internal.Direction_): boolean;
        getStateAtViewpoint(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Vec3_): Internal.BlockState;
        pickupBlock(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: Internal.BlockState_): Internal.ItemStack;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: Internal.ItemStack_, arg5: Internal.ToolAction_): Internal.BlockState;
        isBed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        getExplosionResistance(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        getBedDirection(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): Internal.Direction;
        canStickTo(arg0: Internal.BlockState_, arg1: Internal.BlockState_): boolean;
        arch$getFluid(): Internal.FlowingFluid;
        getFireSpreadSpeed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        getLightEmission(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): number;
        setBedOccupied(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.LivingEntity_, arg4: boolean): void;
        arch$registryName(): ResourceLocation;
        addLandingEffects(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: Internal.LivingEntity_, arg5: number): boolean;
        canDropFromExplosion(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): boolean;
        isConduitFrame(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): boolean;
        getEnchantPowerBonus(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): number;
        addRunningEffects(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        getDrops(arg0: Internal.BlockState_, arg1: Internal.LootContext$Builder_): Internal.List<Internal.ItemStack>;
        getShape(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.CollisionContext_): Internal.VoxelShape;
        propagatesSkylightDown(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        onPlace(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: boolean): void;
        isPathfindable(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.PathComputationType_): boolean;
        getSoundType(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): Internal.SoundType;
        getFluidState(arg0: Internal.BlockState_): Internal.FluidState;
        isBurning(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getMapColor(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.MaterialColor_): Internal.MaterialColor;
        get pickupSound(): Internal.Optional<Internal.SoundEvent>
        get blockStatesKJS(): Internal.List<Internal.BlockState>
        get fluid(): Internal.FlowingFluid
        readonly static "POSSIBLE_FLOW_DIRECTIONS": [Internal.Direction, Internal.Direction, Internal.Direction, Internal.Direction, Internal.Direction];
        readonly static "STABLE_SHAPE": any;
        readonly static "LEVEL": Internal.IntegerProperty;
    }
    type LiquidBlock_ = LiquidBlock;
    interface Supplier <T> {
        get(): T;
    }
    type Supplier_<T> = Supplier<T> | (()=>T);
    class InputEvent$ClickInputEvent extends Internal.InputEvent {
        constructor()
        constructor(arg0: number, arg1: Internal.KeyMapping_, arg2: Hand_)
        shouldSwingHand(): boolean;
        isCancelable(): boolean;
        isPickBlock(): boolean;
        isUseItem(): boolean;
        getListenerList(): Internal.ListenerList;
        isAttack(): boolean;
        getHand(): Hand;
        setSwingHand(arg0: boolean): void;
        getKeyMapping(): Internal.KeyMapping;
        get cancelable(): boolean
        get pickBlock(): boolean
        get useItem(): boolean
        get listenerList(): Internal.ListenerList
        get attack(): boolean
        get hand(): Hand
        set swingHand(arg0: boolean)
        get keyMapping(): Internal.KeyMapping
    }
    type InputEvent$ClickInputEvent_ = InputEvent$ClickInputEvent;
    class ServerPlayer extends Internal.Player {
        constructor(arg0: Internal.MinecraftServer_, arg1: Internal.ServerLevel_, arg2: Internal.GameProfile_)
        openCommandBlock(arg0: Internal.CommandBlockEntity_): void;
        setExperienceLevels(arg0: number): void;
        getAddEntityPacket(): Internal.Packet<any>;
        getAdvancements(): Internal.PlayerAdvancements;
        canInteractWith(arg0: BlockPos_, arg1: number): boolean;
        giveExperiencePoints(arg0: number): void;
        onUpdateAbilities(): void;
        startSleeping(arg0: BlockPos_): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        sendMerchantOffers(arg0: number, arg1: Internal.MerchantOffers_, arg2: number, arg3: number, arg4: boolean, arg5: boolean): void;
        resetRecipes(arg0: Internal.Collection_<Internal.Recipe_<any>>): number;
        teleportTo(arg0: Internal.ServerLevel_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        loadGameTypes(arg0: Internal.CompoundTag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        onLeaveCombat(): void;
        playNotifySound(arg0: Internal.SoundEvent_, arg1: Internal.SoundSource_, arg2: number, arg3: number): void;
        dismountTo(arg0: number, arg1: number, arg2: number): void;
        resetStat(arg0: Internal.Stat_<any>): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        disconnect(): void;
        allowsListing(): boolean;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        isRespawnForced(): boolean;
        broadcastToPlayer(arg0: Internal.ServerPlayer_): boolean;
        canChatInColor(): boolean;
        alwaysAccepts(): boolean;
        die(arg0: Internal.DamageSource_): void;
        awardRecipesByKey(arg0: ResourceLocation_[]): void;
        openItemGui(arg0: Internal.ItemStack_, arg1: Hand_): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        crit(arg0: Internal.Entity_): void;
        displayClientMessage(arg0: Internal.Component_, arg1: boolean): void;
        isChangingDimension(): boolean;
        initInventoryMenu(): void;
        getAttackRange(): number;
        closeContainer(): void;
        asKJS(): Internal.EntityJS;
        awardStat(arg0: Internal.Stat_<any>, arg1: number): void;
        openTextEdit(arg0: Internal.SignBlockEntity_): void;
        drop(arg0: Internal.ItemStack_, arg1: boolean, arg2: boolean): Internal.ItemEntity;
        canRiderInteract(): boolean;
        stopRiding(): void;
        isCreative(): boolean;
        isSpectator(): boolean;
        attack(arg0: Internal.Entity_): void;
        giveExperienceLevels(arg0: number): void;
        shouldRiderSit(): boolean;
        lookAt(arg0: Internal.EntityAnchorArgument$Anchor_, arg1: Vec3_): void;
        doCheckFallDamage(arg0: number, arg1: boolean): void;
        getChatVisibility(): Internal.ChatVisiblity;
        mayInteract(arg0: Internal.Level_, arg1: BlockPos_): boolean;
        getReachDistance(): number;
        updateOptions(arg0: Internal.ServerboundClientInformationPacket_): void;
        moveTo(arg0: number, arg1: number, arg2: number): void;
        canHarmPlayer(arg0: Internal.Player_): boolean;
        openMenu(arg0: Internal.MenuProvider_): Internal.OptionalInt;
        awardKillScore(arg0: Internal.Entity_, arg1: number, arg2: Internal.DamageSource_): void;
        sendTexturePack(arg0: string, arg1: string, arg2: boolean, arg3: Internal.Component_): void;
        resetSentInfo(): void;
        doCloseContainer(): void;
        drop(arg0: boolean): boolean;
        swing(arg0: Hand_): void;
        resetFallDistance(): void;
        onEnchantmentPerformed(arg0: Internal.ItemStack_, arg1: number): void;
        getStats(): Internal.ServerStatsCounter;
        hasDisconnected(): boolean;
        getStepHeight(): number;
        trackStartFallingPosition(): void;
        startRiding(arg0: Internal.Entity_, arg1: boolean): boolean;
        awardRecipes(arg0: Internal.Collection_<Internal.Recipe_<any>>): number;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setExperiencePoints(arg0: number): void;
        getLastSectionPos(): Internal.SectionPos;
        restoreFrom(arg0: Internal.ServerPlayer_, arg1: boolean): void;
        sendMessage(arg0: Internal.Component_, arg1: Internal.UUID_): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getCamera(): Internal.Entity;
        setLastSectionPos(arg0: Internal.SectionPos_): void;
        getRespawnAngle(): number;
        canInteractWith(arg0: Internal.Entity_, arg1: number): boolean;
        isCloseEnough(arg0: Internal.Entity_, arg1: number): boolean;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        getTextFilter(): Internal.TextFilter;
        magicCrit(arg0: Internal.Entity_): void;
        getLanguage(): string;
        tick(): void;
        isInvulnerableTo(arg0: Internal.DamageSource_): boolean;
        initMenu(arg0: Internal.AbstractContainerMenu_): void;
        stopSleepInBed(arg0: boolean, arg1: boolean): void;
        setRespawnPosition(arg0: Internal.ResourceKey_<Internal.Level_>, arg1: BlockPos_, arg2: number, arg3: boolean, arg4: boolean): void;
        trackChunk(arg0: Internal.ChunkPos_, arg1: Internal.Packet_<any>): void;
        doTick(): void;
        isTextFilteringEnabled(): boolean;
        teleportTo(arg0: number, arg1: number, arg2: number): void;
        hasChangedDimension(): void;
        trackEnteredOrExitedLavaOnVehicle(): void;
        shouldFilterMessageTo(arg0: Internal.ServerPlayer_): boolean;
        lookAt(arg0: Internal.EntityAnchorArgument$Anchor_, arg1: Internal.Entity_, arg2: Internal.EntityAnchorArgument$Anchor_): void;
        getTabListDisplayName(): Internal.Component;
        getRespawnDimension(): Internal.ResourceKey<Internal.Level>;
        refreshTabListName(): void;
        canHit(arg0: Internal.Entity_, arg1: number): boolean;
        getRecipeBook(): Internal.ServerRecipeBook;
        onEnterCombat(): void;
        getRespawnPosition(): BlockPos;
        resetLastActionTime(): void;
        getIpAddress(): string;
        getLevel(): Internal.Level;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        getLastActionTime(): number;
        getParts(): Internal.PartEntity<any>[];
        setGameMode(arg0: Internal.GameType_): boolean;
        nextContainerCounter(): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        openHorseInventory(arg0: Internal.AbstractHorse_, arg1: Internal.Container_): void;
        untrackChunk(arg0: Internal.ChunkPos_): void;
        setCamera(arg0: Internal.Entity_): void;
        setLevel(arg0: Internal.ServerLevel_): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        sendMessage(arg0: Internal.Component_, arg1: Internal.ChatType_, arg2: Internal.UUID_): void;
        setPlayerInput(arg0: number, arg1: number, arg2: boolean, arg3: boolean): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        take(arg0: Internal.Entity_, arg1: number): void;
        startSleepInBed(arg0: BlockPos_): Internal.Either<Internal.Player$BedSleepingProblem, net.minecraft.util.Unit>;
        set experienceLevels(arg0: number)
        get addEntityPacket(): Internal.Packet<any>
        get advancements(): Internal.PlayerAdvancements
        get respawnForced(): boolean
        get changingDimension(): boolean
        get attackRange(): number
        get creative(): boolean
        get spectator(): boolean
        get chatVisibility(): Internal.ChatVisiblity
        get reachDistance(): number
        get stats(): Internal.ServerStatsCounter
        get stepHeight(): number
        set experiencePoints(arg0: number)
        get lastSectionPos(): Internal.SectionPos
        get camera(): Internal.Entity
        set lastSectionPos(arg0: Internal.SectionPos_)
        get respawnAngle(): number
        get textFilter(): Internal.TextFilter
        get language(): string
        get textFilteringEnabled(): boolean
        get tabListDisplayName(): Internal.Component
        get respawnDimension(): Internal.ResourceKey<Internal.Level>
        get recipeBook(): Internal.ServerRecipeBook
        get respawnPosition(): BlockPos
        get ipAddress(): string
        get level(): Internal.Level
        get multipartEntity(): boolean
        get lastActionTime(): number
        get parts(): Internal.PartEntity<any>[]
        set gameMode(arg0: Internal.GameType_)
        set camera(arg0: Internal.Entity_)
        set level(arg0: Internal.ServerLevel_)
        "latency": number;
        "containerCounter": number;
        "wonGame": boolean;
        readonly "gameMode": Internal.ServerPlayerGameMode;
        readonly "server": Internal.MinecraftServer;
        "connection": Internal.ServerGamePacketListenerImpl;
    }
    type ServerPlayer_ = ServerPlayer;
    class FogRenderer$FogMode extends Internal.Enum<Internal.FogRenderer$FogMode> {
        static valueOf(arg0: string): Internal.FogRenderer$FogMode;
        static values(): Internal.FogRenderer$FogMode[];
        readonly static "FOG_TERRAIN": Internal.FogRenderer$FogMode;
        readonly static "FOG_SKY": Internal.FogRenderer$FogMode;
    }
    type FogRenderer$FogMode_ = FogRenderer$FogMode | "fog_sky" | "fog_terrain";
    interface DoubleIterable extends Internal.Iterable<number> {
        forEach(arg0: it.unimi.dsi.fastutil.doubles.DoubleConsumer_): void;
        iterator(): Internal.Iterator<any>;
        spliterator(): Internal.Spliterator<any>;
        doubleSpliterator(): Internal.DoubleSpliterator;
        forEach(arg0: Internal.DoubleConsumer_): void;
        forEach(arg0: Internal.Consumer_<any>): void;
        doubleIterator(): Internal.DoubleIterator;
    }
    type DoubleIterable_ = DoubleIterable;
    class ContainerScreenEvent$DrawBackground extends Internal.ContainerScreenEvent {
        constructor()
        constructor(arg0: Internal.AbstractContainerScreen_<any>, arg1: Internal.PoseStack_, arg2: number, arg3: number)
        getPoseStack(): Internal.PoseStack;
        getListenerList(): Internal.ListenerList;
        getMouseY(): number;
        getMouseX(): number;
        get poseStack(): Internal.PoseStack
        get listenerList(): Internal.ListenerList
        get mouseY(): number
        get mouseX(): number
    }
    type ContainerScreenEvent$DrawBackground_ = ContainerScreenEvent$DrawBackground;
    interface IForgeFluidState {
        isEntityInside(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Entity_, arg3: number, arg4: Internal.HolderSet_<Internal.Fluid_>, arg5: boolean): boolean;
        getExplosionResistance(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Explosion_): number;
    }
    type IForgeFluidState_ = IForgeFluidState;
    class StringBuffer extends Internal.AbstractStringBuilder implements Internal.CharSequence, Internal.Comparable<Internal.StringBuffer>, Internal.Serializable {
        constructor()
        constructor(arg0: Internal.CharSequence_)
        constructor(arg0: number)
        constructor(arg0: string)
        append(arg0: number): this;
        compareTo(arg0: Internal.StringBuffer_): number;
        codePointAt(arg0: number): number;
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder;
        lastIndexOf(arg0: string): number;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): Internal.Appendable;
        append(arg0: number): Internal.AbstractStringBuilder;
        compareTo(arg0: any): number;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        indexOf(arg0: string): number;
        getChars(arg0: number, arg1: number, arg2: string[], arg3: number): void;
        lastIndexOf(arg0: string, arg1: number): number;
        insert(arg0: number, arg1: boolean): Internal.AbstractStringBuilder;
        charAt(arg0: number): string;
        reverse(): this;
        length(): number;
        replace(arg0: number, arg1: number, arg2: string): Internal.AbstractStringBuilder;
        append(arg0: number): this;
        trimToSize(): void;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        append(arg0: string): Internal.AbstractStringBuilder;
        delete(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        append(arg0: string): this;
        indexOf(arg0: string, arg1: number): number;
        ensureCapacity(arg0: number): void;
        chars(): Internal.IntStream;
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: Internal.CharSequence_): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: any): Internal.AbstractStringBuilder;
        capacity(): number;
        deleteCharAt(arg0: number): this;
        codePointCount(arg0: number, arg1: number): number;
        append(arg0: string[]): Internal.AbstractStringBuilder;
        substring(arg0: number): string;
        setCharAt(arg0: number, arg1: string): void;
        setLength(arg0: number): void;
        isEmpty(): boolean;
        codePointBefore(arg0: number): number;
        subSequence(arg0: number, arg1: number): Internal.CharSequence;
        append(arg0: Internal.StringBuffer_): Internal.AbstractStringBuilder;
        appendCodePoint(arg0: number): Internal.AbstractStringBuilder;
        append(arg0: string[], arg1: number, arg2: number): this;
        substring(arg0: number, arg1: number): string;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        toString(): string;
        insert(arg0: number, arg1: Internal.CharSequence_, arg2: number, arg3: number): Internal.AbstractStringBuilder;
        append(arg0: boolean): this;
        append(arg0: number): this;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.AbstractStringBuilder;
        offsetByCodePoints(arg0: number, arg1: number): number;
        insert(arg0: number, arg1: string[]): Internal.AbstractStringBuilder;
        append(arg0: any): Internal.AbstractStringBuilder;
        append(arg0: Internal.CharSequence_): Internal.AbstractStringBuilder;
        codePoints(): Internal.IntStream;
        set length(arg0: number)
        get empty(): boolean
    }
    type StringBuffer_ = StringBuffer;
    class BookCloningRecipe extends Internal.CustomRecipe {
        constructor(arg0: ResourceLocation_)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        matches(arg0: Internal.CraftingContainer_, arg1: Internal.Level_): boolean;
        getRemainingItems(arg0: Internal.Container_): Internal.NonNullList<any>;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        getSerializer(): Internal.RecipeSerializer<any>;
        isIncomplete(): boolean;
        assemble(arg0: Internal.CraftingContainer_): Internal.ItemStack;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get serializer(): Internal.RecipeSerializer<any>
        get incomplete(): boolean
    }
    type BookCloningRecipe_ = BookCloningRecipe;
    class ClientboundSetSimulationDistancePacket extends Internal.Record implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        hashCode(): number;
        simulationDistance(): number;
        toString(): string;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        equals(arg0: any): boolean;
        isSkippable(): boolean;
        get skippable(): boolean
    }
    type ClientboundSetSimulationDistancePacket_ = ClientboundSetSimulationDistancePacket;
    class EntityPotionEffectsJS {
        constructor(e: Internal.LivingEntity_)
        getActive(mobEffect: Internal.MobEffect_): Internal.MobEffectInstance;
        add(mobEffect: Internal.MobEffect_, duration: number, amplifier: number, ambient: boolean, showParticles: boolean): void;
        add(mobEffect: Internal.MobEffect_, duration: number): void;
        clear(): void;
        getActive(): Internal.Collection<Internal.MobEffectInstance>;
        isActive(mobEffect: Internal.MobEffect_): boolean;
        add(mobEffect: Internal.MobEffect_, duration: number, amplifier: number): void;
        getMap(): Internal.Map<Internal.MobEffect, Internal.MobEffectInstance>;
        isApplicable(effect: Internal.MobEffectInstance_): boolean;
        add(mobEffect: Internal.MobEffect_): void;
        getDuration(mobEffect: Internal.MobEffect_): number;
        get active(): Internal.Collection<Internal.MobEffectInstance>
        get map(): Internal.Map<Internal.MobEffect, Internal.MobEffectInstance>
    }
    type EntityPotionEffectsJS_ = EntityPotionEffectsJS;
    interface Int2FloatFunction extends Internal.IntToDoubleFunction, it.unimi.dsi.fastutil.Function<number, number> {
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2FloatFunction;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Int2ShortFunction;
        apply(arg0: number): number;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Int2ByteFunction;
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        andThenReference(arg0: Internal.Float2ReferenceFunction_<any>): Internal.Int2ReferenceFunction<T>;
        containsKey(arg0: number): boolean;
        defaultReturnValue(arg0: number): void;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2FloatFunction;
        containsKey(arg0: any): boolean;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2FloatFunction;
        andThenFloat(arg0: Internal.Float2FloatFunction_): this;
        composeInt(arg0: Internal.Int2IntFunction_): this;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Int2IntFunction;
        put(arg0: any, arg1: any): any;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Int2LongFunction;
        composeReference(arg0: Internal.Reference2IntFunction_<any>): Internal.Reference2FloatFunction<T>;
        composeObject(arg0: Internal.Object2IntFunction_<any>): Internal.Object2FloatFunction<T>;
        remove(arg0: number): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        defaultReturnValue(): number;
        andThenObject(arg0: Internal.Float2ObjectFunction_<any>): Internal.Int2ObjectFunction<T>;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Int2DoubleFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        getOrDefault(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        size(): number;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2FloatFunction;
        clear(): void;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2FloatFunction;
        put(arg0: number, arg1: number): number;
        get(arg0: number): number;
        remove(arg0: any): any;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2FloatFunction;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Int2CharFunction;
        put(arg0: number, arg1: number): number;
    }
    type Int2FloatFunction_ = ((arg0: number)=>number) | Int2FloatFunction;
    class RenderArmEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource_, arg2: number, arg3: Internal.AbstractClientPlayer_, arg4: Internal.HumanoidArm_)
        getPlayer(): Internal.AbstractClientPlayer;
        getArm(): Internal.HumanoidArm;
        getPoseStack(): Internal.PoseStack;
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        getPackedLight(): number;
        getMultiBufferSource(): Internal.MultiBufferSource;
        get player(): Internal.AbstractClientPlayer
        get arm(): Internal.HumanoidArm
        get poseStack(): Internal.PoseStack
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
        get packedLight(): number
        get multiBufferSource(): Internal.MultiBufferSource
    }
    type RenderArmEvent_ = RenderArmEvent;
    class VibrationListener implements Internal.GameEventListener {
        constructor(arg0: Internal.PositionSource_, arg1: number, arg2: Internal.VibrationListener$VibrationListenerConfig_)
        handleGameEvent(arg0: Internal.Level_, arg1: Internal.GameEvent_, arg2: Internal.Entity_, arg3: BlockPos_): boolean;
        tick(arg0: Internal.Level_): void;
        getListenerSource(): Internal.PositionSource;
        getListenerRadius(): number;
        get listenerSource(): Internal.PositionSource
        get listenerRadius(): number
    }
    type VibrationListener_ = VibrationListener;
    interface ItemBuilder$ItemColorJS {
        getColor(arg0: Internal.ItemStackJS_, arg1: number): Internal.Color;
    }
    type ItemBuilder$ItemColorJS_ = ItemBuilder$ItemColorJS | ((arg0: Internal.ItemStackJS, arg1: number)=>Internal.Color_);
    class EntityViewRenderEvent$FogDensity extends Internal.EntityViewRenderEvent$FogEvent {
        constructor()
        constructor(arg0: Internal.FogRenderer$FogMode_, arg1: Internal.Camera_, arg2: number, arg3: number)
        getDensity(): number;
        getMode(): Internal.FogRenderer$FogMode;
        isCancelable(): boolean;
        setDensity(arg0: number): void;
        getListenerList(): Internal.ListenerList;
        get density(): number
        get mode(): Internal.FogRenderer$FogMode
        get cancelable(): boolean
        set density(arg0: number)
        get listenerList(): Internal.ListenerList
    }
    type EntityViewRenderEvent$FogDensity_ = EntityViewRenderEvent$FogDensity;
    interface BlockColumn {
        getBlock(arg0: number): Internal.BlockState;
        setBlock(arg0: number, arg1: Internal.BlockState_): void;
    }
    type BlockColumn_ = BlockColumn;
    class ScriptType extends Internal.Enum<Internal.ScriptType> {
        isClient(): boolean;
        getLogFile(): Internal.Path;
        isServer(): boolean;
        static valueOf(name: string): Internal.ScriptType;
        static values(): Internal.ScriptType[];
        static of(level: Internal.LevelReader_): Internal.ScriptType;
        static getCurrent(def: Internal.ScriptType_): Internal.ScriptType;
        get client(): boolean
        get logFile(): Internal.Path
        get server(): boolean
        readonly "name": string;
        readonly static "STARTUP": Internal.ScriptType;
        readonly "executor": Internal.ExecutorService;
        readonly "console": Internal.ConsoleJS;
        readonly "warnings": Internal.List<string>;
        readonly "manager": Internal.Supplier<Internal.ScriptManager>;
        readonly static "SERVER": Internal.ScriptType;
        readonly static "CLIENT": Internal.ScriptType;
        readonly "errors": Internal.List<string>;
    }
    type ScriptType_ = ScriptType | "startup" | "server" | "client";
    class PermissionType <T> {
        hashCode(): number;
        toString(): string;
        typeToken(): Internal.Class<T>;
        equals(arg0: any): boolean;
        typeName(): string;
    }
    type PermissionType_<T> = PermissionType<T>;
    class ServerFunctionLibrary implements Internal.PreparableReloadListener {
        constructor(arg0: number, arg1: Internal.CommandDispatcher_<Internal.CommandSourceStack_>)
        getAvailableTags(): Internal.Iterable<ResourceLocation>;
        getName(): string;
        getFunction(arg0: ResourceLocation_): Internal.Optional<Internal.CommandFunction>;
        getTag(arg0: ResourceLocation_): net.minecraft.tags.Tag<Internal.CommandFunction>;
        getFunctions(): Internal.Map<ResourceLocation, Internal.CommandFunction>;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        get availableTags(): Internal.Iterable<ResourceLocation>
        get name(): string
        get functions(): Internal.Map<ResourceLocation, Internal.CommandFunction>
    }
    type ServerFunctionLibrary_ = ServerFunctionLibrary;
    abstract class UserPrincipalLookupService {
        lookupPrincipalByName(arg0: string): Internal.UserPrincipal;
        lookupPrincipalByGroupName(arg0: string): Internal.GroupPrincipal;
    }
    type UserPrincipalLookupService_ = UserPrincipalLookupService;
    interface IntSet extends Internal.Set<number>, Internal.IntCollection {
        stream(): Internal.Stream<number>;
        of(arg0: number, arg1: number): this;
        forEach(arg0: Internal.Consumer_<any>): void;
        add(arg0: number): boolean;
        of(): this;
        forEach(arg0: Internal.IntConsumer_): void;
        intStream(): Internal.IntStream;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        of(arg0: number, arg1: number, arg2: number): this;
        intParallelStream(): Internal.IntStream;
        spliterator(): Internal.IntSpliterator;
        intIterator(): Internal.IntIterator;
        contains(arg0: any): boolean;
        removeIf(arg0: Internal.IntPredicate_): boolean;
        remove(arg0: number): boolean;
        iterator(): Internal.Iterator<any>;
        forEach(arg0: it.unimi.dsi.fastutil.ints.IntConsumer_): void;
        toIntArray(arg0: number[]): number[];
        parallelStream(): Internal.Stream<number>;
        remove(arg0: any): boolean;
        removeIf(arg0: it.unimi.dsi.fastutil.ints.IntPredicate_): boolean;
        of(arg0: number): this;
        intSpliterator(): Internal.IntSpliterator;
        add(arg0: any): boolean;
        of(...arg0: number[]): this;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        rem(arg0: number): boolean;
    }
    type IntSet_ = IntSet;
    class NearestItemSensor extends Internal.Sensor<Internal.Mob> {
        constructor()
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
        readonly static "MAX_DISTANCE_TO_WANTED_ITEM": 9;
    }
    type NearestItemSensor_ = NearestItemSensor;
    class EntityJS implements Internal.MessageSender, Internal.WrappedJS {
        constructor(e: Internal.Entity_)
        getDistance(pos: BlockPos_): number;
        playSound(id: Internal.SoundEvent_, volume: number, pitch: number): void;
        getMinecraftEntity(): Internal.Entity;
        getRidingEntity(): this;
        setGlowing(glowing: boolean): void;
        isSilent(): boolean;
        remove(): void;
        isOnScoreboardTeam(teamID: string): boolean;
        getPitch(): number;
        isAlive(): boolean;
        setFullNBT(nbt: Internal.CompoundTag_): void;
        mergeFullNBT(tag: Internal.CompoundTag_): this;
        getPlayer(): Internal.PlayerJS<any>;
        isCrouching(): boolean;
        runCommandSilent(command: string): number;
        setPosition(x: number, y: number, z: number): void;
        isAnimal(): boolean;
        isPlayer(): boolean;
        setY(y: number): void;
        getTags(): Internal.Set<string>;
        isBoss(): boolean;
        getLevel(): Internal.LevelJS;
        isLiving(): boolean;
        isGlowing(): boolean;
        setFallDistance(fallDistance: number): void;
        getX(): number;
        getNoGravity(): boolean;
        removePassengers(): void;
        getCustomName(): Internal.Component;
        getDisplayName(): Internal.Component;
        setPosition(block: Internal.BlockContainerJS_): void;
        setMotionZ(z: number): void;
        setCustomName(name: Internal.Component_): void;
        attack(hp: number): void;
        setNoClip(noClip: boolean): void;
        getFullNBT(): Internal.CompoundTag;
        getTeamId(): string;
        getFacing(): Internal.Direction;
        isUnderWater(): boolean;
        attack(source: string, hp: number): void;
        getTicksExisted(): number;
        dismountRidingEntity(): void;
        isSwimming(): boolean;
        rayTrace(distance: number): Internal.RayTraceResultJS;
        getMotionX(): number;
        isWaterCreature(): boolean;
        getPersistentData(): Internal.CompoundTag;
        toString(): string;
        setX(x: number): void;
        getRecursivePassengers(): Internal.EntityArrayList;
        isInvulnerable(): boolean;
        getNoClip(): boolean;
        isInWater(): boolean;
        getHasCustomName(): boolean;
        startRiding(e: Internal.EntityJS_, force: boolean): boolean;
        isFrame(): boolean;
        setMotion(x: number, y: number, z: number): void;
        getDistanceSq(x: number, y: number, z: number): number;
        playSound(id: Internal.SoundEvent_): void;
        getCustomNameAlwaysVisible(): boolean;
        setStepHeight(stepHeight: number): void;
        getDistance(x: number, y: number, z: number): number;
        setMotionY(y: number): void;
        setNoGravity(noGravity: boolean): void;
        isPeacefulCreature(): boolean;
        setRotation(yaw: number, pitch: number): void;
        setYaw(yaw: number): void;
        getItem(): Internal.ItemStackJS;
        getStepHeight(): number;
        isAmbientCreature(): boolean;
        isMonster(): boolean;
        isOnSameTeam(e: Internal.EntityJS_): boolean;
        getHorizontalFacing(): Internal.Direction;
        getType(): string;
        setCustomNameAlwaysVisible(b: boolean): void;
        isSprinting(): boolean;
        getBlock(): Internal.BlockContainerJS;
        getNbt(): Internal.CompoundTag;
        setInvisible(invisible: boolean): void;
        getMotionY(): number;
        getName(): Internal.Component;
        getPassengers(): Internal.EntityArrayList;
        isPassenger(e: Internal.EntityJS_): boolean;
        getEyeHeight(): number;
        getZ(): number;
        getYaw(): number;
        getId(): Internal.UUID;
        spawn(): void;
        setMotionX(x: number): void;
        teleportTo(dimension: ResourceLocation_, x: number, y: number, z: number, yaw: number, pitch: number): void;
        setSilent(isSilent: boolean): void;
        setOnFire(seconds: number): void;
        kill(): void;
        setPitch(pitch: number): void;
        getFallDistance(): number;
        addMotion(x: number, y: number, z: number): void;
        extinguish(): void;
        isOnGround(): boolean;
        getServer(): Internal.ServerJS;
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void;
        getMotionZ(): number;
        tell(message: Internal.Component_): void;
        isInvisible(): boolean;
        setZ(z: number): void;
        setStatusMessage(message: Internal.Component_): void;
        getY(): number;
        getDistanceSq(pos: BlockPos_): number;
        getProfile(): Internal.GameProfile;
        runCommand(command: string): number;
        setInvulnerable(invulnerable: boolean): void;
        get minecraftEntity(): Internal.Entity
        get ridingEntity(): Internal.EntityJS
        set glowing(glowing: boolean)
        get silent(): boolean
        get pitch(): number
        get alive(): boolean
        set fullNBT(nbt: Internal.CompoundTag_)
        get player(): Internal.PlayerJS<any>
        get crouching(): boolean
        get animal(): boolean
        get player(): boolean
        set y(y: number)
        get tags(): Internal.Set<string>
        get boss(): boolean
        get level(): Internal.LevelJS
        get living(): boolean
        get glowing(): boolean
        set fallDistance(fallDistance: number)
        get x(): number
        get noGravity(): boolean
        get customName(): Internal.Component
        get displayName(): Internal.Component
        set position(block: Internal.BlockContainerJS_)
        set motionZ(z: number)
        set customName(name: Internal.Component_)
        set noClip(noClip: boolean)
        get fullNBT(): Internal.CompoundTag
        get teamId(): string
        get facing(): Internal.Direction
        get underWater(): boolean
        get ticksExisted(): number
        get swimming(): boolean
        get motionX(): number
        get waterCreature(): boolean
        get persistentData(): Internal.CompoundTag
        set x(x: number)
        get recursivePassengers(): Internal.EntityArrayList
        get invulnerable(): boolean
        get noClip(): boolean
        get inWater(): boolean
        get hasCustomName(): boolean
        get frame(): boolean
        get customNameAlwaysVisible(): boolean
        set stepHeight(stepHeight: number)
        set motionY(y: number)
        set noGravity(noGravity: boolean)
        get peacefulCreature(): boolean
        set yaw(yaw: number)
        get item(): Internal.ItemStackJS
        get stepHeight(): number
        get ambientCreature(): boolean
        get monster(): boolean
        get horizontalFacing(): Internal.Direction
        get type(): string
        set customNameAlwaysVisible(b: boolean)
        get sprinting(): boolean
        get block(): Internal.BlockContainerJS
        get nbt(): Internal.CompoundTag
        set invisible(invisible: boolean)
        get motionY(): number
        get name(): Internal.Component
        get passengers(): Internal.EntityArrayList
        get eyeHeight(): number
        get z(): number
        get yaw(): number
        get id(): Internal.UUID
        set motionX(x: number)
        set silent(isSilent: boolean)
        set onFire(seconds: number)
        set pitch(pitch: number)
        get fallDistance(): number
        get onGround(): boolean
        get server(): Internal.ServerJS
        get motionZ(): number
        get invisible(): boolean
        set z(z: number)
        set statusMessage(message: Internal.Component_)
        get y(): number
        get profile(): Internal.GameProfile
        set invulnerable(invulnerable: boolean)
    }
    type EntityJS_ = EntityJS;
    class IntTag extends Internal.NumericTag {
        static valueOf(arg0: number): Internal.IntTag;
        getAsDouble(): number;
        getType(): Internal.TagType<Internal.IntTag>;
        accept(arg0: Internal.TagVisitor_): void;
        getAsLong(): number;
        getAsFloat(): number;
        hashCode(): number;
        getAsString(): string;
        getAsInt(): number;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        getAsByte(): number;
        getAsNumber(): Internal.Number;
        write(arg0: Internal.DataOutput_): void;
        getId(): number;
        getAsShort(): number;
        equals(arg0: any): boolean;
        copy(): this;
        accept(arg0: Internal.StreamTagVisitor_): Internal.StreamTagVisitor$ValueResult;
        get asDouble(): number
        get type(): Internal.TagType<Internal.IntTag>
        get asLong(): number
        get asFloat(): number
        get asString(): string
        get asInt(): number
        get asByte(): number
        get asNumber(): Internal.Number
        get id(): number
        get asShort(): number
        readonly static "TYPE": any;
    }
    type IntTag_ = IntTag;
    interface GenerationProperties {
        getFeatures(arg0: DecorationGenerationStep_): Internal.Iterable<Internal.Holder<Internal.PlacedFeature>>;
        getCarvers(arg0: CarvingGenerationStep_): Internal.Iterable<Internal.Holder<Internal.ConfiguredWorldCarver<any>>>;
        getFeatures(): Internal.List<Internal.Iterable<Internal.Holder<Internal.PlacedFeature>>>;
        get features(): Internal.List<Internal.Iterable<Internal.Holder<Internal.PlacedFeature>>>
    }
    type GenerationProperties_ = GenerationProperties;
    class Advancement$Builder implements Internal.IForgeAdvancementBuilder {
        build(arg0: ResourceLocation_): Internal.Advancement;
        static fromNetwork(arg0: Internal.FriendlyByteBuf_): Internal.Advancement$Builder;
        getCriteria(): Internal.Map<string, Internal.Criterion>;
        toString(): string;
        static fromJson(arg0: Internal.JsonObject_, arg1: Internal.DeserializationContext_, arg2: Internal.ICondition$IContext_): Internal.Advancement$Builder;
        addCriterion(arg0: string, arg1: Internal.Criterion_): this;
        rewards(arg0: Internal.AdvancementRewards$Builder_): this;
        parent(arg0: ResourceLocation_): this;
        display(arg0: Internal.ItemLike_, arg1: Internal.Component_, arg2: Internal.Component_, arg3: ResourceLocation_, arg4: Internal.FrameType_, arg5: boolean, arg6: boolean, arg7: boolean): this;
        parent(arg0: Internal.Advancement_): this;
        save(arg0: Internal.Consumer_<Internal.Advancement_>, arg1: string): Internal.Advancement;
        serializeToJson(): Internal.JsonObject;
        canBuild(arg0: Internal.Function_<ResourceLocation_, Internal.Advancement_>): boolean;
        static fromJson(arg0: Internal.JsonObject_, arg1: Internal.DeserializationContext_): Internal.Advancement$Builder;
        static advancement(): Internal.Advancement$Builder;
        save(arg0: Internal.Consumer_<Internal.Advancement_>, arg1: ResourceLocation_, arg2: Internal.ExistingFileHelper_): Internal.Advancement;
        addCriterion(arg0: string, arg1: Internal.CriterionTriggerInstance_): this;
        display(arg0: Internal.ItemStack_, arg1: Internal.Component_, arg2: Internal.Component_, arg3: ResourceLocation_, arg4: Internal.FrameType_, arg5: boolean, arg6: boolean, arg7: boolean): this;
        requirements(arg0: Internal.RequirementsStrategy_): this;
        requirements(arg0: string[][]): this;
        rewards(arg0: Internal.AdvancementRewards_): this;
        serializeToNetwork(arg0: Internal.FriendlyByteBuf_): void;
        display(arg0: Internal.DisplayInfo_): this;
        get criteria(): Internal.Map<string, Internal.Criterion>
    }
    type Advancement$Builder_ = Advancement$Builder;
    abstract class Raider extends Internal.PatrollingMonster {
        setTicksOutsideRaid(arg0: number): void;
        canJoinRaid(): boolean;
        setCurrentRaid(arg0: Internal.Raid_): void;
        setCanJoinRaid(arg0: boolean): void;
        isCelebrating(): boolean;
        getWave(): number;
        getStepHeight(): number;
        requiresCustomPersistence(): boolean;
        getTicksOutsideRaid(): number;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        setWave(arg0: number): void;
        isMultipartEntity(): boolean;
        canJoinPatrol(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getCurrentRaid(): Internal.Raid;
        getCelebrateSound(): Internal.SoundEvent;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        hasActiveRaid(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        die(arg0: Internal.DamageSource_): void;
        setCelebrating(arg0: boolean): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        removeWhenFarAway(arg0: number): boolean;
        applyRaidBuffs(arg0: number, arg1: boolean): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        set ticksOutsideRaid(arg0: number)
        set currentRaid(arg0: Internal.Raid_)
        set canJoinRaid(arg0: boolean)
        get celebrating(): boolean
        get wave(): number
        get stepHeight(): number
        get ticksOutsideRaid(): number
        set wave(arg0: number)
        get multipartEntity(): boolean
        get currentRaid(): Internal.Raid
        get celebrateSound(): Internal.SoundEvent
        get parts(): Internal.PartEntity<any>[]
        set celebrating(arg0: boolean)
    }
    type Raider_ = Raider;
    interface IReverseTag <V> {
        containsTag(arg0: Internal.TagKey_<V>): boolean;
        containsTag(arg0: Internal.ITag_<V>): boolean;
        getTagKeys(): Internal.Stream<Internal.TagKey<V>>;
        get tagKeys(): Internal.Stream<Internal.TagKey<V>>
    }
    type IReverseTag_<V> = IReverseTag<V>;
    class SinglePoolElement extends Internal.StructurePoolElement {
        constructor(arg0: Internal.StructureTemplate_)
        getDataMarkers(arg0: Internal.StructureManager_, arg1: BlockPos_, arg2: Internal.Rotation_, arg3: boolean): Internal.List<Internal.StructureTemplate$StructureBlockInfo>;
        getType(): Internal.StructurePoolElementType<any>;
        getSize(arg0: Internal.StructureManager_, arg1: Internal.Rotation_): Vec3i;
        toString(): string;
        place(arg0: Internal.StructureManager_, arg1: Internal.WorldGenLevel_, arg2: Internal.StructureFeatureManager_, arg3: Internal.ChunkGenerator_, arg4: BlockPos_, arg5: BlockPos_, arg6: Internal.Rotation_, arg7: Internal.BoundingBox_, arg8: Internal.Random_, arg9: boolean): boolean;
        getShuffledJigsawBlocks(arg0: Internal.StructureManager_, arg1: BlockPos_, arg2: Internal.Rotation_, arg3: Internal.Random_): Internal.List<Internal.StructureTemplate$StructureBlockInfo>;
        getBoundingBox(arg0: Internal.StructureManager_, arg1: BlockPos_, arg2: Internal.Rotation_): Internal.BoundingBox;
        get type(): Internal.StructurePoolElementType<any>
        readonly static "CODEC": any;
    }
    type SinglePoolElement_ = SinglePoolElement;
    class ScreenEvent$KeyboardCharTypedEvent$Post extends Internal.ScreenEvent$KeyboardCharTypedEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: string, arg2: number)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$KeyboardCharTypedEvent$Post_ = ScreenEvent$KeyboardCharTypedEvent$Post;
    class TaggedChoice$TaggedChoiceType <K> extends com.mojang.datafixers.types.Type<com.mojang.datafixers.util.Pair<K, any>> {
        constructor(arg0: string, arg1: com.mojang.datafixers.types.Type_<K>, arg2: Internal.Map_<K, com.mojang.datafixers.types.Type_<any>>)
        findChoiceType(arg0: string, arg1: number): Internal.Optional<Internal.TaggedChoice$TaggedChoiceType<any>>;
        toString(): string;
        all(arg0: Internal.TypeRewriteRule_, arg1: boolean, arg2: boolean): Internal.RewriteResult<com.mojang.datafixers.util.Pair<K, any>, any>;
        getKeyType(): com.mojang.datafixers.types.Type<K>;
        findCheckedType(arg0: number): Internal.Optional<com.mojang.datafixers.types.Type<any>>;
        point(arg0: Internal.DynamicOps_<any>): Internal.Optional<com.mojang.datafixers.util.Pair<K, any>>;
        static elementResult(arg0: K, arg1: Internal.TaggedChoice$TaggedChoiceType_<K>, arg2: Internal.RewriteResult_<FT, FR>): Internal.RewriteResult<com.mojang.datafixers.util.Pair<K, any>, com.mojang.datafixers.util.Pair<K, any>>;
        hasType(arg0: K): boolean;
        findTypeInChildren(arg0: com.mojang.datafixers.types.Type_<FT>, arg1: com.mojang.datafixers.types.Type_<FR>, arg2: Internal.Type$TypeMatcher_<FT, FR>, arg3: boolean): Internal.Either<Internal.TypedOptic<com.mojang.datafixers.util.Pair<K, any>, any, FT, FR>, Internal.Type$FieldNotFoundException>;
        findFieldTypeOpt(arg0: string): Internal.Optional<com.mojang.datafixers.types.Type<any>>;
        hashCode(): number;
        getName(): string;
        point(arg0: Internal.DynamicOps_<any>, arg1: K, arg2: any): Internal.Optional<Internal.Typed<com.mojang.datafixers.util.Pair<K, any>>>;
        equals(arg0: any, arg1: boolean, arg2: boolean): boolean;
        types(): Internal.Map<K, com.mojang.datafixers.types.Type<any>>;
        one(arg0: Internal.TypeRewriteRule_): Internal.Optional<Internal.RewriteResult<com.mojang.datafixers.util.Pair<K, any>, any>>;
        updateMu(arg0: Internal.RecursiveTypeFamily_): com.mojang.datafixers.types.Type<any>;
        buildTemplate(): Internal.TypeTemplate;
        get keyType(): com.mojang.datafixers.types.Type<K>
        get name(): string
    }
    type TaggedChoice$TaggedChoiceType_<K> = TaggedChoice$TaggedChoiceType<K>;
    class CarvingMaskPlacement extends Internal.PlacementModifier {
        static forStep(arg0: CarvingGenerationStep_): Internal.CarvingMaskPlacement;
        type(): Internal.PlacementModifierType<any>;
        getPositions(arg0: Internal.PlacementContext_, arg1: Internal.Random_, arg2: BlockPos_): Internal.Stream<BlockPos>;
        readonly static "CODEC": any;
    }
    type CarvingMaskPlacement_ = CarvingMaskPlacement;
    class Dynamic <T> extends Internal.DynamicLike<T> {
        constructor(arg0: Internal.DynamicOps_<T>, arg1: T)
        constructor(arg0: Internal.DynamicOps_<T>)
        asLongStreamOpt(): Internal.DataResult<Internal.LongStream>;
        getGeneric(arg0: T): Internal.DataResult<T>;
        merge(arg0: Internal.Dynamic_<any>, arg1: Internal.Dynamic_<any>): Internal.OptionalDynamic<T>;
        static convert(arg0: Internal.DynamicOps_<S>, arg1: Internal.DynamicOps_<T>, arg2: S): T;
        getMapValues(): Internal.DataResult<Internal.Map<Internal.Dynamic<T>, Internal.Dynamic<T>>>;
        asString(): Internal.DataResult<string>;
        update(arg0: string, arg1: Internal.Function_<Internal.Dynamic_<any>, Internal.Dynamic_<any>>): this;
        asIntStreamOpt(): Internal.DataResult<Internal.IntStream>;
        merge(arg0: Internal.Dynamic_<any>): Internal.OptionalDynamic<T>;
        into(arg0: Internal.Function_<any, any>): V;
        getElement(arg0: string): Internal.DataResult<T>;
        getElementGeneric(arg0: T): Internal.DataResult<T>;
        convert(arg0: Internal.DynamicOps_<R>): Internal.Dynamic<R>;
        updateGeneric(arg0: T, arg1: Internal.Function_<T, T>): this;
        updateMapValues(arg0: Internal.Function_<com.mojang.datafixers.util.Pair_<Internal.Dynamic_<any>, Internal.Dynamic_<any>>, com.mojang.datafixers.util.Pair_<Internal.Dynamic_<any>, Internal.Dynamic_<any>>>): this;
        toString(): string;
        decode(arg0: Internal.Decoder_<any>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>;
        remove(arg0: string): this;
        set(arg0: string, arg1: Internal.Dynamic_<any>): this;
        asNumber(): Internal.DataResult<Internal.Number>;
        cast(arg0: Internal.DynamicOps_<U>): U;
        asByteBufferOpt(): Internal.DataResult<Internal.ByteBuffer>;
        hashCode(): number;
        asStreamOpt(): Internal.DataResult<Internal.Stream<Internal.Dynamic<T>>>;
        castTyped(arg0: Internal.DynamicOps_<U>): Internal.Dynamic<U>;
        getValue(): T;
        asMapOpt(): Internal.DataResult<Internal.Stream<com.mojang.datafixers.util.Pair<Internal.Dynamic<T>, Internal.Dynamic<T>>>>;
        map(arg0: Internal.Function_<any, any>): this;
        equals(arg0: any): boolean;
        get(arg0: string): Internal.OptionalDynamic<T>;
        get mapValues(): Internal.DataResult<Internal.Map<Internal.Dynamic<T>, Internal.Dynamic<T>>>
        get value(): T
    }
    type Dynamic_<T> = Dynamic<T>;
    interface ObjectIterable <K> extends Internal.Iterable<K> {
        iterator(): Internal.Iterator<any>;
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.ObjectSpliterator<K>;
    }
    type ObjectIterable_<K> = ObjectIterable<K>;
    class Direction8 extends Internal.Enum<Internal.Direction8> {
        getDirections(): Internal.Set<Internal.Direction>;
        static values(): Internal.Direction8[];
        static valueOf(arg0: string): Internal.Direction8;
        get directions(): Internal.Set<Internal.Direction>
        readonly static "NORTH_EAST": Internal.Direction8;
        readonly static "EAST": Internal.Direction8;
        readonly static "NORTH_WEST": Internal.Direction8;
        readonly static "SOUTH_EAST": Internal.Direction8;
        readonly static "SOUTH_WEST": Internal.Direction8;
        readonly static "NORTH": Internal.Direction8;
        readonly static "SOUTH": Internal.Direction8;
        readonly static "WEST": Internal.Direction8;
    }
    type Direction8_ = "north_west" | "west" | "north_east" | "east" | "south_west" | "south" | "north" | Direction8 | "south_east";
    interface DoubleToIntFunction {
        applyAsInt(arg0: number): number;
    }
    type DoubleToIntFunction_ = ((arg0: number)=>number) | DoubleToIntFunction;
    class PlayerEvent$ItemPickupEvent extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.ItemEntity_, arg2: Internal.ItemStack_)
        getStack(): Internal.ItemStack;
        getListenerList(): Internal.ListenerList;
        getOriginalEntity(): Internal.ItemEntity;
        get stack(): Internal.ItemStack
        get listenerList(): Internal.ListenerList
        get originalEntity(): Internal.ItemEntity
    }
    type PlayerEvent$ItemPickupEvent_ = PlayerEvent$ItemPickupEvent;
    interface DoubleStream extends Internal.BaseStream<number, Internal.DoubleStream> {
        builder(): Internal.DoubleStream$Builder;
        iterator(): Internal.PrimitiveIterator$OfDouble;
        iterate(arg0: number, arg1: Internal.DoubleUnaryOperator_): this;
        mapToObj(arg0: Internal.DoubleFunction_<any>): Internal.Stream<U>;
        skip(arg0: number): this;
        min(): Internal.OptionalDouble;
        limit(arg0: number): this;
        reduce(arg0: Internal.DoubleBinaryOperator_): Internal.OptionalDouble;
        iterate(arg0: number, arg1: Internal.DoublePredicate_, arg2: Internal.DoubleUnaryOperator_): this;
        concat(arg0: Internal.DoubleStream_, arg1: Internal.DoubleStream_): this;
        summaryStatistics(): Internal.DoubleSummaryStatistics;
        noneMatch(arg0: Internal.DoublePredicate_): boolean;
        max(): Internal.OptionalDouble;
        allMatch(arg0: Internal.DoublePredicate_): boolean;
        reduce(arg0: number, arg1: Internal.DoubleBinaryOperator_): number;
        flatMap(arg0: Internal.DoubleFunction_<any>): this;
        sequential(): Internal.BaseStream<any, any>;
        of(arg0: number): this;
        of(...arg0: number[]): this;
        mapToLong(arg0: Internal.DoubleToLongFunction_): Internal.LongStream;
        count(): number;
        peek(arg0: Internal.DoubleConsumer_): this;
        toArray(): number[];
        distinct(): this;
        boxed(): Internal.Stream<number>;
        map(arg0: Internal.DoubleUnaryOperator_): this;
        empty(): this;
        forEachOrdered(arg0: Internal.DoubleConsumer_): void;
        anyMatch(arg0: Internal.DoublePredicate_): boolean;
        filter(arg0: Internal.DoublePredicate_): this;
        findAny(): Internal.OptionalDouble;
        dropWhile(arg0: Internal.DoublePredicate_): this;
        generate(arg0: Internal.DoubleSupplier_): this;
        mapToInt(arg0: Internal.DoubleToIntFunction_): Internal.IntStream;
        mapMulti(arg0: Internal.DoubleStream$DoubleMapMultiConsumer_): this;
        spliterator(): Internal.Spliterator<any>;
        takeWhile(arg0: Internal.DoublePredicate_): this;
        findFirst(): Internal.OptionalDouble;
        forEach(arg0: Internal.DoubleConsumer_): void;
        sum(): number;
        average(): Internal.OptionalDouble;
        sorted(): this;
        parallel(): Internal.BaseStream<any, any>;
        collect(arg0: Internal.Supplier_<R>, arg1: Internal.ObjDoubleConsumer_<R>, arg2: Internal.BiConsumer_<R, R>): R;
    }
    type DoubleStream_ = DoubleStream;
    interface App2 <F, A, B> {
    }
    type App2_<F, A, B> = App2<F, A, B>;
    class LocalDate implements Internal.Temporal, Internal.TemporalAdjuster, Internal.ChronoLocalDate, Internal.Serializable {
        datesUntil(arg0: Internal.LocalDate_, arg1: Internal.Period_): Internal.Stream<Internal.LocalDate>;
        static now(): Internal.LocalDate;
        static of(arg0: number, arg1: number, arg2: number): Internal.LocalDate;
        getMonth(): Internal.Month;
        plusMonths(arg0: number): this;
        static from(arg0: Internal.TemporalAccessor_): Internal.LocalDate;
        toEpochSecond(arg0: Internal.LocalTime_, arg1: Internal.ZoneOffset_): number;
        isAfter(arg0: Internal.ChronoLocalDate_): boolean;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Temporal;
        getDayOfWeek(): Internal.DayOfWeek;
        atTime(arg0: Internal.OffsetTime_): Internal.OffsetDateTime;
        compareTo(arg0: any): number;
        atTime(arg0: number, arg1: number): Internal.LocalDateTime;
        static ofInstant(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.LocalDate;
        getDayOfMonth(): number;
        datesUntil(arg0: Internal.LocalDate_): Internal.Stream<Internal.LocalDate>;
        with(arg0: Internal.TemporalAdjuster_): Internal.Temporal;
        atStartOfDay(): Internal.LocalDateTime;
        with(arg0: Internal.TemporalField_, arg1: number): Internal.Temporal;
        isSupported(arg0: Internal.TemporalField_): boolean;
        toEpochDay(): number;
        format(arg0: Internal.DateTimeFormatter_): string;
        minus(arg0: Internal.TemporalAmount_): Internal.ChronoLocalDate;
        getChronology(): Internal.Chronology;
        plusWeeks(arg0: number): this;
        withDayOfYear(arg0: number): this;
        static ofYearDay(arg0: number, arg1: number): Internal.LocalDate;
        withMonth(arg0: number): this;
        getYear(): number;
        compareTo(arg0: Internal.ChronoLocalDate_): number;
        atTime(arg0: Internal.LocalTime_): Internal.ChronoLocalDateTime<any>;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        atStartOfDay(arg0: Internal.ZoneId_): Internal.ZonedDateTime;
        get(arg0: Internal.TemporalField_): number;
        withDayOfMonth(arg0: number): this;
        minusYears(arg0: number): this;
        isBefore(arg0: Internal.ChronoLocalDate_): boolean;
        static now(arg0: Internal.Clock_): Internal.LocalDate;
        static parse(arg0: Internal.CharSequence_): Internal.LocalDate;
        lengthOfYear(): number;
        getMonthValue(): number;
        minusDays(arg0: number): this;
        until(arg0: Internal.ChronoLocalDate_): Internal.ChronoPeriod;
        plusDays(arg0: number): this;
        atTime(arg0: number, arg1: number, arg2: number): Internal.LocalDateTime;
        getLong(arg0: Internal.TemporalField_): number;
        static ofEpochDay(arg0: number): Internal.LocalDate;
        minusWeeks(arg0: number): this;
        getEra(): Internal.IsoEra;
        withYear(arg0: number): this;
        atTime(arg0: number, arg1: number, arg2: number, arg3: number): Internal.LocalDateTime;
        static parse(arg0: Internal.CharSequence_, arg1: Internal.DateTimeFormatter_): Internal.LocalDate;
        toString(): string;
        plusYears(arg0: number): this;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        minusMonths(arg0: number): this;
        getDayOfYear(): number;
        query(arg0: Internal.TemporalQuery_<R>): R;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        plus(arg0: Internal.TemporalAmount_): Internal.Temporal;
        hashCode(): number;
        isEqual(arg0: Internal.ChronoLocalDate_): boolean;
        static of(arg0: number, arg1: Internal.Month_, arg2: number): Internal.LocalDate;
        static now(arg0: Internal.ZoneId_): Internal.LocalDate;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.ChronoLocalDate;
        lengthOfMonth(): number;
        equals(arg0: any): boolean;
        isLeapYear(): boolean;
        get month(): Internal.Month
        get dayOfWeek(): Internal.DayOfWeek
        get dayOfMonth(): number
        get chronology(): Internal.Chronology
        get year(): number
        get monthValue(): number
        get era(): Internal.IsoEra
        get dayOfYear(): number
        get leapYear(): boolean
        readonly static "MIN": Internal.LocalDate;
        readonly static "EPOCH": Internal.LocalDate;
        readonly static "MAX": Internal.LocalDate;
    }
    type LocalDate_ = LocalDate;
    interface VerticalAnchor {
        aboveBottom(arg0: number): this;
        absolute(arg0: number): this;
        belowTop(arg0: number): this;
        bottom(): this;
        top(): this;
        resolveY(arg0: Internal.WorldGenerationContext_): number;
        readonly static "BOTTOM": any;
        readonly static "CODEC": any;
        readonly static "TOP": any;
    }
    type VerticalAnchor_ = VerticalAnchor;
    interface FeatureConfiguration {
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "NONE": Internal.NoneFeatureConfiguration;
    }
    type FeatureConfiguration_ = FeatureConfiguration;
    class DynamicTexture extends Internal.AbstractTexture {
        constructor(arg0: Internal.NativeImage_)
        constructor(arg0: number, arg1: number, arg2: boolean)
        getPixels(): Internal.NativeImage;
        upload(): void;
        load(arg0: Internal.ResourceManager_): void;
        close(): void;
        setPixels(arg0: Internal.NativeImage_): void;
        get pixels(): Internal.NativeImage
        set pixels(arg0: Internal.NativeImage_)
    }
    type DynamicTexture_ = DynamicTexture;
    interface SharedSuggestionProvider {
        getSelectedEntities(): Internal.Collection<string>;
        suggest(arg0: Internal.Stream_<string>, arg1: Internal.SuggestionsBuilder_): Internal.CompletableFuture<Internal.Suggestions>;
        suggestResource(arg0: Internal.Stream_<ResourceLocation_>, arg1: Internal.SuggestionsBuilder_): Internal.CompletableFuture<Internal.Suggestions>;
        suggestCoordinates(arg0: string, arg1: Internal.Collection_<Internal.SharedSuggestionProvider$TextCoordinates_>, arg2: Internal.SuggestionsBuilder_, arg3: Internal.Predicate_<string>): Internal.CompletableFuture<Internal.Suggestions>;
        suggest(arg0: string[], arg1: Internal.SuggestionsBuilder_): Internal.CompletableFuture<Internal.Suggestions>;
        getAvailableSoundEvents(): Internal.Collection<ResourceLocation>;
        suggestResource(arg0: Internal.Iterable_<T>, arg1: Internal.SuggestionsBuilder_, arg2: Internal.Function_<T, ResourceLocation_>, arg3: Internal.Function_<T, Internal.Message_>): Internal.CompletableFuture<Internal.Suggestions>;
        hasPermission(arg0: number): boolean;
        getRecipeNames(): Internal.Stream<ResourceLocation>;
        suggestResource(arg0: Internal.Stream_<ResourceLocation_>, arg1: Internal.SuggestionsBuilder_, arg2: string): Internal.CompletableFuture<Internal.Suggestions>;
        filterResources(arg0: Internal.Iterable_<T>, arg1: string, arg2: Internal.Function_<T, ResourceLocation_>, arg3: Internal.Consumer_<T>): void;
        matchesSubStr(arg0: string, arg1: string): boolean;
        suggest2DCoordinates(arg0: string, arg1: Internal.Collection_<Internal.SharedSuggestionProvider$TextCoordinates_>, arg2: Internal.SuggestionsBuilder_, arg3: Internal.Predicate_<string>): Internal.CompletableFuture<Internal.Suggestions>;
        suggest(arg0: Internal.Iterable_<T>, arg1: Internal.SuggestionsBuilder_, arg2: Internal.Function_<T, string>, arg3: Internal.Function_<T, Internal.Message_>): Internal.CompletableFuture<Internal.Suggestions>;
        suggestRegistryElements(arg0: Internal.Registry_<any>, arg1: Internal.SharedSuggestionProvider$ElementSuggestionType_, arg2: Internal.SuggestionsBuilder_): void;
        suggest(arg0: Internal.Iterable_<string>, arg1: Internal.SuggestionsBuilder_): Internal.CompletableFuture<Internal.Suggestions>;
        customSuggestion(arg0: Internal.CommandContext_<any>): Internal.CompletableFuture<Internal.Suggestions>;
        suggestResource(arg0: Internal.Iterable_<ResourceLocation_>, arg1: Internal.SuggestionsBuilder_): Internal.CompletableFuture<Internal.Suggestions>;
        getAllTeams(): Internal.Collection<string>;
        filterResources(arg0: Internal.Iterable_<T>, arg1: string, arg2: string, arg3: Internal.Function_<T, ResourceLocation_>, arg4: Internal.Consumer_<T>): void;
        registryAccess(): Internal.RegistryAccess;
        getRelevantCoordinates(): Internal.Collection<Internal.SharedSuggestionProvider$TextCoordinates>;
        getAbsoluteCoordinates(): Internal.Collection<Internal.SharedSuggestionProvider$TextCoordinates>;
        suggestRegistryElements(arg0: Internal.ResourceKey_<any>, arg1: Internal.SharedSuggestionProvider$ElementSuggestionType_, arg2: Internal.SuggestionsBuilder_, arg3: Internal.CommandContext_<any>): Internal.CompletableFuture<Internal.Suggestions>;
        suggestResource(arg0: Internal.Iterable_<ResourceLocation_>, arg1: Internal.SuggestionsBuilder_, arg2: string): Internal.CompletableFuture<Internal.Suggestions>;
        levels(): Internal.Set<Internal.ResourceKey<Internal.Level>>;
        getOnlinePlayerNames(): Internal.Collection<string>;
        suggestResource(arg0: Internal.Stream_<T>, arg1: Internal.SuggestionsBuilder_, arg2: Internal.Function_<T, ResourceLocation_>, arg3: Internal.Function_<T, Internal.Message_>): Internal.CompletableFuture<Internal.Suggestions>;
        get selectedEntities(): Internal.Collection<string>
        get availableSoundEvents(): Internal.Collection<ResourceLocation>
        get recipeNames(): Internal.Stream<ResourceLocation>
        get allTeams(): Internal.Collection<string>
        get relevantCoordinates(): Internal.Collection<Internal.SharedSuggestionProvider$TextCoordinates>
        get absoluteCoordinates(): Internal.Collection<Internal.SharedSuggestionProvider$TextCoordinates>
        get onlinePlayerNames(): Internal.Collection<string>
    }
    type SharedSuggestionProvider_ = SharedSuggestionProvider;
    class OptionalDouble {
        orElse(arg0: number): number;
        toString(): string;
        ifPresent(arg0: Internal.DoubleConsumer_): void;
        orElseThrow(arg0: Internal.Supplier_<any>): number;
        isEmpty(): boolean;
        getAsDouble(): number;
        orElseThrow(): number;
        hashCode(): number;
        isPresent(): boolean;
        stream(): Internal.DoubleStream;
        static empty(): Internal.OptionalDouble;
        orElseGet(arg0: Internal.DoubleSupplier_): number;
        equals(arg0: any): boolean;
        ifPresentOrElse(arg0: Internal.DoubleConsumer_, arg1: Internal.Runnable_): void;
        static of(arg0: number): Internal.OptionalDouble;
        get empty(): boolean
        get asDouble(): number
        get present(): boolean
    }
    type OptionalDouble_ = OptionalDouble;
    abstract class AsynchronousFileChannel implements Internal.AsynchronousChannel {
        lock(arg0: A, arg1: Internal.CompletionHandler_<Internal.FileLock_, any>): void;
        tryLock(): Internal.FileLock;
        size(): number;
        lock(arg0: number, arg1: number, arg2: boolean, arg3: A, arg4: Internal.CompletionHandler_<Internal.FileLock_, any>): void;
        write(arg0: Internal.ByteBuffer_, arg1: number): Internal.Future<number>;
        lock(arg0: number, arg1: number, arg2: boolean): Internal.Future<Internal.FileLock>;
        read(arg0: Internal.ByteBuffer_, arg1: number): Internal.Future<number>;
        write(arg0: Internal.ByteBuffer_, arg1: number, arg2: A, arg3: Internal.CompletionHandler_<number, any>): void;
        lock(): Internal.Future<Internal.FileLock>;
        read(arg0: Internal.ByteBuffer_, arg1: number, arg2: A, arg3: Internal.CompletionHandler_<number, any>): void;
        static open(arg0: Internal.Path_, ...arg1: Internal.OpenOption_[]): Internal.AsynchronousFileChannel;
        tryLock(arg0: number, arg1: number, arg2: boolean): Internal.FileLock;
        truncate(arg0: number): this;
        static open(arg0: Internal.Path_, arg1: Internal.Set_<any>, arg2: Internal.ExecutorService_, ...arg3: any_<any>[]): Internal.AsynchronousFileChannel;
        force(arg0: boolean): void;
    }
    type AsynchronousFileChannel_ = AsynchronousFileChannel;
    class FriendlyByteBuf extends Internal.ByteBuf implements Internal.IForgeFriendlyByteBuf {
        constructor(arg0: Internal.ByteBuf_)
        getBytes(arg0: number, arg1: Internal.OutputStream_, arg2: number): Internal.ByteBuf;
        indexOf(arg0: number, arg1: number, arg2: number): number;
        writeUtf(arg0: string): this;
        readShortLE(): number;
        writeUtf(arg0: string, arg1: number): this;
        readVarInt(): number;
        writeInt(arg0: number): Internal.ByteBuf;
        readDouble(): number;
        skipBytes(arg0: number): Internal.ByteBuf;
        markReaderIndex(): Internal.ByteBuf;
        markWriterIndex(): Internal.ByteBuf;
        getShortLE(arg0: number): number;
        writeItem(arg0: Internal.ItemStack_): this;
        readBlockHitResult(): Internal.BlockHitResult;
        readDate(): Internal.Date;
        readLongArray(): number[];
        resetWriterIndex(): Internal.ByteBuf;
        isReadable(arg0: number): boolean;
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel_, arg2: number): number;
        readUnsignedMedium(): number;
        writeBytes(arg0: Internal.InputStream_, arg1: number): number;
        compareTo(arg0: Internal.ByteBuf_): number;
        touch(arg0: any): Internal.ReferenceCounted;
        readUnsignedMediumLE(): number;
        writeIntLE(arg0: number): Internal.ByteBuf;
        readAnySizeNbt(): Internal.CompoundTag;
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf;
        slice(): Internal.ByteBuf;
        writeMedium(arg0: number): Internal.ByteBuf;
        copy(arg0: number, arg1: number): Internal.ByteBuf;
        resetReaderIndex(): Internal.ByteBuf;
        release(): boolean;
        readBytes(arg0: number[]): Internal.ByteBuf;
        readChunkPos(): Internal.ChunkPos;
        readByte(): number;
        writeResourceLocation(arg0: ResourceLocation_): this;
        writerIndex(arg0: number): Internal.ByteBuf;
        writeMap(arg0: Internal.Map_<K, V>, arg1: Internal.BiConsumer_<Internal.FriendlyByteBuf_, K>, arg2: Internal.BiConsumer_<Internal.FriendlyByteBuf_, V>): void;
        writeOptional(arg0: Internal.Optional_<T>, arg1: Internal.BiConsumer_<Internal.FriendlyByteBuf_, T>): void;
        arrayOffset(): number;
        writeUUID(arg0: Internal.UUID_): this;
        readBytes(arg0: Internal.ByteBuffer_): Internal.ByteBuf;
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf;
        readVarIntArray(arg0: number): number[];
        writeByteArray(arg0: number[]): this;
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        readRegistryIdSafe(arg0: Internal.Class_<any>): T;
        readLongArray(arg0: number[]): number[];
        getUnsignedInt(arg0: number): number;
        getUnsignedMedium(arg0: number): number;
        getUnsignedMediumLE(arg0: number): number;
        maxCapacity(): number;
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset_): Internal.CharSequence;
        clear(): Internal.ByteBuf;
        readMedium(): number;
        unwrap(): Internal.ByteBuf;
        retain(): Internal.ReferenceCounted;
        static getVarLongSize(arg0: number): number;
        writeChunkPos(arg0: Internal.ChunkPos_): this;
        writeBytes(arg0: number[]): Internal.ByteBuf;
        discardReadBytes(): Internal.ByteBuf;
        readLongArray(arg0: number[], arg1: number): number[];
        writeChar(arg0: number): Internal.ByteBuf;
        duplicate(): Internal.ByteBuf;
        getDouble(arg0: number): number;
        capacity(arg0: number): Internal.ByteBuf;
        isDirect(): boolean;
        readUnsignedInt(): number;
        writeDouble(arg0: number): Internal.ByteBuf;
        writeIntIdList(arg0: Internal.IntList_): void;
        readUtf(arg0: number): string;
        readNbt(): Internal.CompoundTag;
        readWithCodec(arg0: Internal.Codec_<T>): T;
        readRegistryId(): T;
        getUnsignedIntLE(arg0: number): number;
        readVarIntArray(): number[];
        readChar(): string;
        readUtf(): string;
        setInt(arg0: number, arg1: number): Internal.ByteBuf;
        bytesBefore(arg0: number, arg1: number, arg2: number): number;
        isWritable(arg0: number): boolean;
        alloc(): Internal.ByteBufAllocator;
        readIntIdList(): Internal.IntList;
        readInt(): number;
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        setChar(arg0: number, arg1: number): Internal.ByteBuf;
        readRegistryIdUnsafe(arg0: Internal.IForgeRegistry_<T>): T;
        writeBytes(arg0: Internal.ByteBuffer_): Internal.ByteBuf;
        getLong(arg0: number): number;
        readBitSet(): Internal.BitSet;
        writeBlockHitResult(arg0: Internal.BlockHitResult_): void;
        accessByteBufWithCorrectSize(): number[];
        readerIndex(arg0: number): Internal.ByteBuf;
        readByteArray(arg0: number): number[];
        readSectionPos(): Internal.SectionPos;
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        asReadOnly(): Internal.ByteBuf;
        hasMemoryAddress(): boolean;
        setZero(arg0: number, arg1: number): Internal.ByteBuf;
        readLongLE(): number;
        getShort(arg0: number): number;
        writeLong(arg0: number): Internal.ByteBuf;
        readCollection(arg0: Internal.IntFunction_<C>, arg1: Internal.Function_<Internal.FriendlyByteBuf_, T>): C;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_): Internal.ByteBuf;
        readUnsignedIntLE(): number;
        getBytes(arg0: number, arg1: Internal.ByteBuffer_): Internal.ByteBuf;
        getInt(arg0: number): number;
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        writeBytes(arg0: Internal.ScatteringByteChannel_, arg1: number): number;
        writeRegistryId(arg0: T): void;
        writeItemStack(arg0: Internal.ItemStack_, arg1: boolean): this;
        setMedium(arg0: number, arg1: number): Internal.ByteBuf;
        static limitValue(arg0: Internal.IntFunction_<T>, arg1: number): Internal.IntFunction<T>;
        writeByte(arg0: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): Internal.ByteBuf;
        ensureWritable(arg0: number, arg1: boolean): number;
        writeVarInt(arg0: number): this;
        getUnsignedShort(arg0: number): number;
        getBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        setDouble(arg0: number, arg1: number): Internal.ByteBuf;
        readUnsignedByte(): number;
        getUnsignedShortLE(arg0: number): number;
        writeVarIntArray(arg0: number[]): this;
        equals(arg0: any): boolean;
        toString(arg0: number, arg1: number, arg2: Internal.Charset_): string;
        readList(arg0: Internal.Function_<Internal.FriendlyByteBuf_, T>): Internal.List<T>;
        readableBytes(): number;
        readFluidStack(): Internal.FluidStack;
        forEachByteDesc(arg0: Internal.ByteProcessor_): number;
        nioBufferCount(): number;
        writeVarLong(arg0: number): this;
        nioBuffers(): Internal.ByteBuffer[];
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        getFloat(arg0: number): number;
        writeFloat(arg0: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        memoryAddress(): number;
        setFloat(arg0: number, arg1: number): Internal.ByteBuf;
        ensureWritable(arg0: number): Internal.ByteBuf;
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        getMediumLE(arg0: number): number;
        maxWritableBytes(): number;
        isReadable(): boolean;
        readIntLE(): number;
        getByte(arg0: number): number;
        writeShort(arg0: number): Internal.ByteBuf;
        writeFluidStack(arg0: Internal.FluidStack_): void;
        getMedium(arg0: number): number;
        bytesBefore(arg0: number, arg1: number): number;
        writeNbt(arg0: Internal.CompoundTag_): this;
        readEnum(arg0: Internal.Class_<T>): T;
        retain(arg0: number): Internal.ReferenceCounted;
        readBoolean(): boolean;
        writeDate(arg0: Internal.Date_): this;
        setCharSequence(arg0: number, arg1: Internal.CharSequence_, arg2: Internal.Charset_): number;
        isReadOnly(): boolean;
        writeLongLE(arg0: number): Internal.ByteBuf;
        writeCharSequence(arg0: Internal.CharSequence_, arg1: Internal.Charset_): number;
        getBytes(arg0: number, arg1: Internal.ByteBuf_): Internal.ByteBuf;
        readUnsignedShort(): number;
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        writeMediumLE(arg0: number): Internal.ByteBuf;
        release(arg0: number): boolean;
        writeBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        forEachByte(arg0: Internal.ByteProcessor_): number;
        setBytes(arg0: number, arg1: Internal.ByteBuf_): Internal.ByteBuf;
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf;
        writeRegistryIdUnsafe(arg0: Internal.IForgeRegistry_<any>, arg1: ResourceLocation_): void;
        getUnsignedByte(arg0: number): number;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_, arg1: number): Internal.ByteBuf;
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        readByteArray(): number[];
        retainedSlice(): Internal.ByteBuf;
        writeWithCodec(arg0: Internal.Codec_<T>, arg1: T): void;
        setShort(arg0: number, arg1: number): Internal.ByteBuf;
        toString(): string;
        readBlockPos(): BlockPos;
        getBoolean(arg0: number): boolean;
        readOptional(arg0: Internal.Function_<Internal.FriendlyByteBuf_, T>): Internal.Optional<T>;
        writeZero(arg0: number): Internal.ByteBuf;
        readVarLong(): number;
        nioBuffer(): Internal.ByteBuffer;
        readBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        readMap(arg0: Internal.IntFunction_<M>, arg1: Internal.Function_<Internal.FriendlyByteBuf_, K>, arg2: Internal.Function_<Internal.FriendlyByteBuf_, V>): M;
        readUnsignedShortLE(): number;
        writeRegistryIdUnsafe(arg0: Internal.IForgeRegistry_<T>, arg1: T): void;
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        writeLongArray(arg0: number[]): this;
        readResourceLocation(): ResourceLocation;
        setBytes(arg0: number, arg1: Internal.InputStream_, arg2: number): number;
        isWritable(): boolean;
        readerIndex(): number;
        setByte(arg0: number, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.GatheringByteChannel_, arg1: number): number;
        readNbt(arg0: Internal.NbtAccounter_): Internal.CompoundTag;
        writerIndex(): number;
        retainedDuplicate(): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): Internal.ByteBuf;
        touch(): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): Internal.ByteBuf;
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf;
        compareTo(arg0: any): number;
        setLong(arg0: number, arg1: number): Internal.ByteBuf;
        readMediumLE(): number;
        writableBytes(): number;
        readWithCount(arg0: Internal.Consumer_<Internal.FriendlyByteBuf_>): void;
        order(): Internal.ByteOrder;
        getChar(arg0: number): string;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number): Internal.ByteBuf;
        readComponent(): Internal.Component;
        discardSomeReadBytes(): Internal.ByteBuf;
        bytesBefore(arg0: number): number;
        readRetainedSlice(arg0: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        writeShortLE(arg0: number): Internal.ByteBuf;
        array(): number[];
        readShort(): number;
        getIntLE(arg0: number): number;
        writeBlockPos(arg0: BlockPos_): this;
        readBytes(arg0: Internal.OutputStream_, arg1: number): Internal.ByteBuf;
        writeSectionPos(arg0: Internal.SectionPos_): this;
        slice(arg0: number, arg1: number): Internal.ByteBuf;
        capacity(): number;
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        readCharSequence(arg0: number, arg1: Internal.Charset_): Internal.CharSequence;
        readUUID(): Internal.UUID;
        writeCollection(arg0: Internal.Collection_<T>, arg1: Internal.BiConsumer_<Internal.FriendlyByteBuf_, T>): void;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): Internal.ByteBuf;
        getLongLE(arg0: number): number;
        readSlice(arg0: number): Internal.ByteBuf;
        readFloat(): number;
        writeBoolean(arg0: boolean): Internal.ByteBuf;
        setIndex(arg0: number, arg1: number): Internal.ByteBuf;
        hasArray(): boolean;
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf;
        writeBitSet(arg0: Internal.BitSet_): void;
        static getVarIntSize(arg0: number): number;
        writeBytes(arg0: Internal.ByteBuf_): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel_, arg2: number): number;
        readItem(): Internal.ItemStack;
        readLong(): number;
        copy(): Internal.ByteBuf;
        writeComponent(arg0: Internal.Component_): this;
        readMap(arg0: Internal.Function_<Internal.FriendlyByteBuf_, K>, arg1: Internal.Function_<Internal.FriendlyByteBuf_, V>): Internal.Map<K, V>;
        readBytes(arg0: number): Internal.ByteBuf;
        writeEnum(arg0: Internal.Enum_<any>): this;
        refCnt(): number;
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf;
        hashCode(): number;
        toString(arg0: Internal.Charset_): string;
        order(arg0: Internal.ByteOrder_): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuffer_): Internal.ByteBuf;
        get direct(): boolean
        get readable(): boolean
        get readOnly(): boolean
        get writable(): boolean
        readonly static "MAX_COMPONENT_STRING_LENGTH": 262144;
        readonly static "MAX_STRING_LENGTH": 32767;
    }
    type FriendlyByteBuf_ = FriendlyByteBuf;
    class Rabbit extends Internal.Animal {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        customServerAiStep(): void;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        static checkRabbitSpawnRules(arg0: Internal.EntityType_<Internal.Rabbit_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        getStepHeight(): number;
        getJumpCompletion(arg0: number): number;
        asKJS(): Internal.EntityJS;
        isFood(arg0: Internal.ItemStack_): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        getSoundSource(): Internal.SoundSource;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        startJumping(): void;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        getRabbitType(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        setRabbitType(arg0: number): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        setSpeedModifier(arg0: number): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        setJumping(arg0: boolean): void;
        getLeashOffset(): Vec3;
        canSpawnSprintParticle(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get soundSource(): Internal.SoundSource
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get rabbitType(): number
        set rabbitType(arg0: number)
        set speedModifier(arg0: number)
        set jumping(arg0: boolean)
        get leashOffset(): Vec3
        readonly static "TYPE_WHITE_SPLOTCHED": 3;
        readonly static "EVIL_ARMOR_VALUE": 8;
        readonly static "BREED_SPEED_MOD": 0.8;
        readonly static "TYPE_SALT": 5;
        readonly static "TYPE_WHITE": 1;
        readonly static "ATTACK_SPEED_MOD": 1.4;
        readonly static "TYPE_BLACK": 2;
        readonly static "TYPE_GOLD": 4;
        readonly static "STROLL_SPEED_MOD": 0.6;
        readonly static "TYPE_EVIL": 99;
        readonly static "EVIL_ATTACK_POWER": 8;
        readonly static "FLEE_SPEED_MOD": 2.2;
        readonly static "FOLLOW_SPEED_MOD": 1.0;
        readonly static "TYPE_BROWN": 0;
    }
    type Rabbit_ = Rabbit;
    abstract class Charset implements Internal.Comparable<Internal.Charset> {
        static isSupported(arg0: string): boolean;
        aliases(): Internal.Set<string>;
        displayName(): string;
        static availableCharsets(): Internal.SortedMap<string, Internal.Charset>;
        toString(): string;
        newEncoder(): Internal.CharsetEncoder;
        newDecoder(): Internal.CharsetDecoder;
        encode(arg0: string): Internal.ByteBuffer;
        canEncode(): boolean;
        isRegistered(): boolean;
        compareTo(arg0: any): number;
        decode(arg0: Internal.ByteBuffer_): Internal.CharBuffer;
        name(): string;
        contains(arg0: Internal.Charset_): boolean;
        displayName(arg0: Internal.Locale_): string;
        hashCode(): number;
        compareTo(arg0: Internal.Charset_): number;
        static defaultCharset(): Internal.Charset;
        encode(arg0: Internal.CharBuffer_): Internal.ByteBuffer;
        equals(arg0: any): boolean;
        static forName(arg0: string): Internal.Charset;
        get registered(): boolean
    }
    type Charset_ = Charset;
    interface BlockEntityPredicateDataCheck {
        checkData(arg0: Internal.CompoundTag_): boolean;
    }
    type BlockEntityPredicateDataCheck_ = ((arg0: Internal.CompoundTag)=>boolean) | BlockEntityPredicateDataCheck;
    class PrintStream extends Internal.FilterOutputStream implements Internal.Closeable, Internal.Appendable {
        constructor(arg0: Internal.File_)
        constructor(arg0: Internal.OutputStream_, arg1: boolean)
        constructor(arg0: Internal.OutputStream_)
        constructor(arg0: string, arg1: string)
        constructor(arg0: string, arg1: Internal.Charset_)
        constructor(arg0: Internal.File_, arg1: Internal.Charset_)
        constructor(arg0: Internal.OutputStream_, arg1: boolean, arg2: Internal.Charset_)
        constructor(arg0: string)
        constructor(arg0: Internal.OutputStream_, arg1: boolean, arg2: string)
        constructor(arg0: Internal.File_, arg1: string)
        print(arg0: string): void;
        println(arg0: number): void;
        printf(arg0: string, ...arg1: any[]): this;
        println(): void;
        format(arg0: Internal.Locale_, arg1: string, ...arg2: any[]): this;
        println(arg0: number): void;
        write(arg0: number[]): void;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): Internal.Appendable;
        append(arg0: string): Internal.Appendable;
        print(arg0: number): void;
        println(arg0: string): void;
        flush(): void;
        write(arg0: number): void;
        print(arg0: number): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        format(arg0: string, ...arg1: any[]): this;
        print(arg0: boolean): void;
        print(arg0: number): void;
        println(arg0: string): void;
        println(arg0: string[]): void;
        println(arg0: boolean): void;
        append(arg0: Internal.CharSequence_): Internal.Appendable;
        printf(arg0: Internal.Locale_, arg1: string, ...arg2: any[]): this;
        println(arg0: number): void;
        checkError(): boolean;
        println(arg0: number): void;
        print(arg0: string[]): void;
        print(arg0: any): void;
        print(arg0: string): void;
        close(): void;
        writeBytes(arg0: number[]): void;
        print(arg0: number): void;
        println(arg0: any): void;
    }
    type PrintStream_ = PrintStream;
    interface BiomeProperties {
        getEffectsProperties(): Internal.EffectsProperties;
        getClimateProperties(): Internal.ClimateProperties;
        getGenerationProperties(): Internal.GenerationProperties;
        getCategory(): Internal.Biome$BiomeCategory;
        getSpawnProperties(): Internal.SpawnProperties;
        get effectsProperties(): Internal.EffectsProperties
        get climateProperties(): Internal.ClimateProperties
        get generationProperties(): Internal.GenerationProperties
        get category(): Internal.Biome$BiomeCategory
        get spawnProperties(): Internal.SpawnProperties
    }
    type BiomeProperties_ = BiomeProperties;
    abstract class ForwardingList <E> extends Internal.ForwardingCollection<E> implements Internal.List<E> {
        get(arg0: number): E;
        replaceAll(arg0: Internal.UnaryOperator_<E>): void;
        subList(arg0: number, arg1: number): Internal.List<E>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: E): void;
        listIterator(): Internal.ListIterator<E>;
        forEach(arg0: Internal.Consumer_<any>): void;
        parallelStream(): Internal.Stream<E>;
        sort(arg0: Internal.Comparator_<any>): void;
        listIterator(arg0: number): Internal.ListIterator<E>;
        set(arg0: number, arg1: E): E;
        hashCode(): number;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        stream(): Internal.Stream<E>;
        spliterator(): Internal.Spliterator<E>;
        addAll(arg0: number, arg1: Internal.Collection_<any>): boolean;
        remove(arg0: number): E;
        equals(arg0: any): boolean;
        lastIndexOf(arg0: any): number;
    }
    type ForwardingList_<E> = ForwardingList<E>;
    class ModuleDescriptor$Builder {
        version(arg0: string): this;
        opens(arg0: Internal.Set_<Internal.ModuleDescriptor$Opens$Modifier_>, arg1: string, arg2: Internal.Set_<string>): this;
        requires(arg0: Internal.Set_<Internal.ModuleDescriptor$Requires$Modifier_>, arg1: string): this;
        requires(arg0: Internal.ModuleDescriptor$Requires_): this;
        requires(arg0: string): this;
        provides(arg0: string, arg1: Internal.List_<string>): this;
        version(arg0: Internal.ModuleDescriptor$Version_): this;
        mainClass(arg0: string): this;
        opens(arg0: Internal.Set_<Internal.ModuleDescriptor$Opens$Modifier_>, arg1: string): this;
        packages(arg0: Internal.Set_<string>): this;
        exports(arg0: Internal.ModuleDescriptor$Exports_): this;
        opens(arg0: string): this;
        opens(arg0: string, arg1: Internal.Set_<string>): this;
        requires(arg0: Internal.Set_<Internal.ModuleDescriptor$Requires$Modifier_>, arg1: string, arg2: Internal.ModuleDescriptor$Version_): this;
        build(): Internal.ModuleDescriptor;
        opens(arg0: Internal.ModuleDescriptor$Opens_): this;
        provides(arg0: Internal.ModuleDescriptor$Provides_): this;
        uses(arg0: string): this;
        exports(arg0: Internal.Set_<Internal.ModuleDescriptor$Exports$Modifier_>, arg1: string, arg2: Internal.Set_<string>): this;
        exports(arg0: Internal.Set_<Internal.ModuleDescriptor$Exports$Modifier_>, arg1: string): this;
        exports(arg0: string): this;
        exports(arg0: string, arg1: Internal.Set_<string>): this;
    }
    type ModuleDescriptor$Builder_ = ModuleDescriptor$Builder;
    class ExpirableValue <T> {
        constructor(arg0: T, arg1: number)
        static codec(arg0: Internal.Codec_<T>): Internal.Codec<Internal.ExpirableValue<T>>;
        toString(): string;
        static of(arg0: T): Internal.ExpirableValue<T>;
        canExpire(): boolean;
        static of(arg0: T, arg1: number): Internal.ExpirableValue<T>;
        getValue(): T;
        hasExpired(): boolean;
        tick(): void;
        getTimeToLive(): number;
        get value(): T
        get timeToLive(): number
    }
    type ExpirableValue_<T> = ExpirableValue<T>;
    interface ShortPredicate extends Internal.Predicate<number>, Internal.IntPredicate {
        test(arg0: any): boolean;
        test(arg0: number): boolean;
        and(arg0: Internal.IntPredicate_): Internal.IntPredicate;
        and(arg0: Internal.Predicate_<any>): Internal.Predicate<number>;
        or(arg0: Internal.ShortPredicate_): this;
        or(arg0: Internal.Predicate_<any>): Internal.Predicate<number>;
        test(arg0: number): boolean;
        or(arg0: Internal.IntPredicate_): this;
        negate(): Internal.IntPredicate;
        test(arg0: number): boolean;
        and(arg0: Internal.ShortPredicate_): this;
    }
    type ShortPredicate_ = ShortPredicate | ((arg0: number)=>boolean);
    class CropBlockBuilder extends Internal.BlockBuilder {
        constructor(i: ResourceLocation_)
        texture(id: string, tex: string): Internal.BlockBuilder;
        dropSeed(dropSeed: boolean): this;
        growTick(growSpeedCallback: Internal.ToDoubleFunction_<Internal.RandomTickCallbackJS_>): this;
        bonemeal(bonemealCallback: Internal.ToIntFunction_<Internal.RandomTickCallbackJS_>): this;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        age(age: number, builder: Internal.Consumer_<Internal.CropBlockBuilder$ShapeBuilder_>): this;
        crop(output: any, chance: number): this;
        age(age: number): this;
        createObject(): Internal.Block;
        crop(output: any): this;
        survive(surviveCallback: Internal.CropBlockBuilder$SurviveCallback_): this;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
    }
    type CropBlockBuilder_ = CropBlockBuilder;
    abstract class Stages {
        constructor(p: Internal.Player_)
        static overrideCreation(event: Internal.Consumer_<Internal.StageCreationEvent_>): void;
        replace(stages: Internal.Collection_<string>): void;
        static removed(event: Internal.Consumer_<Internal.StageChangeEvent_>): void;
        getAll(): Internal.Collection<string>;
        static added(event: Internal.Consumer_<Internal.StageChangeEvent_>): void;
        addNoUpdate(arg0: string): boolean;
        add(stage: string): boolean;
        static invokeAdded(stages: Internal.Stages_, stage: string): void;
        removeNoUpdate(arg0: string): boolean;
        has(stage: string): boolean;
        static get(player: Internal.Player_): Internal.Stages;
        static invokeRemoved(stages: Internal.Stages_, stage: string): void;
        set(stage: string, enabled: boolean): boolean;
        toggle(stage: string): boolean;
        remove(stage: string): boolean;
        sync(): void;
        clear(): boolean;
        get all(): Internal.Collection<string>
        readonly "player": Internal.Player;
    }
    type Stages_ = Stages;
    class Tesselator {
        constructor()
        constructor(arg0: number)
        getBuilder(): Internal.BufferBuilder;
        end(): void;
        static getInstance(): Internal.Tesselator;
        get builder(): Internal.BufferBuilder
        get instance(): Internal.Tesselator
    }
    type Tesselator_ = Tesselator;
    class SynchedEntityData$DataItem <T> {
        constructor(arg0: Internal.EntityDataAccessor_<T>, arg1: T)
        copy(): this;
        setValue(arg0: T): void;
        getValue(): T;
        isDirty(): boolean;
        setDirty(arg0: boolean): void;
        getAccessor(): Internal.EntityDataAccessor<T>;
        set value(arg0: T)
        get value(): T
        get dirty(): boolean
        set dirty(arg0: boolean)
        get accessor(): Internal.EntityDataAccessor<T>
    }
    type SynchedEntityData$DataItem_<T> = SynchedEntityData$DataItem<T>;
    abstract class AbstractHorse extends Internal.Animal implements Internal.Saddleable, Internal.ContainerListener, Internal.PlayerRideableJumping {
        getOwnerUUID(): Internal.UUID;
        canMate(arg0: Internal.Animal_): boolean;
        isBred(): boolean;
        static createBaseHorseAttributes(): Internal.AttributeSupplier$Builder;
        isEating(): boolean;
        getStepHeight(): number;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        handleStopJump(): void;
        getMaxSpawnClusterSize(): number;
        getEatAnim(arg0: number): number;
        getMouthAnim(arg0: number): number;
        makeMad(): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setBred(arg0: boolean): void;
        canJump(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        isArmor(arg0: Internal.ItemStack_): boolean;
        invalidateCaps(): void;
        isSaddled(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getMaxTemper(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        positionRider(arg0: Internal.Entity_): void;
        alwaysAccepts(): boolean;
        fedFood(arg0: Internal.Player_, arg1: Internal.ItemStack_): Internal.InteractionResult;
        setTemper(arg0: number): void;
        onClimbable(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        isSaddleable(): boolean;
        canEatGrass(): boolean;
        openInventory(arg0: Internal.Player_): void;
        isWearingArmor(): boolean;
        getCapability(arg0: Internal.Capability_<T>, arg1: Internal.Direction_): Internal.LazyOptional<T>;
        travel(arg0: Vec3_): void;
        getSlot(arg0: number): Internal.SlotAccess;
        getDismountLocationForPassenger(arg0: Internal.LivingEntity_): Vec3;
        getControllingPassenger(): Internal.Entity;
        asKJS(): Internal.EntityJS;
        isFood(arg0: Internal.ItemStack_): boolean;
        equipSaddle(arg0: Internal.SoundSource_): void;
        getCustomJump(): number;
        canRiderInteract(): boolean;
        isJumping(): boolean;
        isMultipartEntity(): boolean;
        getTemper(): number;
        serializeNBT(): Internal.Tag;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        tameWithName(arg0: Internal.Player_): boolean;
        getAmbientSoundInterval(): number;
        deserializeNBT(arg0: Internal.Tag_): void;
        setEating(arg0: boolean): void;
        canBeControlledByRider(): boolean;
        canWearArmor(): boolean;
        onPlayerJump(arg0: number): void;
        hasInventoryChanged(arg0: Internal.Container_): boolean;
        aiStep(): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        modifyTemper(arg0: number): number;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        isTamed(): boolean;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        setOwnerUUID(arg0: Internal.UUID_): void;
        setStanding(arg0: boolean): void;
        getStandAnim(arg0: number): number;
        setIsJumping(arg0: boolean): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        isPushable(): boolean;
        handleStartJump(arg0: number): void;
        setTamed(arg0: boolean): void;
        containerChanged(arg0: Internal.Container_): void;
        isStanding(): boolean;
        get ownerUUID(): Internal.UUID
        get bred(): boolean
        get eating(): boolean
        get stepHeight(): number
        get maxSpawnClusterSize(): number
        set bred(arg0: boolean)
        get saddled(): boolean
        get maxTemper(): number
        set temper(arg0: number)
        get saddleable(): boolean
        get wearingArmor(): boolean
        get controllingPassenger(): Internal.Entity
        get customJump(): number
        get jumping(): boolean
        get multipartEntity(): boolean
        get temper(): number
        get parts(): Internal.PartEntity<any>[]
        get ambientSoundInterval(): number
        set eating(arg0: boolean)
        get tamed(): boolean
        set ownerUUID(arg0: Internal.UUID_)
        set standing(arg0: boolean)
        set isJumping(arg0: boolean)
        get pushable(): boolean
        set tamed(arg0: boolean)
        get standing(): boolean
        "sprintCounter": number;
        readonly static "CHEST_SLOT_OFFSET": 499;
        readonly static "INVENTORY_SLOT_OFFSET": 500;
        "tailCounter": number;
        readonly static "INV_BASE_COUNT": 2;
        readonly static "INV_SLOT_SADDLE": 0;
        readonly static "EQUIPMENT_SLOT_OFFSET": 400;
        readonly static "INV_SLOT_ARMOR": 1;
    }
    type AbstractHorse_ = AbstractHorse;
    abstract class ChunkRenderDispatcher$RenderChunk$ChunkCompileTask implements Internal.Comparable<Internal.ChunkRenderDispatcher$RenderChunk$ChunkCompileTask> {
        constructor(arg0: Internal.ChunkRenderDispatcher$RenderChunk_, arg1: Internal.ChunkPos_, arg2: number, arg3: boolean)
        constructor(arg0: Internal.ChunkRenderDispatcher$RenderChunk_, arg1: number, arg2: boolean)
        compareTo(arg0: Internal.ChunkRenderDispatcher$RenderChunk$ChunkCompileTask_): number;
        getModelData(arg0: BlockPos_): Internal.IModelData;
        cancel(): void;
        doTask(arg0: Internal.ChunkBufferBuilderPack_): Internal.CompletableFuture<Internal.ChunkRenderDispatcher$ChunkTaskResult>;
        compareTo(arg0: any): number;
    }
    type ChunkRenderDispatcher$RenderChunk$ChunkCompileTask_ = ChunkRenderDispatcher$RenderChunk$ChunkCompileTask;
    class RegistryLoader$Bound extends Internal.Record {
        constructor(arg0: Internal.RegistryAccess$Writable_, arg1: Internal.RegistryLoader_)
        overrideRegistryFromResources(arg0: Internal.ResourceKey_<any>, arg1: Internal.Codec_<E>, arg2: Internal.DynamicOps_<Internal.JsonElement_>): Internal.DataResult<any>;
        hashCode(): number;
        toString(): string;
        access(): Internal.RegistryAccess$Writable;
        overrideElementFromResources(arg0: Internal.ResourceKey_<any>, arg1: Internal.Codec_<E>, arg2: Internal.ResourceKey_<E>, arg3: Internal.DynamicOps_<Internal.JsonElement_>): Internal.DataResult<Internal.Holder<E>>;
        equals(arg0: any): boolean;
        loader(): Internal.RegistryLoader;
    }
    type RegistryLoader$Bound_ = RegistryLoader$Bound;
    class Pillager extends Internal.AbstractIllager implements Internal.InventoryCarrier, Internal.CrossbowAttackMob {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getSlot(arg0: number): Internal.SlotAccess;
        performCrossbowAttack(arg0: Internal.LivingEntity_, arg1: number): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        onCrossbowAttackPerformed(): void;
        performRangedAttack(arg0: Internal.LivingEntity_, arg1: number): void;
        canFireProjectileWeapon(arg0: Internal.ProjectileWeaponItem_): boolean;
        isAlliedTo(arg0: Internal.Entity_): boolean;
        getInventory(): Internal.Container;
        shootCrossbowProjectile(arg0: Internal.LivingEntity_, arg1: Internal.ItemStack_, arg2: Internal.Projectile_, arg3: number): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        getMaxSpawnClusterSize(): number;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getCelebrateSound(): Internal.SoundEvent;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getProjectileShotVector(arg0: Internal.LivingEntity_, arg1: Vec3_, arg2: number): Internal.Vector3f;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setChargingCrossbow(arg0: boolean): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getWalkTargetValue(arg0: BlockPos_, arg1: Internal.LevelReader_): number;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        isChargingCrossbow(): boolean;
        getArmPose(): Internal.AbstractIllager$IllagerArmPose;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        shootCrossbowProjectile(arg0: Internal.LivingEntity_, arg1: Internal.LivingEntity_, arg2: Internal.Projectile_, arg3: number, arg4: number): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        applyRaidBuffs(arg0: number, arg1: boolean): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get inventory(): Internal.Container
        get maxSpawnClusterSize(): number
        get multipartEntity(): boolean
        get celebrateSound(): Internal.SoundEvent
        get parts(): Internal.PartEntity<any>[]
        set chargingCrossbow(arg0: boolean)
        get chargingCrossbow(): boolean
        get armPose(): Internal.AbstractIllager$IllagerArmPose
    }
    type Pillager_ = Pillager;
    class TagsUpdatedEvent$UpdateCause extends Internal.Enum<Internal.TagsUpdatedEvent$UpdateCause> {
        static values(): Internal.TagsUpdatedEvent$UpdateCause[];
        static valueOf(arg0: string): Internal.TagsUpdatedEvent$UpdateCause;
        readonly static "CLIENT_PACKET_RECEIVED": Internal.TagsUpdatedEvent$UpdateCause;
        readonly static "SERVER_DATA_LOAD": Internal.TagsUpdatedEvent$UpdateCause;
    }
    type TagsUpdatedEvent$UpdateCause_ = "client_packet_received" | TagsUpdatedEvent$UpdateCause | "server_data_load";
    class Direction$AxisDirection extends Internal.Enum<Internal.Direction$AxisDirection> {
        opposite(): this;
        static values(): Internal.Direction$AxisDirection[];
        toString(): string;
        getStep(): number;
        getName(): string;
        static valueOf(arg0: string): Internal.Direction$AxisDirection;
        get step(): number
        get name(): string
        readonly static "POSITIVE": Internal.Direction$AxisDirection;
        readonly static "NEGATIVE": Internal.Direction$AxisDirection;
    }
    type Direction$AxisDirection_ = "negative" | "positive" | Direction$AxisDirection;
    class ShulkerBullet extends Internal.Projectile {
        constructor(arg0: Internal.Level_, arg1: Internal.LivingEntity_, arg2: Internal.Entity_, arg3: Internal.Direction$Axis_)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        recreateFromPacket(arg0: Internal.ClientboundAddEntityPacket_): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        getBrightness(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        isPickable(): boolean;
        checkDespawn(): void;
        tick(): void;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        getSoundSource(): Internal.SoundSource;
        isMultipartEntity(): boolean;
        isOnFire(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRenderAtSqrDistance(arg0: number): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get brightness(): number
        get stepHeight(): number
        get pickable(): boolean
        get soundSource(): Internal.SoundSource
        get multipartEntity(): boolean
        get onFire(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type ShulkerBullet_ = ShulkerBullet;
    abstract class SimpleJsonResourceReloadListener extends Internal.SimplePreparableReloadListener<Internal.Map<ResourceLocation, Internal.JsonElement>> {
        constructor(arg0: any_, arg1: string)
        getName(): string;
        get name(): string
    }
    type SimpleJsonResourceReloadListener_ = SimpleJsonResourceReloadListener;
    interface ToFloatFunction <C> {
        apply(arg0: C): number;
    }
    type ToFloatFunction_<C> = ToFloatFunction<C> | ((arg0: C)=>number);
    class CombatTracker {
        constructor(arg0: Internal.LivingEntity_)
        getDeathMessage(): Internal.Component;
        getKillerId(): number;
        prepareForDamage(): void;
        recordDamage(arg0: Internal.DamageSource_, arg1: number, arg2: number): void;
        isTakingDamage(): boolean;
        getKiller(): Internal.LivingEntity;
        getLastEntry(): Internal.CombatEntry;
        recheckStatus(): void;
        isInCombat(): boolean;
        getMob(): Internal.LivingEntity;
        getCombatDuration(): number;
        get deathMessage(): Internal.Component
        get killerId(): number
        get takingDamage(): boolean
        get killer(): Internal.LivingEntity
        get lastEntry(): Internal.CombatEntry
        get inCombat(): boolean
        get mob(): Internal.LivingEntity
        get combatDuration(): number
        readonly static "RESET_COMBAT_STATUS_TIME": 300;
        readonly static "RESET_DAMAGE_STATUS_TIME": 100;
    }
    type CombatTracker_ = CombatTracker;
    interface Merchant {
        notifyTradeUpdated(arg0: Internal.ItemStack_): void;
        notifyTrade(arg0: Internal.MerchantOffer_): void;
        setTradingPlayer(arg0: Internal.Player_): void;
        isClientSide(): boolean;
        getTradingPlayer(): Internal.Player;
        canRestock(): boolean;
        getOffers(): Internal.MerchantOffers;
        openTradingScreen(arg0: Internal.Player_, arg1: Internal.Component_, arg2: number): void;
        getNotifyTradeSound(): Internal.SoundEvent;
        overrideOffers(arg0: Internal.MerchantOffers_): void;
        overrideXp(arg0: number): void;
        showProgressBar(): boolean;
        getVillagerXp(): number;
        set tradingPlayer(arg0: Internal.Player_)
        get clientSide(): boolean
        get tradingPlayer(): Internal.Player
        get offers(): Internal.MerchantOffers
        get notifyTradeSound(): Internal.SoundEvent
        get villagerXp(): number
    }
    type Merchant_ = Merchant;
    class MemoryStatus extends Internal.Enum<Internal.MemoryStatus> {
        static valueOf(arg0: string): Internal.MemoryStatus;
        static values(): Internal.MemoryStatus[];
        readonly static "VALUE_PRESENT": Internal.MemoryStatus;
        readonly static "VALUE_ABSENT": Internal.MemoryStatus;
        readonly static "REGISTERED": Internal.MemoryStatus;
    }
    type MemoryStatus_ = "value_present" | MemoryStatus | "value_absent" | "registered";
    class IdMapper <T> implements Internal.IdMap<T> {
        constructor()
        constructor(arg0: number)
        byId(arg0: number): T;
        size(): number;
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<T>;
        contains(arg0: number): boolean;
        byIdOrThrow(arg0: number): T;
        getId(arg0: T): number;
        iterator(): Internal.Iterator<T>;
        add(arg0: T): void;
        addMapping(arg0: T, arg1: number): void;
    }
    type IdMapper_<T> = IdMapper<T>;
    class ServerboundSetCreativeModeSlotPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: Internal.ItemStack_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getItem(): Internal.ItemStack;
        getSlotNum(): number;
        isSkippable(): boolean;
        get item(): Internal.ItemStack
        get slotNum(): number
        get skippable(): boolean
    }
    type ServerboundSetCreativeModeSlotPacket_ = ServerboundSetCreativeModeSlotPacket;
    class FluidState extends Internal.StateHolder<Internal.Fluid, Internal.FluidState> implements Internal.IForgeFluidState {
        constructor(arg0: Internal.Fluid_, arg1: Internal.ImmutableMap_<Internal.Property_<any>, Internal.Comparable_<any>>, arg2: Internal.MapCodec_<Internal.FluidState_>)
        getType(): Internal.Fluid;
        isSource(): boolean;
        getShape(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.VoxelShape;
        isEntityInside(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Entity_, arg3: number, arg4: Internal.HolderSet_<Internal.Fluid_>, arg5: boolean): boolean;
        getHeight(arg0: Internal.BlockGetter_, arg1: BlockPos_): number;
        isEmpty(): boolean;
        createLegacyBlock(): Internal.BlockState;
        getFlow(arg0: Internal.BlockGetter_, arg1: BlockPos_): Vec3;
        holder(): Internal.Holder<Internal.Fluid>;
        getTags(): Internal.Stream<Internal.TagKey<Internal.Fluid>>;
        isSourceOfType(arg0: Internal.Fluid_): boolean;
        getAmount(): number;
        isRandomlyTicking(): boolean;
        getOwnHeight(): number;
        animateTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Random_): void;
        is(arg0: Internal.HolderSet_<Internal.Fluid_>): boolean;
        tick(arg0: Internal.Level_, arg1: BlockPos_): void;
        getDripParticle(): Internal.ParticleOptions;
        shouldRenderBackwardUpFace(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        getExplosionResistance(): number;
        is(arg0: Internal.Fluid_): boolean;
        canBeReplacedWith(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Fluid_, arg3: Internal.Direction_): boolean;
        randomTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Random_): void;
        getExplosionResistance(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Explosion_): number;
        is(arg0: Internal.TagKey_<Internal.Fluid_>): boolean;
        get type(): Internal.Fluid
        get source(): boolean
        get empty(): boolean
        get tags(): Internal.Stream<Internal.TagKey<Internal.Fluid>>
        get amount(): number
        get randomlyTicking(): boolean
        get ownHeight(): number
        get dripParticle(): Internal.ParticleOptions
        get explosionResistance(): number
        readonly static "AMOUNT_FULL": 8;
        readonly static "AMOUNT_MAX": 9;
        readonly static "CODEC": any;
    }
    type FluidState_ = FluidState;
    class ChunkAccess$TicksToSave extends Internal.Record {
        constructor(blocks: Internal.SerializableTickContainer_<Internal.Block_>, fluids: Internal.SerializableTickContainer_<Internal.Fluid_>)
        fluids(): Internal.SerializableTickContainer<Internal.Fluid>;
        hashCode(): number;
        toString(): string;
        blocks(): Internal.SerializableTickContainer<Internal.Block>;
        equals(arg0: any): boolean;
    }
    type ChunkAccess$TicksToSave_ = ChunkAccess$TicksToSave;
    class Creeper extends Internal.Monster implements Internal.PowerableMob {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        thunderHit(arg0: Internal.ServerLevel_, arg1: Internal.LightningBolt_): void;
        getStepHeight(): number;
        getSwellDir(): number;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        setTarget(arg0: Internal.LivingEntity_): void;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setSwellDir(arg0: number): void;
        getMaxFallDistance(): number;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        ignite(): void;
        increaseDroppedSkulls(): void;
        isPowered(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        isIgnited(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getSwelling(arg0: number): number;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        canDropMobsSkull(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get swellDir(): number
        set target(arg0: Internal.LivingEntity_)
        get multipartEntity(): boolean
        set swellDir(arg0: number)
        get maxFallDistance(): number
        get parts(): Internal.PartEntity<any>[]
        get powered(): boolean
        get ignited(): boolean
    }
    type Creeper_ = Creeper;
    interface Int2CharFunction extends it.unimi.dsi.fastutil.Function<number, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: string): string;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Int2IntFunction;
        remove(arg0: number): string;
        getOrDefault(arg0: any, arg1: any): any;
        composeReference(arg0: Internal.Reference2IntFunction_<any>): Internal.Reference2CharFunction<T>;
        containsKey(arg0: number): boolean;
        defaultReturnValue(): string;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2CharFunction;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Int2ShortFunction;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2CharFunction;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2CharFunction;
        containsKey(arg0: any): boolean;
        getOrDefault(arg0: number, arg1: string): string;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        defaultReturnValue(arg0: string): void;
        applyAsInt(arg0: number): number;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Int2FloatFunction;
        put(arg0: number, arg1: string): string;
        get(arg0: any): string;
        apply(arg0: number): string;
        put(arg0: any, arg1: any): any;
        andThenChar(arg0: Internal.Char2CharFunction_): this;
        composeInt(arg0: Internal.Int2IntFunction_): this;
        andThenObject(arg0: Internal.Char2ObjectFunction_<any>): Internal.Int2ObjectFunction<T>;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2CharFunction;
        get(arg0: number): string;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        put(arg0: number, arg1: string): string;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Int2ByteFunction;
        andThenReference(arg0: Internal.Char2ReferenceFunction_<any>): Internal.Int2ReferenceFunction<T>;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Int2DoubleFunction;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2CharFunction;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2CharFunction;
        size(): number;
        clear(): void;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Int2LongFunction;
        composeObject(arg0: Internal.Object2IntFunction_<any>): Internal.Object2CharFunction<T>;
        remove(arg0: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, string>;
    }
    type Int2CharFunction_ = Int2CharFunction | ((arg0: number)=>string);
    class SoundSource extends Internal.Enum<Internal.SoundSource> {
        static valueOf(arg0: string): Internal.SoundSource;
        static values(): Internal.SoundSource[];
        getName(): string;
        get name(): string
        readonly static "HOSTILE": Internal.SoundSource;
        readonly static "MUSIC": Internal.SoundSource;
        readonly static "RECORDS": Internal.SoundSource;
        readonly static "NEUTRAL": Internal.SoundSource;
        readonly static "MASTER": Internal.SoundSource;
        readonly static "BLOCKS": Internal.SoundSource;
        readonly static "PLAYERS": Internal.SoundSource;
        readonly static "WEATHER": Internal.SoundSource;
        readonly static "AMBIENT": Internal.SoundSource;
        readonly static "VOICE": Internal.SoundSource;
    }
    type SoundSource_ = SoundSource | "records" | "weather" | "neutral" | "music" | "players" | "blocks" | "ambient" | "master" | "voice" | "hostile";
    abstract class Enchantment extends Internal.ForgeRegistryEntry<Internal.Enchantment> implements Internal.IForgeEnchantment {
        getFullname(arg0: number): Internal.Component;
        getDamageProtection(arg0: number, arg1: Internal.DamageSource_): number;
        getRarity(): Internal.Enchantment$Rarity;
        isCompatibleWith(arg0: Internal.Enchantment_): boolean;
        isTradeable(): boolean;
        getMaxLevel(): number;
        doPostAttack(arg0: Internal.LivingEntity_, arg1: Internal.Entity_, arg2: number): void;
        isTreasureOnly(): boolean;
        getMinLevel(): number;
        getSlotItems(arg0: Internal.LivingEntity_): Internal.Map<EquipmentSlot, Internal.ItemStack>;
        getDamageBonus(arg0: number, arg1: Internal.MobType_): number;
        getMaxCost(arg0: number): number;
        isCurse(): boolean;
        isDiscoverable(): boolean;
        getDamageBonus(arg0: number, arg1: Internal.MobType_, arg2: Internal.ItemStack_): number;
        getMinCost(arg0: number): number;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_): boolean;
        static byId(arg0: number): Internal.Enchantment;
        getDescriptionId(): string;
        doPostHurt(arg0: Internal.LivingEntity_, arg1: Internal.Entity_, arg2: number): void;
        canEnchant(arg0: Internal.ItemStack_): boolean;
        isAllowedOnBooks(): boolean;
        get rarity(): Internal.Enchantment$Rarity
        get tradeable(): boolean
        get maxLevel(): number
        get treasureOnly(): boolean
        get minLevel(): number
        get curse(): boolean
        get discoverable(): boolean
        get descriptionId(): string
        get allowedOnBooks(): boolean
        readonly "category": Internal.EnchantmentCategory;
    }
    type Enchantment_ = Special.Enchantment | Enchantment;
    class Frustum {
        constructor(arg0: Internal.Frustum_)
        constructor(arg0: Internal.Matrix4f_, arg1: Internal.Matrix4f_)
        prepare(arg0: number, arg1: number, arg2: number): void;
        isVisible(arg0: Internal.AABB_): boolean;
        offsetToFullyIncludeCameraCube(arg0: number): this;
        readonly static "OFFSET_STEP": 4;
    }
    type Frustum_ = Frustum;
    class BlockRightClickEventJS extends Internal.PlayerEventJS {
        constructor(player: Internal.Player_, hand: Hand_, pos: BlockPos_, direction: Internal.Direction_)
        getFacing(): Internal.Direction;
        getEntity(): Internal.EntityJS;
        canCancel(): boolean;
        getHand(): Hand;
        getItem(): Internal.ItemStackJS;
        getBlock(): Internal.BlockContainerJS;
        get facing(): Internal.Direction
        get entity(): Internal.EntityJS
        get hand(): Hand
        get item(): Internal.ItemStackJS
        get block(): Internal.BlockContainerJS
    }
    type BlockRightClickEventJS_ = BlockRightClickEventJS;
    abstract class AgeableMob extends Internal.PathfinderMob {
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        ageUp(arg0: number, arg1: boolean): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setBaby(arg0: boolean): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        canBreed(): boolean;
        setAge(arg0: number): void;
        ageUp(arg0: number): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isBaby(): boolean;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): this;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        getAge(): number;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        set baby(arg0: boolean)
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        set age(arg0: number)
        get baby(): boolean
        get age(): number
        readonly static "BABY_START_AGE": -24000;
    }
    type AgeableMob_ = AgeableMob;
    class ClientLevel extends Internal.Level {
        constructor(arg0: Internal.ClientPacketListener_, arg1: any_, arg2: Internal.ResourceKey_<Internal.Level_>, arg3: Internal.Holder_<Internal.DimensionType_>, arg4: number, arg5: number, arg6: Internal.Supplier_<Internal.ProfilerFiller_>, arg7: Internal.LevelRenderer_, arg8: boolean, arg9: number)
        tickNonPassenger(arg0: Internal.Entity_): void;
        effects(): Internal.DimensionSpecialEffects;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_): Internal.Player;
        getShade(arg0: Internal.Direction_, arg1: boolean): number;
        dayTime(): number;
        playSound(arg0: Internal.Player_, arg1: Internal.Entity_, arg2: Internal.SoundEvent_, arg3: Internal.SoundSource_, arg4: number, arg5: number): void;
        isUnobstructed(arg0: Internal.Entity_, arg1: Internal.VoxelShape_): boolean;
        addAlwaysVisibleParticle(arg0: Internal.ParticleOptions_, arg1: boolean, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        getMaxSection(): number;
        gameEvent(arg0: Internal.GameEvent_, arg1: Internal.Entity_): void;
        getLevelData(): Internal.LevelData;
        getBrightness(arg0: Internal.LightLayer_, arg1: BlockPos_): number;
        setDefaultSpawnPos(arg0: BlockPos_, arg1: number): void;
        getSectionYFromSectionIndex(arg0: number): number;
        unload(arg0: Internal.LevelChunk_): void;
        setKnownState(arg0: BlockPos_, arg1: Internal.BlockState_): void;
        tick(arg0: Internal.BooleanSupplier_): void;
        gatherChunkSourceStats(): string;
        isEmptyBlock(arg0: BlockPos_): boolean;
        getMaxLocalRawBrightness(arg0: BlockPos_, arg1: number): number;
        shouldTickDeath(arg0: Internal.Entity_): boolean;
        getBlockCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        getTimeOfDay(arg0: number): number;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getHeightmapPos(arg0: Internal.Heightmap$Types_, arg1: BlockPos_): BlockPos;
        setLightReady(arg0: number, arg1: number): void;
        blockUpdated(arg0: BlockPos_, arg1: Internal.Block_): void;
        getEntities(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.Entity>;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_): Internal.List<T>;
        getBlockTicks(): Internal.LevelTickAccess<Internal.Block>;
        getEntityCount(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        disconnect(): void;
        getBrightness(arg0: BlockPos_): number;
        getNearestEntity(arg0: Internal.List_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number): T;
        setDayTime(arg0: number): void;
        getMinBuildHeight(): number;
        clearTintCaches(): void;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Fluid_, arg2: number): void;
        addDestroyBlockEffect(arg0: BlockPos_, arg1: Internal.BlockState_): void;
        setGameTime(arg0: number): void;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): Internal.Player;
        playSound(arg0: Internal.Player_, arg1: number, arg2: number, arg3: number, arg4: Internal.SoundEvent_, arg5: Internal.SoundSource_, arg6: number, arg7: number): void;
        calculateBlockTint(arg0: BlockPos_, arg1: Internal.ColorResolver_): number;
        queueLightUpdate(arg0: Internal.Runnable_): void;
        hasChunkAt(arg0: number, arg1: number): boolean;
        getFluidTicks(): Internal.LevelTickAccess<Internal.Fluid>;
        getSectionIndex(arg0: number): number;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: number, arg2: number, arg3: number): Internal.Player;
        getMaxBuildHeight(): number;
        setMapData(arg0: string, arg1: Internal.MapItemSavedData_): void;
        hasChunksAt(arg0: BlockPos_, arg1: BlockPos_): boolean;
        destroyBlock(arg0: BlockPos_, arg1: boolean): boolean;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Block_, arg2: number): void;
        addFreshEntity(arg0: Internal.Entity_): boolean;
        putNonPlayerEntity(arg0: number, arg1: Internal.Entity_): void;
        getCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        getSkyFlashTime(): number;
        destroyBlock(arg0: BlockPos_, arg1: boolean, arg2: Internal.Entity_): boolean;
        entitiesForRendering(): Internal.Iterable<Internal.Entity>;
        getHeight(): number;
        animateTick(arg0: number, arg1: number, arg2: number): void;
        getChunk(arg0: BlockPos_): Internal.ChunkAccess;
        getSkyDarken(arg0: number): number;
        gameEvent(arg0: Internal.GameEvent_, arg1: BlockPos_): void;
        toString(): string;
        getMaxLocalRawBrightness(arg0: BlockPos_): number;
        isUnobstructed(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.CollisionContext_): boolean;
        players(): Internal.List<Internal.AbstractClientPlayer>;
        setSectionDirtyWithNeighbors(arg0: number, arg1: number, arg2: number): void;
        doAnimateTick(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Random_, arg5: Internal.Block_, arg6: Internal.BlockPos$MutableBlockPos_): void;
        hasChunkAt(arg0: BlockPos_): boolean;
        getBiome(arg0: BlockPos_): Internal.Holder<Internal.Biome>;
        addAlwaysVisibleParticle(arg0: Internal.ParticleOptions_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
        asKJS(): Internal.LevelJS;
        getSharedSpawnAngle(): number;
        createFireworks(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.CompoundTag_): void;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Block_, arg2: number, arg3: Internal.TickPriority_): void;
        hasNearbyAlivePlayer(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        tickEntities(): void;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: number, arg3: number, arg4: number): Internal.Player;
        getBlockTint(arg0: BlockPos_, arg1: Internal.ColorResolver_): number;
        getMinSection(): number;
        findFreePosition(arg0: Internal.Entity_, arg1: Internal.VoxelShape_, arg2: Vec3_, arg3: number, arg4: number, arg5: number): Internal.Optional<Vec3>;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        getChunkSource(): Internal.ClientChunkCache;
        getNearestPlayer(arg0: Internal.Entity_, arg1: number): Internal.Player;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getBlockStatesIfLoaded(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        playLocalSound(arg0: BlockPos_, arg1: Internal.SoundEvent_, arg2: Internal.SoundSource_, arg3: number, arg4: number, arg5: boolean): void;
        setScoreboard(arg0: Internal.Scoreboard_): void;
        getPartEntities(): Internal.Collection<Internal.PartEntity<any>>;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        sendPacketToServer(arg0: Internal.Packet_<any>): void;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        getRawBrightness(arg0: BlockPos_, arg1: number): number;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        getSharedSpawnPos(): BlockPos;
        addParticle(arg0: Internal.ParticleOptions_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
        getDifficulty(): Internal.Difficulty;
        canSeeSky(arg0: BlockPos_): boolean;
        addParticle(arg0: Internal.ParticleOptions_, arg1: boolean, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        getMoonPhase(): number;
        isUnobstructed(arg0: Internal.Entity_): boolean;
        getCloudColor(arg0: number): Vec3;
        getUncachedNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        playLocalSound(arg0: number, arg1: number, arg2: number, arg3: Internal.SoundEvent_, arg4: Internal.SoundSource_, arg5: number, arg6: number, arg7: boolean): void;
        getPlayerByUUID(arg0: Internal.UUID_): Internal.Player;
        canSeeSkyFromBelowWater(arg0: BlockPos_): boolean;
        getSectionsCount(): number;
        getFreeMapId(): number;
        getSectionIndexFromSectionY(arg0: number): number;
        getNearbyPlayers(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: Internal.AABB_): Internal.List<Internal.Player>;
        levelEvent(arg0: Internal.Player_, arg1: number, arg2: BlockPos_, arg3: number): void;
        fillReportDetails(arg0: Internal.CrashReport_): Internal.CrashReportCategory;
        noCollision(arg0: Internal.Entity_): boolean;
        getChunk(arg0: number, arg1: number, arg2: Internal.ChunkStatus_): Internal.ChunkAccess;
        setSkyFlashTime(arg0: number): void;
        setBlocksDirty(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: Internal.BlockState_): void;
        hasChunk(arg0: number, arg1: number): boolean;
        getNearbyEntities(arg0: Internal.Class_<T>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: Internal.AABB_): Internal.List<T>;
        getMapData(arg0: string): Internal.MapItemSavedData;
        destroyBlockProgress(arg0: number, arg1: BlockPos_, arg2: number): void;
        getSkyColor(arg0: Vec3_, arg1: number): Vec3;
        getMoonBrightness(): number;
        noCollision(arg0: Internal.AABB_): boolean;
        isWaterAt(arg0: BlockPos_): boolean;
        setServerSimulationDistance(arg0: number): void;
        isLightUpdateQueueEmpty(): boolean;
        getDirectSignal(arg0: BlockPos_, arg1: Internal.Direction_): number;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        getEntityCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.VoxelShape>;
        collidesWithSuffocatingBlock(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        noCollision(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        isOutsideBuildHeight(arg0: number): boolean;
        gameEvent(arg0: Internal.Entity_, arg1: Internal.GameEvent_, arg2: Internal.Entity_): void;
        removeEntity(arg0: number, arg1: Internal.Entity$RemovalReason_): void;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Fluid_, arg2: number, arg3: Internal.TickPriority_): void;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Predicate_<Internal.Entity_>): Internal.Player;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getNearestEntity(arg0: Internal.Class_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number, arg6: Internal.AABB_): T;
        globalLevelEvent(arg0: number, arg1: BlockPos_, arg2: number): void;
        registryAccess(): Internal.RegistryAccess;
        pollLightUpdates(): void;
        getServerSimulationDistance(): number;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_, arg2: Internal.Predicate_<any>): Internal.List<T>;
        onChunkLoaded(arg0: Internal.ChunkPos_): void;
        addPlayer(arg0: number, arg1: Internal.AbstractClientPlayer_): void;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        sendBlockUpdated(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: Internal.BlockState_, arg3: number): void;
        levelEvent(arg0: number, arg1: BlockPos_, arg2: number): void;
        getScoreboard(): Internal.Scoreboard;
        getRecipeManager(): Internal.RecipeManager;
        gameEvent(arg0: Internal.Entity_, arg1: Internal.GameEvent_, arg2: BlockPos_): void;
        containsAnyLiquid(arg0: Internal.AABB_): boolean;
        getEntity(arg0: number): Internal.Entity;
        getMaxLightLevel(): number;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
        getStarBrightness(arg0: number): number;
        get maxSection(): number
        get levelData(): Internal.LevelData
        get blockTicks(): Internal.LevelTickAccess<Internal.Block>
        get entityCount(): number
        set dayTime(arg0: number)
        get minBuildHeight(): number
        set gameTime(arg0: number)
        get fluidTicks(): Internal.LevelTickAccess<Internal.Fluid>
        get maxBuildHeight(): number
        get skyFlashTime(): number
        get height(): number
        get sharedSpawnAngle(): number
        get minSection(): number
        get chunkSource(): Internal.ClientChunkCache
        set scoreboard(arg0: Internal.Scoreboard_)
        get partEntities(): Internal.Collection<Internal.PartEntity<any>>
        get sharedSpawnPos(): BlockPos
        get difficulty(): Internal.Difficulty
        get moonPhase(): number
        get sectionsCount(): number
        get freeMapId(): number
        set skyFlashTime(arg0: number)
        get moonBrightness(): number
        set serverSimulationDistance(arg0: number)
        get lightUpdateQueueEmpty(): boolean
        get serverSimulationDistance(): number
        get scoreboard(): Internal.Scoreboard
        get recipeManager(): Internal.RecipeManager
        get maxLightLevel(): number
    }
    type ClientLevel_ = ClientLevel;
    interface IRegistryDelegate <T> extends Internal.Supplier<T> {
        type(): Internal.Class<T>;
        name(): ResourceLocation;
        get(): T;
    }
    type IRegistryDelegate_<T> = IRegistryDelegate<T>;
    abstract class RuleTest {
        constructor()
        test(arg0: Internal.BlockState_, arg1: Internal.Random_): boolean;
        readonly static "CODEC": any;
    }
    type RuleTest_ = RuleTest;
    class PermissionNode <T> {
        constructor(arg0: string, arg1: string, arg2: Internal.PermissionType_<T>, arg3: Internal.PermissionNode$PermissionResolver_<T>, ...arg4: any_<any>[])
        constructor(arg0: ResourceLocation_, arg1: Internal.PermissionType_<T>, arg2: Internal.PermissionNode$PermissionResolver_<T>, ...arg3: any_<any>[])
        hashCode(): number;
        getDefaultResolver(): Internal.PermissionNode$PermissionResolver<T>;
        setInformation(arg0: Internal.Component_, arg1: Internal.Component_): Internal.PermissionNode<any>;
        getReadableName(): Internal.Component;
        getDynamics(): any[];
        getType(): Internal.PermissionType<T>;
        equals(arg0: any): boolean;
        getNodeName(): string;
        getDescription(): Internal.Component;
        get defaultResolver(): Internal.PermissionNode$PermissionResolver<T>
        get readableName(): Internal.Component
        get dynamics(): any[]
        get type(): Internal.PermissionType<T>
        get nodeName(): string
        get description(): Internal.Component
    }
    type PermissionNode_<T> = PermissionNode<T>;
    class DeserializationContext {
        constructor(arg0: ResourceLocation_, arg1: Internal.PredicateManager_)
        deserializeConditions(arg0: Internal.JsonArray_, arg1: string, arg2: Internal.LootContextParamSet_): Internal.LootItemCondition[];
        getAdvancementId(): ResourceLocation;
        get advancementId(): ResourceLocation
    }
    type DeserializationContext_ = DeserializationContext;
    class ClientChatEvent extends Internal.Event {
        constructor()
        constructor(arg0: string)
        isCancelable(): boolean;
        getMessage(): string;
        getListenerList(): Internal.ListenerList;
        setMessage(arg0: string): void;
        getOriginalMessage(): string;
        get cancelable(): boolean
        get message(): string
        get listenerList(): Internal.ListenerList
        set message(arg0: string)
        get originalMessage(): string
    }
    type ClientChatEvent_ = ClientChatEvent;
    class MapItemSavedData$HoldingPlayer {
        readonly "player": Internal.Player;
        "step": number;
    }
    type MapItemSavedData$HoldingPlayer_ = MapItemSavedData$HoldingPlayer;
    abstract class BlockBehaviour extends Internal.ForgeRegistryEntry<Internal.Block> implements Internal.BlockKJS {
        constructor(arg0: Internal.BlockBehaviour$Properties_)
        getOcclusionShape(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): Internal.VoxelShape;
        setFrictionKJS(arg0: number): void;
        getSignal(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        setExplosionResistanceKJS(arg0: number): void;
        neighborChanged(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Block_, arg4: BlockPos_, arg5: boolean): void;
        getBlockSupportShape(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): Internal.VoxelShape;
        getVisualShape(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.CollisionContext_): Internal.VoxelShape;
        isCollisionShapeFullBlock(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        setMaterialKJS(arg0: Internal.Material_): void;
        getBlockStatesKJS(): Internal.List<Internal.BlockState>;
        getMenuProvider(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_): Internal.MenuProvider;
        setIsRandomlyTickingKJS(arg0: boolean): void;
        updateIndirectNeighbourShapes(arg0: Internal.BlockState_, arg1: Internal.LevelAccessor_, arg2: BlockPos_, arg3: number, arg4: number): void;
        use(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: Hand_, arg5: Internal.BlockHitResult_): Internal.InteractionResult;
        canSurvive(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): boolean;
        getPistonPushReaction(arg0: Internal.BlockState_): Internal.PushReaction;
        getShadeBrightness(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): number;
        defaultMaterialColor(): Internal.MaterialColor;
        getCollisionShape(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.CollisionContext_): Internal.VoxelShape;
        asItem(): Internal.Item;
        triggerEvent(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: number, arg4: number): boolean;
        getTypeData(): Internal.CompoundTag;
        spawnAfterBreak(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.ItemStack_): void;
        getRenderShape(arg0: Internal.BlockState_): Internal.RenderShape;
        getLightBlock(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): number;
        skipRendering(arg0: Internal.BlockState_, arg1: Internal.BlockState_, arg2: Internal.Direction_): boolean;
        getDirectSignal(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        getMaxHorizontalOffset(): number;
        getDestroyProgress(arg0: Internal.BlockState_, arg1: Internal.Player_, arg2: Internal.BlockGetter_, arg3: BlockPos_): number;
        setHasCollisionKJS(arg0: boolean): void;
        getSeed(arg0: Internal.BlockState_, arg1: BlockPos_): number;
        defaultDestroyTime(): number;
        setSpeedFactorKJS(arg0: number): void;
        getMaxVerticalOffset(): number;
        updateShape(arg0: Internal.BlockState_, arg1: Internal.Direction_, arg2: Internal.BlockState_, arg3: Internal.LevelAccessor_, arg4: BlockPos_, arg5: BlockPos_): Internal.BlockState;
        tick(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.Random_): void;
        randomTick(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.Random_): void;
        rotate(arg0: Internal.BlockState_, arg1: Internal.Rotation_): Internal.BlockState;
        useShapeForLightOcclusion(arg0: Internal.BlockState_): boolean;
        entityInside(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Entity_): void;
        canBeReplaced(arg0: Internal.BlockState_, arg1: Internal.Fluid_): boolean;
        mirror(arg0: Internal.BlockState_, arg1: Internal.Mirror_): Internal.BlockState;
        setJumpFactorKJS(arg0: number): void;
        getBlockBuilderKJS(): Internal.BlockBuilder;
        canBeReplaced(arg0: Internal.BlockState_, arg1: Internal.BlockPlaceContext_): boolean;
        isSignalSource(arg0: Internal.BlockState_): boolean;
        getDrops(arg0: Internal.BlockState_, arg1: Internal.LootContext$Builder_): Internal.List<Internal.ItemStack>;
        setSoundTypeKJS(arg0: Internal.SoundType_): void;
        attack(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_): void;
        getOffsetType(): Internal.BlockBehaviour$OffsetType;
        getShape(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.CollisionContext_): Internal.VoxelShape;
        setBlockBuilderKJS(b: Internal.BlockBuilder_): void;
        onProjectileHit(arg0: Internal.Level_, arg1: Internal.BlockState_, arg2: Internal.BlockHitResult_, arg3: Internal.Projectile_): void;
        getLootTable(): ResourceLocation;
        getInteractionShape(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): Internal.VoxelShape;
        onPlace(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: boolean): void;
        isPathfindable(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.PathComputationType_): boolean;
        hasAnalogOutputSignal(arg0: Internal.BlockState_): boolean;
        getFluidState(arg0: Internal.BlockState_): Internal.FluidState;
        onRemove(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: boolean): void;
        getAnalogOutputSignal(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_): number;
        set frictionKJS(arg0: number)
        set explosionResistanceKJS(arg0: number)
        set materialKJS(arg0: Internal.Material_)
        get blockStatesKJS(): Internal.List<Internal.BlockState>
        set isRandomlyTickingKJS(arg0: boolean)
        get typeData(): Internal.CompoundTag
        get maxHorizontalOffset(): number
        set hasCollisionKJS(arg0: boolean)
        set speedFactorKJS(arg0: number)
        get maxVerticalOffset(): number
        set jumpFactorKJS(arg0: number)
        get blockBuilderKJS(): Internal.BlockBuilder
        set soundTypeKJS(arg0: Internal.SoundType_)
        get offsetType(): Internal.BlockBehaviour$OffsetType
        set blockBuilderKJS(b: Internal.BlockBuilder_)
        get lootTable(): ResourceLocation
        readonly "properties": Internal.BlockBehaviour$Properties;
    }
    type BlockBehaviour_ = BlockBehaviour;
    interface PositionSource {
        getPosition(arg0: Internal.Level_): Internal.Optional<BlockPos>;
        getType(): Internal.PositionSourceType<any>;
        get type(): Internal.PositionSourceType<any>
        readonly static "CODEC": any;
    }
    type PositionSource_ = PositionSource;
    interface OwnableEntity {
        getOwnerUUID(): Internal.UUID;
        getOwner(): Internal.Entity;
        get ownerUUID(): Internal.UUID
        get owner(): Internal.Entity
    }
    type OwnableEntity_ = OwnableEntity;
    class VillagerProfessionBuilder extends Internal.BuilderBase<Internal.VillagerProfession> {
        constructor(i: ResourceLocation_)
        workSound(t: Internal.SoundEvent_): this;
        poiType(t: Internal.PoiType_): this;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.VillagerProfession>;
        createObject(): any;
        requestedItems(t: Internal.Item_[]): this;
        secondaryPoi(t: Internal.Block_[]): this;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.VillagerProfession>
    }
    type VillagerProfessionBuilder_ = VillagerProfessionBuilder;
    abstract class VarHandle implements Internal.Constable {
        getAndBitwiseAnd(...arg0: any[]): any;
        weakCompareAndSet(...arg0: any[]): boolean;
        getAndBitwiseXor(...arg0: any[]): any;
        compareAndSet(...arg0: any[]): boolean;
        accessModeType(arg0: Internal.VarHandle$AccessMode_): Internal.MethodType;
        set(...arg0: any[]): void;
        compareAndExchangeAcquire(...arg0: any[]): any;
        getAndSet(...arg0: any[]): any;
        getAndBitwiseAndRelease(...arg0: any[]): any;
        hasInvokeExactBehavior(): boolean;
        getAndBitwiseXorRelease(...arg0: any[]): any;
        weakCompareAndSetPlain(...arg0: any[]): boolean;
        getAndBitwiseXorAcquire(...arg0: any[]): any;
        setVolatile(...arg0: any[]): void;
        getAndAddAcquire(...arg0: any[]): any;
        getAndAdd(...arg0: any[]): any;
        getAndBitwiseOr(...arg0: any[]): any;
        getAndAddRelease(...arg0: any[]): any;
        getAndBitwiseOrRelease(...arg0: any[]): any;
        getAndBitwiseOrAcquire(...arg0: any[]): any;
        static releaseFence(): void;
        static fullFence(): void;
        coordinateTypes(): Internal.List<Internal.Class<any>>;
        static storeStoreFence(): void;
        getAcquire(...arg0: any[]): any;
        getOpaque(...arg0: any[]): any;
        toMethodHandle(arg0: Internal.VarHandle$AccessMode_): Internal.MethodHandle;
        toString(): string;
        setOpaque(...arg0: any[]): void;
        compareAndExchange(...arg0: any[]): any;
        compareAndExchangeRelease(...arg0: any[]): any;
        getVolatile(...arg0: any[]): any;
        getAndBitwiseAndAcquire(...arg0: any[]): any;
        varType(): Internal.Class<any>;
        withInvokeBehavior(): this;
        get(...arg0: any[]): any;
        getAndSetAcquire(...arg0: any[]): any;
        describeConstable(): Internal.Optional<Internal.VarHandle$VarHandleDesc>;
        static acquireFence(): void;
        getAndSetRelease(...arg0: any[]): any;
        weakCompareAndSetRelease(...arg0: any[]): boolean;
        weakCompareAndSetAcquire(...arg0: any[]): boolean;
        withInvokeExactBehavior(): this;
        static loadLoadFence(): void;
        isAccessModeSupported(arg0: Internal.VarHandle$AccessMode_): boolean;
        setRelease(...arg0: any[]): void;
        set volatile(...arg0: any[])
        set opaque(...arg0: any[])
        set release(...arg0: any[])
    }
    type VarHandle_ = VarHandle;
    interface DoubleStream$DoubleMapMultiConsumer {
        accept(arg0: number, arg1: Internal.DoubleConsumer_): void;
    }
    type DoubleStream$DoubleMapMultiConsumer_ = ((arg0: number, arg1: Internal.DoubleConsumer)=>void) | DoubleStream$DoubleMapMultiConsumer;
    abstract class AbstractGolem extends Internal.PathfinderMob {
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getAmbientSoundInterval(): number;
        deserializeNBT(arg0: Internal.Tag_): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        removeWhenFarAway(arg0: number): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get ambientSoundInterval(): number
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type AbstractGolem_ = AbstractGolem;
    class EntityAnchorArgument$Anchor extends Internal.Enum<Internal.EntityAnchorArgument$Anchor> {
        static getByName(arg0: string): Internal.EntityAnchorArgument$Anchor;
        static values(): Internal.EntityAnchorArgument$Anchor[];
        apply(arg0: Internal.CommandSourceStack_): Vec3;
        apply(arg0: Internal.Entity_): Vec3;
        static valueOf(arg0: string): Internal.EntityAnchorArgument$Anchor;
        readonly static "FEET": Internal.EntityAnchorArgument$Anchor;
        readonly static "EYES": Internal.EntityAnchorArgument$Anchor;
    }
    type EntityAnchorArgument$Anchor_ = "eyes" | "feet" | EntityAnchorArgument$Anchor;
    interface IForgePackResources {
        isHidden(): boolean;
        get hidden(): boolean
    }
    type IForgePackResources_ = IForgePackResources;
    class BindingsEvent {
        constructor(m: Internal.ScriptManager_, d: Internal.SharedContextData_)
        addFunction(name: string, callback: Internal.DynamicFunction$Callback_): void;
        getType(): Internal.ScriptType;
        addFunction(name: string, function_: Internal.BaseFunction_): void;
        add(name: string, value: any): void;
        addFunction(name: string, callback: Internal.DynamicFunction$Callback_, ...types: Internal.Class_<any>[]): void;
        get type(): Internal.ScriptType
        readonly "contextData": Internal.SharedContextData;
        readonly "manager": Internal.ScriptManager;
        readonly "type": Internal.ScriptType;
        readonly static "EVENT": any;
    }
    type BindingsEvent_ = BindingsEvent;
    interface GuiEventListener {
        charTyped(arg0: string, arg1: number): boolean;
        mouseDragged(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): boolean;
        mouseReleased(arg0: number, arg1: number, arg2: number): boolean;
        changeFocus(arg0: boolean): boolean;
        mouseClicked(arg0: number, arg1: number, arg2: number): boolean;
        mouseScrolled(arg0: number, arg1: number, arg2: number): boolean;
        keyReleased(arg0: number, arg1: number, arg2: number): boolean;
        mouseMoved(arg0: number, arg1: number): void;
        isMouseOver(arg0: number, arg1: number): boolean;
        keyPressed(arg0: number, arg1: number, arg2: number): boolean;
        readonly static "DOUBLE_CLICK_THRESHOLD_MS": 250;
    }
    type GuiEventListener_ = GuiEventListener;
    interface DoubleToLongFunction {
        applyAsLong(arg0: number): number;
    }
    type DoubleToLongFunction_ = DoubleToLongFunction | ((arg0: number)=>number);
    interface LevelTimeAccess extends Internal.LevelReader {
        getBlockTint(arg0: BlockPos_, arg1: Internal.ColorResolver_): number;
        getMinSection(): number;
        dayTime(): number;
        findFreePosition(arg0: Internal.Entity_, arg1: Internal.VoxelShape_, arg2: Vec3_, arg3: number, arg4: number, arg5: number): Internal.Optional<Vec3>;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        isUnobstructed(arg0: Internal.Entity_, arg1: Internal.VoxelShape_): boolean;
        getMaxSection(): number;
        getBrightness(arg0: Internal.LightLayer_, arg1: BlockPos_): number;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getBlockStatesIfLoaded(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getSectionYFromSectionIndex(arg0: number): number;
        isEmptyBlock(arg0: BlockPos_): boolean;
        getMaxLocalRawBrightness(arg0: BlockPos_, arg1: number): number;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        getBlockCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        getRawBrightness(arg0: BlockPos_, arg1: number): number;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        getTimeOfDay(arg0: number): number;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getHeightmapPos(arg0: Internal.Heightmap$Types_, arg1: BlockPos_): BlockPos;
        canSeeSky(arg0: BlockPos_): boolean;
        getMoonPhase(): number;
        isUnobstructed(arg0: Internal.Entity_): boolean;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getBrightness(arg0: BlockPos_): number;
        canSeeSkyFromBelowWater(arg0: BlockPos_): boolean;
        getSectionsCount(): number;
        getMinBuildHeight(): number;
        getSectionIndexFromSectionY(arg0: number): number;
        noCollision(arg0: Internal.Entity_): boolean;
        getChunk(arg0: number, arg1: number, arg2: Internal.ChunkStatus_): Internal.ChunkAccess;
        hasChunkAt(arg0: number, arg1: number): boolean;
        getSectionIndex(arg0: number): number;
        getMaxBuildHeight(): number;
        hasChunksAt(arg0: BlockPos_, arg1: BlockPos_): boolean;
        getMoonBrightness(): number;
        noCollision(arg0: Internal.AABB_): boolean;
        getChunk(arg0: number, arg1: number): Internal.ChunkAccess;
        isWaterAt(arg0: BlockPos_): boolean;
        getDirectSignal(arg0: BlockPos_, arg1: Internal.Direction_): number;
        getCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        collidesWithSuffocatingBlock(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getHeight(): number;
        getNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        noCollision(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getChunk(arg0: BlockPos_): Internal.ChunkAccess;
        isOutsideBuildHeight(arg0: number): boolean;
        getMaxLocalRawBrightness(arg0: BlockPos_): number;
        isUnobstructed(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.CollisionContext_): boolean;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        hasChunkAt(arg0: BlockPos_): boolean;
        getBiome(arg0: BlockPos_): Internal.Holder<Internal.Biome>;
        getChunkForCollisions(arg0: number, arg1: number): Internal.BlockGetter;
        containsAnyLiquid(arg0: Internal.AABB_): boolean;
        getMaxLightLevel(): number;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
        get minSection(): number
        get maxSection(): number
        get moonPhase(): number
        get sectionsCount(): number
        get minBuildHeight(): number
        get maxBuildHeight(): number
        get moonBrightness(): number
        get height(): number
        get maxLightLevel(): number
    }
    type LevelTimeAccess_ = LevelTimeAccess;
    class AttackEntityEvent extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.Entity_)
        getTarget(): Internal.Entity;
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get target(): Internal.Entity
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type AttackEntityEvent_ = AttackEntityEvent;
    class ChunkDataEvent$Load extends Internal.ChunkDataEvent {
        constructor()
        constructor(arg0: Internal.ChunkAccess_, arg1: Internal.CompoundTag_, arg2: Internal.ChunkStatus$ChunkType_)
        getListenerList(): Internal.ListenerList;
        getStatus(): Internal.ChunkStatus$ChunkType;
        get listenerList(): Internal.ListenerList
        get status(): Internal.ChunkStatus$ChunkType
    }
    type ChunkDataEvent$Load_ = ChunkDataEvent$Load;
    interface RenderLayerParent <T, M> {
        getModel(): M;
        getTextureLocation(arg0: T): ResourceLocation;
        get model(): M
    }
    type RenderLayerParent_<T, M> = RenderLayerParent<T, M>;
    class DecimalFormatSymbols implements Internal.Cloneable, Internal.Serializable {
        constructor()
        constructor(arg0: Internal.Locale_)
        clone(): any;
        getDecimalSeparator(): string;
        setDecimalSeparator(arg0: string): void;
        setInternationalCurrencySymbol(arg0: string): void;
        getInternationalCurrencySymbol(): string;
        static getAvailableLocales(): Internal.Locale[];
        getNaN(): string;
        getMinusSign(): string;
        getMonetaryDecimalSeparator(): string;
        getCurrency(): Internal.Currency;
        setCurrency(arg0: Internal.Currency_): void;
        getPercent(): string;
        setPercent(arg0: string): void;
        setMonetaryDecimalSeparator(arg0: string): void;
        getDigit(): string;
        getPerMill(): string;
        setPerMill(arg0: string): void;
        setMonetaryGroupingSeparator(arg0: string): void;
        static getInstance(): Internal.DecimalFormatSymbols;
        setMinusSign(arg0: string): void;
        getGroupingSeparator(): string;
        getCurrencySymbol(): string;
        getPatternSeparator(): string;
        static getInstance(arg0: Internal.Locale_): Internal.DecimalFormatSymbols;
        getZeroDigit(): string;
        setNaN(arg0: string): void;
        getExponentSeparator(): string;
        hashCode(): number;
        setCurrencySymbol(arg0: string): void;
        setGroupingSeparator(arg0: string): void;
        setDigit(arg0: string): void;
        setZeroDigit(arg0: string): void;
        setPatternSeparator(arg0: string): void;
        equals(arg0: any): boolean;
        setExponentSeparator(arg0: string): void;
        getMonetaryGroupingSeparator(): string;
        setInfinity(arg0: string): void;
        getInfinity(): string;
        get decimalSeparator(): string
        set decimalSeparator(arg0: string)
        set internationalCurrencySymbol(arg0: string)
        get internationalCurrencySymbol(): string
        get availableLocales(): Internal.Locale[]
        get naN(): string
        get minusSign(): string
        get monetaryDecimalSeparator(): string
        get currency(): Internal.Currency
        set currency(arg0: Internal.Currency_)
        get percent(): string
        set percent(arg0: string)
        set monetaryDecimalSeparator(arg0: string)
        get digit(): string
        get perMill(): string
        set perMill(arg0: string)
        set monetaryGroupingSeparator(arg0: string)
        get instance(): Internal.DecimalFormatSymbols
        set minusSign(arg0: string)
        get groupingSeparator(): string
        get currencySymbol(): string
        get patternSeparator(): string
        get zeroDigit(): string
        set naN(arg0: string)
        get exponentSeparator(): string
        set currencySymbol(arg0: string)
        set groupingSeparator(arg0: string)
        set digit(arg0: string)
        set zeroDigit(arg0: string)
        set patternSeparator(arg0: string)
        set exponentSeparator(arg0: string)
        get monetaryGroupingSeparator(): string
        set infinity(arg0: string)
        get infinity(): string
    }
    type DecimalFormatSymbols_ = DecimalFormatSymbols;
    class LlamaSpit extends Internal.Projectile {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        constructor(arg0: Internal.Level_, arg1: Internal.Llama_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        recreateFromPacket(arg0: Internal.ClientboundAddEntityPacket_): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        tick(): void;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type LlamaSpit_ = LlamaSpit;
    class InSquarePlacement extends Internal.PlacementModifier {
        constructor()
        static spread(): Internal.InSquarePlacement;
        type(): Internal.PlacementModifierType<any>;
        getPositions(arg0: Internal.PlacementContext_, arg1: Internal.Random_, arg2: BlockPos_): Internal.Stream<BlockPos>;
        readonly static "CODEC": any;
    }
    type InSquarePlacement_ = InSquarePlacement;
    interface EntityTypeTest <B, T> {
        tryCast(arg0: B): T;
        forClass(arg0: Internal.Class_<T>): this;
        getBaseClass(): Internal.Class<any>;
        get baseClass(): Internal.Class<any>
    }
    type EntityTypeTest_<B, T> = EntityTypeTest<B, T>;
    interface Boolean2LongFunction extends it.unimi.dsi.fastutil.Function<boolean, number> {
        getOrDefault(arg0: boolean, arg1: number): number;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2LongFunction;
        getOrDefault(arg0: any, arg1: any): any;
        get(arg0: boolean): number;
        composeReference(arg0: Internal.Reference2BooleanFunction_<any>): Internal.Reference2LongFunction<T>;
        andThenReference(arg0: Internal.Long2ReferenceFunction_<any>): Internal.Boolean2ReferenceFunction<T>;
        get(arg0: any): number;
        containsKey(arg0: any): boolean;
        composeObject(arg0: Internal.Object2BooleanFunction_<any>): Internal.Object2LongFunction<T>;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Boolean2CharFunction;
        remove(arg0: any): number;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2LongFunction;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Boolean2ByteFunction;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2LongFunction;
        put(arg0: any, arg1: any): any;
        andThenObject(arg0: Internal.Long2ObjectFunction_<any>): Internal.Boolean2ObjectFunction<T>;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Boolean2DoubleFunction;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2LongFunction;
        defaultReturnValue(): number;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Boolean2FloatFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2LongFunction;
        getOrDefault(arg0: any, arg1: number): number;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2LongFunction;
        remove(arg0: boolean): number;
        containsKey(arg0: boolean): boolean;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Boolean2IntFunction;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Boolean2ShortFunction;
        size(): number;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2LongFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<boolean, T>;
        andThenLong(arg0: Internal.Long2LongFunction_): this;
        apply(arg0: boolean): number;
        clear(): void;
        put(arg0: boolean, arg1: number): number;
        put(arg0: boolean, arg1: number): number;
        defaultReturnValue(arg0: number): void;
    }
    type Boolean2LongFunction_ = Boolean2LongFunction | ((arg0: boolean)=>number);
    class MenuType <T> extends Internal.ForgeRegistryEntry<Internal.MenuType<any>> implements Internal.IForgeMenuType<T> {
        constructor(arg0: Internal.MenuType$MenuSupplier_<T>)
        create(arg0: number, arg1: Internal.Inventory_, arg2: Internal.FriendlyByteBuf_): T;
        create(arg0: number, arg1: Internal.Inventory_): T;
        readonly static "MERCHANT": Internal.MenuType<any>;
        readonly static "CARTOGRAPHY_TABLE": Internal.MenuType<any>;
        readonly static "SMOKER": Internal.MenuType<any>;
        readonly static "GENERIC_9x6": Internal.MenuType<any>;
        readonly static "ANVIL": Internal.MenuType<any>;
        readonly static "GENERIC_9x4": Internal.MenuType<any>;
        readonly static "BEACON": Internal.MenuType<any>;
        readonly static "LOOM": Internal.MenuType<any>;
        readonly static "STONECUTTER": Internal.MenuType<any>;
        readonly static "GENERIC_9x5": Internal.MenuType<any>;
        readonly static "LECTERN": Internal.MenuType<any>;
        readonly static "SHULKER_BOX": Internal.MenuType<any>;
        readonly static "CRAFTING": Internal.MenuType<any>;
        readonly static "SMITHING": Internal.MenuType<any>;
        readonly static "ENCHANTMENT": Internal.MenuType<any>;
        readonly static "GENERIC_9x2": Internal.MenuType<any>;
        readonly static "GENERIC_3x3": Internal.MenuType<any>;
        readonly static "FURNACE": Internal.MenuType<any>;
        readonly static "GENERIC_9x3": Internal.MenuType<any>;
        readonly static "GRINDSTONE": Internal.MenuType<any>;
        readonly static "GENERIC_9x1": Internal.MenuType<any>;
        readonly static "BREWING_STAND": Internal.MenuType<any>;
        readonly static "HOPPER": Internal.MenuType<any>;
        readonly static "BLAST_FURNACE": Internal.MenuType<any>;
    }
    type MenuType_<T> = Special.MenuType | MenuType<T>;
    class LivingEntity$Fallsounds extends Internal.Record {
        constructor(small: Internal.SoundEvent_, big: Internal.SoundEvent_)
        hashCode(): number;
        toString(): string;
        small(): Internal.SoundEvent;
        big(): Internal.SoundEvent;
        equals(arg0: any): boolean;
    }
    type LivingEntity$Fallsounds_ = LivingEntity$Fallsounds;
    interface Reference2FloatFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: any, arg1: any): any;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2FloatFunction;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Reference2DoubleFunction<K>;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Reference2CharFunction<K>;
        removeFloat(arg0: any): number;
        defaultReturnValue(arg0: number): void;
        getOrDefault(arg0: any, arg1: number): number;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2FloatFunction;
        apply(arg0: K): number;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2FloatFunction;
        containsKey(arg0: any): boolean;
        andThenReference(arg0: Internal.Float2ReferenceFunction_<any>): Internal.Reference2ReferenceFunction<K, T>;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2FloatFunction;
        put(arg0: any, arg1: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2FloatFunction;
        applyAsDouble(arg0: K): number;
        put(arg0: K, arg1: number): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        defaultReturnValue(): number;
        getFloat(arg0: any): number;
        remove(arg0: any): number;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Reference2IntFunction<K>;
        andThenObject(arg0: Internal.Float2ObjectFunction_<any>): Internal.Reference2ObjectFunction<K, T>;
        andThenFloat(arg0: Internal.Float2FloatFunction_): this;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Reference2LongFunction<K>;
        getOrDefault(arg0: any, arg1: number): number;
        size(): number;
        composeObject(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Object2FloatFunction<T>;
        composeReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Reference2FloatFunction<T>;
        clear(): void;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Reference2ByteFunction<K>;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2FloatFunction;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Reference2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2FloatFunction;
        put(arg0: K, arg1: number): number;
        get(arg0: any): any;
    }
    type Reference2FloatFunction_<K> = Reference2FloatFunction<K> | ((arg0: any)=>number);
    class DragonSittingFlamingPhase extends Internal.AbstractDragonSittingPhase {
        constructor(arg0: Internal.EnderDragon_)
        doClientTick(): void;
        end(): void;
        resetFlameCount(): void;
        begin(): void;
        doServerTick(): void;
        getPhase(): Internal.EnderDragonPhase<Internal.DragonSittingFlamingPhase>;
        get phase(): Internal.EnderDragonPhase<Internal.DragonSittingFlamingPhase>
    }
    type DragonSittingFlamingPhase_ = DragonSittingFlamingPhase;
    interface Function10 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> {
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function3<T8, T9, T10, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10): R;
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function<T10, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function8<T3, T4, T5, T6, T7, T8, T9, T10, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function5<T6, T7, T8, T9, T10, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.BiFunction<T9, T10, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function7<T4, T5, T6, T7, T8, T9, T10, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function6<T5, T6, T7, T8, T9, T10, R>>;
        curry(): Internal.Function<T1, Internal.Function9<T2, T3, T4, T5, T6, T7, T8, T9, T10, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function4<T7, T8, T9, T10, R>>;
    }
    type Function10_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> = Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>;
    class VillageSectionsDebugRenderer implements Internal.DebugRenderer$SimpleDebugRenderer {
        setNotVillageSection(arg0: Internal.SectionPos_): void;
        setVillageSection(arg0: Internal.SectionPos_): void;
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource_, arg2: number, arg3: number, arg4: number): void;
        clear(): void;
        set notVillageSection(arg0: Internal.SectionPos_)
        set villageSection(arg0: Internal.SectionPos_)
    }
    type VillageSectionsDebugRenderer_ = VillageSectionsDebugRenderer;
    class VillagerTypeBuilder extends Internal.BuilderBase<Internal.VillagerType> {
        constructor(i: ResourceLocation_)
        createObject(): any;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.VillagerType>;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.VillagerType>
    }
    type VillagerTypeBuilder_ = VillagerTypeBuilder;
    class LockCode {
        constructor(arg0: string)
        static fromTag(arg0: Internal.CompoundTag_): Internal.LockCode;
        unlocksWith(arg0: Internal.ItemStack_): boolean;
        addToTag(arg0: Internal.CompoundTag_): void;
        readonly static "NO_LOCK": Internal.LockCode;
        readonly static "TAG_LOCK": "Lock";
    }
    type LockCode_ = LockCode;
    interface Compressable extends Internal.Keyable {
        compressor(arg0: Internal.DynamicOps_<T>): Internal.KeyCompressor<T>;
    }
    type Compressable_ = Compressable;
    class ClientboundRemoveEntitiesPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(...arg0: number[])
        constructor(arg0: Internal.IntList_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        getEntityIds(): Internal.IntList;
        get skippable(): boolean
        get entityIds(): Internal.IntList
    }
    type ClientboundRemoveEntitiesPacket_ = ClientboundRemoveEntitiesPacket;
    class ChatComponent extends Internal.GuiComponent {
        constructor(arg0: Internal.Minecraft_)
        addMessage(arg0: Internal.Component_): void;
        enqueueMessage(arg0: Internal.Component_): void;
        render(arg0: Internal.PoseStack_, arg1: number): void;
        handleChatQueueClicked(arg0: number, arg1: number): boolean;
        getWidth(): number;
        rescaleChat(): void;
        getScale(): number;
        addRecentChat(arg0: string): void;
        scrollChat(arg0: number): void;
        getLinesPerPage(): number;
        getClickedComponentStyleAt(arg0: number, arg1: number): Internal.Style;
        static getHeight(arg0: number): number;
        getRecentChat(): Internal.List<string>;
        getHeight(): number;
        resetChatScroll(): void;
        static getWidth(arg0: number): number;
        clearMessages(arg0: boolean): void;
        get width(): number
        get scale(): number
        get linesPerPage(): number
        get recentChat(): Internal.List<string>
        get height(): number
    }
    type ChatComponent_ = ChatComponent;
    class LootingLevelEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.LivingEntity_, arg1: Internal.DamageSource_, arg2: number)
        getDamageSource(): Internal.DamageSource;
        setLootingLevel(arg0: number): void;
        getListenerList(): Internal.ListenerList;
        getLootingLevel(): number;
        get damageSource(): Internal.DamageSource
        set lootingLevel(arg0: number)
        get listenerList(): Internal.ListenerList
        get lootingLevel(): number
    }
    type LootingLevelEvent_ = LootingLevelEvent;
    class EnchantmentBuilder extends Internal.BuilderBase<Internal.Enchantment> {
        constructor(i: ResourceLocation_)
        rare(): this;
        damageProtection(i: Internal.EnchantmentBuilder$DamageProtectionFunction_): this;
        createObject(): any;
        maxLevel(i: number): this;
        veryRare(): this;
        canEnchant(i: Internal.Object2BooleanFunction_<Internal.ItemStackJS_>): this;
        postAttack(i: Internal.EnchantmentBuilder$PostFunction_): this;
        checkCompatibility(i: Internal.Object2BooleanFunction_<ResourceLocation_>): this;
        rarity(r: Internal.Enchantment$Rarity_): this;
        maxCost(i: Internal.Int2IntFunction_): this;
        minLevel(i: number): this;
        category(c: Internal.EnchantmentCategory_): this;
        minCost(i: Internal.Int2IntFunction_): this;
        postHurt(i: Internal.EnchantmentBuilder$PostFunction_): this;
        vanishable(): this;
        crossbow(): this;
        trident(): this;
        slots(s: EquipmentSlot_[]): this;
        uncommon(): this;
        curse(): this;
        undiscoverable(): this;
        armorLegs(): this;
        armorFeet(): this;
        treasureOnly(): this;
        armorChest(): this;
        untradeable(): this;
        damageBonus(i: Internal.EnchantmentBuilder$DamageBonusFunction_): this;
        weapon(): this;
        bow(): this;
        breakable(): this;
        armorHead(): this;
        fishingRod(): this;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Enchantment>;
        armor(): this;
        wearable(): this;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Enchantment>
    }
    type EnchantmentBuilder_ = EnchantmentBuilder;
    interface InventoryCarrier {
        getInventory(): Internal.Container;
        get inventory(): Internal.Container
    }
    type InventoryCarrier_ = InventoryCarrier;
    interface Function15 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R> {
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function11<T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13, arg13: T14, arg14: T15): R;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function9<T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, Internal.Function3<T13, T14, T15, R>>;
        curry(): Internal.Function<T1, Internal.Function14<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function10<T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function5<T11, T12, T13, T14, T15, R>>;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function8<T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry13(): Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, Internal.BiFunction<T14, T15, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function12<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function4<T12, T13, T14, T15, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function13<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function6<T10, T11, T12, T13, T14, T15, R>>;
        curry14(): Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, Internal.Function<T15, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function7<T9, T10, T11, T12, T13, T14, T15, R>>;
    }
    type Function15_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R> = Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>;
    interface FloatIterable extends Internal.Iterable<number> {
        forEach(arg0: Internal.FloatConsumer_): void;
        iterator(): Internal.Iterator<any>;
        spliterator(): Internal.Spliterator<any>;
        doubleSpliterator(): Internal.DoubleSpliterator;
        forEach(arg0: Internal.Consumer_<any>): void;
        forEach(arg0: Internal.DoubleConsumer_): void;
        doubleIterator(): Internal.DoubleIterator;
    }
    type FloatIterable_ = FloatIterable;
    interface Function16 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R> {
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function8<T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry(): Internal.Function<T1, Internal.Function15<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry15(): Internal.Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, Internal.Function<T16, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function11<T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry13(): Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, Internal.Function3<T14, T15, T16, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function12<T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, Internal.Function4<T13, T14, T15, T16, R>>;
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function5<T12, T13, T14, T15, T16, R>>;
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function7<T10, T11, T12, T13, T14, T15, T16, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function14<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13, arg13: T14, arg14: T15, arg15: T16): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function9<T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function6<T11, T12, T13, T14, T15, T16, R>>;
        curry14(): Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, Internal.BiFunction<T15, T16, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function10<T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function13<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
    }
    type Function16_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R> = Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>;
    interface Function13 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R> {
        curry2(): Internal.BiFunction<T1, T2, Internal.Function11<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function8<T6, T7, T8, T9, T10, T11, T12, T13, R>>;
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, Internal.Function<T13, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13): R;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function7<T7, T8, T9, T10, T11, T12, T13, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function5<T9, T10, T11, T12, T13, R>>;
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.BiFunction<T12, T13, R>>;
        curry(): Internal.Function<T1, Internal.Function12<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function10<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function9<T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function6<T8, T9, T10, T11, T12, T13, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function3<T11, T12, T13, R>>;
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function4<T10, T11, T12, T13, R>>;
    }
    type Function13_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R> = Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>;
    class ClientboundCooldownPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.Item_, arg1: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getItem(): Internal.Item;
        isSkippable(): boolean;
        getDuration(): number;
        get item(): Internal.Item
        get skippable(): boolean
        get duration(): number
    }
    type ClientboundCooldownPacket_ = ClientboundCooldownPacket;
    interface PrivilegedAction <T> {
        run(): T;
    }
    type PrivilegedAction_<T> = (()=>T) | PrivilegedAction<T>;
    interface Function14 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R> {
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function7<T8, T9, T10, T11, T12, T13, T14, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function6<T9, T10, T11, T12, T13, T14, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function4<T11, T12, T13, T14, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function11<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function8<T7, T8, T9, T10, T11, T12, T13, T14, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function10<T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>;
        curry13(): Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, Internal.Function<T14, R>>;
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function5<T10, T11, T12, T13, T14, R>>;
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, Internal.BiFunction<T13, T14, R>>;
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function3<T12, T13, T14, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function9<T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>;
        curry(): Internal.Function<T1, Internal.Function13<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function12<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13, arg13: T14): R;
    }
    type Function14_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R> = Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>;
    interface Function11 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R> {
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function7<T5, T6, T7, T8, T9, T10, T11, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11): R;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function3<T9, T10, T11, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function8<T4, T5, T6, T7, T8, T9, T10, T11, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function5<T7, T8, T9, T10, T11, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function9<T3, T4, T5, T6, T7, T8, T9, T10, T11, R>>;
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.BiFunction<T10, T11, R>>;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function4<T8, T9, T10, T11, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function6<T6, T7, T8, T9, T10, T11, R>>;
        curry(): Internal.Function<T1, Internal.Function10<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function<T11, R>>;
    }
    type Function11_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R> = Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>;
    interface Function12 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R> {
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function3<T10, T11, T12, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function6<T7, T8, T9, T10, T11, T12, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.BiFunction<T11, T12, R>>;
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function<T12, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function8<T5, T6, T7, T8, T9, T10, T11, T12, R>>;
        curry(): Internal.Function<T1, Internal.Function11<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function7<T6, T7, T8, T9, T10, T11, T12, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function9<T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function4<T9, T10, T11, T12, R>>;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function5<T8, T9, T10, T11, T12, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function10<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12): R;
    }
    type Function12_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R> = Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>;
    interface Principal {
        hashCode(): number;
        toString(): string;
        getName(): string;
        equals(arg0: any): boolean;
        implies(arg0: Internal.Subject_): boolean;
        get name(): string
    }
    type Principal_ = Principal;
    interface IForgeBlockEntity extends Internal.ICapabilitySerializable<Internal.CompoundTag> {
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        getModelData(): Internal.IModelData;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        onChunkUnloaded(): void;
        getTileData(): Internal.CompoundTag;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        serializeNBT(): Internal.CompoundTag;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get modelData(): Internal.IModelData
        get tileData(): Internal.CompoundTag
        get renderBoundingBox(): Internal.AABB
        readonly static "INFINITE_EXTENT_AABB": Internal.AABB;
    }
    type IForgeBlockEntity_ = IForgeBlockEntity;
    interface ConditionUserBuilder <T> {
        when(arg0: Internal.LootItemCondition$Builder_): T;
        unwrap(): T;
    }
    type ConditionUserBuilder_<T> = ConditionUserBuilder<T>;
    abstract class Goal {
        constructor()
        isInterruptable(): boolean;
        start(): void;
        toString(): string;
        getFlags(): Internal.EnumSet<Internal.Goal$Flag>;
        setFlags(arg0: Internal.EnumSet_<Internal.Goal$Flag_>): void;
        stop(): void;
        canUse(): boolean;
        requiresUpdateEveryTick(): boolean;
        canContinueToUse(): boolean;
        tick(): void;
        get interruptable(): boolean
        get flags(): Internal.EnumSet<Internal.Goal$Flag>
        set flags(arg0: Internal.EnumSet_<Internal.Goal$Flag_>)
    }
    type Goal_ = Goal;
    class RandomSpreadType extends Internal.Enum<Internal.RandomSpreadType> implements Internal.StringRepresentable {
        evaluate(arg0: Internal.RandomSource_, arg1: number): number;
        static valueOf(arg0: string): Internal.RandomSpreadType;
        getSerializedName(): string;
        static byName(arg0: string): Internal.RandomSpreadType;
        static values(): Internal.RandomSpreadType[];
        get serializedName(): string
        readonly static "LINEAR": Internal.RandomSpreadType;
        readonly static "TRIANGULAR": Internal.RandomSpreadType;
        readonly static "CODEC": any;
    }
    type RandomSpreadType_ = "linear" | RandomSpreadType | "triangular";
    class ImmutableList$Builder <E> extends Internal.ImmutableCollection$Builder<E> {
        constructor()
        add(arg0: any[]): Internal.ImmutableCollection$Builder<any>;
        addAll(arg0: Internal.Iterable_<any>): Internal.ImmutableCollection$Builder<any>;
        build(): Internal.ImmutableCollection<any>;
        add(arg0: any): Internal.ImmutableCollection$Builder<any>;
        addAll(arg0: Internal.Iterator_<any>): this;
    }
    type ImmutableList$Builder_<E> = ImmutableList$Builder<E>;
    class STBTTFontinfo extends Internal.Struct implements Internal.NativeResource {
        constructor(arg0: Internal.ByteBuffer_)
        static create(arg0: number): Internal.STBTTFontinfo$Buffer;
        static malloc(arg0: number): Internal.STBTTFontinfo$Buffer;
        static mallocStack(arg0: number, arg1: Internal.MemoryStack_): Internal.STBTTFontinfo$Buffer;
        static create(): Internal.STBTTFontinfo;
        static malloc(): Internal.STBTTFontinfo;
        static callocStack(arg0: number): Internal.STBTTFontinfo$Buffer;
        static callocStack(arg0: Internal.MemoryStack_): Internal.STBTTFontinfo;
        sizeof(): number;
        static mallocStack(arg0: Internal.MemoryStack_): Internal.STBTTFontinfo;
        static mallocStack(): Internal.STBTTFontinfo;
        static calloc(): Internal.STBTTFontinfo;
        static createSafe(arg0: number, arg1: number): Internal.STBTTFontinfo$Buffer;
        close(): void;
        static createSafe(arg0: number): Internal.STBTTFontinfo;
        static callocStack(arg0: number, arg1: Internal.MemoryStack_): Internal.STBTTFontinfo$Buffer;
        static mallocStack(arg0: number): Internal.STBTTFontinfo$Buffer;
        static create(arg0: number): Internal.STBTTFontinfo;
        static create(arg0: number, arg1: number): Internal.STBTTFontinfo$Buffer;
        static calloc(arg0: number): Internal.STBTTFontinfo$Buffer;
        static callocStack(): Internal.STBTTFontinfo;
        readonly static "ALIGNOF": 8;
        readonly static "SIZEOF": 160;
    }
    type STBTTFontinfo_ = STBTTFontinfo;
    interface DebugRenderer$SimpleDebugRenderer {
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource_, arg2: number, arg3: number, arg4: number): void;
        clear(): void;
    }
    type DebugRenderer$SimpleDebugRenderer_ = DebugRenderer$SimpleDebugRenderer;
    class BlockIDPredicate implements Internal.BlockPredicate {
        constructor(i: ResourceLocation_)
        with(key: string, value: string): this;
        checkState(state: Internal.BlockState_): boolean;
        toString(): string;
        check(b: Internal.BlockContainerJS_): boolean;
        getBlockState(): Internal.BlockState;
        getBlockProperties(): Internal.List<Internal.BlockIDPredicate$PropertyObject>;
        get blockState(): Internal.BlockState
        get blockProperties(): Internal.List<Internal.BlockIDPredicate$PropertyObject>
    }
    type BlockIDPredicate_ = BlockIDPredicate;
    interface LongBinaryOperator {
        applyAsLong(arg0: number, arg1: number): number;
    }
    type LongBinaryOperator_ = LongBinaryOperator | ((arg0: number, arg1: number)=>number);
    class ClientboundCustomPayloadPacket implements Internal.Packet<Internal.ClientGamePacketListener>, Internal.ICustomPacket<Internal.ClientboundCustomPayloadPacket> {
        constructor(arg0: ResourceLocation_, arg1: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getData(): Internal.FriendlyByteBuf;
        write(arg0: Internal.FriendlyByteBuf_): void;
        setData(arg0: Internal.FriendlyByteBuf_): void;
        getName(): ResourceLocation;
        getIndex(): number;
        setName(arg0: ResourceLocation_): void;
        getThis(): this;
        setIndex(arg0: number): void;
        isSkippable(): boolean;
        getInternalData(): Internal.FriendlyByteBuf;
        getDirection(): Internal.NetworkDirection;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getIdentifier(): ResourceLocation;
        get data(): Internal.FriendlyByteBuf
        set data(arg0: Internal.FriendlyByteBuf_)
        get name(): ResourceLocation
        get index(): number
        set name(arg0: ResourceLocation_)
        get this(): Internal.ClientboundCustomPayloadPacket
        set index(arg0: number)
        get skippable(): boolean
        get internalData(): Internal.FriendlyByteBuf
        get direction(): Internal.NetworkDirection
        get identifier(): ResourceLocation
        readonly static "DEBUG_POI_REMOVED_PACKET": ResourceLocation;
        readonly static "DEBUG_RAIDS": ResourceLocation;
        readonly static "DEBUG_POI_TICKET_COUNT_PACKET": ResourceLocation;
        readonly static "DEBUG_HIVE": ResourceLocation;
        readonly static "DEBUG_NEIGHBORSUPDATE_PACKET": ResourceLocation;
        readonly static "DEBUG_STRUCTURES_PACKET": ResourceLocation;
        readonly static "DEBUG_BRAIN": ResourceLocation;
        readonly static "DEBUG_VILLAGE_SECTIONS": ResourceLocation;
        readonly static "DEBUG_PATHFINDING_PACKET": ResourceLocation;
        readonly static "DEBUG_GAME_EVENT": ResourceLocation;
        readonly static "DEBUG_GOAL_SELECTOR": ResourceLocation;
        readonly static "BRAND": ResourceLocation;
        readonly static "DEBUG_GAME_EVENT_LISTENER": ResourceLocation;
        readonly static "DEBUG_WORLDGENATTEMPT_PACKET": ResourceLocation;
        readonly static "DEBUG_BEE": ResourceLocation;
        readonly static "DEBUG_POI_ADDED_PACKET": ResourceLocation;
        readonly static "DEBUG_GAME_TEST_ADD_MARKER": ResourceLocation;
        readonly static "DEBUG_GAME_TEST_CLEAR": ResourceLocation;
    }
    type ClientboundCustomPayloadPacket_ = ClientboundCustomPayloadPacket;
    abstract class ShortBuffer extends Internal.Buffer implements Internal.Comparable<Internal.ShortBuffer> {
        mismatch(arg0: Internal.ShortBuffer_): number;
        put(arg0: number): this;
        asReadOnlyBuffer(): this;
        reset(): Internal.Buffer;
        isDirect(): boolean;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): this;
        put(arg0: number[]): this;
        arrayOffset(): number;
        compareTo(arg0: any): number;
        get(): number;
        limit(arg0: number): this;
        position(arg0: number): this;
        flip(): Internal.Buffer;
        clear(): Internal.Buffer;
        order(): Internal.ByteOrder;
        static allocate(arg0: number): Internal.ShortBuffer;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): this;
        get(arg0: number): number;
        get(arg0: number[]): this;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.ShortBuffer;
        put(arg0: Internal.ShortBuffer_): this;
        hasArray(): boolean;
        put(arg0: number, arg1: number): this;
        put(arg0: number, arg1: number[]): this;
        duplicate(): this;
        get(arg0: number, arg1: number[]): this;
        toString(): string;
        get(arg0: number[], arg1: number, arg2: number): this;
        rewind(): Internal.Buffer;
        static wrap(arg0: number[]): Internal.ShortBuffer;
        compareTo(arg0: Internal.ShortBuffer_): number;
        array(): number[];
        mark(): Internal.Buffer;
        put(arg0: number[], arg1: number, arg2: number): this;
        compact(): this;
        hashCode(): number;
        slice(): Internal.Buffer;
        put(arg0: number, arg1: Internal.ShortBuffer_, arg2: number, arg3: number): this;
        slice(arg0: number, arg1: number): Internal.Buffer;
        equals(arg0: any): boolean;
        get direct(): boolean
    }
    type ShortBuffer_ = ShortBuffer;
    class Ingredient implements Internal.Predicate<Internal.ItemStack>, Internal.IngredientKJS {
        isVanilla(): boolean;
        static of(arg0: Internal.Stream_<Internal.ItemStack_>): Internal.Ingredient;
        static invalidateAll(): void;
        isSimple(): boolean;
        static valueFromJson(arg0: Internal.JsonObject_): Internal.Ingredient$Value;
        asKJS(): Internal.IngredientJS;
        isEmpty(): boolean;
        toJson(): Internal.JsonElement;
        static of(): Internal.Ingredient;
        test(arg0: any): boolean;
        static of(...arg0: Internal.ItemLike_[]): Internal.Ingredient;
        static merge(arg0: Internal.Collection_<Internal.Ingredient_>): Internal.Ingredient;
        negate(): Internal.Predicate<Internal.ItemStack>;
        static fromNetwork(arg0: Internal.FriendlyByteBuf_): Internal.Ingredient;
        checkInvalidation(): boolean;
        static of(...arg0: Internal.ItemStack_[]): Internal.Ingredient;
        getSerializer(): Internal.IIngredientSerializer<any>;
        static of(arg0: Internal.TagKey_<Internal.Item_>): Internal.Ingredient;
        or(arg0: Internal.Predicate_<any>): Internal.Predicate<Internal.ItemStack>;
        toNetwork(arg0: Internal.FriendlyByteBuf_): void;
        getItems(): Internal.ItemStack[];
        getStackingIds(): Internal.IntList;
        test(arg0: Internal.ItemStack_): boolean;
        getItemsKJS(): Internal.ItemStack[];
        static fromValues(arg0: Internal.Stream_<any>): Internal.Ingredient;
        static fromJson(arg0: Internal.JsonElement_): Internal.Ingredient;
        and(arg0: Internal.Predicate_<any>): Internal.Predicate<Internal.ItemStack>;
        get vanilla(): boolean
        get simple(): boolean
        get empty(): boolean
        get serializer(): Internal.IIngredientSerializer<any>
        get items(): Internal.ItemStack[]
        get stackingIds(): Internal.IntList
        get itemsKJS(): Internal.ItemStack[]
        readonly static "EMPTY": Internal.Ingredient;
    }
    type Ingredient_ = Ingredient;
    interface LongIterable extends Internal.Iterable<number> {
        forEach(arg0: it.unimi.dsi.fastutil.longs.LongConsumer_): void;
        iterator(): Internal.Iterator<any>;
        spliterator(): Internal.Spliterator<any>;
        forEach(arg0: Internal.Consumer_<any>): void;
        longIterator(): Internal.LongIterator;
        longSpliterator(): Internal.LongSpliterator;
        forEach(arg0: Internal.LongConsumer_): void;
    }
    type LongIterable_ = LongIterable;
    interface ItemLike {
        asItem(): Internal.Item;
    }
    type ItemLike_ = ItemLike;
    class BiomeGenerationSettingsBuilder extends Internal.BiomeGenerationSettings$Builder {
        constructor(arg0: Internal.BiomeGenerationSettings_)
        getFeatures(arg0: DecorationGenerationStep_): Internal.List<Internal.Holder<Internal.PlacedFeature>>;
        getCarvers(arg0: CarvingGenerationStep_): Internal.List<Internal.Holder<Internal.ConfiguredWorldCarver<any>>>;
    }
    type BiomeGenerationSettingsBuilder_ = BiomeGenerationSettingsBuilder;
    class ArmorItemBuilder$Leggings extends Internal.ArmorItemBuilder {
        constructor(i: ResourceLocation_)
        createObject(): any;
    }
    type ArmorItemBuilder$Leggings_ = ArmorItemBuilder$Leggings;
    class Sensing {
        constructor(arg0: Internal.Mob_)
        hasLineOfSight(arg0: Internal.Entity_): boolean;
        tick(): void;
    }
    type Sensing_ = Sensing;
    class StructureSpawnOverride extends Internal.Record {
        constructor(arg0: Internal.StructureSpawnOverride$BoundingBoxType_, arg1: Internal.WeightedRandomList_<Internal.MobSpawnSettings$SpawnerData_>)
        hashCode(): number;
        toString(): string;
        boundingBox(): Internal.StructureSpawnOverride$BoundingBoxType;
        equals(arg0: any): boolean;
        spawns(): Internal.WeightedRandomList<Internal.MobSpawnSettings$SpawnerData>;
        readonly static "CODEC": any;
    }
    type StructureSpawnOverride_ = StructureSpawnOverride;
    class AccessibleObject implements Internal.AnnotatedElement {
        setAccessible(arg0: boolean): void;
        getAnnotationsByType(arg0: Internal.Class_<T>): T[];
        canAccess(arg0: any): boolean;
        getDeclaredAnnotation(arg0: Internal.Class_<T>): T;
        getDeclaredAnnotationsByType(arg0: Internal.Class_<T>): T[];
        trySetAccessible(): boolean;
        getAnnotation(arg0: Internal.Class_<T>): T;
        getAnnotations(): Internal.Annotation[];
        isAnnotationPresent(arg0: Internal.Class_<any>): boolean;
        static setAccessible(arg0: Internal.AccessibleObject_[], arg1: boolean): void;
        getDeclaredAnnotations(): Internal.Annotation[];
        isAccessible(): boolean;
        set accessible(arg0: boolean)
        get annotations(): Internal.Annotation[]
        get declaredAnnotations(): Internal.Annotation[]
        get accessible(): boolean
    }
    type AccessibleObject_ = AccessibleObject;
    interface ParticleEngine$SpriteParticleRegistration <T> {
        create(arg0: Internal.SpriteSet_): Internal.ParticleProvider<T>;
    }
    type ParticleEngine$SpriteParticleRegistration_<T> = ParticleEngine$SpriteParticleRegistration<T> | ((arg0: Internal.SpriteSet)=>Internal.ParticleProvider_<T>);
    class SharedSuggestionProvider$TextCoordinates {
        constructor(arg0: string, arg1: string, arg2: string)
        readonly "y": string;
        readonly "x": string;
        readonly "z": string;
        readonly static "DEFAULT_LOCAL": Internal.SharedSuggestionProvider$TextCoordinates;
        readonly static "DEFAULT_GLOBAL": Internal.SharedSuggestionProvider$TextCoordinates;
    }
    type SharedSuggestionProvider$TextCoordinates_ = SharedSuggestionProvider$TextCoordinates;
    class CarvingMask {
        constructor(arg0: number, arg1: number)
        constructor(arg0: number[], arg1: number)
        stream(arg0: Internal.ChunkPos_): Internal.Stream<BlockPos>;
        setAdditionalMask(arg0: Internal.CarvingMask$Mask_): void;
        set(arg0: number, arg1: number, arg2: number): void;
        get(arg0: number, arg1: number, arg2: number): boolean;
        toArray(): number[];
        set additionalMask(arg0: Internal.CarvingMask$Mask_)
    }
    type CarvingMask_ = CarvingMask;
    class TimeUnit extends Internal.Enum<Internal.TimeUnit> {
        sleep(arg0: number): void;
        convert(arg0: number, arg1: Internal.TimeUnit_): number;
        static of(arg0: Internal.ChronoUnit_): Internal.TimeUnit;
        toMillis(arg0: number): number;
        toNanos(arg0: number): number;
        timedJoin(arg0: Internal.Thread_, arg1: number): void;
        toSeconds(arg0: number): number;
        timedWait(arg0: any, arg1: number): void;
        toMinutes(arg0: number): number;
        static values(): Internal.TimeUnit[];
        toMicros(arg0: number): number;
        convert(arg0: Internal.Duration_): number;
        static valueOf(arg0: string): Internal.TimeUnit;
        toChronoUnit(): Internal.ChronoUnit;
        toHours(arg0: number): number;
        toDays(arg0: number): number;
        readonly static "MINUTES": Internal.TimeUnit;
        readonly static "SECONDS": Internal.TimeUnit;
        readonly static "DAYS": Internal.TimeUnit;
        readonly static "NANOSECONDS": Internal.TimeUnit;
        readonly static "MICROSECONDS": Internal.TimeUnit;
        readonly static "MILLISECONDS": Internal.TimeUnit;
        readonly static "HOURS": Internal.TimeUnit;
    }
    type TimeUnit_ = "nanoseconds" | "minutes" | "seconds" | TimeUnit | "days" | "hours" | "microseconds" | "milliseconds";
    class BlockColors {
        constructor()
        getColor(arg0: Internal.BlockState_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_, arg3: number): number;
        getColor(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_): number;
        getColoringProperties(arg0: Internal.Block_): Internal.Set<Internal.Property<any>>;
        register(arg0: Internal.BlockColor_, ...arg1: Internal.Block_[]): void;
        static createDefault(): Internal.BlockColors;
    }
    type BlockColors_ = BlockColors;
    class FrontAndTop extends Internal.Enum<Internal.FrontAndTop> implements Internal.StringRepresentable {
        static fromFrontAndTop(arg0: Internal.Direction_, arg1: Internal.Direction_): Internal.FrontAndTop;
        front(): Internal.Direction;
        getSerializedName(): string;
        static values(): Internal.FrontAndTop[];
        static valueOf(arg0: string): Internal.FrontAndTop;
        top(): Internal.Direction;
        get serializedName(): string
        readonly static "DOWN_SOUTH": Internal.FrontAndTop;
        readonly static "DOWN_NORTH": Internal.FrontAndTop;
        readonly static "DOWN_EAST": Internal.FrontAndTop;
        readonly static "SOUTH_UP": Internal.FrontAndTop;
        readonly static "NORTH_UP": Internal.FrontAndTop;
        readonly static "UP_EAST": Internal.FrontAndTop;
        readonly static "UP_NORTH": Internal.FrontAndTop;
        readonly static "EAST_UP": Internal.FrontAndTop;
        readonly static "DOWN_WEST": Internal.FrontAndTop;
        readonly static "UP_WEST": Internal.FrontAndTop;
        readonly static "UP_SOUTH": Internal.FrontAndTop;
        readonly static "WEST_UP": Internal.FrontAndTop;
    }
    type FrontAndTop_ = "south_up" | "north_up" | FrontAndTop | "up_west" | "down_east" | "down_south" | "up_east" | "east_up" | "down_north" | "down_west" | "up_south" | "west_up" | "up_north";
    interface BufferVertexConsumer extends Internal.VertexConsumer {
        uv2(arg0: number): Internal.VertexConsumer;
        color(arg0: number, arg1: number, arg2: number, arg3: number): Internal.VertexConsumer;
        color(arg0: number): Internal.VertexConsumer;
        normalIntValue(arg0: number): number;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void;
        normal(arg0: number, arg1: number, arg2: number): Internal.VertexConsumer;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void;
        overlayCoords(arg0: number): Internal.VertexConsumer;
        vertex(arg0: number, arg1: number, arg2: number): Internal.VertexConsumer;
        color(arg0: number, arg1: number, arg2: number, arg3: number): Internal.VertexConsumer;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number[], arg7: number, arg8: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
        currentElement(): Internal.VertexFormatElement;
        overlayCoords(arg0: number, arg1: number): Internal.VertexConsumer;
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer_): number;
        applyBakedNormals(arg0: Internal.Vector3f_, arg1: Internal.ByteBuffer_, arg2: Internal.Matrix3f_): void;
        nextElement(): void;
        normal(arg0: Internal.Matrix3f_, arg1: number, arg2: number, arg3: number): Internal.VertexConsumer;
        uvShort(arg0: number, arg1: number, arg2: number): Internal.VertexConsumer;
        putShort(arg0: number, arg1: number): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        putByte(arg0: number, arg1: number): void;
        uv2(arg0: number, arg1: number): Internal.VertexConsumer;
        putFloat(arg0: number, arg1: number): void;
        vertex(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number, arg11: number, arg12: number, arg13: number): void;
        getVertexFormat(): Internal.VertexFormat;
        vertex(arg0: Internal.Matrix4f_, arg1: number, arg2: number, arg3: number): Internal.VertexConsumer;
        uv(arg0: number, arg1: number): Internal.VertexConsumer;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void;
        get vertexFormat(): Internal.VertexFormat
    }
    type BufferVertexConsumer_ = BufferVertexConsumer;
    class MethodInfo {
        constructor()
        toString(): string;
        "isHidden": boolean;
        "bean": string;
        "signature": Internal.MethodSignature;
        "method": Internal.Method;
    }
    type MethodInfo_ = MethodInfo;
    interface ProfilerMeasured {
        profiledMetrics(): Internal.List<Internal.MetricSampler>;
    }
    type ProfilerMeasured_ = ProfilerMeasured;
    class StructureTemplate$StructureEntityInfo {
        constructor(arg0: Vec3_, arg1: BlockPos_, arg2: Internal.CompoundTag_)
        readonly "nbt": Internal.CompoundTag;
        readonly "pos": Vec3;
        readonly "blockPos": BlockPos;
    }
    type StructureTemplate$StructureEntityInfo_ = StructureTemplate$StructureEntityInfo;
    class ItemArmorTierEventJS extends Internal.StartupEventJS {
        constructor()
        add(id: string, tier: Internal.Consumer_<Internal.MutableArmorTier_>): void;
        add(id: string, parent: string, tier: Internal.Consumer_<Internal.MutableArmorTier_>): void;
    }
    type ItemArmorTierEventJS_ = ItemArmorTierEventJS;
    class NoiseProvider extends Internal.NoiseBasedStateProvider {
        constructor(arg0: number, arg1: Internal.NormalNoise$NoiseParameters_, arg2: number, arg3: Internal.List_<Internal.BlockState_>)
        getState(arg0: Internal.Random_, arg1: BlockPos_): Internal.BlockState;
        readonly static "CODEC": any;
    }
    type NoiseProvider_ = NoiseProvider;
    abstract class PlayerList {
        constructor(arg0: Internal.MinecraftServer_, arg1: Internal.RegistryAccess$Frozen_, arg2: Internal.PlayerDataStorage_, arg3: number)
        broadcastMessage(arg0: Internal.Component_, arg1: Internal.ChatType_, arg2: Internal.UUID_): void;
        placeNewPlayer(arg0: Internal.Connection_, arg1: Internal.ServerPlayer_): void;
        sendAllPlayerInfo(arg0: Internal.ServerPlayer_): void;
        setSimulationDistance(arg0: number): void;
        getSingleplayerData(): Internal.CompoundTag;
        reloadResources(): void;
        broadcast(arg0: Internal.Player_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.ResourceKey_<Internal.Level_>, arg6: Internal.Packet_<any>): void;
        sendPlayerPermissionLevel(arg0: Internal.ServerPlayer_): void;
        saveAll(): void;
        remove(arg0: Internal.ServerPlayer_): void;
        isOp(arg0: Internal.GameProfile_): boolean;
        getPlayerCount(): number;
        broadcastMessage(arg0: Internal.Component_, arg1: Internal.Function_<Internal.ServerPlayer_, Internal.Component_>, arg2: Internal.ChatType_, arg3: Internal.UUID_): void;
        getIpBans(): Internal.IpBanList;
        getOpNames(): string[];
        addWorldborderListener(arg0: Internal.ServerLevel_): void;
        reloadWhiteList(): void;
        setViewDistance(arg0: number): void;
        getPlayer(arg0: Internal.UUID_): Internal.ServerPlayer;
        tick(): void;
        isWhiteListed(arg0: Internal.GameProfile_): boolean;
        getSimulationDistance(): number;
        broadcastToTeam(arg0: Internal.Player_, arg1: Internal.Component_): void;
        getMaxPlayers(): number;
        setAllowCheatsForAllPlayers(arg0: boolean): void;
        isAllowCheatsForAllPlayers(): boolean;
        getServer(): Internal.MinecraftServer;
        canPlayerLogin(arg0: Internal.SocketAddress_, arg1: Internal.GameProfile_): Internal.Component;
        getWhiteList(): Internal.UserWhiteList;
        broadcastAll(arg0: Internal.Packet_<any>, arg1: Internal.ResourceKey_<Internal.Level_>): void;
        respawn(arg0: Internal.ServerPlayer_, arg1: boolean): Internal.ServerPlayer;
        broadcastAll(arg0: Internal.Packet_<any>): void;
        getPlayers(): Internal.List<Internal.ServerPlayer>;
        getPlayerAdvancements(arg0: Internal.ServerPlayer_): Internal.PlayerAdvancements;
        op(arg0: Internal.GameProfile_): void;
        getPlayerNamesArray(): string[];
        getPlayerByName(arg0: string): Internal.ServerPlayer;
        load(arg0: Internal.ServerPlayer_): Internal.CompoundTag;
        getPlayerStats(arg0: Internal.Player_): Internal.ServerStatsCounter;
        deop(arg0: Internal.GameProfile_): void;
        removePlayer(arg0: Internal.ServerPlayer_): boolean;
        removeAll(): void;
        getWhiteListNames(): string[];
        sendLevelInfo(arg0: Internal.ServerPlayer_, arg1: Internal.ServerLevel_): void;
        addPlayer(arg0: Internal.ServerPlayer_): boolean;
        broadcastToAllExceptTeam(arg0: Internal.Player_, arg1: Internal.Component_): void;
        canBypassPlayerLimit(arg0: Internal.GameProfile_): boolean;
        setUsingWhiteList(arg0: boolean): void;
        getPlayerForLogin(arg0: Internal.GameProfile_): Internal.ServerPlayer;
        getViewDistance(): number;
        isUsingWhitelist(): boolean;
        getBans(): Internal.UserBanList;
        getPlayersWithAddress(arg0: string): Internal.List<Internal.ServerPlayer>;
        getOps(): Internal.ServerOpList;
        set simulationDistance(arg0: number)
        get singleplayerData(): Internal.CompoundTag
        get playerCount(): number
        get ipBans(): Internal.IpBanList
        get opNames(): string[]
        set viewDistance(arg0: number)
        get simulationDistance(): number
        get maxPlayers(): number
        set allowCheatsForAllPlayers(arg0: boolean)
        get allowCheatsForAllPlayers(): boolean
        get server(): Internal.MinecraftServer
        get whiteList(): Internal.UserWhiteList
        get players(): Internal.List<Internal.ServerPlayer>
        get playerNamesArray(): string[]
        get whiteListNames(): string[]
        set usingWhiteList(arg0: boolean)
        get viewDistance(): number
        get usingWhitelist(): boolean
        get bans(): Internal.UserBanList
        get ops(): Internal.ServerOpList
        readonly static "USERBANLIST_FILE": Internal.File;
        readonly static "OPLIST_FILE": Internal.File;
        readonly static "IPBANLIST_FILE": Internal.File;
        readonly static "WHITELIST_FILE": Internal.File;
    }
    type PlayerList_ = PlayerList;
    class FireworkRocketEntity extends Internal.Projectile implements Internal.FireworkRocketEntityKJS, Internal.ItemSupplier {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number, arg4: Internal.ItemStack_)
        constructor(arg0: Internal.Level_, arg1: Internal.ItemStack_, arg2: number, arg3: number, arg4: number, arg5: boolean)
        constructor(arg0: Internal.Level_, arg1: Internal.ItemStack_, arg2: Internal.Entity_, arg3: number, arg4: number, arg5: number, arg6: boolean)
        constructor(arg0: Internal.Level_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        constructor(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: number, arg3: number, arg4: number, arg5: Internal.ItemStack_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        isShotAtAngle(): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        getItem(): Internal.ItemStack;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        tick(): void;
        asKJS(): Internal.EntityJS;
        shouldRender(arg0: number, arg1: number, arg2: number): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setLifetimeKJS(arg0: number): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRenderAtSqrDistance(arg0: number): boolean;
        shouldRiderSit(): boolean;
        handleEntityEvent(arg0: number): void;
        isAttackable(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get shotAtAngle(): boolean
        get item(): Internal.ItemStack
        get stepHeight(): number
        set lifetimeKJS(arg0: number)
        get multipartEntity(): boolean
        get attackable(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type FireworkRocketEntity_ = FireworkRocketEntity;
    class ServerboundCustomPayloadPacket implements Internal.Packet<Internal.ServerGamePacketListener>, Internal.ICustomPacket<Internal.ServerboundCustomPayloadPacket> {
        constructor(arg0: ResourceLocation_, arg1: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getData(): Internal.FriendlyByteBuf;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        setData(arg0: Internal.FriendlyByteBuf_): void;
        getName(): ResourceLocation;
        getIndex(): number;
        setName(arg0: ResourceLocation_): void;
        setIndex(arg0: number): void;
        isSkippable(): boolean;
        getInternalData(): Internal.FriendlyByteBuf;
        getDirection(): Internal.NetworkDirection;
        getThis(): this;
        getIdentifier(): ResourceLocation;
        get data(): Internal.FriendlyByteBuf
        set data(arg0: Internal.FriendlyByteBuf_)
        get name(): ResourceLocation
        get index(): number
        set name(arg0: ResourceLocation_)
        set index(arg0: number)
        get skippable(): boolean
        get internalData(): Internal.FriendlyByteBuf
        get direction(): Internal.NetworkDirection
        get this(): Internal.ServerboundCustomPayloadPacket
        get identifier(): ResourceLocation
        readonly static "BRAND": ResourceLocation;
    }
    type ServerboundCustomPayloadPacket_ = ServerboundCustomPayloadPacket;
    class ServerboundPlayerCommandPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.Entity_, arg1: Internal.ServerboundPlayerCommandPacket$Action_)
        constructor(arg0: Internal.Entity_, arg1: Internal.ServerboundPlayerCommandPacket$Action_, arg2: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getData(): number;
        getAction(): Internal.ServerboundPlayerCommandPacket$Action;
        isSkippable(): boolean;
        getId(): number;
        get data(): number
        get action(): Internal.ServerboundPlayerCommandPacket$Action
        get skippable(): boolean
        get id(): number
    }
    type ServerboundPlayerCommandPacket_ = ServerboundPlayerCommandPacket;
    interface ByteChannel extends Internal.ReadableByteChannel, Internal.WritableByteChannel {
    }
    type ByteChannel_ = ByteChannel;
    abstract class AbstractInterruptibleChannel implements Internal.InterruptibleChannel, Internal.Channel {
        isOpen(): boolean;
        close(): void;
        get open(): boolean
    }
    type AbstractInterruptibleChannel_ = AbstractInterruptibleChannel;
    class LootPool {
        getBonusRolls(): Internal.NumberProvider;
        addRandomItems(arg0: Internal.Consumer_<Internal.ItemStack_>, arg1: Internal.LootContext_): void;
        static lootPool(): Internal.LootPool$Builder;
        setBonusRolls(arg0: Internal.NumberProvider_): void;
        getName(): string;
        setRolls(arg0: Internal.NumberProvider_): void;
        getRolls(): Internal.NumberProvider;
        validate(arg0: Internal.ValidationContext_): void;
        isFrozen(): boolean;
        freeze(): void;
        get bonusRolls(): Internal.NumberProvider
        set bonusRolls(arg0: Internal.NumberProvider_)
        get name(): string
        set rolls(arg0: Internal.NumberProvider_)
        get rolls(): Internal.NumberProvider
        get frozen(): boolean
    }
    type LootPool_ = LootPool;
    interface IForgeEntity extends Internal.ICapabilitySerializable<Internal.CompoundTag> {
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        canUpdate(arg0: boolean): void;
        isAddedToWorld(): boolean;
        getPersistentData(): Internal.CompoundTag;
        onAddedToWorld(): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        canUpdate(): boolean;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        onRemovedFromWorld(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        revive(): void;
        getStepHeight(): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        get addedToWorld(): boolean
        get persistentData(): Internal.CompoundTag
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type IForgeEntity_ = IForgeEntity;
    interface ItemKJS {
        getTypeDataKJS(): Internal.CompoundTag;
        setMaxDamageKJS(i: number): void;
        setFoodPropertiesKJS(properties: Internal.FoodProperties_): void;
        setMaxStackSizeKJS(i: number): void;
        setFireResistantKJS(b: boolean): void;
        setItemBuilderKJS(b: Internal.ItemBuilder_): void;
        getItemBuilderKJS(): Internal.ItemBuilder;
        setCraftingRemainderKJS(i: Internal.Item_): void;
        setRarityKJS(r: Rarity_): void;
        setBurnTimeKJS(i: number): void;
        get typeDataKJS(): Internal.CompoundTag
        set maxDamageKJS(i: number)
        set foodPropertiesKJS(properties: Internal.FoodProperties_)
        set maxStackSizeKJS(i: number)
        set fireResistantKJS(b: boolean)
        set itemBuilderKJS(b: Internal.ItemBuilder_)
        get itemBuilderKJS(): Internal.ItemBuilder
        set craftingRemainderKJS(i: Internal.Item_)
        set rarityKJS(r: Rarity_)
        set burnTimeKJS(i: number)
    }
    type ItemKJS_ = ItemKJS;
    interface Member {
        getModifiers(): number;
        getName(): string;
        isSynthetic(): boolean;
        getDeclaringClass(): Internal.Class<any>;
        get modifiers(): number
        get name(): string
        get synthetic(): boolean
        get declaringClass(): Internal.Class<any>
        readonly static "PUBLIC": 0;
        readonly static "DECLARED": 1;
    }
    type Member_ = Member;
    interface Widget {
        render(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
    }
    type Widget_ = Widget;
    class NetworkInterface {
        inetAddresses(): Internal.Stream<Internal.InetAddress>;
        isPointToPoint(): boolean;
        subInterfaces(): Internal.Stream<Internal.NetworkInterface>;
        getParent(): this;
        getMTU(): number;
        getHardwareAddress(): number[];
        toString(): string;
        getSubInterfaces(): Internal.Enumeration<Internal.NetworkInterface>;
        static getNetworkInterfaces(): Internal.Enumeration<Internal.NetworkInterface>;
        getIndex(): number;
        static networkInterfaces(): Internal.Stream<Internal.NetworkInterface>;
        supportsMulticast(): boolean;
        isUp(): boolean;
        isVirtual(): boolean;
        static getByName(arg0: string): Internal.NetworkInterface;
        isLoopback(): boolean;
        hashCode(): number;
        static getByIndex(arg0: number): Internal.NetworkInterface;
        getInterfaceAddresses(): Internal.List<Internal.InterfaceAddress>;
        getName(): string;
        getDisplayName(): string;
        static getByInetAddress(arg0: Internal.InetAddress_): Internal.NetworkInterface;
        equals(arg0: any): boolean;
        getInetAddresses(): Internal.Enumeration<Internal.InetAddress>;
        get pointToPoint(): boolean
        get parent(): Internal.NetworkInterface
        get MTU(): number
        get hardwareAddress(): number[]
        get subInterfaces(): Internal.Enumeration<Internal.NetworkInterface>
        get networkInterfaces(): Internal.Enumeration<Internal.NetworkInterface>
        get index(): number
        get up(): boolean
        get virtual(): boolean
        get loopback(): boolean
        get interfaceAddresses(): Internal.List<Internal.InterfaceAddress>
        get name(): string
        get displayName(): string
        get inetAddresses(): Internal.Enumeration<Internal.InetAddress>
    }
    type NetworkInterface_ = NetworkInterface;
    class AbstractMinecart$Type extends Internal.Enum<Internal.AbstractMinecart$Type> {
        static valueOf(arg0: string): Internal.AbstractMinecart$Type;
        static values(): Internal.AbstractMinecart$Type[];
        readonly static "SPAWNER": Internal.AbstractMinecart$Type;
        readonly static "RIDEABLE": Internal.AbstractMinecart$Type;
        readonly static "CHEST": Internal.AbstractMinecart$Type;
        readonly static "HOPPER": Internal.AbstractMinecart$Type;
        readonly static "TNT": Internal.AbstractMinecart$Type;
        readonly static "COMMAND_BLOCK": Internal.AbstractMinecart$Type;
        readonly static "FURNACE": Internal.AbstractMinecart$Type;
    }
    type AbstractMinecart$Type_ = AbstractMinecart$Type | "spawner" | "hopper" | "command_block" | "furnace" | "rideable" | "chest" | "tnt";
    class TreeConfiguration implements Internal.FeatureConfiguration {
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "minimumSize": Internal.FeatureSize;
        readonly "dirtProvider": Internal.BlockStateProvider;
        readonly "forceDirt": boolean;
        readonly static "CODEC": any;
        readonly "foliageProvider": Internal.BlockStateProvider;
        readonly "trunkProvider": Internal.BlockStateProvider;
        readonly "foliagePlacer": Internal.FoliagePlacer;
        readonly "trunkPlacer": Internal.TrunkPlacer;
        readonly "decorators": Internal.List<Internal.TreeDecorator>;
        readonly "ignoreVines": boolean;
    }
    type TreeConfiguration_ = TreeConfiguration;
    interface Int2IntMap$Entry extends Internal.Map$Entry<number, number> {
        setValue(arg0: number): number;
        getValue(): number;
        getKey(): any;
        getIntKey(): number;
        setValue(arg0: number): number;
        getIntValue(): number;
        setValue(arg0: any): any;
        set value(arg0: number)
        get value(): number
        get key(): any
        get intKey(): number
        set value(arg0: number)
        get intValue(): number
        set value(arg0: any)
    }
    type Int2IntMap$Entry_ = Int2IntMap$Entry;
    abstract class RenderTarget {
        constructor(arg0: boolean)
        clear(arg0: boolean): void;
        getColorTextureId(): number;
        blitToScreen(arg0: number, arg1: number): void;
        bindRead(): void;
        unbindWrite(): void;
        setFilterMode(arg0: number): void;
        setClearColor(arg0: number, arg1: number, arg2: number, arg3: number): void;
        blitToScreen(arg0: number, arg1: number, arg2: boolean): void;
        unbindRead(): void;
        createBuffers(arg0: number, arg1: number, arg2: boolean): void;
        enableStencil(): void;
        checkStatus(): void;
        destroyBuffers(): void;
        isStencilEnabled(): boolean;
        bindWrite(arg0: boolean): void;
        resize(arg0: number, arg1: number, arg2: boolean): void;
        getDepthTextureId(): number;
        copyDepthFrom(arg0: Internal.RenderTarget_): void;
        get colorTextureId(): number
        set filterMode(arg0: number)
        get stencilEnabled(): boolean
        get depthTextureId(): number
        "width": number;
        readonly "useDepth": boolean;
        "filterMode": number;
        "height": number;
        "frameBufferId": number;
        "viewHeight": number;
        "viewWidth": number;
    }
    type RenderTarget_ = RenderTarget;
    class ChunkHolder$FullChunkStatus extends Internal.Enum<Internal.ChunkHolder$FullChunkStatus> {
        static valueOf(arg0: string): Internal.ChunkHolder$FullChunkStatus;
        isOrAfter(arg0: Internal.ChunkHolder$FullChunkStatus_): boolean;
        static values(): Internal.ChunkHolder$FullChunkStatus[];
        readonly static "INACCESSIBLE": Internal.ChunkHolder$FullChunkStatus;
        readonly static "BORDER": Internal.ChunkHolder$FullChunkStatus;
        readonly static "TICKING": Internal.ChunkHolder$FullChunkStatus;
        readonly static "ENTITY_TICKING": Internal.ChunkHolder$FullChunkStatus;
    }
    type ChunkHolder$FullChunkStatus_ = "inaccessible" | "entity_ticking" | ChunkHolder$FullChunkStatus | "ticking" | "border";
    class FluidStack {
        constructor(arg0: Internal.Fluid_, arg1: number)
        constructor(arg0: Internal.FluidStack_, arg1: number)
        constructor(arg0: Internal.Fluid_, arg1: number, arg2: Internal.CompoundTag_)
        getDisplayName(): Internal.Component;
        setTag(arg0: Internal.CompoundTag_): void;
        getRawFluid(): Internal.Fluid;
        getOrCreateChildTag(arg0: string): Internal.CompoundTag;
        setAmount(arg0: number): void;
        static readFromPacket(arg0: Internal.FriendlyByteBuf_): Internal.FluidStack;
        removeChildTag(arg0: string): void;
        isEmpty(): boolean;
        writeToNBT(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        shrink(arg0: number): void;
        getAmount(): number;
        static loadFluidStackFromNBT(arg0: Internal.CompoundTag_): Internal.FluidStack;
        static areFluidStackTagsEqual(arg0: Internal.FluidStack_, arg1: Internal.FluidStack_): boolean;
        isFluidEqual(arg0: Internal.FluidStack_): boolean;
        getTranslationKey(): string;
        copy(): this;
        hashCode(): number;
        isFluidEqual(arg0: Internal.ItemStack_): boolean;
        getOrCreateTag(): Internal.CompoundTag;
        getChildTag(arg0: string): Internal.CompoundTag;
        hasTag(): boolean;
        getTag(): Internal.CompoundTag;
        getFluid(): Internal.Fluid;
        isFluidStackIdentical(arg0: Internal.FluidStack_): boolean;
        equals(arg0: any): boolean;
        containsFluid(arg0: Internal.FluidStack_): boolean;
        writeToPacket(arg0: Internal.FriendlyByteBuf_): void;
        grow(arg0: number): void;
        get displayName(): Internal.Component
        set tag(arg0: Internal.CompoundTag_)
        get rawFluid(): Internal.Fluid
        set amount(arg0: number)
        get empty(): boolean
        get amount(): number
        get translationKey(): string
        get orCreateTag(): Internal.CompoundTag
        get tag(): Internal.CompoundTag
        get fluid(): Internal.Fluid
        readonly static "EMPTY": Internal.FluidStack;
        readonly static "CODEC": any;
    }
    type FluidStack_ = FluidStack;
    abstract class Biome$TemperatureModifier extends Internal.Enum<Internal.Biome$TemperatureModifier> implements Internal.StringRepresentable {
        modifyTemperature(arg0: BlockPos_, arg1: number): number;
        static byName(arg0: string): Internal.Biome$TemperatureModifier;
        static valueOf(arg0: string): Internal.Biome$TemperatureModifier;
        getSerializedName(): string;
        getName(): string;
        static values(): Internal.Biome$TemperatureModifier[];
        get serializedName(): string
        get name(): string
        readonly static "FROZEN": any;
        readonly static "NONE": any;
        readonly static "CODEC": any;
    }
    type Biome$TemperatureModifier_ = "frozen" | Biome$TemperatureModifier | "none";
    abstract class AbstractReferenceCountedByteBuf extends Internal.AbstractByteBuf {
        retain(): Internal.ReferenceCounted;
        release(arg0: number): boolean;
        touch(): Internal.ReferenceCounted;
        touch(arg0: any): Internal.ByteBuf;
        refCnt(): number;
        release(): boolean;
        retain(arg0: number): Internal.ReferenceCounted;
    }
    type AbstractReferenceCountedByteBuf_ = AbstractReferenceCountedByteBuf;
    class StructureStart {
        constructor(arg0: Internal.ConfiguredStructureFeature_<any, any>, arg1: Internal.ChunkPos_, arg2: number, arg3: Internal.PiecesContainer_)
        canBeReferenced(): boolean;
        isValid(): boolean;
        getPieces(): Internal.List<Internal.StructurePiece>;
        getChunkPos(): Internal.ChunkPos;
        placeInChunk(arg0: Internal.WorldGenLevel_, arg1: Internal.StructureFeatureManager_, arg2: Internal.ChunkGenerator_, arg3: Internal.Random_, arg4: Internal.BoundingBox_, arg5: Internal.ChunkPos_): void;
        getFeature(): Internal.ConfiguredStructureFeature<any, any>;
        getReferences(): number;
        addReference(): void;
        getBoundingBox(): Internal.BoundingBox;
        createTag(arg0: Internal.StructurePieceSerializationContext_, arg1: Internal.ChunkPos_): Internal.CompoundTag;
        get valid(): boolean
        get pieces(): Internal.List<Internal.StructurePiece>
        get chunkPos(): Internal.ChunkPos
        get feature(): Internal.ConfiguredStructureFeature<any, any>
        get references(): number
        get boundingBox(): Internal.BoundingBox
        readonly static "INVALID_START_ID": "INVALID";
        readonly static "INVALID_START": Internal.StructureStart;
    }
    type StructureStart_ = StructureStart;
    interface Resource extends Internal.Closeable {
        getInputStream(): Internal.InputStream;
        hasMetadata(): boolean;
        getSourceName(): string;
        getLocation(): ResourceLocation;
        getMetadata(arg0: Internal.MetadataSectionSerializer_<T>): T;
        get inputStream(): Internal.InputStream
        get sourceName(): string
        get location(): ResourceLocation
    }
    type Resource_ = Resource;
    class ServerboundUseItemPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Hand_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getHand(): Hand;
        isSkippable(): boolean;
        get hand(): Hand
        get skippable(): boolean
    }
    type ServerboundUseItemPacket_ = ServerboundUseItemPacket;
    interface IIngredientSerializer <T> {
        parse(arg0: Internal.JsonObject_): T;
        parse(arg0: Internal.FriendlyByteBuf_): T;
        write(arg0: Internal.FriendlyByteBuf_, arg1: T): void;
    }
    type IIngredientSerializer_<T> = IIngredientSerializer<T>;
    class ServerboundChangeDifficultyPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.Difficulty_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getDifficulty(): Internal.Difficulty;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        isSkippable(): boolean;
        get difficulty(): Internal.Difficulty
        get skippable(): boolean
    }
    type ServerboundChangeDifficultyPacket_ = ServerboundChangeDifficultyPacket;
    class WitherSkeleton extends Internal.AbstractSkeleton {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        canBeAffected(arg0: Internal.MobEffectInstance_): boolean;
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type WitherSkeleton_ = WitherSkeleton;
    abstract class HandheldItemBuilder extends Internal.ItemBuilder {
        constructor(i: ResourceLocation_, d: number, s: number)
        speed(f: number): this;
        attackDamageBaseline(f: number): this;
        speedBaseline(f: number): this;
        modifyTier(callback: Internal.Consumer_<Internal.MutableToolTier_>): this;
        attackDamageBonus(f: number): this;
        tier(t: Internal.Tier_): this;
    }
    type HandheldItemBuilder_ = HandheldItemBuilder;
    class Explosion$BlockInteraction extends Internal.Enum<Internal.Explosion$BlockInteraction> {
        static valueOf(arg0: string): Internal.Explosion$BlockInteraction;
        static values(): Internal.Explosion$BlockInteraction[];
        readonly static "DESTROY": Internal.Explosion$BlockInteraction;
        readonly static "NONE": Internal.Explosion$BlockInteraction;
        readonly static "BREAK": Internal.Explosion$BlockInteraction;
    }
    type Explosion$BlockInteraction_ = "break" | Explosion$BlockInteraction | "destroy" | "none";
    interface Long2CharFunction extends it.unimi.dsi.fastutil.Function<number, string>, Internal.LongToIntFunction {
        composeReference(arg0: Internal.Reference2LongFunction_<any>): Internal.Reference2CharFunction<T>;
        get(arg0: number): string;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2CharFunction;
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: any, arg1: any): any;
        andThenChar(arg0: Internal.Char2CharFunction_): this;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Long2ByteFunction;
        defaultReturnValue(): string;
        getOrDefault(arg0: number, arg1: string): string;
        put(arg0: number, arg1: string): string;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Long2ShortFunction;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2CharFunction;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Long2LongFunction;
        andThenObject(arg0: Internal.Char2ObjectFunction_<any>): Internal.Long2ObjectFunction<T>;
        defaultReturnValue(arg0: string): void;
        remove(arg0: number): string;
        get(arg0: any): string;
        put(arg0: any, arg1: any): any;
        applyAsInt(arg0: number): number;
        composeObject(arg0: Internal.Object2LongFunction_<any>): Internal.Object2CharFunction<T>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2CharFunction;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2CharFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeLong(arg0: Internal.Long2LongFunction_): this;
        containsKey(arg0: number): boolean;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Long2DoubleFunction;
        apply(arg0: number): string;
        size(): number;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Long2IntFunction;
        andThenReference(arg0: Internal.Char2ReferenceFunction_<any>): Internal.Long2ReferenceFunction<T>;
        clear(): void;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2CharFunction;
        put(arg0: number, arg1: string): string;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Long2FloatFunction;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2CharFunction;
        remove(arg0: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, string>;
    }
    type Long2CharFunction_ = Long2CharFunction | ((arg0: number)=>string);
    class BlastFurnaceMenu extends Internal.AbstractFurnaceMenu {
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Container_, arg3: any_)
        constructor(arg0: number, arg1: Internal.Inventory_)
    }
    type BlastFurnaceMenu_ = BlastFurnaceMenu;
    interface SuggestionProvider <S> {
        getSuggestions(arg0: Internal.CommandContext_<S>, arg1: Internal.SuggestionsBuilder_): Internal.CompletableFuture<Internal.Suggestions>;
    }
    type SuggestionProvider_<S> = SuggestionProvider<S> | ((arg0: Internal.CommandContext<S>, arg1: Internal.SuggestionsBuilder)=>Internal.CompletableFuture_<Internal.Suggestions_>);
    class JigsawConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.Holder_<Internal.StructureTemplatePool_>, arg1: number)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        startPool(): Internal.Holder<Internal.StructureTemplatePool>;
        maxDepth(): number;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
    }
    type JigsawConfiguration_ = JigsawConfiguration;
    interface LootContext$DynamicDrop {
        add(arg0: Internal.LootContext_, arg1: Internal.Consumer_<Internal.ItemStack_>): void;
    }
    type LootContext$DynamicDrop_ = ((arg0: Internal.LootContext, arg1: Internal.Consumer<Internal.ItemStack>)=>void) | LootContext$DynamicDrop;
    class Quaternion {
        constructor(arg0: Internal.Vector3f_, arg1: number, arg2: boolean)
        constructor(arg0: Internal.Quaternion_)
        constructor(arg0: number, arg1: number, arg2: number, arg3: boolean)
        constructor(arg0: number, arg1: number, arg2: number, arg3: number)
        toYXZDegrees(): Internal.Vector3f;
        toString(): string;
        toYXZ(): Internal.Vector3f;
        slerp(arg0: Internal.Quaternion_, arg1: number): void;
        static fromXYZ(arg0: Internal.Vector3f_): Internal.Quaternion;
        normalize(): void;
        static fromYXZ(arg0: number, arg1: number, arg2: number): Internal.Quaternion;
        toXYZ(): Internal.Vector3f;
        conj(): void;
        i(): number;
        j(): number;
        copy(): this;
        hashCode(): number;
        mul(arg0: Internal.Quaternion_): void;
        k(): number;
        toXYZDegrees(): Internal.Vector3f;
        static fromXYZDegrees(arg0: Internal.Vector3f_): Internal.Quaternion;
        r(): number;
        set(arg0: number, arg1: number, arg2: number, arg3: number): void;
        equals(arg0: any): boolean;
        static fromXYZ(arg0: number, arg1: number, arg2: number): Internal.Quaternion;
        mul(arg0: number): void;
        readonly static "ONE": Internal.Quaternion;
    }
    type Quaternion_ = Quaternion;
    class GameRenderer implements Internal.ResourceManagerReloadListener, Internal.AutoCloseable {
        constructor(arg0: Internal.Minecraft_, arg1: Internal.ResourceManager_, arg2: Internal.RenderBuffers_)
        static getRendertypeEntityCutoutShader(): Internal.ShaderInstance;
        renderZoomed(arg0: number, arg1: number, arg2: number): void;
        getProjectionMatrix(arg0: number): Internal.Matrix4f;
        getMinecraft(): Internal.Minecraft;
        static getRendertypeTextIntensityShader(): Internal.ShaderInstance;
        cycleEffect(): void;
        shutdownEffect(): void;
        static getRendertypeEndPortalShader(): Internal.ShaderInstance;
        static getRendertypeTripwireShader(): Internal.ShaderInstance;
        resetData(): void;
        static getRendertypeEntityShadowShader(): Internal.ShaderInstance;
        static getRendertypeCutoutShader(): Internal.ShaderInstance;
        static getRendertypeEyesShader(): Internal.ShaderInstance;
        loadEffect(arg0: ResourceLocation_): void;
        currentEffect(): Internal.PostChain;
        static getPositionColorShader(): Internal.ShaderInstance;
        static getRendertypeTextSeeThroughShader(): Internal.ShaderInstance;
        static getPositionTexColorNormalShader(): Internal.ShaderInstance;
        static getRendertypeBeaconBeamShader(): Internal.ShaderInstance;
        static getRendertypeTextIntensitySeeThroughShader(): Internal.ShaderInstance;
        static getRendertypeLightningShader(): Internal.ShaderInstance;
        static getRendertypeItemEntityTranslucentCullShader(): Internal.ShaderInstance;
        checkEntityPostEffect(arg0: Internal.Entity_): void;
        preloadUiShader(arg0: Internal.ResourceProvider_): void;
        static getRendertypeEntitySmoothCutoutShader(): Internal.ShaderInstance;
        overlayTexture(): Internal.OverlayTexture;
        static getRendertypeLeashShader(): Internal.ShaderInstance;
        isPanoramicMode(): boolean;
        setRenderBlockOutline(arg0: boolean): void;
        static getRendertypeEntityTranslucentCullShader(): Internal.ShaderInstance;
        static getPositionColorTexLightmapShader(): Internal.ShaderInstance;
        lightTexture(): Internal.LightTexture;
        togglePostEffect(): void;
        static getRendertypeArmorCutoutNoCullShader(): Internal.ShaderInstance;
        tick(): void;
        static getRendertypeArmorEntityGlintShader(): Internal.ShaderInstance;
        setPanoramicMode(arg0: boolean): void;
        static getRendertypeTranslucentShader(): Internal.ShaderInstance;
        static getRendertypeEntityCutoutNoCullShader(): Internal.ShaderInstance;
        static getRendertypeEntityTranslucentShader(): Internal.ShaderInstance;
        static getRendertypeEntityDecalShader(): Internal.ShaderInstance;
        displayItemActivation(arg0: Internal.ItemStack_): void;
        resize(arg0: number, arg1: number): void;
        static getRendertypeTextShader(): Internal.ShaderInstance;
        render(arg0: number, arg1: number, arg2: boolean): void;
        getRenderDistance(): number;
        static getParticleShader(): Internal.ShaderInstance;
        static getRendertypeSolidShader(): Internal.ShaderInstance;
        static getRendertypeEntityNoOutlineShader(): Internal.ShaderInstance;
        static getPositionTexShader(): Internal.ShaderInstance;
        static getRendertypeWaterMaskShader(): Internal.ShaderInstance;
        static getRendertypeOutlineShader(): Internal.ShaderInstance;
        static getNightVisionScale(arg0: Internal.LivingEntity_, arg1: number): number;
        static getRendertypeGlintTranslucentShader(): Internal.ShaderInstance;
        static getPositionTexColorShader(): Internal.ShaderInstance;
        renderLevel(arg0: number, arg1: number, arg2: Internal.PoseStack_): void;
        static getBlockShader(): Internal.ShaderInstance;
        getDepthFar(): number;
        getDarkenWorldAmount(arg0: number): number;
        static getRendertypeLinesShader(): Internal.ShaderInstance;
        static getRendertypeEntityCutoutNoCullZOffsetShader(): Internal.ShaderInstance;
        static getRendertypeEntityGlintShader(): Internal.ShaderInstance;
        static getNewEntityShader(): Internal.ShaderInstance;
        getName(): string;
        static getRendertypeCutoutMippedShader(): Internal.ShaderInstance;
        pick(arg0: number): void;
        static getRendertypeArmorGlintShader(): Internal.ShaderInstance;
        static getPositionColorLightmapShader(): Internal.ShaderInstance;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        static getRendertypeCrumblingShader(): Internal.ShaderInstance;
        static getRendertypeEndGatewayShader(): Internal.ShaderInstance;
        static getPositionColorTexShader(): Internal.ShaderInstance;
        resetProjectionMatrix(arg0: Internal.Matrix4f_): void;
        static getRendertypeEntityAlphaShader(): Internal.ShaderInstance;
        onResourceManagerReload(arg0: Internal.ResourceManager_): void;
        static getRendertypeGlintDirectShader(): Internal.ShaderInstance;
        static getRendertypeEntitySolidShader(): Internal.ShaderInstance;
        getShader(arg0: string): Internal.ShaderInstance;
        getMainCamera(): Internal.Camera;
        static getRendertypeTranslucentNoCrumblingShader(): Internal.ShaderInstance;
        static getRendertypeEntityGlintDirectShader(): Internal.ShaderInstance;
        getMapRenderer(): Internal.MapRenderer;
        static getPositionTexLightmapColorShader(): Internal.ShaderInstance;
        static getRendertypeEnergySwirlShader(): Internal.ShaderInstance;
        close(): void;
        static getPositionShader(): Internal.ShaderInstance;
        static getRendertypeGlintShader(): Internal.ShaderInstance;
        reloadShaders(arg0: Internal.ResourceManager_): void;
        static getRendertypeTranslucentMovingBlockShader(): Internal.ShaderInstance;
        setRenderHand(arg0: boolean): void;
        get rendertypeEntityCutoutShader(): Internal.ShaderInstance
        get minecraft(): Internal.Minecraft
        get rendertypeTextIntensityShader(): Internal.ShaderInstance
        get rendertypeEndPortalShader(): Internal.ShaderInstance
        get rendertypeTripwireShader(): Internal.ShaderInstance
        get rendertypeEntityShadowShader(): Internal.ShaderInstance
        get rendertypeCutoutShader(): Internal.ShaderInstance
        get rendertypeEyesShader(): Internal.ShaderInstance
        get positionColorShader(): Internal.ShaderInstance
        get rendertypeTextSeeThroughShader(): Internal.ShaderInstance
        get positionTexColorNormalShader(): Internal.ShaderInstance
        get rendertypeBeaconBeamShader(): Internal.ShaderInstance
        get rendertypeTextIntensitySeeThroughShader(): Internal.ShaderInstance
        get rendertypeLightningShader(): Internal.ShaderInstance
        get rendertypeItemEntityTranslucentCullShader(): Internal.ShaderInstance
        get rendertypeEntitySmoothCutoutShader(): Internal.ShaderInstance
        get rendertypeLeashShader(): Internal.ShaderInstance
        get panoramicMode(): boolean
        set renderBlockOutline(arg0: boolean)
        get rendertypeEntityTranslucentCullShader(): Internal.ShaderInstance
        get positionColorTexLightmapShader(): Internal.ShaderInstance
        get rendertypeArmorCutoutNoCullShader(): Internal.ShaderInstance
        get rendertypeArmorEntityGlintShader(): Internal.ShaderInstance
        set panoramicMode(arg0: boolean)
        get rendertypeTranslucentShader(): Internal.ShaderInstance
        get rendertypeEntityCutoutNoCullShader(): Internal.ShaderInstance
        get rendertypeEntityTranslucentShader(): Internal.ShaderInstance
        get rendertypeEntityDecalShader(): Internal.ShaderInstance
        get rendertypeTextShader(): Internal.ShaderInstance
        get renderDistance(): number
        get particleShader(): Internal.ShaderInstance
        get rendertypeSolidShader(): Internal.ShaderInstance
        get rendertypeEntityNoOutlineShader(): Internal.ShaderInstance
        get positionTexShader(): Internal.ShaderInstance
        get rendertypeWaterMaskShader(): Internal.ShaderInstance
        get rendertypeOutlineShader(): Internal.ShaderInstance
        get rendertypeGlintTranslucentShader(): Internal.ShaderInstance
        get positionTexColorShader(): Internal.ShaderInstance
        get blockShader(): Internal.ShaderInstance
        get depthFar(): number
        get rendertypeLinesShader(): Internal.ShaderInstance
        get rendertypeEntityCutoutNoCullZOffsetShader(): Internal.ShaderInstance
        get rendertypeEntityGlintShader(): Internal.ShaderInstance
        get newEntityShader(): Internal.ShaderInstance
        get name(): string
        get rendertypeCutoutMippedShader(): Internal.ShaderInstance
        get rendertypeArmorGlintShader(): Internal.ShaderInstance
        get positionColorLightmapShader(): Internal.ShaderInstance
        get rendertypeCrumblingShader(): Internal.ShaderInstance
        get rendertypeEndGatewayShader(): Internal.ShaderInstance
        get positionColorTexShader(): Internal.ShaderInstance
        get rendertypeEntityAlphaShader(): Internal.ShaderInstance
        get rendertypeGlintDirectShader(): Internal.ShaderInstance
        get rendertypeEntitySolidShader(): Internal.ShaderInstance
        get mainCamera(): Internal.Camera
        get rendertypeTranslucentNoCrumblingShader(): Internal.ShaderInstance
        get rendertypeEntityGlintDirectShader(): Internal.ShaderInstance
        get mapRenderer(): Internal.MapRenderer
        get positionTexLightmapColorShader(): Internal.ShaderInstance
        get rendertypeEnergySwirlShader(): Internal.ShaderInstance
        get positionShader(): Internal.ShaderInstance
        get rendertypeGlintShader(): Internal.ShaderInstance
        get rendertypeTranslucentMovingBlockShader(): Internal.ShaderInstance
        set renderHand(arg0: boolean)
        readonly static "PROJECTION_Z_NEAR": 0.05;
        readonly static "EFFECT_NONE": 24;
        readonly static "ITEM_ACTIVATION_ANIMATION_LENGTH": 40;
        "blitShader": Internal.ShaderInstance;
        readonly "itemInHandRenderer": Internal.ItemInHandRenderer;
    }
    type GameRenderer_ = GameRenderer;
    class NoiseBasedCountPlacement extends Internal.RepeatingPlacement {
        type(): Internal.PlacementModifierType<any>;
        static of(arg0: number, arg1: number, arg2: number): Internal.NoiseBasedCountPlacement;
        readonly static "CODEC": any;
    }
    type NoiseBasedCountPlacement_ = NoiseBasedCountPlacement;
    class AlterGroundDecorator extends Internal.TreeDecorator {
        constructor(arg0: Internal.BlockStateProvider_)
        place(arg0: Internal.LevelSimulatedReader_, arg1: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>, arg2: Internal.Random_, arg3: Internal.List_<BlockPos_>, arg4: Internal.List_<BlockPos_>): void;
        readonly static "CODEC": any;
    }
    type AlterGroundDecorator_ = AlterGroundDecorator;
    class ModelGenerator$Element {
        constructor()
        box(b: Internal.AABB_): this;
        face(direction: Internal.Direction_, consumer: Internal.Consumer_<Internal.ModelGenerator$Face_>): void;
        toJson(): Internal.JsonObject;
    }
    type ModelGenerator$Element_ = ModelGenerator$Element;
    class Field extends Internal.AccessibleObject implements Internal.Member {
        getModifiers(): number;
        set(arg0: any, arg1: any): void;
        setShort(arg0: any, arg1: number): void;
        getType(): Internal.Class<any>;
        getChar(arg0: any): string;
        getInt(arg0: any): number;
        getName(): string;
        getLong(arg0: any): number;
        setDouble(arg0: any, arg1: number): void;
        getAnnotatedType(): Internal.AnnotatedType;
        getDeclaredAnnotations(): Internal.Annotation[];
        getGenericType(): Internal.Type;
        getShort(arg0: any): number;
        isEnumConstant(): boolean;
        getAnnotationsByType(arg0: Internal.Class_<T>): T[];
        setAccessible(arg0: boolean): void;
        setInt(arg0: any, arg1: number): void;
        getFloat(arg0: any): number;
        toString(): string;
        setByte(arg0: any, arg1: number): void;
        isSynthetic(): boolean;
        getBoolean(arg0: any): boolean;
        getAnnotation(arg0: Internal.Class_<T>): T;
        setFloat(arg0: any, arg1: number): void;
        setBoolean(arg0: any, arg1: boolean): void;
        getDeclaringClass(): Internal.Class<any>;
        getByte(arg0: any): number;
        hashCode(): number;
        toGenericString(): string;
        setChar(arg0: any, arg1: string): void;
        getDouble(arg0: any): number;
        equals(arg0: any): boolean;
        get(arg0: any): any;
        setLong(arg0: any, arg1: number): void;
        get modifiers(): number
        get type(): Internal.Class<any>
        get name(): string
        get annotatedType(): Internal.AnnotatedType
        get declaredAnnotations(): Internal.Annotation[]
        get genericType(): Internal.Type
        get enumConstant(): boolean
        set accessible(arg0: boolean)
        get synthetic(): boolean
        get declaringClass(): Internal.Class<any>
    }
    type Field_ = Field;
    interface ReferenceCounted {
        touch(arg0: any): this;
        retain(): this;
        release(arg0: number): boolean;
        touch(): this;
        refCnt(): number;
        release(): boolean;
        retain(arg0: number): this;
    }
    type ReferenceCounted_ = ReferenceCounted;
    class ItemRenderer implements Internal.ResourceManagerReloadListener {
        constructor(arg0: Internal.TextureManager_, arg1: Internal.ModelManager_, arg2: Internal.ItemColors_, arg3: Internal.BlockEntityWithoutLevelRenderer_)
        static getArmorFoilBuffer(arg0: Internal.MultiBufferSource_, arg1: Internal.RenderType_, arg2: boolean, arg3: boolean): Internal.VertexConsumer;
        renderStatic(arg0: Internal.ItemStack_, arg1: Internal.ItemTransforms$TransformType_, arg2: number, arg3: number, arg4: Internal.PoseStack_, arg5: Internal.MultiBufferSource_, arg6: number): void;
        renderModelLists(arg0: Internal.BakedModel_, arg1: Internal.ItemStack_, arg2: number, arg3: number, arg4: Internal.PoseStack_, arg5: Internal.VertexConsumer_): void;
        renderAndDecorateItem(arg0: Internal.ItemStack_, arg1: number, arg2: number): void;
        static getFoilBuffer(arg0: Internal.MultiBufferSource_, arg1: Internal.RenderType_, arg2: boolean, arg3: boolean): Internal.VertexConsumer;
        onResourceManagerReload(arg0: Internal.ResourceManager_): void;
        render(arg0: Internal.ItemStack_, arg1: Internal.ItemTransforms$TransformType_, arg2: boolean, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number, arg6: number, arg7: Internal.BakedModel_): void;
        getBlockEntityRenderer(): Internal.BlockEntityWithoutLevelRenderer;
        static getFoilBufferDirect(arg0: Internal.MultiBufferSource_, arg1: Internal.RenderType_, arg2: boolean, arg3: boolean): Internal.VertexConsumer;
        renderAndDecorateItem(arg0: Internal.ItemStack_, arg1: number, arg2: number, arg3: number, arg4: number): void;
        renderAndDecorateItem(arg0: Internal.ItemStack_, arg1: number, arg2: number, arg3: number): void;
        getModel(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.LivingEntity_, arg3: number): Internal.BakedModel;
        renderGuiItemDecorations(arg0: Internal.Font_, arg1: Internal.ItemStack_, arg2: number, arg3: number): void;
        renderQuadList(arg0: Internal.PoseStack_, arg1: Internal.VertexConsumer_, arg2: Internal.List_<Internal.BakedQuad_>, arg3: Internal.ItemStack_, arg4: number, arg5: number): void;
        getName(): string;
        renderGuiItemDecorations(arg0: Internal.Font_, arg1: Internal.ItemStack_, arg2: number, arg3: number, arg4: string): void;
        static getCompassFoilBufferDirect(arg0: Internal.MultiBufferSource_, arg1: Internal.RenderType_, arg2: Internal.PoseStack$Pose_): Internal.VertexConsumer;
        renderStatic(arg0: Internal.LivingEntity_, arg1: Internal.ItemStack_, arg2: Internal.ItemTransforms$TransformType_, arg3: boolean, arg4: Internal.PoseStack_, arg5: Internal.MultiBufferSource_, arg6: Internal.Level_, arg7: number, arg8: number, arg9: number): void;
        static getCompassFoilBuffer(arg0: Internal.MultiBufferSource_, arg1: Internal.RenderType_, arg2: Internal.PoseStack$Pose_): Internal.VertexConsumer;
        renderAndDecorateItem(arg0: Internal.LivingEntity_, arg1: Internal.ItemStack_, arg2: number, arg3: number, arg4: number): void;
        getItemModelShaper(): Internal.ItemModelShaper;
        renderAndDecorateFakeItem(arg0: Internal.ItemStack_, arg1: number, arg2: number): void;
        renderGuiItem(arg0: Internal.ItemStack_, arg1: number, arg2: number): void;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        get blockEntityRenderer(): Internal.BlockEntityWithoutLevelRenderer
        get name(): string
        get itemModelShaper(): Internal.ItemModelShaper
        readonly static "COMPASS_FOIL_UI_SCALE": 0.5;
        readonly static "COMPASS_FOIL_FIRST_PERSON_SCALE": 0.75;
        readonly static "ITEM_COUNT_BLIT_OFFSET": 200;
        "blitOffset": number;
        readonly static "ENCHANT_GLINT_LOCATION": ResourceLocation;
    }
    type ItemRenderer_ = ItemRenderer;
    class StructureTemplate$Palette {
        blocks(): Internal.List<Internal.StructureTemplate$StructureBlockInfo>;
        blocks(arg0: Internal.Block_): Internal.List<Internal.StructureTemplate$StructureBlockInfo>;
    }
    type StructureTemplate$Palette_ = StructureTemplate$Palette;
    interface IntList extends Internal.Comparable<Internal.List<any>>, Internal.List<number>, Internal.IntCollection {
        addElements(arg0: number, arg1: number[], arg2: number, arg3: number): void;
        stream(): Internal.Stream<number>;
        subList(arg0: number, arg1: number): this;
        get(arg0: number): number;
        add(arg0: number, arg1: any): void;
        unstableSort(arg0: Internal.IntComparator_): void;
        of(): this;
        intStream(): Internal.IntStream;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        intParallelStream(): Internal.IntStream;
        intIterator(): Internal.IntIterator;
        set(arg0: number, arg1: number): number;
        listIterator(): Internal.ListIterator<any>;
        size(arg0: number): void;
        removeIf(arg0: Internal.IntPredicate_): boolean;
        of(arg0: number, arg1: number): this;
        indexOf(arg0: number): number;
        indexOf(arg0: any): number;
        getElements(arg0: number, arg1: number[], arg2: number, arg3: number): void;
        of(arg0: number, arg1: number, arg2: number): this;
        addElements(arg0: number, arg1: number[]): void;
        add(arg0: number): boolean;
        toIntArray(arg0: number[]): number[];
        remove(arg0: any): boolean;
        of(arg0: number): this;
        sort(arg0: Internal.Comparator_<any>): void;
        replaceAll(arg0: Internal.UnaryOperator_<number>): void;
        lastIndexOf(arg0: number): number;
        add(arg0: any): boolean;
        addAll(arg0: number, arg1: Internal.IntCollection_): boolean;
        spliterator(): Internal.Spliterator<any>;
        unstableSort(arg0: Internal.Comparator_<any>): void;
        set(arg0: number, arg1: number): number;
        set(arg0: number, arg1: any): any;
        lastIndexOf(arg0: any): number;
        addAll(arg0: Internal.IntList_): boolean;
        removeElements(arg0: number, arg1: number): void;
        remove(arg0: number): any;
        forEach(arg0: Internal.Consumer_<any>): void;
        iterator(): Internal.IntListIterator;
        add(arg0: number): boolean;
        sort(arg0: Internal.IntComparator_): void;
        forEach(arg0: Internal.IntConsumer_): void;
        listIterator(arg0: number): Internal.ListIterator<any>;
        addAll(arg0: number, arg1: Internal.IntList_): boolean;
        setElements(arg0: number, arg1: number[]): void;
        add(arg0: number, arg1: number): void;
        getInt(arg0: number): number;
        removeInt(arg0: number): number;
        add(arg0: number, arg1: number): void;
        contains(arg0: any): boolean;
        setElements(arg0: number[]): void;
        forEach(arg0: it.unimi.dsi.fastutil.ints.IntConsumer_): void;
        parallelStream(): Internal.Stream<number>;
        replaceAll(arg0: Internal.IntUnaryOperator_): void;
        replaceAll(arg0: it.unimi.dsi.fastutil.ints.IntUnaryOperator_): void;
        of(...arg0: number[]): this;
        removeIf(arg0: it.unimi.dsi.fastutil.ints.IntPredicate_): boolean;
        intSpliterator(): Internal.IntSpliterator;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        setElements(arg0: number, arg1: number[], arg2: number, arg3: number): void;
        set elements(arg0: number[])
    }
    type IntList_ = IntList;
    interface Long2ReferenceFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.LongFunction<V> {
        andThenReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Long2ReferenceFunction<T>;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Long2ShortFunction;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2ReferenceFunction<V>;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Long2ByteFunction;
        getOrDefault(arg0: any, arg1: V): V;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Long2LongFunction;
        remove(arg0: number): V;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Long2DoubleFunction;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Long2CharFunction;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2ReferenceFunction<V>;
        put(arg0: number, arg1: V): V;
        composeObject(arg0: Internal.Object2LongFunction_<any>): Internal.Object2ReferenceFunction<T, V>;
        apply(arg0: number): V;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2ReferenceFunction<V>;
        put(arg0: number, arg1: V): V;
        get(arg0: any): V;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): V;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2ReferenceFunction<V>;
        apply(arg0: number): V;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2ReferenceFunction<V>;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Long2IntFunction;
        containsKey(arg0: number): boolean;
        composeLong(arg0: Internal.Long2LongFunction_): this;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Long2FloatFunction;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2ReferenceFunction<V>;
        get(arg0: number): V;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        size(): number;
        andThenObject(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Long2ObjectFunction<T>;
        clear(): void;
        composeReference(arg0: Internal.Reference2LongFunction_<any>): Internal.Reference2ReferenceFunction<T, V>;
        defaultReturnValue(): V;
        getOrDefault(arg0: number, arg1: V): V;
        defaultReturnValue(arg0: V): void;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
    }
    type Long2ReferenceFunction_<V> = ((arg0: number)=>V) | Long2ReferenceFunction<V>;
    interface Palette$Factory {
        create(arg0: number, arg1: Internal.IdMap_<A>, arg2: Internal.PaletteResize_<A>, arg3: Internal.List_<A>): Internal.Palette<A>;
    }
    type Palette$Factory_ = Palette$Factory;
    class MaterialJS {
        constructor(i: string, m: Internal.Material_, s: Internal.SoundType_)
        getMinecraftMaterial(): Internal.Material;
        getSound(): Internal.SoundType;
        getId(): string;
        get minecraftMaterial(): Internal.Material
        get sound(): Internal.SoundType
        get id(): string
    }
    type MaterialJS_ = "spore_blossom" | "grass" | "dripstone" | "berry_bush" | "slime" | "ice" | "gilded_blackstone" | "ancient_debris" | "netherite" | "snow" | "small_amethyst_bud" | "amethyst_cluster" | "moss_carpet" | "stone" | "amethyst" | "dragon_egg" | "crop" | "glow_lichen" | "anvil" | "hanging_roots" | "cake" | "nether_wart" | "dirt" | "nether_sprouts" | MaterialJS | "powder_snow" | "honey" | "air" | "small_dripleaf" | "pointed_dripstone" | "nether_ore" | "kelp" | "sand" | "water" | "glass" | "azalea_leaves" | "tuff" | "metal" | "rooted_dirt" | "lava" | "soul_sand" | "moss" | "chain" | "deepslate" | "cave_vines" | "twisting_vines" | "deepslate_bricks" | "sculk_sensor" | "nylium" | "leaves" | "clay" | "netherrack" | "medium_amethyst_bud" | "basalt" | "portal" | "vegetable" | "azalea" | "scaffolding" | "soul_soil" | "big_dripleaf" | "bone" | "vine" | "flowering_azalea" | "sponge" | "lodestone" | "polished_deepslate" | "coral" | "web" | "nether_bricks" | "lantern" | "candle" | "sea_grass" | "calcite" | "weeping_vines" | "plant" | "wart_block" | "nether_gold_ore" | "bamboo_sapling" | "wool" | "deepslate_tiles" | "bamboo" | "shroomlight" | "large_amethyst_bud" | "wood" | "explosive" | "hard_crop" | "copper" | "roots";
    class PlayerAdvancements {
        constructor(arg0: Internal.DataFixer_, arg1: Internal.PlayerList_, arg2: Internal.ServerAdvancementManager_, arg3: Internal.File_, arg4: Internal.ServerPlayer_)
        setPlayer(arg0: Internal.ServerPlayer_): void;
        revoke(arg0: Internal.Advancement_, arg1: string): boolean;
        getOrStartProgress(arg0: Internal.Advancement_): Internal.AdvancementProgress;
        setSelectedTab(arg0: Internal.Advancement_): void;
        award(arg0: Internal.Advancement_, arg1: string): boolean;
        stopListening(): void;
        flushDirty(arg0: Internal.ServerPlayer_): void;
        save(): void;
        reload(arg0: Internal.ServerAdvancementManager_): void;
        set player(arg0: Internal.ServerPlayer_)
        set selectedTab(arg0: Internal.Advancement_)
    }
    type PlayerAdvancements_ = PlayerAdvancements;
    class ClientboundBossEventPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        static createAddPacket(arg0: Internal.BossEvent_): Internal.ClientboundBossEventPacket;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        static createUpdatePropertiesPacket(arg0: Internal.BossEvent_): Internal.ClientboundBossEventPacket;
        dispatch(arg0: Internal.ClientboundBossEventPacket$Handler_): void;
        static createUpdateStylePacket(arg0: Internal.BossEvent_): Internal.ClientboundBossEventPacket;
        static createUpdateProgressPacket(arg0: Internal.BossEvent_): Internal.ClientboundBossEventPacket;
        static createRemovePacket(arg0: Internal.UUID_): Internal.ClientboundBossEventPacket;
        static createUpdateNamePacket(arg0: Internal.BossEvent_): Internal.ClientboundBossEventPacket;
        isSkippable(): boolean;
        get skippable(): boolean
    }
    type ClientboundBossEventPacket_ = ClientboundBossEventPacket;
    abstract class SimplePreparableReloadListener <T> implements Internal.PreparableReloadListener {
        constructor()
        getName(): string;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        get name(): string
    }
    type SimplePreparableReloadListener_<T> = SimplePreparableReloadListener<T>;
    interface Runnable {
        run(): void;
    }
    type Runnable_ = Runnable | (()=>void);
    class IntArrayTag extends Internal.CollectionTag<Internal.IntTag> {
        constructor(arg0: Internal.List_<number>)
        constructor(arg0: number[])
        remove(arg0: number): any;
        add(arg0: number, arg1: Internal.IntTag_): void;
        set(arg0: number, arg1: Internal.Tag_): Internal.Tag;
        forEach(arg0: Internal.Consumer_<any>): void;
        addTag(arg0: number, arg1: Internal.Tag_): boolean;
        spliterator(): Internal.Spliterator<Internal.IntTag>;
        getAsIntArray(): number[];
        add(arg0: number, arg1: any): void;
        replaceAll(arg0: Internal.UnaryOperator_<Internal.IntTag_>): void;
        setTag(arg0: number, arg1: Internal.Tag_): boolean;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        stream(): Internal.Stream<Internal.IntTag>;
        set(arg0: number, arg1: Internal.IntTag_): Internal.IntTag;
        write(arg0: Internal.DataOutput_): void;
        getId(): number;
        get(arg0: number): Internal.IntTag;
        getType(): Internal.TagType<Internal.IntArrayTag>;
        toString(): string;
        accept(arg0: Internal.TagVisitor_): void;
        add(arg0: number, arg1: Internal.Tag_): void;
        sort(arg0: Internal.Comparator_<any>): void;
        getAsString(): string;
        size(): number;
        hashCode(): number;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        clear(): void;
        parallelStream(): Internal.Stream<Internal.IntTag>;
        equals(arg0: any): boolean;
        copy(): this;
        accept(arg0: Internal.StreamTagVisitor_): Internal.StreamTagVisitor$ValueResult;
        set(arg0: number, arg1: any): any;
        getElementType(): number;
        get asIntArray(): number[]
        get id(): number
        get type(): Internal.TagType<Internal.IntArrayTag>
        get asString(): string
        get elementType(): number
        readonly static "TYPE": any;
    }
    type IntArrayTag_ = IntArrayTag;
    class FluidAttributes {
        getStillTexture(arg0: Internal.FluidStack_): ResourceLocation;
        doesVaporize(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.FluidStack_): boolean;
        getStillTexture(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): ResourceLocation;
        getOverlayTexture(): ResourceLocation;
        getFlowingTexture(): ResourceLocation;
        isGaseous(): boolean;
        getDensity(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): number;
        getLuminosity(): number;
        getEmptySound(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): Internal.SoundEvent;
        getColor(): number;
        getDensity(arg0: Internal.FluidStack_): number;
        isGaseous(arg0: Internal.FluidStack_): boolean;
        getDensity(): number;
        isGaseous(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): boolean;
        getTemperature(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): number;
        getTextures(): Internal.Stream<ResourceLocation>;
        getEmptySound(arg0: Internal.FluidStack_): Internal.SoundEvent;
        getTemperature(arg0: Internal.FluidStack_): number;
        canBePlacedInWorld(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.FluidStack_): boolean;
        getBlock(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.FluidState_): Internal.BlockState;
        getRarity(): Rarity;
        getStillTexture(): ResourceLocation;
        getTranslationKey(arg0: Internal.FluidStack_): string;
        vaporize(arg0: Internal.Player_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.FluidStack_): void;
        getFlowingTexture(arg0: Internal.FluidStack_): ResourceLocation;
        getFlowingTexture(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): ResourceLocation;
        isLighterThanAir(): boolean;
        getDisplayName(arg0: Internal.FluidStack_): Internal.Component;
        getViscosity(arg0: Internal.FluidStack_): number;
        getTranslationKey(): string;
        getRarity(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): Rarity;
        getStateForPlacement(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.FluidStack_): Internal.FluidState;
        getBucket(arg0: Internal.FluidStack_): Internal.ItemStack;
        getFillSound(): Internal.SoundEvent;
        getViscosity(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): number;
        getRarity(arg0: Internal.FluidStack_): Rarity;
        static builder(arg0: ResourceLocation_, arg1: ResourceLocation_): Internal.FluidAttributes$Builder;
        getColor(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): number;
        getColor(arg0: Internal.FluidStack_): number;
        canBePlacedInWorld(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.FluidState_): boolean;
        getFillSound(arg0: Internal.FluidStack_): Internal.SoundEvent;
        getTemperature(): number;
        getEmptySound(): Internal.SoundEvent;
        getLuminosity(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): number;
        getFillSound(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): Internal.SoundEvent;
        getViscosity(): number;
        getLuminosity(arg0: Internal.FluidStack_): number;
        get overlayTexture(): ResourceLocation
        get flowingTexture(): ResourceLocation
        get gaseous(): boolean
        get luminosity(): number
        get color(): number
        get density(): number
        get textures(): Internal.Stream<ResourceLocation>
        get rarity(): Rarity
        get stillTexture(): ResourceLocation
        get lighterThanAir(): boolean
        get translationKey(): string
        get fillSound(): Internal.SoundEvent
        get temperature(): number
        get emptySound(): Internal.SoundEvent
        get viscosity(): number
        readonly static "BUCKET_VOLUME": 1000;
    }
    type FluidAttributes_ = FluidAttributes;
    class SpikeFeature$EndSpike {
        constructor(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean)
        isCenterWithinChunk(arg0: BlockPos_): boolean;
        getRadius(): number;
        getCenterX(): number;
        getTopBoundingBox(): Internal.AABB;
        getCenterZ(): number;
        getHeight(): number;
        isGuarded(): boolean;
        get radius(): number
        get centerX(): number
        get topBoundingBox(): Internal.AABB
        get centerZ(): number
        get height(): number
        get guarded(): boolean
        readonly static "CODEC": any;
    }
    type SpikeFeature$EndSpike_ = SpikeFeature$EndSpike;
    interface Object2FloatMap <K> extends Internal.Map<K, number>, Internal.Object2FloatFunction<K> {
        computeFloatIfAbsentPartial(arg0: K, arg1: Internal.Object2FloatFunction_<any>): number;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Object2CharFunction<K>;
        containsValue(arg0: any): boolean;
        values(): Internal.FloatCollection;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2FloatFunction;
        mergeFloat(arg0: K, arg1: number, arg2: Internal.FloatBinaryOperator_): number;
        removeFloat(arg0: any): number;
        defaultReturnValue(arg0: number): void;
        getOrDefault(arg0: any, arg1: number): number;
        apply(arg0: K): number;
        mergeFloat(arg0: K, arg1: number, arg2: Internal.DoubleBinaryOperator_): number;
        computeFloatIfPresent(arg0: K, arg1: Internal.BiFunction_<any, any, any>): number;
        computeIfAbsent(arg0: K, arg1: Internal.ToDoubleFunction_<any>): number;
        keySet(): Internal.Set<any>;
        replace(arg0: any, arg1: any, arg2: any): boolean;
        andThenReference(arg0: Internal.Float2ReferenceFunction_<any>): Internal.Object2ReferenceFunction<K, T>;
        put(arg0: any, arg1: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        put(arg0: K, arg1: number): number;
        putIfAbsent(arg0: K, arg1: number): number;
        computeFloatIfAbsent(arg0: K, arg1: Internal.ToDoubleFunction_<any>): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2FloatFunction;
        mergeFloat(arg0: K, arg1: number, arg2: Internal.BiFunction_<any, any, any>): number;
        containsValue(arg0: number): boolean;
        getOrDefault(arg0: any, arg1: number): number;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2FloatFunction;
        remove(arg0: any, arg1: number): boolean;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2FloatFunction;
        object2FloatEntrySet(): Internal.ObjectSet<Internal.Object2FloatMap$Entry<K>>;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        computeFloat(arg0: K, arg1: Internal.BiFunction_<any, any, any>): number;
        andThenObject(arg0: Internal.Float2ObjectFunction_<any>): Internal.Object2ObjectFunction<K, T>;
        remove(arg0: any): any;
        replace(arg0: K, arg1: number): number;
        putIfAbsent(arg0: any, arg1: any): any;
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        merge(arg0: K, arg1: number, arg2: Internal.BiFunction_<any, any, any>): number;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Object2ShortFunction<K>;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Object2ByteFunction<K>;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<K, number>>;
        replace(arg0: K, arg1: number, arg2: number): boolean;
        containsKey(arg0: any): boolean;
        computeIfAbsent(arg0: K, arg1: Internal.Object2FloatFunction_<any>): number;
        replaceAll(arg0: Internal.BiFunction_<any, any, any>): void;
        compute(arg0: K, arg1: Internal.BiFunction_<any, any, any>): number;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<any, any, any>): number;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2FloatFunction;
        applyAsDouble(arg0: K): number;
        replace(arg0: K, arg1: number): number;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2FloatFunction;
        defaultReturnValue(): number;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        remove(arg0: any, arg1: any): boolean;
        merge(arg0: K, arg1: number, arg2: Internal.BiFunction_<any, any, any>): number;
        size(): number;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2FloatFunction;
        computeIfAbsent(arg0: K, arg1: Internal.Function_<any, any>): number;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Object2LongFunction<K>;
        clear(): void;
        replace(arg0: any, arg1: any): any;
        merge(arg0: any, arg1: any, arg2: Internal.BiFunction_<any, any, any>): any;
        composeObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Object2FloatFunction<T>;
        replace(arg0: K, arg1: number, arg2: number): boolean;
        put(arg0: K, arg1: number): number;
        putIfAbsent(arg0: K, arg1: number): number;
        composeReference(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Reference2FloatFunction<T>;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Object2IntFunction<K>;
        andThenFloat(arg0: Internal.Float2FloatFunction_): Internal.Object2FloatFunction<K>;
    }
    type Object2FloatMap_<K> = Object2FloatMap<K>;
    class Locale implements Internal.Cloneable, Internal.Serializable {
        constructor(arg0: string, arg1: string, arg2: string)
        constructor(arg0: string, arg1: string)
        constructor(arg0: string)
        getUnicodeLocaleKeys(): Internal.Set<string>;
        clone(): any;
        static filterTags(arg0: Internal.List_<Internal.Locale$LanguageRange_>, arg1: Internal.Collection_<string>, arg2: Internal.Locale$FilteringMode_): Internal.List<string>;
        static getISOLanguages(): string[];
        getExtension(arg0: string): string;
        getUnicodeLocaleType(arg0: string): string;
        getISO3Language(): string;
        getDisplayCountry(): string;
        static getAvailableLocales(): Internal.Locale[];
        static setDefault(arg0: Internal.Locale$Category_, arg1: Internal.Locale_): void;
        getScript(): string;
        getISO3Country(): string;
        getExtensionKeys(): Internal.Set<string>;
        toLanguageTag(): string;
        getDisplayCountry(arg0: Internal.Locale_): string;
        getVariant(): string;
        getDisplayScript(arg0: Internal.Locale_): string;
        static setDefault(arg0: Internal.Locale_): void;
        getDisplayName(): string;
        static filterTags(arg0: Internal.List_<Internal.Locale$LanguageRange_>, arg1: Internal.Collection_<string>): Internal.List<string>;
        getDisplayScript(): string;
        getDisplayLanguage(arg0: Internal.Locale_): string;
        toString(): string;
        static getDefault(arg0: Internal.Locale$Category_): Internal.Locale;
        getDisplayName(arg0: Internal.Locale_): string;
        getCountry(): string;
        static lookupTag(arg0: Internal.List_<Internal.Locale$LanguageRange_>, arg1: Internal.Collection_<string>): string;
        static lookup(arg0: Internal.List_<Internal.Locale$LanguageRange_>, arg1: Internal.Collection_<Internal.Locale_>): Internal.Locale;
        getLanguage(): string;
        static forLanguageTag(arg0: string): Internal.Locale;
        static getISOCountries(): string[];
        getDisplayLanguage(): string;
        static getISOCountries(arg0: Internal.Locale$IsoCountryCode_): Internal.Set<string>;
        getUnicodeLocaleAttributes(): Internal.Set<string>;
        hashCode(): number;
        static getDefault(): Internal.Locale;
        hasExtensions(): boolean;
        stripExtensions(): this;
        static filter(arg0: Internal.List_<Internal.Locale$LanguageRange_>, arg1: Internal.Collection_<Internal.Locale_>): Internal.List<Internal.Locale>;
        static filter(arg0: Internal.List_<Internal.Locale$LanguageRange_>, arg1: Internal.Collection_<Internal.Locale_>, arg2: Internal.Locale$FilteringMode_): Internal.List<Internal.Locale>;
        getDisplayVariant(): string;
        getDisplayVariant(arg0: Internal.Locale_): string;
        equals(arg0: any): boolean;
        get unicodeLocaleKeys(): Internal.Set<string>
        get ISOLanguages(): string[]
        get ISO3Language(): string
        get displayCountry(): string
        get availableLocales(): Internal.Locale[]
        get script(): string
        get ISO3Country(): string
        get extensionKeys(): Internal.Set<string>
        get variant(): string
        set default(arg0: Internal.Locale_)
        get displayName(): string
        get displayScript(): string
        get country(): string
        get language(): string
        get ISOCountries(): string[]
        get displayLanguage(): string
        get unicodeLocaleAttributes(): Internal.Set<string>
        get default(): Internal.Locale
        get displayVariant(): string
        readonly static "UNICODE_LOCALE_EXTENSION": "u";
        readonly static "JAPANESE": Internal.Locale;
        readonly static "KOREAN": Internal.Locale;
        readonly static "PRIVATE_USE_EXTENSION": "x";
        readonly static "PRC": Internal.Locale;
        readonly static "UK": Internal.Locale;
        readonly static "ITALY": Internal.Locale;
        readonly static "ROOT": Internal.Locale;
        readonly static "CANADA": Internal.Locale;
        readonly static "GERMANY": Internal.Locale;
        readonly static "US": Internal.Locale;
        readonly static "SIMPLIFIED_CHINESE": Internal.Locale;
        readonly static "ITALIAN": Internal.Locale;
        readonly static "CHINESE": Internal.Locale;
        readonly static "ENGLISH": Internal.Locale;
        readonly static "KOREA": Internal.Locale;
        readonly static "GERMAN": Internal.Locale;
        readonly static "JAPAN": Internal.Locale;
        readonly static "FRANCE": Internal.Locale;
        readonly static "CHINA": Internal.Locale;
        readonly static "TRADITIONAL_CHINESE": Internal.Locale;
        readonly static "CANADA_FRENCH": Internal.Locale;
        readonly static "TAIWAN": Internal.Locale;
        readonly static "FRENCH": Internal.Locale;
    }
    type Locale_ = Locale;
    class RenderRegionCache {
        constructor()
        createRegion(arg0: Internal.Level_, arg1: BlockPos_, arg2: BlockPos_, arg3: number): Internal.RenderChunkRegion;
    }
    type RenderRegionCache_ = RenderRegionCache;
    interface PrimitiveIterator$OfInt extends Internal.PrimitiveIterator<number, Internal.IntConsumer> {
        forEachRemaining(arg0: any): void;
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): any;
        forEachRemaining(arg0: Internal.IntConsumer_): void;
        nextInt(): number;
    }
    type PrimitiveIterator$OfInt_ = PrimitiveIterator$OfInt;
    abstract class ImmutableSet <E> extends Internal.ImmutableCollection<E> implements Internal.Set<E> {
        static of(): Internal.ImmutableSet<E>;
        static of(arg0: E): Internal.ImmutableSet<E>;
        static of(arg0: E, arg1: E): Internal.ImmutableSet<E>;
        iterator(): Internal.Iterator<any>;
        static builderWithExpectedSize(arg0: number): Internal.ImmutableSet$Builder<E>;
        static of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): Internal.ImmutableSet<E>;
        forEach(arg0: Internal.Consumer_<any>): void;
        static of(arg0: E, arg1: E, arg2: E, arg3: E): Internal.ImmutableSet<E>;
        parallelStream(): Internal.Stream<E>;
        static of(arg0: E, arg1: E, arg2: E): Internal.ImmutableSet<E>;
        static of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, ...arg6: E[]): Internal.ImmutableSet<E>;
        static copyOf(arg0: Internal.Collection_<any>): Internal.ImmutableSet<E>;
        hashCode(): number;
        static copyOf(arg0: Internal.Iterable_<any>): Internal.ImmutableSet<E>;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        stream(): Internal.Stream<E>;
        static builder(): Internal.ImmutableSet$Builder<E>;
        static copyOf(arg0: E[]): Internal.ImmutableSet<E>;
        static toImmutableSet(): Internal.Collector<E, any, Internal.ImmutableSet<E>>;
        static copyOf(arg0: Internal.Iterator_<any>): Internal.ImmutableSet<E>;
        spliterator(): Internal.Spliterator<E>;
        equals(arg0: any): boolean;
    }
    type ImmutableSet_<E> = ImmutableSet<E>;
    interface IMinecartCollisionHandler {
        getMinecartCollisionBox(arg0: Internal.AbstractMinecart_): Internal.AABB;
        getCollisionBox(arg0: Internal.AbstractMinecart_, arg1: Internal.Entity_): Internal.AABB;
        getBoundingBox(arg0: Internal.AbstractMinecart_): Internal.AABB;
        onEntityCollision(arg0: Internal.AbstractMinecart_, arg1: Internal.Entity_): void;
    }
    type IMinecartCollisionHandler_ = IMinecartCollisionHandler;
    interface Decoder$Boxed <A> {
        decode(arg0: Internal.Dynamic_<T>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>;
        decoder(): Internal.Decoder<A>;
    }
    type Decoder$Boxed_<A> = Decoder$Boxed<A>;
    class AdultSensor extends Internal.Sensor<Internal.AgeableMob> {
        constructor()
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
    }
    type AdultSensor_ = AdultSensor;
    class Configuration {
        resolveAndBind(arg0: Internal.ModuleFinder_, arg1: Internal.ModuleFinder_, arg2: Internal.Collection_<string>): this;
        static resolve(arg0: Internal.ModuleFinder_, arg1: Internal.List_<Internal.Configuration_>, arg2: Internal.ModuleFinder_, arg3: Internal.Collection_<string>): Internal.Configuration;
        toString(): string;
        parents(): Internal.List<Internal.Configuration>;
        modules(): Internal.Set<Internal.ResolvedModule>;
        resolve(arg0: Internal.ModuleFinder_, arg1: Internal.ModuleFinder_, arg2: Internal.Collection_<string>): this;
        static resolveAndBind(arg0: Internal.ModuleFinder_, arg1: Internal.List_<Internal.Configuration_>, arg2: Internal.ModuleFinder_, arg3: Internal.Collection_<string>): Internal.Configuration;
        static empty(): Internal.Configuration;
        findModule(arg0: string): Internal.Optional<Internal.ResolvedModule>;
    }
    type Configuration_ = Configuration;
    interface IForgeBucketPickup {
        getPickupSound(arg0: Internal.BlockState_): Internal.Optional<Internal.SoundEvent>;
    }
    type IForgeBucketPickup_ = IForgeBucketPickup;
    interface GameEventDispatcher {
        unregister(arg0: Internal.GameEventListener_): void;
        isEmpty(): boolean;
        post(arg0: Internal.GameEvent_, arg1: Internal.Entity_, arg2: BlockPos_): void;
        register(arg0: Internal.GameEventListener_): void;
        get empty(): boolean
        readonly static "NOOP": any;
    }
    type GameEventDispatcher_ = GameEventDispatcher;
    class VariableSet implements Internal.UnitVariables {
        constructor()
        setMutable(name: string, initialValue: number): Internal.MutableNumberUnit;
        createSubset(): this;
        get(entry: string): Internal.Unit;
        set(name: string, value: Internal.Unit_): this;
        getVariables(): this;
        set(name: string, value: number): this;
        get variables(): Internal.VariableSet
    }
    type VariableSet_ = VariableSet;
    class TypedOptic <S, T, A, B> {
        constructor(arg0: Internal.TypeToken_<any>, arg1: com.mojang.datafixers.types.Type_<S>, arg2: com.mojang.datafixers.types.Type_<T>, arg3: com.mojang.datafixers.types.Type_<A>, arg4: com.mojang.datafixers.types.Type_<B>, arg5: Internal.Optic_<any, S, T, A, B>)
        constructor(arg0: Internal.Set_<Internal.TypeToken_<any>>, arg1: com.mojang.datafixers.types.Type_<S>, arg2: com.mojang.datafixers.types.Type_<T>, arg3: com.mojang.datafixers.types.Type_<A>, arg4: com.mojang.datafixers.types.Type_<B>, arg5: Internal.Optic_<any, S, T, A, B>)
        aType(): com.mojang.datafixers.types.Type<A>;
        static tagged(arg0: Internal.TaggedChoice$TaggedChoiceType_<K>, arg1: K, arg2: com.mojang.datafixers.types.Type_<A>, arg3: com.mojang.datafixers.types.Type_<B>): Internal.TypedOptic<com.mojang.datafixers.util.Pair<K, any>, com.mojang.datafixers.util.Pair<K, any>, A, B>;
        bounds(): Internal.Set<Internal.TypeToken<any>>;
        static compoundListKeys(arg0: com.mojang.datafixers.types.Type_<K>, arg1: com.mojang.datafixers.types.Type_<K2>, arg2: com.mojang.datafixers.types.Type_<V>): Internal.TypedOptic<Internal.List<com.mojang.datafixers.util.Pair<K, V>>, Internal.List<com.mojang.datafixers.util.Pair<K2, V>>, K, K2>;
        static inj2(arg0: com.mojang.datafixers.types.Type_<F>, arg1: com.mojang.datafixers.types.Type_<G>, arg2: com.mojang.datafixers.types.Type_<G2>): Internal.TypedOptic<Internal.Either<F, G>, Internal.Either<F, G2>, G, G2>;
        tType(): com.mojang.datafixers.types.Type<T>;
        compose(arg0: Internal.TypedOptic_<A, B, A1, B1>): Internal.TypedOptic<S, T, A1, B1>;
        upCast(arg0: Internal.TypeToken_<Proof2>): Internal.Optional<Internal.Optic<any, S, T, A, B>>;
        optic(): Internal.Optic<any, S, T, A, B>;
        static instanceOf(arg0: Internal.Collection_<Internal.TypeToken_<any>>, arg1: Internal.TypeToken_<Proof2>): boolean;
        static proj2(arg0: com.mojang.datafixers.types.Type_<F>, arg1: com.mojang.datafixers.types.Type_<G>, arg2: com.mojang.datafixers.types.Type_<G2>): Internal.TypedOptic<com.mojang.datafixers.util.Pair<F, G>, com.mojang.datafixers.util.Pair<F, G2>, G, G2>;
        apply(arg0: Internal.TypeToken_<Proof2>, arg1: Internal.App_<Proof2, P>, arg2: Internal.App2_<P, A, B>): Internal.App2<P, S, T>;
        sType(): com.mojang.datafixers.types.Type<S>;
        static proj1(arg0: com.mojang.datafixers.types.Type_<F>, arg1: com.mojang.datafixers.types.Type_<G>, arg2: com.mojang.datafixers.types.Type_<F2>): Internal.TypedOptic<com.mojang.datafixers.util.Pair<F, G>, com.mojang.datafixers.util.Pair<F2, G>, F, F2>;
        static compoundListElements(arg0: com.mojang.datafixers.types.Type_<K>, arg1: com.mojang.datafixers.types.Type_<V>, arg2: com.mojang.datafixers.types.Type_<V2>): Internal.TypedOptic<Internal.List<com.mojang.datafixers.util.Pair<K, V>>, Internal.List<com.mojang.datafixers.util.Pair<K, V2>>, V, V2>;
        static adapter(arg0: com.mojang.datafixers.types.Type_<S>, arg1: com.mojang.datafixers.types.Type_<T>): Internal.TypedOptic<S, T, S, T>;
        bType(): com.mojang.datafixers.types.Type<B>;
        static list(arg0: com.mojang.datafixers.types.Type_<A>, arg1: com.mojang.datafixers.types.Type_<B>): Internal.TypedOptic<Internal.List<A>, Internal.List<B>, A, B>;
        static inj1(arg0: com.mojang.datafixers.types.Type_<F>, arg1: com.mojang.datafixers.types.Type_<G>, arg2: com.mojang.datafixers.types.Type_<F2>): Internal.TypedOptic<Internal.Either<F, G>, Internal.Either<F2, G>, F, F2>;
    }
    type TypedOptic_<S, T, A, B> = TypedOptic<S, T, A, B>;
    class ItemEntity extends Internal.Entity {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number, arg4: Internal.ItemStack_)
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number, arg4: Internal.ItemStack_, arg5: number, arg6: number, arg7: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static areMergable(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        setNeverPickUp(): void;
        setExtendedLifetime(): void;
        copy(): this;
        setPickUpDelay(arg0: number): void;
        setNoPickUpDelay(): void;
        playerTouch(arg0: Internal.Player_): void;
        getStepHeight(): number;
        getSpin(arg0: number): number;
        asKJS(): Internal.EntityJS;
        getThrower(): Internal.UUID;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        static merge(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: number): Internal.ItemStack;
        getAddEntityPacket(): Internal.Packet<any>;
        canRiderInteract(): boolean;
        getSoundSource(): Internal.SoundSource;
        setItem(arg0: Internal.ItemStack_): void;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        fireImmune(): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        setThrower(arg0: Internal.UUID_): void;
        hasPickUpDelay(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getName(): Internal.Component;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        makeFakeItem(): void;
        getItem(): Internal.ItemStack;
        setOwner(arg0: Internal.UUID_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getOwner(): Internal.UUID;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        occludesVibrations(): boolean;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getAge(): number;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        setDefaultPickUpDelay(): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        setUnlimitedLifetime(): void;
        isAttackable(): boolean;
        set pickUpDelay(arg0: number)
        get stepHeight(): number
        get thrower(): Internal.UUID
        get addEntityPacket(): Internal.Packet<any>
        get soundSource(): Internal.SoundSource
        set item(arg0: Internal.ItemStack_)
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        set thrower(arg0: Internal.UUID_)
        get name(): Internal.Component
        get item(): Internal.ItemStack
        set owner(arg0: Internal.UUID_)
        get owner(): Internal.UUID
        get age(): number
        get attackable(): boolean
        "lifespan": number;
        readonly "bobOffs": number;
        readonly static "LIFETIME": 6000;
        "age": number;
    }
    type ItemEntity_ = ItemEntity;
    class PlacementContext extends Internal.WorldGenerationContext {
        constructor(arg0: Internal.WorldGenLevel_, arg1: Internal.ChunkGenerator_, arg2: Internal.Optional_<Internal.PlacedFeature_>)
        generator(): Internal.ChunkGenerator;
        getHeight(arg0: Internal.Heightmap$Types_, arg1: number, arg2: number): number;
        getMinBuildHeight(): number;
        topFeature(): Internal.Optional<Internal.PlacedFeature>;
        getBlockState(arg0: BlockPos_): Internal.BlockState;
        getLevel(): Internal.WorldGenLevel;
        getCarvingMask(arg0: Internal.ChunkPos_, arg1: CarvingGenerationStep_): Internal.CarvingMask;
        get minBuildHeight(): number
        get level(): Internal.WorldGenLevel
    }
    type PlacementContext_ = PlacementContext;
    abstract class NodeEvaluator {
        constructor()
        getBlockPathType(arg0: Internal.BlockGetter_, arg1: number, arg2: number, arg3: number, arg4: Internal.Mob_, arg5: number, arg6: number, arg7: number, arg8: boolean, arg9: boolean): Internal.BlockPathTypes;
        canOpenDoors(): boolean;
        canPassDoors(): boolean;
        canFloat(): boolean;
        setCanOpenDoors(arg0: boolean): void;
        getNeighbors(arg0: Internal.Node_[], arg1: Internal.Node_): number;
        setCanFloat(arg0: boolean): void;
        prepare(arg0: Internal.PathNavigationRegion_, arg1: Internal.Mob_): void;
        setCanPassDoors(arg0: boolean): void;
        getGoal(arg0: number, arg1: number, arg2: number): Internal.Target;
        getBlockPathType(arg0: Internal.BlockGetter_, arg1: number, arg2: number, arg3: number): Internal.BlockPathTypes;
        getStart(): Internal.Node;
        done(): void;
        set canOpenDoors(arg0: boolean)
        set canFloat(arg0: boolean)
        set canPassDoors(arg0: boolean)
        get start(): Internal.Node
    }
    type NodeEvaluator_ = NodeEvaluator;
    class RenderStateShard$EmptyTextureStateShard extends Internal.RenderStateShard {
        constructor(arg0: Internal.Runnable_, arg1: Internal.Runnable_)
    }
    type RenderStateShard$EmptyTextureStateShard_ = RenderStateShard$EmptyTextureStateShard;
    class RenderType$CompositeState {
        toString(): string;
        static builder(): Internal.RenderType$CompositeState$CompositeStateBuilder;
    }
    type RenderType$CompositeState_ = RenderType$CompositeState;
    class StructureSpawnOverride$BoundingBoxType extends Internal.Enum<Internal.StructureSpawnOverride$BoundingBoxType> implements Internal.StringRepresentable {
        static byName(arg0: string): Internal.StructureSpawnOverride$BoundingBoxType;
        static values(): Internal.StructureSpawnOverride$BoundingBoxType[];
        getSerializedName(): string;
        static valueOf(arg0: string): Internal.StructureSpawnOverride$BoundingBoxType;
        get serializedName(): string
        readonly static "STRUCTURE": Internal.StructureSpawnOverride$BoundingBoxType;
        readonly static "VALUES": any;
        readonly static "CODEC": any;
        readonly static "PIECE": Internal.StructureSpawnOverride$BoundingBoxType;
    }
    type StructureSpawnOverride$BoundingBoxType_ = StructureSpawnOverride$BoundingBoxType | "structure" | "piece";
    class RecordCodecBuilder <O, F> implements Internal.App<Internal.RecordCodecBuilder$Mu<O>, F> {
        static create(arg0: Internal.Function_<Internal.RecordCodecBuilder$Instance_<O>, any>): Internal.Codec<O>;
        static unbox(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, F>): Internal.RecordCodecBuilder<O, F>;
        static stable(arg0: F): Internal.RecordCodecBuilder<O, F>;
        static deprecated(arg0: F, arg1: number): Internal.RecordCodecBuilder<O, F>;
        static of(arg0: Internal.Function_<O, F>, arg1: string, arg2: Internal.Codec_<F>): Internal.RecordCodecBuilder<O, F>;
        static build(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, O>): Internal.MapCodec<O>;
        static instance(): Internal.RecordCodecBuilder$Instance<O>;
        static point(arg0: F, arg1: Internal.Lifecycle_): Internal.RecordCodecBuilder<O, F>;
        dependent(arg0: Internal.Function_<O, E>, arg1: Internal.MapEncoder_<E>, arg2: Internal.Function_<any, any>): Internal.RecordCodecBuilder<O, E>;
        static mapCodec(arg0: Internal.Function_<Internal.RecordCodecBuilder$Instance_<O>, any>): Internal.MapCodec<O>;
        static of(arg0: Internal.Function_<O, F>, arg1: Internal.MapCodec_<F>): Internal.RecordCodecBuilder<O, F>;
        static point(arg0: F): Internal.RecordCodecBuilder<O, F>;
    }
    type RecordCodecBuilder_<O, F> = RecordCodecBuilder<O, F>;
    class ScreenEvent$InitScreenEvent$Pre extends Internal.ScreenEvent$InitScreenEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: Internal.List_<Internal.GuiEventListener_>, arg2: Internal.Consumer_<Internal.GuiEventListener_>, arg3: Internal.Consumer_<Internal.GuiEventListener_>)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$InitScreenEvent$Pre_ = ScreenEvent$InitScreenEvent$Pre;
    interface DoubleComparator extends Internal.Comparator<number> {
        reversed(): this;
        thenComparingInt(arg0: Internal.ToIntFunction_<any>): Internal.Comparator<number>;
        compare(arg0: any, arg1: any): number;
        thenComparing(arg0: Internal.Function_<any, any>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.DoubleComparator_): this;
        thenComparingDouble(arg0: Internal.ToDoubleFunction_<any>): Internal.Comparator<number>;
        compare(arg0: number, arg1: number): number;
        thenComparing(arg0: Internal.Comparator_<any>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.Function_<any, any>, arg1: Internal.Comparator_<any>): Internal.Comparator<number>;
        thenComparingLong(arg0: Internal.ToLongFunction_<any>): Internal.Comparator<number>;
        compare(arg0: number, arg1: number): number;
    }
    type DoubleComparator_ = DoubleComparator | ((arg0: number, arg1: number)=>number);
    interface PostPlacementProcessor {
        afterPlace(arg0: Internal.WorldGenLevel_, arg1: Internal.StructureFeatureManager_, arg2: Internal.ChunkGenerator_, arg3: Internal.Random_, arg4: Internal.BoundingBox_, arg5: Internal.ChunkPos_, arg6: Internal.PiecesContainer_): void;
        readonly static "NONE": any;
    }
    type PostPlacementProcessor_ = ((arg0: Internal.WorldGenLevel, arg1: Internal.StructureFeatureManager, arg2: Internal.ChunkGenerator, arg3: Internal.Random, arg4: Internal.BoundingBox, arg5: Internal.ChunkPos, arg6: Internal.PiecesContainer)=>void) | PostPlacementProcessor;
    class Skeleton extends Internal.AbstractSkeleton {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        isShaking(): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        isFreezeConverting(): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        tick(): void;
        asKJS(): Internal.EntityJS;
        canFreeze(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        setFreezeConverting(arg0: boolean): void;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get shaking(): boolean
        get freezeConverting(): boolean
        get stepHeight(): number
        get multipartEntity(): boolean
        set freezeConverting(arg0: boolean)
        get parts(): Internal.PartEntity<any>[]
        readonly static "CONVERSION_TAG": "StrayConversionTime";
    }
    type Skeleton_ = Skeleton;
    class UserWhiteList extends Internal.StoredUserList<Internal.GameProfile, any> {
        constructor(arg0: Internal.File_)
        isWhiteListed(arg0: Internal.GameProfile_): boolean;
        getUserList(): string[];
        get userList(): string[]
    }
    type UserWhiteList_ = UserWhiteList;
    interface Position {
        z(): number;
        y(): number;
        x(): number;
    }
    type Position_ = Position;
    class OptionalInt {
        static empty(): Internal.OptionalInt;
        toString(): string;
        ifPresentOrElse(arg0: Internal.IntConsumer_, arg1: Internal.Runnable_): void;
        isEmpty(): boolean;
        static of(arg0: number): Internal.OptionalInt;
        getAsInt(): number;
        hashCode(): number;
        isPresent(): boolean;
        orElseThrow(): number;
        orElseGet(arg0: Internal.IntSupplier_): number;
        equals(arg0: any): boolean;
        orElseThrow(arg0: Internal.Supplier_<any>): number;
        stream(): Internal.IntStream;
        orElse(arg0: number): number;
        ifPresent(arg0: Internal.IntConsumer_): void;
        get empty(): boolean
        get asInt(): number
        get present(): boolean
    }
    type OptionalInt_ = OptionalInt;
    abstract class WaterAnimal extends Internal.PathfinderMob {
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getAmbientSoundInterval(): number;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMobType(): Internal.MobType;
        canBeLeashed(arg0: Internal.Player_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        static checkSurfaceWaterAnimalSpawnRules(arg0: Internal.EntityType_<any>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        canBreatheUnderwater(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        baseTick(): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        isPushedByFluid(): boolean;
        serializeNBT(): Internal.Tag;
        checkSpawnObstruction(arg0: Internal.LevelReader_): boolean;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get ambientSoundInterval(): number
        get mobType(): Internal.MobType
        get stepHeight(): number
        get multipartEntity(): boolean
        get pushedByFluid(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type WaterAnimal_ = WaterAnimal;
    class CountPlacement extends Internal.RepeatingPlacement {
        static of(arg0: number): Internal.CountPlacement;
        static of(arg0: Internal.IntProvider_): Internal.CountPlacement;
        type(): Internal.PlacementModifierType<any>;
        readonly static "CODEC": any;
    }
    type CountPlacement_ = CountPlacement;
    class NoteBlockInstrument extends Internal.Enum<Internal.NoteBlockInstrument> implements Internal.StringRepresentable {
        static values(): Internal.NoteBlockInstrument[];
        static valueOf(arg0: string): Internal.NoteBlockInstrument;
        getSerializedName(): string;
        static byState(arg0: Internal.BlockState_): Internal.NoteBlockInstrument;
        getSoundEvent(): Internal.SoundEvent;
        get serializedName(): string
        get soundEvent(): Internal.SoundEvent
        readonly static "XYLOPHONE": Internal.NoteBlockInstrument;
        readonly static "COW_BELL": Internal.NoteBlockInstrument;
        readonly static "HAT": Internal.NoteBlockInstrument;
        readonly static "GUITAR": Internal.NoteBlockInstrument;
        readonly static "PLING": Internal.NoteBlockInstrument;
        readonly static "FLUTE": Internal.NoteBlockInstrument;
        readonly static "CHIME": Internal.NoteBlockInstrument;
        readonly static "BIT": Internal.NoteBlockInstrument;
        readonly static "SNARE": Internal.NoteBlockInstrument;
        readonly static "BANJO": Internal.NoteBlockInstrument;
        readonly static "IRON_XYLOPHONE": Internal.NoteBlockInstrument;
        readonly static "BASEDRUM": Internal.NoteBlockInstrument;
        readonly static "BASS": Internal.NoteBlockInstrument;
        readonly static "DIDGERIDOO": Internal.NoteBlockInstrument;
        readonly static "HARP": Internal.NoteBlockInstrument;
        readonly static "BELL": Internal.NoteBlockInstrument;
    }
    type NoteBlockInstrument_ = "bell" | "iron_xylophone" | "harp" | "snare" | "hat" | "didgeridoo" | "chime" | NoteBlockInstrument | "banjo" | "pling" | "basedrum" | "flute" | "bass" | "guitar" | "cow_bell" | "bit" | "xylophone";
    class NativeImage implements Internal.AutoCloseable {
        constructor(arg0: Internal.NativeImage$Format_, arg1: number, arg2: number, arg3: boolean)
        constructor(arg0: number, arg1: number, arg2: boolean)
        getPixelRGBA(arg0: number, arg1: number): number;
        copyFrom(arg0: Internal.NativeImage_): void;
        copyRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: boolean, arg7: boolean): void;
        flipY(): void;
        static read(arg0: Internal.InputStream_): Internal.NativeImage;
        static fromBase64(arg0: string): Internal.NativeImage;
        downloadTexture(arg0: number, arg1: boolean): void;
        setPixelLuminance(arg0: number, arg1: number, arg2: number): void;
        writeToFile(arg0: Internal.Path_): void;
        static read(arg0: Internal.NativeImage$Format_, arg1: Internal.InputStream_): Internal.NativeImage;
        upload(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean, arg8: boolean, arg9: boolean, arg10: boolean): void;
        upload(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean, arg8: boolean): void;
        writeToFile(arg0: string): void;
        writeToFile(arg0: Internal.File_): void;
        getHeight(): number;
        resizeSubRectTo(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.NativeImage_): void;
        untrack(): void;
        static read(arg0: Internal.NativeImage$Format_, arg1: Internal.ByteBuffer_): Internal.NativeImage;
        fillRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        getGreenOrLuminance(arg0: number, arg1: number): number;
        toString(): string;
        getWidth(): number;
        downloadDepthBuffer(arg0: number): void;
        static getR(arg0: number): number;
        blendPixel(arg0: number, arg1: number, arg2: number): void;
        copyFromFont(arg0: Internal.STBTTFontinfo_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number): void;
        static getG(arg0: number): number;
        drawPixels(): void;
        getLuminanceOrAlpha(arg0: number, arg1: number): number;
        getRedOrLuminance(arg0: number, arg1: number): number;
        getBlueOrLuminance(arg0: number, arg1: number): number;
        format(): Internal.NativeImage$Format;
        static getB(arg0: number): number;
        upload(arg0: number, arg1: number, arg2: number, arg3: boolean): void;
        static getA(arg0: number): number;
        setPixelRGBA(arg0: number, arg1: number, arg2: number): void;
        close(): void;
        makePixelArray(): number[];
        asByteArray(): number[];
        static read(arg0: Internal.ByteBuffer_): Internal.NativeImage;
        static combine(arg0: number, arg1: number, arg2: number, arg3: number): number;
        get height(): number
        get width(): number
    }
    type NativeImage_ = NativeImage;
    interface ExecutorService extends Internal.Executor {
        shutdown(): void;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit_): boolean;
        isShutdown(): boolean;
        submit(arg0: Internal.Callable_<T>): Internal.Future<T>;
        invokeAny(arg0: Internal.Collection_<any>, arg1: number, arg2: Internal.TimeUnit_): T;
        shutdownNow(): Internal.List<Internal.Runnable>;
        submit(arg0: Internal.Runnable_, arg1: T): Internal.Future<T>;
        submit(arg0: Internal.Runnable_): Internal.Future<any>;
        invokeAll(arg0: Internal.Collection_<any>, arg1: number, arg2: Internal.TimeUnit_): Internal.List<Internal.Future<T>>;
        invokeAny(arg0: Internal.Collection_<any>): T;
        invokeAll(arg0: Internal.Collection_<any>): Internal.List<Internal.Future<T>>;
        isTerminated(): boolean;
        get shutdown(): boolean
        get terminated(): boolean
    }
    type ExecutorService_ = ExecutorService;
    class ZoneOffsetTransitionRule$TimeDefinition extends Internal.Enum<Internal.ZoneOffsetTransitionRule$TimeDefinition> {
        static valueOf(arg0: string): Internal.ZoneOffsetTransitionRule$TimeDefinition;
        createDateTime(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneOffset_, arg2: Internal.ZoneOffset_): Internal.LocalDateTime;
        static values(): Internal.ZoneOffsetTransitionRule$TimeDefinition[];
        readonly static "UTC": Internal.ZoneOffsetTransitionRule$TimeDefinition;
        readonly static "WALL": Internal.ZoneOffsetTransitionRule$TimeDefinition;
        readonly static "STANDARD": Internal.ZoneOffsetTransitionRule$TimeDefinition;
    }
    type ZoneOffsetTransitionRule$TimeDefinition_ = "standard" | ZoneOffsetTransitionRule$TimeDefinition | "utc" | "wall";
    abstract class TamableAnimal extends Internal.Animal implements Internal.OwnableEntity {
        isOwnedBy(arg0: Internal.LivingEntity_): boolean;
        getOwnerUUID(): Internal.UUID;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        isOrderedToSit(): boolean;
        canAttack(arg0: Internal.LivingEntity_): boolean;
        isAlliedTo(arg0: Internal.Entity_): boolean;
        isTame(): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        getTeam(): Internal.Team;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setInSittingPose(arg0: boolean): void;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        isInSittingPose(): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        setTame(arg0: boolean): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canBeLeashed(arg0: Internal.Player_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tame(arg0: Internal.Player_): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        setOwnerUUID(arg0: Internal.UUID_): void;
        alwaysAccepts(): boolean;
        die(arg0: Internal.DamageSource_): void;
        getOwner(): Internal.Entity;
        getClassification(arg0: boolean): Internal.MobCategory;
        setOrderedToSit(arg0: boolean): void;
        wantsToAttack(arg0: Internal.LivingEntity_, arg1: Internal.LivingEntity_): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get ownerUUID(): Internal.UUID
        get stepHeight(): number
        get orderedToSit(): boolean
        get tame(): boolean
        get team(): Internal.Team
        get multipartEntity(): boolean
        set inSittingPose(arg0: boolean)
        get parts(): Internal.PartEntity<any>[]
        get inSittingPose(): boolean
        set tame(arg0: boolean)
        set ownerUUID(arg0: Internal.UUID_)
        get owner(): Internal.Entity
        set orderedToSit(arg0: boolean)
    }
    type TamableAnimal_ = TamableAnimal;
    interface ChannelProgressivePromise extends Internal.ChannelProgressiveFuture, Internal.ChannelPromise, Internal.ProgressivePromise<void> {
        awaitUninterruptibly(): this;
        sync(): this;
        setProgress(arg0: number, arg1: number): this;
        setSuccess(): this;
        setSuccess(arg0: void): this;
        unvoid(): this;
        setFailure(arg0: Internal.Throwable_): this;
        addListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        syncUninterruptibly(): this;
        await(): this;
        removeListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        addListener(arg0: Internal.GenericFutureListener_<any>): this;
        removeListener(arg0: Internal.GenericFutureListener_<any>): this;
        set success(arg0: void)
        set failure(arg0: Internal.Throwable_)
    }
    type ChannelProgressivePromise_ = ChannelProgressivePromise;
    class ItemModelPropertiesEventJS extends Internal.StartupEventJS {
        constructor()
        registerAll(overwriteId: string, callback: Internal.ItemModelPropertiesEventJS$ItemPropertiesCallback_): void;
        register(ingredient: Internal.IngredientJS_, overwriteId: string, callback: Internal.ItemModelPropertiesEventJS$ItemPropertiesCallback_): void;
    }
    type ItemModelPropertiesEventJS_ = ItemModelPropertiesEventJS;
    class PortalInfo {
        constructor(arg0: Vec3_, arg1: Vec3_, arg2: number, arg3: number)
        readonly "pos": Vec3;
        readonly "speed": Vec3;
        readonly "yRot": number;
        readonly "xRot": number;
    }
    type PortalInfo_ = PortalInfo;
    abstract class Feature <FC> extends Internal.ForgeRegistryEntry<Internal.Feature<any>> {
        constructor(arg0: Internal.Codec_<FC>)
        static isGrassOrDirt(arg0: Internal.LevelSimulatedReader_, arg1: BlockPos_): boolean;
        place(arg0: FC, arg1: Internal.WorldGenLevel_, arg2: Internal.ChunkGenerator_, arg3: Internal.Random_, arg4: BlockPos_): boolean;
        static isAir(arg0: Internal.LevelSimulatedReader_, arg1: BlockPos_): boolean;
        place(arg0: Internal.FeaturePlaceContext_<FC>): boolean;
        static checkNeighbors(arg0: Internal.Function_<BlockPos_, Internal.BlockState_>, arg1: BlockPos_, arg2: Internal.Predicate_<Internal.BlockState_>): boolean;
        static isDirt(arg0: Internal.BlockState_): boolean;
        static isAdjacentToAir(arg0: Internal.Function_<BlockPos_, Internal.BlockState_>, arg1: BlockPos_): boolean;
        configuredCodec(): Internal.Codec<Internal.ConfiguredFeature<FC, Internal.Feature<FC>>>;
        static isReplaceable(arg0: Internal.TagKey_<Internal.Block_>): Internal.Predicate<Internal.BlockState>;
        readonly static "FREEZE_TOP_LAYER": any;
        readonly static "BLOCK_COLUMN": any;
        readonly static "DRIPSTONE_CLUSTER": any;
        readonly static "RANDOM_BOOLEAN_SELECTOR": any;
        readonly static "FOSSIL": any;
        readonly static "TREE": any;
        readonly static "HUGE_FUNGUS": any;
        readonly static "RANDOM_PATCH": any;
        readonly static "DISK": any;
        readonly static "ICEBERG": any;
        readonly static "BASALT_PILLAR": any;
        readonly static "WATERLOGGED_VEGETATION_PATCH": any;
        readonly static "CORAL_CLAW": any;
        readonly static "END_ISLAND": any;
        readonly static "GLOWSTONE_BLOB": any;
        readonly static "BASALT_COLUMNS": any;
        readonly static "NO_OP": any;
        readonly static "SIMPLE_RANDOM_SELECTOR": any;
        readonly static "GEODE": any;
        readonly static "BLUE_ICE": any;
        readonly static "CORAL_TREE": any;
        readonly static "SIMPLE_BLOCK": any;
        readonly static "NO_BONEMEAL_FLOWER": any;
        readonly static "BAMBOO": any;
        readonly static "TWISTING_VINES": any;
        readonly static "SCATTERED_ORE": any;
        readonly static "NETHER_FOREST_VEGETATION": any;
        readonly static "BONUS_CHEST": Internal.BonusChestFeature;
        readonly static "POINTED_DRIPSTONE": any;
        readonly static "ICE_SPIKE": any;
        readonly static "SEA_PICKLE": any;
        readonly static "REPLACE_BLOBS": any;
        readonly static "VINES": any;
        readonly static "VOID_START_PLATFORM": any;
        readonly static "LAKE": any;
        readonly static "ROOT_SYSTEM": any;
        readonly static "FLOWER": any;
        readonly static "LARGE_DRIPSTONE": any;
        readonly static "RANDOM_SELECTOR": any;
        readonly static "BLOCK_PILE": any;
        readonly static "ICE_PATCH": any;
        readonly static "REPLACE_SINGLE_BLOCK": any;
        readonly static "ORE": any;
        readonly static "SEAGRASS": Internal.SeagrassFeature;
        readonly static "WEEPING_VINES": any;
        readonly static "SPRING": any;
        readonly static "UNDERWATER_MAGMA": any;
        readonly static "END_SPIKE": any;
        readonly static "DELTA_FEATURE": any;
        readonly static "FILL_LAYER": any;
        readonly static "HUGE_RED_MUSHROOM": any;
        readonly static "CHORUS_PLANT": any;
        readonly static "MONSTER_ROOM": any;
        readonly static "FOREST_ROCK": any;
        readonly static "KELP": any;
        readonly static "GLOW_LICHEN": any;
        readonly static "HUGE_BROWN_MUSHROOM": any;
        readonly static "VEGETATION_PATCH": any;
        readonly static "END_GATEWAY": any;
        readonly static "DESERT_WELL": any;
        readonly static "CORAL_MUSHROOM": any;
    }
    type Feature_<FC> = Special.Feature | Feature<FC>;
    interface Enemy {
        readonly static "XP_REWARD_BOSS": 50;
        readonly static "XP_REWARD_MEDIUM": 5;
        readonly static "XP_REWARD_SMALL": 3;
        readonly static "XP_REWARD_HUGE": 20;
        readonly static "XP_REWARD_NONE": 0;
        readonly static "XP_REWARD_LARGE": 10;
    }
    type Enemy_ = Enemy;
    abstract class Entity extends Internal.CapabilityProvider<Internal.Entity> implements Internal.EntityAccess, Internal.Nameable, Internal.IForgeEntity, Internal.EntityKJS, Internal.CommandSource {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        showVehicleHealth(): boolean;
        isInWall(): boolean;
        playSound(arg0: Internal.SoundEvent_, arg1: number, arg2: number): void;
        getAllSlots(): Internal.Iterable<Internal.ItemStack>;
        getUpVector(arg0: number): Vec3;
        getXRot(): number;
        gameEvent(arg0: Internal.GameEvent_, arg1: Internal.Entity_): void;
        getBrightness(): number;
        remove(arg0: Internal.Entity$RemovalReason_): void;
        getBlockZ(): number;
        isSuppressingBounce(): boolean;
        isSilent(): boolean;
        startSeenByPlayer(arg0: Internal.ServerPlayer_): void;
        getGameEventListenerRegistrar(): Internal.GameEventListenerRegistrar;
        isPushedByFluid(): boolean;
        isOnFire(): boolean;
        rotate(arg0: Internal.Rotation_): number;
        getPassengersAndSelf(): Internal.Stream<Internal.Entity>;
        position(): Vec3;
        displayFireAnimation(): boolean;
        setDeltaMovement(arg0: number, arg1: number, arg2: number): void;
        turn(arg0: number, arg1: number): void;
        getAirSupply(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getRopeHoldPosition(arg0: number): Vec3;
        copyPosition(arg0: Internal.Entity_): void;
        onAddedToWorld(): void;
        updateFluidHeightAndDoFluidPushing(arg0: Internal.TagKey_<Internal.Fluid_>, arg1: number): boolean;
        isCrouching(): boolean;
        moveTo(arg0: BlockPos_, arg1: number, arg2: number): void;
        chunkPosition(): Internal.ChunkPos;
        canBeCollidedWith(): boolean;
        getMotionDirection(): Internal.Direction;
        getFeetBlockState(): Internal.BlockState;
        lavaHurt(): void;
        gameEvent(arg0: Internal.GameEvent_): void;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): this;
        canChangeDimensions(): boolean;
        getCommandSenderWorld(): Internal.Level;
        positionRider(arg0: Internal.Entity_): void;
        baseTick(): void;
        broadcastToPlayer(arg0: Internal.ServerPlayer_): boolean;
        alwaysAccepts(): boolean;
        changeDimension(arg0: Internal.ServerLevel_): this;
        isShiftKeyDown(): boolean;
        setUUID(arg0: Internal.UUID_): void;
        isVisuallyCrawling(): boolean;
        checkOutOfWorld(): void;
        getEyeHeightAccess(arg0: Internal.Pose_, arg1: Internal.EntityDimensions_): number;
        getCustomName(): Internal.Component;
        getMaxAirSupply(): number;
        isVisuallySwimming(): boolean;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        distanceToSqr(arg0: Internal.Entity_): number;
        ignoreExplosion(): boolean;
        asKJS(): Internal.EntityJS;
        canFreeze(): boolean;
        isAlliedTo(arg0: Internal.Entity_): boolean;
        getBlockY(): number;
        isSpectator(): boolean;
        getDimensions(arg0: Internal.Pose_): Internal.EntityDimensions;
        isInWaterOrBubble(): boolean;
        isPassengerOfSameVehicle(arg0: Internal.Entity_): boolean;
        getBoundingBoxForCulling(): Internal.AABB;
        isSwimming(): boolean;
        mayInteract(arg0: Internal.Level_, arg1: BlockPos_): boolean;
        setSprinting(arg0: boolean): void;
        spawnAtLocation(arg0: Internal.ItemLike_, arg1: number): Internal.ItemEntity;
        getPersistentData(): Internal.CompoundTag;
        setPortalCooldown(): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getRandomZ(arg0: number): number;
        isInvulnerable(): boolean;
        isInLava(): boolean;
        awardKillScore(arg0: Internal.Entity_, arg1: number, arg2: Internal.DamageSource_): void;
        getPosition(arg0: number): Vec3;
        isInWater(): boolean;
        getPortalWaitTime(): number;
        setRemoved(arg0: Internal.Entity$RemovalReason_): void;
        eyeBlockPosition(): BlockPos;
        getFluidJumpThreshold(): number;
        isInWaterRainOrBubble(): boolean;
        getRemovalReason(): Internal.Entity$RemovalReason;
        isIgnoringBlockTriggers(): boolean;
        getHandHoldingItemAngle(arg0: Internal.Item_): Vec3;
        isInvisibleTo(arg0: Internal.Player_): boolean;
        getType(): Internal.EntityType<any>;
        canUpdate(arg0: boolean): void;
        setAirSupply(arg0: number): void;
        getIndirectPassengers(): Internal.Iterable<Internal.Entity>;
        getRootVehicle(): this;
        distanceToSqr(arg0: Vec3_): number;
        getOnPos(): BlockPos;
        resetFallDistance(): void;
        save(arg0: Internal.CompoundTag_): boolean;
        blockPosition(): BlockPos;
        isSteppingCarefully(): boolean;
        getStepHeight(): number;
        isNoGravity(): boolean;
        setBoundingBox(arg0: Internal.AABB_): void;
        getBlockX(): number;
        acceptsFailure(): boolean;
        getEncodeId(): string;
        gameEvent(arg0: Internal.GameEvent_, arg1: Internal.Entity_, arg2: BlockPos_): void;
        getY(arg0: number): number;
        setOldPosAndRot(): void;
        setInvisible(arg0: boolean): void;
        getName(): Internal.Component;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        isFree(arg0: number, arg1: number, arg2: number): boolean;
        updateSwimming(): void;
        onInsideBubbleColumn(arg0: boolean): void;
        tick(): void;
        setRemainingFireTicks(arg0: number): void;
        getEyePosition(): Vec3;
        shouldInformAdmins(): boolean;
        getEyeHeight(): number;
        rideTick(): void;
        hasPassenger(arg0: Internal.Predicate_<Internal.Entity_>): boolean;
        setPos(arg0: Vec3_): void;
        getUUID(): Internal.UUID;
        hasPermissions(arg0: number): boolean;
        shouldShowName(): boolean;
        setSilent(arg0: boolean): void;
        getArmorSlots(): Internal.Iterable<Internal.ItemStack>;
        hasExactlyOnePlayerPassenger(): boolean;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        push(arg0: number, arg1: number, arg2: number): void;
        kill(): void;
        setCustomNameVisible(arg0: boolean): void;
        isAlliedTo(arg0: Internal.Team_): boolean;
        isOnPortalCooldown(): boolean;
        getScoreboardName(): string;
        getRemainingFireTicks(): number;
        onlyOpCanSetNbt(): boolean;
        startRiding(arg0: Internal.Entity_): boolean;
        saveWithoutId(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        isMultipartEntity(): boolean;
        getForward(): Vec3;
        serializeNBT(): Internal.Tag;
        setPosRaw(arg0: number, arg1: number, arg2: number): void;
        fireImmune(): boolean;
        getMaxFallDistance(): number;
        isOnGround(): boolean;
        handleEntityEvent(arg0: number): void;
        getParts(): Internal.PartEntity<any>[];
        getZ(arg0: number): number;
        getId(): number;
        isAlwaysTicking(): boolean;
        interactAt(arg0: Internal.Player_, arg1: Vec3_, arg2: Hand_): Internal.InteractionResult;
        getTicksFrozen(): number;
        deserializeNBT(arg0: Internal.Tag_): void;
        lerpTo(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: boolean): void;
        onPassengerTurned(arg0: Internal.Entity_): void;
        getRandomX(arg0: number): number;
        revive(): void;
        spawnAtLocation(arg0: Internal.ItemLike_): Internal.ItemEntity;
        getEyeY(): number;
        spawnAtLocation(arg0: Internal.ItemStack_, arg1: number): Internal.ItemEntity;
        getBbWidth(): number;
        setGlowingTag(arg0: boolean): void;
        occludesVibrations(): boolean;
        pick(arg0: number, arg1: number, arg2: boolean): Internal.HitResult;
        getBoundingBox(): Internal.AABB;
        isInWaterOrRain(): boolean;
        isDescending(): boolean;
        getPacketCoordinates(): Vec3;
        setItemSlot(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): void;
        getYHeadRot(): number;
        equals(arg0: any): boolean;
        getViewYRot(arg0: number): number;
        setInvulnerable(arg0: boolean): void;
        push(arg0: Internal.Entity_): void;
        mirror(arg0: Internal.Mirror_): number;
        canUpdate(): boolean;
        playerTouch(arg0: Internal.Player_): void;
        addTag(arg0: string): boolean;
        getEyeHeight(arg0: Internal.Pose_): number;
        getTicksRequiredToFreeze(): number;
        getAddEntityPacket(): Internal.Packet<any>;
        getYRot(): number;
        load(arg0: Internal.CompoundTag_): void;
        getTeam(): Internal.Team;
        shouldRenderAtSqrDistance(arg0: number): boolean;
        isAlive(): boolean;
        setTicksFrozen(arg0: number): void;
        getBbHeight(): number;
        recreateFromPacket(arg0: Internal.ClientboundAddEntityPacket_): void;
        killed(arg0: Internal.ServerLevel_, arg1: Internal.LivingEntity_): void;
        getMyRidingOffset(): number;
        move(arg0: Internal.MoverType_, arg1: Vec3_): void;
        dismountTo(arg0: number, arg1: number, arg2: number): void;
        getTags(): Internal.Set<string>;
        getViewVector(arg0: number): Vec3;
        setDeltaMovement(arg0: Vec3_): void;
        onRemovedFromWorld(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isPickable(): boolean;
        hasCustomName(): boolean;
        setYHeadRot(arg0: number): void;
        getX(): number;
        isVehicle(): boolean;
        absMoveTo(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        getLeashOffset(): Vec3;
        getPickResult(): Internal.ItemStack;
        getPercentFrozen(): number;
        isAttackable(): boolean;
        getRandomY(): number;
        spawnAtLocation(arg0: Internal.ItemStack_): Internal.ItemEntity;
        getDisplayName(): Internal.Component;
        shouldBlockExplode(arg0: Internal.Explosion_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: number): boolean;
        hasGlowingTag(): boolean;
        thunderHit(arg0: Internal.ServerLevel_, arg1: Internal.LightningBolt_): void;
        setIsInPowderSnow(arg0: boolean): void;
        doEnchantDamageEffects(arg0: Internal.LivingEntity_, arg1: Internal.Entity_): void;
        setCustomName(arg0: Internal.Component_): void;
        getSlot(arg0: number): Internal.SlotAccess;
        getControllingPassenger(): this;
        stopSeenByPlayer(arg0: Internal.ServerPlayer_): void;
        shouldBeSaved(): boolean;
        isUnderWater(): boolean;
        animateHurt(): void;
        getViewXRot(arg0: number): number;
        canRiderInteract(): boolean;
        stopRiding(): void;
        isCustomNameVisible(): boolean;
        getX(arg0: number): number;
        getPistonPushReaction(): Internal.PushReaction;
        removeTag(arg0: string): boolean;
        shouldRiderSit(): boolean;
        lookAt(arg0: Internal.EntityAnchorArgument$Anchor_, arg1: Vec3_): void;
        setPose(arg0: Internal.Pose_): void;
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        getDeltaMovement(): Vec3;
        getFluidHeight(arg0: Internal.TagKey_<Internal.Fluid_>): number;
        static collideBoundingBox(arg0: Internal.Entity_, arg1: Vec3_, arg2: Internal.AABB_, arg3: Internal.Level_, arg4: Internal.List_<Internal.VoxelShape_>): Vec3;
        getStringUUID(): string;
        gameEvent(arg0: Internal.GameEvent_, arg1: BlockPos_): void;
        toString(): string;
        hasPassenger(arg0: Internal.Entity_): boolean;
        hasIndirectPassenger(arg0: Internal.Entity_): boolean;
        getEntityData(): Internal.SynchedEntityData;
        getPassengersRidingOffset(): number;
        setSecondsOnFire(arg0: number): void;
        moveTo(arg0: number, arg1: number, arg2: number): void;
        handleInsidePortal(arg0: BlockPos_): void;
        setYRot(arg0: number): void;
        rideableUnderWater(): boolean;
        isPushable(): boolean;
        discard(): void;
        setYBodyRot(arg0: number): void;
        clearFire(): void;
        onClientRemoval(): void;
        absMoveTo(arg0: number, arg1: number, arg2: number): void;
        acceptsSuccess(): boolean;
        restoreFrom(arg0: Internal.Entity_): void;
        setNoGravity(arg0: boolean): void;
        getDimensionChangingDelay(): number;
        setOnGround(arg0: boolean): void;
        setPos(arg0: number, arg1: number, arg2: number): void;
        setPacketCoordinates(arg0: number, arg1: number, arg2: number): void;
        getPickRadius(): number;
        createCommandSourceStack(): Internal.CommandSourceStack;
        isControlledByLocalInstance(): boolean;
        getVehicle(): this;
        startRiding(arg0: Internal.Entity_, arg1: boolean): boolean;
        isRemoved(): boolean;
        setSwimming(arg0: boolean): void;
        teleportToWithTicket(arg0: number, arg1: number, arg2: number): void;
        setId(arg0: number): void;
        sendMessage(arg0: Internal.Component_, arg1: Internal.UUID_): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getLightProbePosition(arg0: number): Vec3;
        getRotationVector(): Internal.Vec2;
        fillCrashReportCategory(arg0: Internal.CrashReportCategory_): void;
        refreshDimensions(): void;
        isSprinting(): boolean;
        onAboveBubbleCol(arg0: boolean): void;
        canCollideWith(arg0: Internal.Entity_): boolean;
        setShiftKeyDown(arg0: boolean): void;
        getEyePosition(arg0: number): Vec3;
        moveTo(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        getBlockExplosionResistance(arg0: Internal.Explosion_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: Internal.FluidState_, arg5: number): number;
        isPassenger(): boolean;
        checkDespawn(): void;
        isEyeInFluid(arg0: Internal.TagKey_<Internal.Fluid_>): boolean;
        isInvulnerableTo(arg0: Internal.DamageSource_): boolean;
        makeStuckInBlock(arg0: Internal.BlockState_, arg1: Vec3_): void;
        skipAttackInteraction(arg0: Internal.Entity_): boolean;
        lerpMotion(arg0: number, arg1: number, arg2: number): void;
        shouldRender(arg0: number, arg1: number, arg2: number): boolean;
        getZ(): number;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        distanceTo(arg0: Internal.Entity_): number;
        getPassengers(): Internal.List<Internal.Entity>;
        lerpHeadTo(arg0: number, arg1: number): void;
        setPacketCoordinates(arg0: Vec3_): void;
        canSpawnSprintParticle(): boolean;
        distanceToSqr(arg0: number, arg1: number, arg2: number): number;
        teleportTo(arg0: number, arg1: number, arg2: number): void;
        getServer(): Internal.MinecraftServer;
        getSelfAndPassengers(): Internal.Stream<Internal.Entity>;
        moveRelative(arg0: number, arg1: Vec3_): void;
        static getViewScale(): number;
        isAddedToWorld(): boolean;
        getFirstPassenger(): this;
        saveAsPassenger(arg0: Internal.CompoundTag_): boolean;
        getHandSlots(): Internal.Iterable<Internal.ItemStack>;
        isCurrentlyGlowing(): boolean;
        interact(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getDismountLocationForPassenger(arg0: Internal.LivingEntity_): Vec3;
        isDiscrete(): boolean;
        getTeamColor(): number;
        setXRot(arg0: number): void;
        unRide(): void;
        getLevel(): Internal.Level;
        getSoundSource(): Internal.SoundSource;
        getPose(): Internal.Pose;
        touchingUnloadedChunk(): boolean;
        getLookAngle(): Vec3;
        moveTo(arg0: Vec3_): void;
        isColliding(arg0: BlockPos_, arg1: Internal.BlockState_): boolean;
        getPersistentDataKJS(): Internal.CompoundTag;
        removeVehicle(): void;
        isInvisible(): boolean;
        is(arg0: Internal.Entity_): boolean;
        closerThan(arg0: Internal.Entity_, arg1: number): boolean;
        getY(): number;
        ejectPassengers(): void;
        hashCode(): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        static setViewScale(arg0: number): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        isFreezing(): boolean;
        setLevelCallback(arg0: Internal.EntityInLevelCallback_): void;
        isFullyFrozen(): boolean;
        setSharedFlagOnFire(arg0: boolean): void;
        getDirection(): Internal.Direction;
        get inWall(): boolean
        get allSlots(): Internal.Iterable<Internal.ItemStack>
        get XRot(): number
        get brightness(): number
        get blockZ(): number
        get suppressingBounce(): boolean
        get silent(): boolean
        get gameEventListenerRegistrar(): Internal.GameEventListenerRegistrar
        get pushedByFluid(): boolean
        get onFire(): boolean
        get passengersAndSelf(): Internal.Stream<Internal.Entity>
        get airSupply(): number
        get crouching(): boolean
        get motionDirection(): Internal.Direction
        get feetBlockState(): Internal.BlockState
        get commandSenderWorld(): Internal.Level
        get shiftKeyDown(): boolean
        set UUID(arg0: Internal.UUID_)
        get visuallyCrawling(): boolean
        get customName(): Internal.Component
        get maxAirSupply(): number
        get visuallySwimming(): boolean
        get blockY(): number
        get spectator(): boolean
        get inWaterOrBubble(): boolean
        get boundingBoxForCulling(): Internal.AABB
        get swimming(): boolean
        set sprinting(arg0: boolean)
        get persistentData(): Internal.CompoundTag
        get invulnerable(): boolean
        get inLava(): boolean
        get inWater(): boolean
        get portalWaitTime(): number
        set removed(arg0: Internal.Entity$RemovalReason_)
        get fluidJumpThreshold(): number
        get inWaterRainOrBubble(): boolean
        get removalReason(): Internal.Entity$RemovalReason
        get ignoringBlockTriggers(): boolean
        get type(): Internal.EntityType<any>
        set airSupply(arg0: number)
        get indirectPassengers(): Internal.Iterable<Internal.Entity>
        get rootVehicle(): Internal.Entity
        get onPos(): BlockPos
        get steppingCarefully(): boolean
        get stepHeight(): number
        get noGravity(): boolean
        set boundingBox(arg0: Internal.AABB_)
        get blockX(): number
        get encodeId(): string
        set invisible(arg0: boolean)
        get name(): Internal.Component
        set remainingFireTicks(arg0: number)
        get eyePosition(): Vec3
        get eyeHeight(): number
        set pos(arg0: Vec3_)
        get UUID(): Internal.UUID
        set silent(arg0: boolean)
        get armorSlots(): Internal.Iterable<Internal.ItemStack>
        set customNameVisible(arg0: boolean)
        get onPortalCooldown(): boolean
        get scoreboardName(): string
        get remainingFireTicks(): number
        get multipartEntity(): boolean
        get forward(): Vec3
        get maxFallDistance(): number
        get onGround(): boolean
        get parts(): Internal.PartEntity<any>[]
        get id(): number
        get alwaysTicking(): boolean
        get ticksFrozen(): number
        get eyeY(): number
        get bbWidth(): number
        set glowingTag(arg0: boolean)
        get boundingBox(): Internal.AABB
        get inWaterOrRain(): boolean
        get descending(): boolean
        get packetCoordinates(): Vec3
        get YHeadRot(): number
        set invulnerable(arg0: boolean)
        get ticksRequiredToFreeze(): number
        get addEntityPacket(): Internal.Packet<any>
        get YRot(): number
        get team(): Internal.Team
        get alive(): boolean
        set ticksFrozen(arg0: number)
        get bbHeight(): number
        get myRidingOffset(): number
        get tags(): Internal.Set<string>
        set deltaMovement(arg0: Vec3_)
        get pickable(): boolean
        set YHeadRot(arg0: number)
        get x(): number
        get vehicle(): boolean
        get leashOffset(): Vec3
        get pickResult(): Internal.ItemStack
        get percentFrozen(): number
        get attackable(): boolean
        get randomY(): number
        get displayName(): Internal.Component
        set isInPowderSnow(arg0: boolean)
        set customName(arg0: Internal.Component_)
        get controllingPassenger(): Internal.Entity
        get underWater(): boolean
        get customNameVisible(): boolean
        get pistonPushReaction(): Internal.PushReaction
        set pose(arg0: Internal.Pose_)
        get deltaMovement(): Vec3
        get stringUUID(): string
        get entityData(): Internal.SynchedEntityData
        get passengersRidingOffset(): number
        set secondsOnFire(arg0: number)
        set YRot(arg0: number)
        get pushable(): boolean
        set YBodyRot(arg0: number)
        set noGravity(arg0: boolean)
        get dimensionChangingDelay(): number
        set onGround(arg0: boolean)
        get pickRadius(): number
        get controlledByLocalInstance(): boolean
        get vehicle(): Internal.Entity
        get removed(): boolean
        set swimming(arg0: boolean)
        set id(arg0: number)
        get rotationVector(): Internal.Vec2
        get sprinting(): boolean
        set shiftKeyDown(arg0: boolean)
        get passenger(): boolean
        get z(): number
        get passengers(): Internal.List<Internal.Entity>
        set packetCoordinates(arg0: Vec3_)
        get server(): Internal.MinecraftServer
        get selfAndPassengers(): Internal.Stream<Internal.Entity>
        get viewScale(): number
        get addedToWorld(): boolean
        get firstPassenger(): Internal.Entity
        get handSlots(): Internal.Iterable<Internal.ItemStack>
        get currentlyGlowing(): boolean
        get discrete(): boolean
        get teamColor(): number
        set XRot(arg0: number)
        get level(): Internal.Level
        get soundSource(): Internal.SoundSource
        get pose(): Internal.Pose
        get lookAngle(): Vec3
        get persistentDataKJS(): Internal.CompoundTag
        get invisible(): boolean
        get y(): number
        set viewScale(arg0: number)
        get freezing(): boolean
        set levelCallback(arg0: Internal.EntityInLevelCallback_)
        get fullyFrozen(): boolean
        set sharedFlagOnFire(arg0: boolean)
        get direction(): Internal.Direction
        "xRotO": number;
        readonly static "UUID_TAG": "UUID";
        readonly static "DEFAULT_BB_WIDTH": 0.6;
        "yOld": number;
        "wasInPowderSnow": boolean;
        "verticalCollision": boolean;
        readonly static "FREEZE_HURT_FREQUENCY": 40;
        readonly static "BASE_TICKS_REQUIRED_TO_FREEZE": 140;
        "tickCount": number;
        "verticalCollisionBelow": boolean;
        readonly static "TOTAL_AIR_SUPPLY": 300;
        "zOld": number;
        "fallDistance": number;
        readonly static "BREATHING_DISTANCE_BELOW_EYES": 0.11111111;
        "blocksBuilding": boolean;
        "walkDist": number;
        "noCulling": boolean;
        readonly static "PASSENGERS_TAG": "Passengers";
        "hurtMarked": boolean;
        "isInPowderSnow": boolean;
        readonly static "MAX_ENTITY_TAG_COUNT": 1024;
        readonly static "DELTA_AFFECTED_BY_BLOCKS_BELOW": 0.5000001;
        "yo": number;
        "xo": number;
        "zo": number;
        "invulnerableTime": number;
        "horizontalCollision": boolean;
        "yRotO": number;
        "level": Internal.Level;
        "wasOnFire": boolean;
        "flyDist": number;
        readonly static "BOARDING_COOLDOWN": 60;
        readonly static "DEFAULT_BB_HEIGHT": 1.8;
        "hasImpulse": boolean;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        "maxUpStep": number;
        "minorHorizontalCollision": boolean;
        "xOld": number;
        "moveDist": number;
        "walkDistO": number;
        "noPhysics": boolean;
        readonly static "ID_TAG": "id";
    }
    type Entity_ = Entity;
    class ClientboundRespawnPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.Holder_<Internal.DimensionType_>, arg1: Internal.ResourceKey_<Internal.Level_>, arg2: number, arg3: Internal.GameType_, arg4: Internal.GameType_, arg5: boolean, arg6: boolean, arg7: boolean)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getDimension(): Internal.ResourceKey<Internal.Level>;
        shouldKeepAllPlayerData(): boolean;
        getSeed(): number;
        getDimensionType(): Internal.Holder<Internal.DimensionType>;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getPreviousPlayerGameType(): Internal.GameType;
        getPlayerGameType(): Internal.GameType;
        isSkippable(): boolean;
        isFlat(): boolean;
        isDebug(): boolean;
        get dimension(): Internal.ResourceKey<Internal.Level>
        get seed(): number
        get dimensionType(): Internal.Holder<Internal.DimensionType>
        get previousPlayerGameType(): Internal.GameType
        get playerGameType(): Internal.GameType
        get skippable(): boolean
        get flat(): boolean
        get debug(): boolean
    }
    type ClientboundRespawnPacket_ = ClientboundRespawnPacket;
    class Schema {
        constructor(arg0: number, arg1: Internal.Schema_)
        getParent(): this;
        register(arg0: Internal.Map_<string, Internal.Supplier_<Internal.TypeTemplate_>>, arg1: string, arg2: Internal.Supplier_<Internal.TypeTemplate_>): void;
        getType(arg0: Internal.DSL$TypeReference_): com.mojang.datafixers.types.Type<any>;
        registerSimple(arg0: Internal.Map_<string, Internal.Supplier_<Internal.TypeTemplate_>>, arg1: string): void;
        types(): Internal.Set<string>;
        registerEntities(arg0: Internal.Schema_): Internal.Map<string, Internal.Supplier<Internal.TypeTemplate>>;
        getVersionKey(): number;
        getTypeRaw(arg0: Internal.DSL$TypeReference_): com.mojang.datafixers.types.Type<any>;
        resolveTemplate(arg0: string): Internal.TypeTemplate;
        registerType(arg0: boolean, arg1: Internal.DSL$TypeReference_, arg2: Internal.Supplier_<Internal.TypeTemplate_>): void;
        registerTypes(arg0: Internal.Schema_, arg1: Internal.Map_<string, Internal.Supplier_<Internal.TypeTemplate_>>, arg2: Internal.Map_<string, Internal.Supplier_<Internal.TypeTemplate_>>): void;
        getChoiceType(arg0: Internal.DSL$TypeReference_, arg1: string): com.mojang.datafixers.types.Type<any>;
        registerBlockEntities(arg0: Internal.Schema_): Internal.Map<string, Internal.Supplier<Internal.TypeTemplate>>;
        register(arg0: Internal.Map_<string, Internal.Supplier_<Internal.TypeTemplate_>>, arg1: string, arg2: Internal.Function_<string, Internal.TypeTemplate_>): void;
        findChoiceType(arg0: Internal.DSL$TypeReference_): Internal.TaggedChoice$TaggedChoiceType<any>;
        id(arg0: string): Internal.TypeTemplate;
        get parent(): Internal.Schema
        get versionKey(): number
    }
    type Schema_ = Schema;
    interface Toast {
        getToken(): any;
        width(): number;
        height(): number;
        render(arg0: Internal.PoseStack_, arg1: Internal.ToastComponent_, arg2: number): Internal.Toast$Visibility;
        get token(): any
        readonly static "TEXTURE": ResourceLocation;
        readonly static "NO_TOKEN": any;
    }
    type Toast_ = Toast;
    class NearestBedSensor extends Internal.Sensor<Internal.Mob> {
        constructor()
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
    }
    type NearestBedSensor_ = NearestBedSensor;
    class ChunkWatchEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.ServerPlayer_, arg1: Internal.ChunkPos_, arg2: Internal.ServerLevel_)
        getPos(): Internal.ChunkPos;
        getListenerList(): Internal.ListenerList;
        getWorld(): Internal.ServerLevel;
        getPlayer(): Internal.ServerPlayer;
        get pos(): Internal.ChunkPos
        get listenerList(): Internal.ListenerList
        get world(): Internal.ServerLevel
        get player(): Internal.ServerPlayer
    }
    type ChunkWatchEvent_ = ChunkWatchEvent;
    interface LongSupplier {
        getAsLong(): number;
        get asLong(): number
    }
    type LongSupplier_ = LongSupplier | (()=>number);
    class BeeDebugRenderer$BeeInfo {
        constructor(arg0: Internal.UUID_, arg1: number, arg2: Internal.Position_, arg3: net.minecraft.world.level.pathfinder.Path_, arg4: BlockPos_, arg5: BlockPos_, arg6: number)
        toString(): string;
        hasFlower(): boolean;
        getName(): string;
        getUuid(): Internal.UUID;
        hasHive(arg0: BlockPos_): boolean;
        get name(): string
        get uuid(): Internal.UUID
        readonly "path": net.minecraft.world.level.pathfinder.Path;
        readonly "blacklistedHives": Internal.Set<BlockPos>;
        readonly "uuid": Internal.UUID;
        readonly "id": number;
        readonly "pos": Internal.Position;
        readonly "flowerPos": BlockPos;
        readonly "hivePos": BlockPos;
        readonly "goals": Internal.List<string>;
        readonly "travelTicks": number;
    }
    type BeeDebugRenderer$BeeInfo_ = BeeDebugRenderer$BeeInfo;
    class InventoryChangedEventJS extends Internal.PlayerEventJS {
        constructor(p: Internal.ServerPlayer_, is: Internal.ItemStack_, s: number)
        getEntity(): Internal.EntityJS;
        getItem(): Internal.ItemStackJS;
        getSlot(): number;
        get entity(): Internal.EntityJS
        get item(): Internal.ItemStackJS
        get slot(): number
    }
    type InventoryChangedEventJS_ = InventoryChangedEventJS;
    interface Char2FloatFunction extends Internal.IntToDoubleFunction, it.unimi.dsi.fastutil.Function<string, number> {
        applyAsDouble(arg0: number): number;
        get(arg0: any): number;
        andThenFloat(arg0: Internal.Float2FloatFunction_): this;
        composeChar(arg0: Internal.Char2CharFunction_): this;
        getOrDefault(arg0: any, arg1: any): any;
        put(arg0: string, arg1: number): number;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2FloatFunction;
        composeReference(arg0: Internal.Reference2CharFunction_<any>): Internal.Reference2FloatFunction<T>;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2FloatFunction;
        defaultReturnValue(arg0: number): void;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2FloatFunction;
        containsKey(arg0: string): boolean;
        andThenObject(arg0: Internal.Float2ObjectFunction_<any>): Internal.Char2ObjectFunction<T>;
        get(arg0: string): number;
        containsKey(arg0: any): boolean;
        put(arg0: any, arg1: any): any;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Char2CharFunction;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2FloatFunction;
        getOrDefault(arg0: string, arg1: number): number;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Char2IntFunction;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Char2LongFunction;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2FloatFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        defaultReturnValue(): number;
        remove(arg0: string): number;
        apply(arg0: string): number;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Char2ByteFunction;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Char2ShortFunction;
        size(): number;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2FloatFunction;
        andThenReference(arg0: Internal.Float2ReferenceFunction_<any>): Internal.Char2ReferenceFunction<T>;
        clear(): void;
        composeObject(arg0: Internal.Object2CharFunction_<any>): Internal.Object2FloatFunction<T>;
        remove(arg0: any): any;
        put(arg0: string, arg1: number): number;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Char2DoubleFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<string, T>;
    }
    type Char2FloatFunction_ = Char2FloatFunction | ((arg0: string)=>number);
    abstract class ModuleReference {
        open(): Internal.ModuleReader;
        location(): Internal.Optional<Internal.URI>;
        descriptor(): Internal.ModuleDescriptor;
    }
    type ModuleReference_ = ModuleReference;
    class BannerPattern extends Internal.Enum<Internal.BannerPattern> implements Internal.IExtensibleEnum {
        static create(arg0: string, arg1: string, arg2: string): Internal.BannerPattern;
        getHashname(): string;
        static values(): Internal.BannerPattern[];
        static byHash(arg0: string): Internal.BannerPattern;
        static valueOf(arg0: string): Internal.BannerPattern;
        init(): void;
        static byFilename(arg0: string): Internal.BannerPattern;
        getFilename(): string;
        location(arg0: boolean): ResourceLocation;
        static create(arg0: string, arg1: string, arg2: string, arg3: boolean): Internal.BannerPattern;
        get hashname(): string
        get filename(): string
        readonly static "STRIPE_CENTER": Internal.BannerPattern;
        readonly static "HALF_HORIZONTAL": Internal.BannerPattern;
        readonly static "STRIPE_MIDDLE": Internal.BannerPattern;
        readonly static "HALF_VERTICAL": Internal.BannerPattern;
        readonly static "SQUARE_TOP_LEFT": Internal.BannerPattern;
        readonly static "STRIPE_SMALL": Internal.BannerPattern;
        readonly static "STRIPE_RIGHT": Internal.BannerPattern;
        readonly static "CIRCLE_MIDDLE": Internal.BannerPattern;
        readonly static "GRADIENT_UP": Internal.BannerPattern;
        readonly static "TRIANGLES_TOP": Internal.BannerPattern;
        readonly static "CROSS": Internal.BannerPattern;
        readonly static "DIAGONAL_RIGHT_MIRROR": Internal.BannerPattern;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "COUNT": 41;
        readonly static "CREEPER": Internal.BannerPattern;
        readonly static "TRIANGLE_TOP": Internal.BannerPattern;
        readonly static "GRADIENT": Internal.BannerPattern;
        readonly static "STRIPE_TOP": Internal.BannerPattern;
        readonly static "BASE": Internal.BannerPattern;
        readonly static "GLOBE": Internal.BannerPattern;
        readonly static "DIAGONAL_RIGHT": Internal.BannerPattern;
        readonly static "SKULL": Internal.BannerPattern;
        readonly static "PIGLIN": Internal.BannerPattern;
        readonly static "DIAGONAL_LEFT": Internal.BannerPattern;
        readonly static "SQUARE_BOTTOM_LEFT": Internal.BannerPattern;
        readonly static "TRIANGLE_BOTTOM": Internal.BannerPattern;
        readonly static "RHOMBUS_MIDDLE": Internal.BannerPattern;
        readonly static "CURLY_BORDER": Internal.BannerPattern;
        readonly static "BORDER": Internal.BannerPattern;
        readonly static "BRICKS": Internal.BannerPattern;
        readonly static "STRIPE_DOWNRIGHT": Internal.BannerPattern;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "PATTERN_ITEM_COUNT": 6;
        readonly static "FLOWER": Internal.BannerPattern;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "AVAILABLE_PATTERNS": 34;
        readonly static "SQUARE_TOP_RIGHT": Internal.BannerPattern;
        readonly static "STRAIGHT_CROSS": Internal.BannerPattern;
        readonly static "HALF_HORIZONTAL_MIRROR": Internal.BannerPattern;
        readonly static "HALF_VERTICAL_MIRROR": Internal.BannerPattern;
        readonly "hasPatternItem": boolean;
        readonly static "DIAGONAL_LEFT_MIRROR": Internal.BannerPattern;
        readonly static "TRIANGLES_BOTTOM": Internal.BannerPattern;
        readonly static "STRIPE_BOTTOM": Internal.BannerPattern;
        readonly static "STRIPE_DOWNLEFT": Internal.BannerPattern;
        readonly static "STRIPE_LEFT": Internal.BannerPattern;
        readonly static "SQUARE_BOTTOM_RIGHT": Internal.BannerPattern;
        readonly static "MOJANG": Internal.BannerPattern;
    }
    type BannerPattern_ = "circle_middle" | "straight_cross" | "triangle_bottom" | "gradient_up" | "half_vertical" | "flower" | "rhombus_middle" | "stripe_top" | "stripe_downright" | "globe" | "diagonal_left_mirror" | "half_vertical_mirror" | "creeper" | "base" | "stripe_left" | "diagonal_right_mirror" | "diagonal_left" | "triangle_top" | "half_horizontal_mirror" | "square_bottom_left" | "triangles_bottom" | "stripe_bottom" | "stripe_small" | BannerPattern | "bricks" | "square_top_right" | "stripe_right" | "skull" | "curly_border" | "diagonal_right" | "square_bottom_right" | "piglin" | "mojang" | "half_horizontal" | "square_top_left" | "gradient" | "stripe_downleft" | "stripe_center" | "triangles_top" | "cross" | "border" | "stripe_middle";
    class ClientboundCustomSoundPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: ResourceLocation_, arg1: Internal.SoundSource_, arg2: Vec3_, arg3: number, arg4: number)
        handle(arg0: Internal.PacketListener_): void;
        getX(): number;
        getY(): number;
        getVolume(): number;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getZ(): number;
        getSource(): Internal.SoundSource;
        getPitch(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getName(): ResourceLocation;
        isSkippable(): boolean;
        get x(): number
        get y(): number
        get volume(): number
        get z(): number
        get source(): Internal.SoundSource
        get pitch(): number
        get name(): ResourceLocation
        get skippable(): boolean
        readonly static "LOCATION_ACCURACY": 8.0;
    }
    type ClientboundCustomSoundPacket_ = ClientboundCustomSoundPacket;
    class SecureRandom extends Internal.Random {
        constructor()
        constructor(arg0: number[])
        static getInstance(arg0: string, arg1: string): Internal.SecureRandom;
        nextFloat(arg0: number): number;
        static getInstance(arg0: string, arg1: Internal.SecureRandomParameters_, arg2: Internal.Provider_): Internal.SecureRandom;
        nextBytes(arg0: number[], arg1: Internal.SecureRandomParameters_): void;
        nextLong(arg0: number, arg1: number): number;
        getParameters(): Internal.SecureRandomParameters;
        static getInstance(arg0: string, arg1: Internal.Provider_): Internal.SecureRandom;
        getAlgorithm(): string;
        static getInstanceStrong(): Internal.SecureRandom;
        nextDouble(arg0: number): number;
        nextLong(arg0: number): number;
        nextFloat(arg0: number, arg1: number): number;
        reseed(): void;
        setSeed(arg0: number[]): void;
        nextBytes(arg0: number[]): void;
        generateSeed(arg0: number): number[];
        toString(): string;
        nextDouble(arg0: number, arg1: number): number;
        nextExponential(): number;
        setSeed(arg0: number): void;
        nextInt(arg0: number, arg1: number): number;
        isDeprecated(): boolean;
        getProvider(): Internal.Provider;
        nextGaussian(arg0: number, arg1: number): number;
        static getSeed(arg0: number): number[];
        reseed(arg0: Internal.SecureRandomParameters_): void;
        static getInstance(arg0: string, arg1: Internal.SecureRandomParameters_): Internal.SecureRandom;
        static getInstance(arg0: string): Internal.SecureRandom;
        static getInstance(arg0: string, arg1: Internal.SecureRandomParameters_, arg2: string): Internal.SecureRandom;
        get parameters(): Internal.SecureRandomParameters
        get algorithm(): string
        get instanceStrong(): Internal.SecureRandom
        set seed(arg0: number[])
        set seed(arg0: number)
        get deprecated(): boolean
        get provider(): Internal.Provider
    }
    type SecureRandom_ = SecureRandom;
    interface TickableSoundInstance extends Internal.SoundInstance {
        isStopped(): boolean;
        canStartSilent(): boolean;
        getStream(arg0: Internal.SoundBufferLibrary_, arg1: Internal.Sound_, arg2: boolean): Internal.CompletableFuture<Internal.AudioStream>;
        canPlaySound(): boolean;
        tick(): void;
        get stopped(): boolean
    }
    type TickableSoundInstance_ = TickableSoundInstance;
    abstract class Executable extends Internal.AccessibleObject implements Internal.Member, Internal.GenericDeclaration {
        getAnnotatedExceptionTypes(): Internal.AnnotatedType[];
        getAnnotatedParameterTypes(): Internal.AnnotatedType[];
        getAnnotationsByType(arg0: Internal.Class_<T>): T[];
        isVarArgs(): boolean;
        getGenericExceptionTypes(): Internal.Type[];
        getGenericParameterTypes(): Internal.Type[];
        getModifiers(): number;
        isSynthetic(): boolean;
        getAnnotation(arg0: Internal.Class_<T>): T;
        getDeclaringClass(): Internal.Class<any>;
        getAnnotatedReturnType(): Internal.AnnotatedType;
        getExceptionTypes(): Internal.Class<any>[];
        getParameterTypes(): Internal.Class<any>[];
        getParameters(): any[];
        getParameterAnnotations(): Internal.Annotation[][];
        toGenericString(): string;
        getName(): string;
        getParameterCount(): number;
        getAnnotatedReceiverType(): Internal.AnnotatedType;
        getDeclaredAnnotations(): Internal.Annotation[];
        getTypeParameters(): any[];
        get annotatedExceptionTypes(): Internal.AnnotatedType[]
        get annotatedParameterTypes(): Internal.AnnotatedType[]
        get varArgs(): boolean
        get genericExceptionTypes(): Internal.Type[]
        get genericParameterTypes(): Internal.Type[]
        get modifiers(): number
        get synthetic(): boolean
        get declaringClass(): Internal.Class<any>
        get annotatedReturnType(): Internal.AnnotatedType
        get exceptionTypes(): Internal.Class<any>[]
        get parameterTypes(): Internal.Class<any>[]
        get parameters(): any[]
        get parameterAnnotations(): Internal.Annotation[][]
        get name(): string
        get parameterCount(): number
        get annotatedReceiverType(): Internal.AnnotatedType
        get declaredAnnotations(): Internal.Annotation[]
        get typeParameters(): any[]
    }
    type Executable_ = Executable;
    interface IForgeRecipeSerializer <T> {
        fromJson(arg0: ResourceLocation_, arg1: Internal.JsonObject_, arg2: Internal.ICondition$IContext_): T;
    }
    type IForgeRecipeSerializer_<T> = IForgeRecipeSerializer<T>;
    class GlowItemFrame extends Internal.ItemFrame {
        constructor(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Direction_)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getRotateItemSound(): Internal.SoundEvent;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        getAddItemSound(): Internal.SoundEvent;
        asKJS(): Internal.EntityJS;
        getPlaceSound(): Internal.SoundEvent;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getBreakSound(): Internal.SoundEvent;
        getParts(): Internal.PartEntity<any>[];
        getRemoveItemSound(): Internal.SoundEvent;
        get rotateItemSound(): Internal.SoundEvent
        get stepHeight(): number
        get addItemSound(): Internal.SoundEvent
        get placeSound(): Internal.SoundEvent
        get multipartEntity(): boolean
        get breakSound(): Internal.SoundEvent
        get parts(): Internal.PartEntity<any>[]
        get removeItemSound(): Internal.SoundEvent
    }
    type GlowItemFrame_ = GlowItemFrame;
    class BlockStateModifyPlacementCallbackJS extends Internal.BlockStateModifyCallbackJS {
        constructor(context: Internal.BlockPlaceContext_, block: Internal.Block_)
        waterlogged(waterlogged: boolean): this;
        getClickedFace(): Internal.Direction;
        getPlayer(): Internal.PlayerJS<any>;
        getClickedBlock(): Internal.BlockContainerJS;
        getNearestLookingDirections(): Internal.Direction[];
        waterlogged(): this;
        getHorizontalDirection(): Internal.Direction;
        getRotation(): number;
        canPlace(): boolean;
        getItem(): Internal.ItemStackJS;
        getLevel(): Internal.LevelJS;
        getFluidStateAtClickedPos(): Internal.FluidState;
        isInWater(): boolean;
        getNearestLookingDirection(): Internal.Direction;
        getClickLocation(): Vec3;
        getNearestLookingVerticalDirection(): Internal.Direction;
        isSecondaryUseActive(): boolean;
        isClickedPosIn(fluid: Internal.Fluid_): boolean;
        replacingClickedOnBlock(): boolean;
        getHand(): Hand;
        getClickedPos(): BlockPos;
        isInside(): boolean;
        get clickedFace(): Internal.Direction
        get player(): Internal.PlayerJS<any>
        get clickedBlock(): Internal.BlockContainerJS
        get nearestLookingDirections(): Internal.Direction[]
        get horizontalDirection(): Internal.Direction
        get rotation(): number
        get item(): Internal.ItemStackJS
        get level(): Internal.LevelJS
        get fluidStateAtClickedPos(): Internal.FluidState
        get inWater(): boolean
        get nearestLookingDirection(): Internal.Direction
        get clickLocation(): Vec3
        get nearestLookingVerticalDirection(): Internal.Direction
        get secondaryUseActive(): boolean
        get hand(): Hand
        get clickedPos(): BlockPos
        get inside(): boolean
        readonly "context": Internal.BlockPlaceContext;
        "block": Internal.BlockContainerJS;
        readonly "minecraftBlock": Internal.Block;
    }
    type BlockStateModifyPlacementCallbackJS_ = BlockStateModifyPlacementCallbackJS;
    class HugeFungusConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.BlockState_, arg1: Internal.BlockState_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: boolean)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "stemState": Internal.BlockState;
        readonly "validBaseState": Internal.BlockState;
        readonly "hatState": Internal.BlockState;
        readonly "planted": boolean;
        readonly "decorState": Internal.BlockState;
        readonly static "CODEC": any;
    }
    type HugeFungusConfiguration_ = HugeFungusConfiguration;
    class MegaJungleTrunkPlacer extends Internal.GiantTrunkPlacer {
        constructor(arg0: number, arg1: number, arg2: number)
        placeTrunk(arg0: Internal.LevelSimulatedReader_, arg1: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>, arg2: Internal.Random_, arg3: number, arg4: BlockPos_, arg5: Internal.TreeConfiguration_): Internal.List<Internal.FoliagePlacer$FoliageAttachment>;
        readonly static "CODEC": any;
    }
    type MegaJungleTrunkPlacer_ = MegaJungleTrunkPlacer;
    interface RegistryAccess {
        registry(arg0: Internal.ResourceKey_<any>): Internal.Optional<any>;
        load(arg0: Internal.RegistryAccess$Writable_, arg1: Internal.DynamicOps_<Internal.JsonElement_>, arg2: Internal.RegistryLoader_): void;
        freeze(): Internal.RegistryAccess$Frozen;
        createRegistry(arg0: Internal.ResourceKey_<any>): Internal.WritableRegistry<any>;
        registries(): Internal.Stream<Internal.RegistryAccess$RegistryEntry<any>>;
        knownRegistries(): Internal.Iterable<Internal.RegistryAccess$RegistryData<any>>;
        builtinCopy(): Internal.RegistryAccess$Writable;
        readFromDisk(arg0: Internal.Dynamic_<any>): this;
        ownedRegistryOrThrow(arg0: Internal.ResourceKey_<any>): Internal.Registry<E>;
        ownedRegistry(arg0: Internal.ResourceKey_<any>): Internal.Optional<Internal.Registry<E>>;
        retrieveRegistry(arg0: Internal.ResourceKey_<any>, arg1: Internal.Dynamic_<any>): Internal.Registry<E>;
        allElementsLifecycle(): Internal.Lifecycle;
        registryOrThrow(arg0: Internal.ResourceKey_<any>): Internal.Registry<E>;
        ownedRegistries(): Internal.Stream<Internal.RegistryAccess$RegistryEntry<any>>;
        fromRegistryOfRegistries(arg0: Internal.Registry_<any>): Internal.RegistryAccess$Frozen;
        networkSafeRegistries(): Internal.Stream<Internal.RegistryAccess$RegistryEntry<any>>;
        readonly static "REGISTRIES": {[key: Internal.ResourceKey<any>]: Internal.RegistryAccess$RegistryData<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryAccess$RegistryData<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryAccess$RegistryData<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryAccess$RegistryData<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryAccess$RegistryData<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryAccess$RegistryData<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryAccess$RegistryData<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryAccess$RegistryData<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryAccess$RegistryData<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryAccess$RegistryData<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryAccess$RegistryData<any>, [key: Internal.ResourceKey<any>]: Internal.RegistryAccess$RegistryData<any>};
        readonly static "NETWORK_CODEC": any;
        readonly static "BUILTIN": any;
        readonly static "LOGGER": any;
    }
    type RegistryAccess_ = RegistryAccess;
    class VegetationPatchConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.TagKey_<Internal.Block_>, arg1: Internal.BlockStateProvider_, arg2: Internal.Holder_<Internal.PlacedFeature_>, arg3: Internal.CaveSurface_, arg4: Internal.IntProvider_, arg5: number, arg6: number, arg7: number, arg8: Internal.IntProvider_, arg9: number)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "replaceable": Internal.TagKey<Internal.Block>;
        readonly static "CODEC": any;
        readonly "vegetationFeature": Internal.Holder<Internal.PlacedFeature>;
        readonly "groundState": Internal.BlockStateProvider;
        readonly "extraBottomBlockChance": number;
        readonly "verticalRange": number;
        readonly "extraEdgeColumnChance": number;
        readonly "xzRadius": Internal.IntProvider;
        readonly "depth": Internal.IntProvider;
        readonly "vegetationChance": number;
        readonly "surface": Internal.CaveSurface;
    }
    type VegetationPatchConfiguration_ = VegetationPatchConfiguration;
    class SpellcasterIllager$IllagerSpell extends Internal.Enum<Internal.SpellcasterIllager$IllagerSpell> {
        static values(): Internal.SpellcasterIllager$IllagerSpell[];
        static byId(arg0: number): Internal.SpellcasterIllager$IllagerSpell;
        static valueOf(arg0: string): Internal.SpellcasterIllager$IllagerSpell;
        readonly static "FANGS": Internal.SpellcasterIllager$IllagerSpell;
        readonly static "DISAPPEAR": Internal.SpellcasterIllager$IllagerSpell;
        readonly static "SUMMON_VEX": Internal.SpellcasterIllager$IllagerSpell;
        readonly static "NONE": Internal.SpellcasterIllager$IllagerSpell;
        readonly static "WOLOLO": Internal.SpellcasterIllager$IllagerSpell;
        readonly static "BLINDNESS": Internal.SpellcasterIllager$IllagerSpell;
    }
    type SpellcasterIllager$IllagerSpell_ = SpellcasterIllager$IllagerSpell | "summon_vex" | "fangs" | "disappear" | "none" | "wololo" | "blindness";
    abstract class DefaultedVertexConsumer implements Internal.VertexConsumer {
        constructor()
        uv2(arg0: number): Internal.VertexConsumer;
        color(arg0: number): Internal.VertexConsumer;
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer_): number;
        applyBakedNormals(arg0: Internal.Vector3f_, arg1: Internal.ByteBuffer_, arg2: Internal.Matrix3f_): void;
        normal(arg0: Internal.Matrix3f_, arg1: number, arg2: number, arg3: number): Internal.VertexConsumer;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void;
        defaultColor(arg0: number, arg1: number, arg2: number, arg3: number): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        overlayCoords(arg0: number): Internal.VertexConsumer;
        vertex(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number, arg11: number, arg12: number, arg13: number): void;
        color(arg0: number, arg1: number, arg2: number, arg3: number): Internal.VertexConsumer;
        getVertexFormat(): Internal.VertexFormat;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number[], arg7: number, arg8: boolean): void;
        vertex(arg0: Internal.Matrix4f_, arg1: number, arg2: number, arg3: number): Internal.VertexConsumer;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
        unsetDefaultColor(): void;
        get vertexFormat(): Internal.VertexFormat
    }
    type DefaultedVertexConsumer_ = DefaultedVertexConsumer;
    class Evoker extends Internal.SpellcasterIllager {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        isAlliedTo(arg0: Internal.Entity_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getCelebrateSound(): Internal.SoundEvent;
        shouldRiderSit(): boolean;
        applyRaidBuffs(arg0: number, arg1: boolean): void;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get multipartEntity(): boolean
        get celebrateSound(): Internal.SoundEvent
        get parts(): Internal.PartEntity<any>[]
    }
    type Evoker_ = Evoker;
    class InputEvent extends Internal.Event {
        constructor()
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type InputEvent_ = InputEvent;
    abstract class Dictionary <K, V> {
        constructor()
        keys(): Internal.Enumeration<K>;
        size(): number;
        put(arg0: K, arg1: V): V;
        isEmpty(): boolean;
        get(arg0: any): V;
        remove(arg0: any): V;
        elements(): Internal.Enumeration<V>;
        get empty(): boolean
    }
    type Dictionary_<K, V> = Dictionary<K, V>;
    class Throwable implements Internal.Serializable {
        constructor()
        constructor(arg0: string, arg1: Internal.Throwable_)
        constructor(arg0: Internal.Throwable_)
        constructor(arg0: string)
        getMessage(): string;
        toString(): string;
        getCause(): this;
        getStackTrace(): Internal.StackTraceElement[];
        printStackTrace(arg0: Internal.PrintWriter_): void;
        getSuppressed(): Internal.Throwable[];
        addSuppressed(arg0: Internal.Throwable_): void;
        fillInStackTrace(): this;
        printStackTrace(): void;
        initCause(arg0: Internal.Throwable_): this;
        setStackTrace(arg0: Internal.StackTraceElement_[]): void;
        printStackTrace(arg0: Internal.PrintStream_): void;
        getLocalizedMessage(): string;
        get message(): string
        get cause(): Internal.Throwable
        get stackTrace(): Internal.StackTraceElement[]
        get suppressed(): Internal.Throwable[]
        set stackTrace(arg0: Internal.StackTraceElement_[])
        get localizedMessage(): string
    }
    type Throwable_ = Throwable;
    class ClientboundBlockBreakAckPacket extends Internal.Record implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: Internal.ServerboundPlayerActionPacket$Action_, arg3: boolean, arg4: string)
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: Internal.ServerboundPlayerActionPacket$Action_, arg3: boolean)
        handle(arg0: Internal.PacketListener_): void;
        allGood(): boolean;
        write(arg0: Internal.FriendlyByteBuf_): void;
        hashCode(): number;
        toString(): string;
        pos(): BlockPos;
        state(): Internal.BlockState;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        action(): Internal.ServerboundPlayerActionPacket$Action;
        equals(arg0: any): boolean;
        isSkippable(): boolean;
        get skippable(): boolean
    }
    type ClientboundBlockBreakAckPacket_ = ClientboundBlockBreakAckPacket;
    class MagmaCube extends Internal.Slime {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        static checkMagmaCubeSpawnRules(arg0: Internal.EntityType_<Internal.MagmaCube_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getBrightness(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        checkSpawnObstruction(arg0: Internal.LevelReader_): boolean;
        isOnFire(): boolean;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get brightness(): number
        get stepHeight(): number
        get multipartEntity(): boolean
        get onFire(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type MagmaCube_ = MagmaCube;
    interface InjectedRegistryEntryExtension <T> {
        arch$holder(): Internal.Holder<T>;
        arch$registryName(): ResourceLocation;
    }
    type InjectedRegistryEntryExtension_<T> = InjectedRegistryEntryExtension<T>;
    class StructurePieceSerializationContext extends Internal.Record {
        constructor(arg0: Internal.ResourceManager_, arg1: Internal.RegistryAccess_, arg2: Internal.StructureManager_)
        hashCode(): number;
        toString(): string;
        structureManager(): Internal.StructureManager;
        static fromLevel(arg0: Internal.ServerLevel_): Internal.StructurePieceSerializationContext;
        resourceManager(): Internal.ResourceManager;
        registryAccess(): Internal.RegistryAccess;
        equals(arg0: any): boolean;
    }
    type StructurePieceSerializationContext_ = StructurePieceSerializationContext;
    class ServerboundContainerButtonClickPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: number, arg1: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getButtonId(): number;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getContainerId(): number;
        isSkippable(): boolean;
        get buttonId(): number
        get containerId(): number
        get skippable(): boolean
    }
    type ServerboundContainerButtonClickPacket_ = ServerboundContainerButtonClickPacket;
    interface BlockBehaviour$StatePredicate {
        test(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
    }
    type BlockBehaviour$StatePredicate_ = BlockBehaviour$StatePredicate;
    class ServerboundRenameItemPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: string)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getName(): string;
        isSkippable(): boolean;
        get name(): string
        get skippable(): boolean
    }
    type ServerboundRenameItemPacket_ = ServerboundRenameItemPacket;
    interface MessageSizeEstimator$Handle {
        size(arg0: any): number;
    }
    type MessageSizeEstimator$Handle_ = MessageSizeEstimator$Handle;
    class ServerboundPlayerAbilitiesPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.Abilities_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        isSkippable(): boolean;
        isFlying(): boolean;
        get skippable(): boolean
        get flying(): boolean
    }
    type ServerboundPlayerAbilitiesPacket_ = ServerboundPlayerAbilitiesPacket;
    interface Encoder <A> {
        encodeStart(arg0: Internal.DynamicOps_<T>, arg1: A): Internal.DataResult<T>;
        comap(arg0: Internal.Function_<any, any>): Internal.Encoder<B>;
        fieldOf(arg0: string): Internal.MapEncoder<A>;
        empty(): Internal.MapEncoder<A>;
        error(arg0: string): this;
        flatComap(arg0: Internal.Function_<any, any>): Internal.Encoder<B>;
        withLifecycle(arg0: Internal.Lifecycle_): this;
        encode(arg0: A, arg1: Internal.DynamicOps_<T>, arg2: T): Internal.DataResult<T>;
    }
    type Encoder_<A> = Encoder<A>;
    class RenderGameOverlayEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.PoseStack_, arg1: number, arg2: Internal.Window_)
        getType(): Internal.RenderGameOverlayEvent$ElementType;
        isCancelable(): boolean;
        getWindow(): Internal.Window;
        getMatrixStack(): Internal.PoseStack;
        getListenerList(): Internal.ListenerList;
        getPartialTicks(): number;
        get type(): Internal.RenderGameOverlayEvent$ElementType
        get cancelable(): boolean
        get window(): Internal.Window
        get matrixStack(): Internal.PoseStack
        get listenerList(): Internal.ListenerList
        get partialTicks(): number
    }
    type RenderGameOverlayEvent_ = RenderGameOverlayEvent;
    interface Container extends Internal.Clearable {
        stopOpen(arg0: Internal.Player_): void;
        getMaxStackSize(): number;
        countItem(arg0: Internal.Item_): number;
        isEmpty(): boolean;
        removeItemNoUpdate(arg0: number): Internal.ItemStack;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        stillValid(arg0: Internal.Player_): boolean;
        removeItem(arg0: number, arg1: number): Internal.ItemStack;
        setChanged(): void;
        getItem(arg0: number): Internal.ItemStack;
        getContainerSize(): number;
        setItem(arg0: number, arg1: Internal.ItemStack_): void;
        get maxStackSize(): number
        get empty(): boolean
        get containerSize(): number
        readonly static "LARGE_MAX_STACK_SIZE": 64;
    }
    type Container_ = Container;
    abstract class Direction$Axis extends Internal.Enum<Internal.Direction$Axis> implements Internal.Predicate<Internal.Direction>, Internal.StringRepresentable {
        getPlane(): Internal.Direction$Plane;
        static values(): Internal.Direction$Axis[];
        isVertical(): boolean;
        static byName(arg0: string): Internal.Direction$Axis;
        toString(): string;
        getSerializedName(): string;
        static getRandom(arg0: Internal.Random_): Internal.Direction$Axis;
        isHorizontal(): boolean;
        test(arg0: any): boolean;
        or(arg0: Internal.Predicate_<any>): Internal.Predicate<Internal.Direction>;
        choose(arg0: number, arg1: number, arg2: number): number;
        and(arg0: Internal.Predicate_<any>): Internal.Predicate<Internal.Direction>;
        static valueOf(arg0: string): Internal.Direction$Axis;
        getName(): string;
        choose(arg0: number, arg1: number, arg2: number): number;
        test(arg0: Internal.Direction_): boolean;
        negate(): Internal.Predicate<Internal.Direction>;
        get plane(): Internal.Direction$Plane
        get vertical(): boolean
        get serializedName(): string
        get horizontal(): boolean
        get name(): string
        readonly static "Z": any;
        readonly static "VALUES": any;
        readonly static "CODEC": any;
        readonly static "Y": any;
        readonly static "X": any;
    }
    type Direction$Axis_ = Direction$Axis | "z" | "y" | "x";
    interface ErrorReporter {
        error(arg0: string, arg1: string, arg2: number, arg3: string, arg4: number): void;
        runtimeError(arg0: string, arg1: string, arg2: number, arg3: string, arg4: number): Internal.EvaluatorException;
        warning(arg0: string, arg1: string, arg2: number, arg3: string, arg4: number): void;
    }
    type ErrorReporter_ = ErrorReporter;
    class SimpleCookingSerializer <T> extends Internal.ForgeRegistryEntry<Internal.RecipeSerializer<any>> implements Internal.RecipeSerializer<T> {
        constructor(arg0: any_<T>, arg1: number)
        fromJson(arg0: ResourceLocation_, arg1: Internal.JsonObject_): Internal.Recipe<any>;
        toNetwork(arg0: Internal.FriendlyByteBuf_, arg1: T): void;
        fromJson(arg0: ResourceLocation_, arg1: Internal.JsonObject_, arg2: Internal.ICondition$IContext_): T;
        toNetwork(arg0: Internal.FriendlyByteBuf_, arg1: Internal.Recipe_<any>): void;
        fromNetwork(arg0: ResourceLocation_, arg1: Internal.FriendlyByteBuf_): Internal.Recipe<any>;
    }
    type SimpleCookingSerializer_<T> = SimpleCookingSerializer<T>;
    class MegaJungleFoliagePlacer extends Internal.FoliagePlacer {
        constructor(arg0: Internal.IntProvider_, arg1: Internal.IntProvider_, arg2: number)
        foliageHeight(arg0: Internal.Random_, arg1: number, arg2: Internal.TreeConfiguration_): number;
        readonly static "CODEC": any;
    }
    type MegaJungleFoliagePlacer_ = MegaJungleFoliagePlacer;
    interface BiConsumer <T, U> {
        accept(arg0: T, arg1: U): void;
        andThen(arg0: Internal.BiConsumer_<any, any>): this;
    }
    type BiConsumer_<T, U> = ((arg0: T, arg1: U)=>void) | BiConsumer<T, U>;
    class PlayerInteractEvent extends Internal.PlayerEvent {
        constructor()
        getPos(): BlockPos;
        getWorld(): Internal.Level;
        getCancellationResult(): Internal.InteractionResult;
        getListenerList(): Internal.ListenerList;
        getHand(): Hand;
        getSide(): Internal.LogicalSide;
        setCancellationResult(arg0: Internal.InteractionResult_): void;
        getFace(): Internal.Direction;
        getItemStack(): Internal.ItemStack;
        get pos(): BlockPos
        get world(): Internal.Level
        get cancellationResult(): Internal.InteractionResult
        get listenerList(): Internal.ListenerList
        get hand(): Hand
        get side(): Internal.LogicalSide
        set cancellationResult(arg0: Internal.InteractionResult_)
        get face(): Internal.Direction
        get itemStack(): Internal.ItemStack
    }
    type PlayerInteractEvent_ = PlayerInteractEvent;
    interface MapCodec$ResultFunction <A> {
        apply(arg0: Internal.DynamicOps_<T>, arg1: Internal.MapLike_<T>, arg2: Internal.DataResult_<A>): Internal.DataResult<A>;
        coApply(arg0: Internal.DynamicOps_<T>, arg1: A, arg2: Internal.RecordBuilder_<T>): Internal.RecordBuilder<T>;
    }
    type MapCodec$ResultFunction_<A> = MapCodec$ResultFunction<A>;
    class SwordItemBuilder extends Internal.HandheldItemBuilder {
        constructor(i: ResourceLocation_)
        createObject(): Internal.Item;
    }
    type SwordItemBuilder_ = SwordItemBuilder;
    abstract class PainterObject implements Internal.SpecialEquality {
        constructor()
        id(i: string): this;
        hashCode(): number;
        toString(): string;
        update(tag: Internal.CompoundTag_): void;
        specialEquals(o: any, shallow: boolean): boolean;
        equals(o: any): boolean;
        "parent": Internal.PainterObjectStorage;
        "visible": Internal.Unit;
        "id": string;
    }
    type PainterObject_ = PainterObject;
    abstract class Animal extends Internal.AgeableMob {
        canMate(arg0: Internal.Animal_): boolean;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        canFallInLove(): boolean;
        isFood(arg0: Internal.ItemStack_): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        getLoveCause(): Internal.ServerPlayer;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        spawnChildFromBreeding(arg0: Internal.ServerLevel_, arg1: Internal.Animal_): void;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        setInLoveTime(arg0: number): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static checkAnimalSpawnRules(arg0: Internal.EntityType_<any>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        getAmbientSoundInterval(): number;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMyRidingOffset(): number;
        isInLove(): boolean;
        resetLove(): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getInLoveTime(): number;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getWalkTargetValue(arg0: BlockPos_, arg1: Internal.LevelReader_): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        setInLove(arg0: Internal.Player_): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        removeWhenFarAway(arg0: number): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get loveCause(): Internal.ServerPlayer
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        set inLoveTime(arg0: number)
        get ambientSoundInterval(): number
        get myRidingOffset(): number
        get inLove(): boolean
        get inLoveTime(): number
        set inLove(arg0: Internal.Player_)
    }
    type Animal_ = Animal;
    interface CompletionHandler <V, A> {
        completed(arg0: V, arg1: A): void;
        failed(arg0: Internal.Throwable_, arg1: A): void;
    }
    type CompletionHandler_<V, A> = CompletionHandler<V, A>;
    class WandererTradesEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.List_<Internal.VillagerTrades$ItemListing_>, arg1: Internal.List_<Internal.VillagerTrades$ItemListing_>)
        getRareTrades(): Internal.List<Internal.VillagerTrades$ItemListing>;
        getListenerList(): Internal.ListenerList;
        getGenericTrades(): Internal.List<Internal.VillagerTrades$ItemListing>;
        get rareTrades(): Internal.List<Internal.VillagerTrades$ItemListing>
        get listenerList(): Internal.ListenerList
        get genericTrades(): Internal.List<Internal.VillagerTrades$ItemListing>
    }
    type WandererTradesEvent_ = WandererTradesEvent;
    interface Codec <A> extends Internal.Decoder<A>, Internal.Encoder<A> {
        optionalFieldOf(arg0: string, arg1: A): Internal.MapCodec<A>;
        fieldOf(arg0: string): Internal.MapCodec<A>;
        unit(arg0: Internal.Supplier_<A>): this;
        parse(arg0: Internal.Dynamic_<T>): Internal.DataResult<A>;
        orElseGet(arg0: Internal.Consumer_<string>, arg1: Internal.Supplier_<any>): this;
        flatXmap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<S>;
        promotePartial(arg0: Internal.Consumer_<string>): this;
        simple(): Internal.Decoder$Simple<A>;
        flatMap(arg0: Internal.Function_<any, any>): Internal.Decoder<B>;
        floatRange(arg0: number, arg1: number): Internal.Codec<number>;
        stable(): this;
        dispatch(arg0: string, arg1: Internal.Function_<any, any>, arg2: Internal.Function_<any, any>): Internal.Codec<E>;
        dispatch(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<E>;
        dispatchMap(arg0: string, arg1: Internal.Function_<any, any>, arg2: Internal.Function_<any, any>): Internal.MapCodec<E>;
        flatComap(arg0: Internal.Function_<any, any>): Internal.Encoder<B>;
        withLifecycle(arg0: Internal.Lifecycle_): this;
        unit(arg0: A): this;
        intRange(arg0: number, arg1: number): Internal.Codec<number>;
        orElse(arg0: Internal.UnaryOperator_<string>, arg1: A): this;
        pair(arg0: Internal.Codec_<F>, arg1: Internal.Codec_<S>): Internal.Codec<com.mojang.datafixers.util.Pair<F, S>>;
        either(arg0: Internal.Codec_<F>, arg1: Internal.Codec_<S>): Internal.Codec<Internal.Either<F, S>>;
        comap(arg0: Internal.Function_<any, any>): Internal.Encoder<B>;
        checkRange(arg0: N, arg1: N): Internal.Function<N, Internal.DataResult<N>>;
        optionalFieldOf(arg0: string): Internal.MapCodec<Internal.Optional<A>>;
        unboundedMap(arg0: Internal.Codec_<K>, arg1: Internal.Codec_<V>): Internal.UnboundedMapCodec<K, V>;
        dispatchStable(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<E>;
        optionalFieldOf(arg0: string, arg1: Internal.Lifecycle_, arg2: A, arg3: Internal.Lifecycle_): Internal.MapCodec<A>;
        of(arg0: Internal.Encoder_<A>, arg1: Internal.Decoder_<A>, arg2: string): this;
        parse(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<A>;
        mapEither(arg0: Internal.MapCodec_<F>, arg1: Internal.MapCodec_<S>): Internal.MapCodec<Internal.Either<F, S>>;
        doubleRange(arg0: number, arg1: number): Internal.Codec<number>;
        optionalField(arg0: string, arg1: Internal.Codec_<F>): Internal.MapCodec<Internal.Optional<F>>;
        orElseGet(arg0: Internal.UnaryOperator_<string>, arg1: Internal.Supplier_<any>): this;
        simpleMap(arg0: Internal.Codec_<K>, arg1: Internal.Codec_<V>, arg2: Internal.Keyable_): Internal.SimpleMapCodec<K, V>;
        xmap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<S>;
        deprecated(arg0: number): this;
        orElse(arg0: A): this;
        list(arg0: Internal.Codec_<E>): Internal.Codec<Internal.List<E>>;
        boxed(): Internal.Decoder$Boxed<A>;
        map(arg0: Internal.Function_<any, any>): Internal.Decoder<B>;
        of(arg0: Internal.MapEncoder_<A>, arg1: Internal.MapDecoder_<A>): Internal.MapCodec<A>;
        dispatchMap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.MapCodec<E>;
        partialDispatch(arg0: string, arg1: Internal.Function_<any, any>, arg2: Internal.Function_<any, any>): Internal.Codec<E>;
        flatComapMap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<S>;
        comapFlatMap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<S>;
        of(arg0: Internal.Encoder_<A>, arg1: Internal.Decoder_<A>): this;
        orElseGet(arg0: Internal.Supplier_<any>): this;
        optionalFieldOf(arg0: string, arg1: A, arg2: Internal.Lifecycle_): Internal.MapCodec<A>;
        terminal(): Internal.Decoder$Terminal<A>;
        compoundList(arg0: Internal.Codec_<K>, arg1: Internal.Codec_<V>): Internal.Codec<Internal.List<com.mojang.datafixers.util.Pair<K, V>>>;
        of(arg0: Internal.MapEncoder_<A>, arg1: Internal.MapDecoder_<A>, arg2: Internal.Supplier_<string>): Internal.MapCodec<A>;
        orElse(arg0: Internal.Consumer_<string>, arg1: A): this;
        encodeStart(arg0: Internal.DynamicOps_<T>, arg1: A): Internal.DataResult<T>;
        listOf(): Internal.Codec<Internal.List<A>>;
        decode(arg0: Internal.Dynamic_<T>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>;
        mapResult(arg0: Internal.Codec$ResultFunction_<A>): this;
        mapPair(arg0: Internal.MapCodec_<F>, arg1: Internal.MapCodec_<S>): Internal.MapCodec<com.mojang.datafixers.util.Pair<F, S>>;
        readonly static "BOOL": any;
        readonly static "DOUBLE": any;
        readonly static "BYTE_BUFFER": any;
        readonly static "INT": any;
        readonly static "LONG_STREAM": any;
        readonly static "FLOAT": any;
        readonly static "BYTE": any;
        readonly static "EMPTY": any;
        readonly static "INT_STREAM": any;
        readonly static "LONG": any;
        readonly static "SHORT": any;
        readonly static "PASSTHROUGH": any;
        readonly static "STRING": any;
    }
    type Codec_<A> = Codec<A>;
    class BeehiveDecorator extends Internal.TreeDecorator {
        constructor(arg0: number)
        place(arg0: Internal.LevelSimulatedReader_, arg1: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>, arg2: Internal.Random_, arg3: Internal.List_<BlockPos_>, arg4: Internal.List_<BlockPos_>): void;
        readonly static "CODEC": any;
    }
    type BeehiveDecorator_ = BeehiveDecorator;
    interface ResourceProvider {
        getResource(arg0: ResourceLocation_): Internal.Resource;
    }
    type ResourceProvider_ = ((arg0: ResourceLocation)=>Internal.Resource_) | ResourceProvider;
    class LivingEntityJS extends Internal.EntityJS {
        constructor(e: Internal.LivingEntity_)
        damageEquipment(slot: EquipmentSlot_, amount: number, onBroken: Internal.Consumer_<Internal.ItemStackJS_>): void;
        getAttributeTotalValue(attribute: Internal.Attribute_): number;
        damageHeldItem(hand: Hand_, amount: number): void;
        isUndead(): boolean;
        removeAttribute(attribute: Internal.Attribute_, identifier: string): void;
        getMovementSpeed(): number;
        getAttackingEntity(): this;
        isHoldingInAnyHand(ingredient: any): boolean;
        getHeadArmorItem(): Internal.ItemStackJS;
        setDefaultMovementSpeedMultiplier(speed: number): void;
        getRevengeTarget(): this;
        setAbsorptionAmount(amount: number): void;
        setMovementSpeed(speed: number): void;
        getLastAttackedEntityTime(): number;
        getMainHandItem(): Internal.ItemStackJS;
        isSleeping(): boolean;
        getHeldItem(hand: Hand_): Internal.ItemStackJS;
        getFeetArmorItem(): Internal.ItemStackJS;
        setRevengeTarget(target: Internal.LivingEntityJS_): void;
        isElytraFlying(): boolean;
        isChild(): boolean;
        setHeadArmorItem(item: Internal.ItemStackJS_): void;
        getLastAttackedEntity(): this;
        setTotalMovementSpeedMultiplier(speed: number): void;
        swingArm(hand: Hand_): void;
        setHealth(hp: number): void;
        isLiving(): boolean;
        damageEquipment(slot: EquipmentSlot_): void;
        getTotalMovementSpeed(): number;
        rayTrace(): Internal.RayTraceResultJS;
        setChestArmorItem(item: Internal.ItemStackJS_): void;
        getEquipment(slot: EquipmentSlot_): Internal.ItemStackJS;
        setDefaultMovementSpeed(speed: number): void;
        getRevengeTimer(): number;
        setFeetArmorItem(item: Internal.ItemStackJS_): void;
        getAbsorptionAmount(): number;
        damageHeldItem(): void;
        getIdleTime(): number;
        isOnLadder(): boolean;
        heal(hp: number): void;
        setEquipment(slot: EquipmentSlot_, item: Internal.ItemStackJS_): void;
        getLegsArmorItem(): Internal.ItemStackJS;
        getOffHandItem(): Internal.ItemStackJS;
        getChestArmorItem(): Internal.ItemStackJS;
        setMaxHealth(hp: number): void;
        setLegsArmorItem(item: Internal.ItemStackJS_): void;
        getLastDamageSource(): Internal.DamageSource;
        setMovementSpeedAddition(speed: number): void;
        modifyAttribute(attribute: Internal.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): void;
        setHeldItem(hand: Hand_, item: Internal.ItemStackJS_): void;
        getReachDistance(): number;
        getHealth(): number;
        getMaxHealth(): number;
        setOffHandItem(item: Internal.ItemStackJS_): void;
        damageEquipment(slot: EquipmentSlot_, amount: number): void;
        setAttributeBaseValue(attribute: Internal.Attribute_, value: number): void;
        canEntityBeSeen(entity: Internal.LivingEntityJS_): boolean;
        getPotionEffects(): Internal.EntityPotionEffectsJS;
        setStatusMessage(message: Internal.Component_): void;
        getAttributeBaseValue(attribute: Internal.Attribute_): number;
        damageHeldItem(hand: Hand_, amount: number, onBroken: Internal.Consumer_<Internal.ItemStackJS_>): void;
        getDefaultMovementSpeed(): number;
        setMainHandItem(item: Internal.ItemStackJS_): void;
        get undead(): boolean
        get movementSpeed(): number
        get attackingEntity(): Internal.LivingEntityJS
        get headArmorItem(): Internal.ItemStackJS
        set defaultMovementSpeedMultiplier(speed: number)
        get revengeTarget(): Internal.LivingEntityJS
        set absorptionAmount(amount: number)
        set movementSpeed(speed: number)
        get lastAttackedEntityTime(): number
        get mainHandItem(): Internal.ItemStackJS
        get sleeping(): boolean
        get feetArmorItem(): Internal.ItemStackJS
        set revengeTarget(target: Internal.LivingEntityJS_)
        get elytraFlying(): boolean
        get child(): boolean
        set headArmorItem(item: Internal.ItemStackJS_)
        get lastAttackedEntity(): Internal.LivingEntityJS
        set totalMovementSpeedMultiplier(speed: number)
        set health(hp: number)
        get living(): boolean
        get totalMovementSpeed(): number
        set chestArmorItem(item: Internal.ItemStackJS_)
        set defaultMovementSpeed(speed: number)
        get revengeTimer(): number
        set feetArmorItem(item: Internal.ItemStackJS_)
        get absorptionAmount(): number
        get idleTime(): number
        get onLadder(): boolean
        get legsArmorItem(): Internal.ItemStackJS
        get offHandItem(): Internal.ItemStackJS
        get chestArmorItem(): Internal.ItemStackJS
        set maxHealth(hp: number)
        set legsArmorItem(item: Internal.ItemStackJS_)
        get lastDamageSource(): Internal.DamageSource
        set movementSpeedAddition(speed: number)
        get reachDistance(): number
        get health(): number
        get maxHealth(): number
        set offHandItem(item: Internal.ItemStackJS_)
        get potionEffects(): Internal.EntityPotionEffectsJS
        set statusMessage(message: Internal.Component_)
        get defaultMovementSpeed(): number
        set mainHandItem(item: Internal.ItemStackJS_)
        readonly static "PLAYER_CUSTOM_SPEED": Internal.UUID;
        readonly "minecraftLivingEntity": Internal.LivingEntity;
        readonly static "PLAYER_CUSTOM_SPEED_NAME": "kubejs.player.speed.modifier";
    }
    type LivingEntityJS_ = LivingEntityJS;
    class EntityDimensions {
        constructor(arg0: number, arg1: number, arg2: boolean)
        static fixed(arg0: number, arg1: number): Internal.EntityDimensions;
        scale(arg0: number): this;
        toString(): string;
        scale(arg0: number, arg1: number): this;
        makeBoundingBox(arg0: Vec3_): Internal.AABB;
        static scalable(arg0: number, arg1: number): Internal.EntityDimensions;
        makeBoundingBox(arg0: number, arg1: number, arg2: number): Internal.AABB;
        readonly "width": number;
        readonly "height": number;
        readonly "fixed": boolean;
    }
    type EntityDimensions_ = EntityDimensions;
    class FluidAttributes$Builder {
        rarity(arg0: Rarity_): this;
        sound(arg0: Internal.SoundEvent_, arg1: Internal.SoundEvent_): this;
        sound(arg0: Internal.SoundEvent_): this;
        temperature(arg0: number): this;
        luminosity(arg0: number): this;
        viscosity(arg0: number): this;
        density(arg0: number): this;
        gaseous(): this;
        build(arg0: Internal.Fluid_): Internal.FluidAttributes;
        translationKey(arg0: string): this;
        color(arg0: number): this;
        overlay(arg0: ResourceLocation_): this;
    }
    type FluidAttributes$Builder_ = FluidAttributes$Builder;
    class EntityPositionSource implements Internal.PositionSource {
        constructor(arg0: number)
        getPosition(arg0: Internal.Level_): Internal.Optional<BlockPos>;
        getType(): Internal.PositionSourceType<any>;
        get type(): Internal.PositionSourceType<any>
        readonly static "CODEC": any;
    }
    type EntityPositionSource_ = EntityPositionSource;
    interface SlotAccess {
        forEquipmentSlot(arg0: Internal.LivingEntity_, arg1: EquipmentSlot_): this;
        set(arg0: Internal.ItemStack_): boolean;
        forContainer(arg0: Internal.Container_, arg1: number): this;
        get(): Internal.ItemStack;
        forEquipmentSlot(arg0: Internal.LivingEntity_, arg1: EquipmentSlot_, arg2: Internal.Predicate_<Internal.ItemStack_>): this;
        forContainer(arg0: Internal.Container_, arg1: number, arg2: Internal.Predicate_<Internal.ItemStack_>): this;
        readonly static "NULL": any;
    }
    type SlotAccess_ = SlotAccess;
    class CubeDefinition {
        bake(arg0: number, arg1: number): Internal.ModelPart$Cube;
    }
    type CubeDefinition_ = CubeDefinition;
    interface IntConsumer {
        accept(arg0: number): void;
        andThen(arg0: Internal.IntConsumer_): this;
    }
    type IntConsumer_ = ((arg0: number)=>void) | IntConsumer;
    abstract class AbstractList <E> extends Internal.AbstractCollection<E> implements Internal.List<E> {
        get(arg0: number): E;
        add(arg0: E): boolean;
        replaceAll(arg0: Internal.UnaryOperator_<E>): void;
        subList(arg0: number, arg1: number): Internal.List<E>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: E): void;
        listIterator(): Internal.ListIterator<E>;
        forEach(arg0: Internal.Consumer_<any>): void;
        parallelStream(): Internal.Stream<E>;
        sort(arg0: Internal.Comparator_<any>): void;
        listIterator(arg0: number): Internal.ListIterator<E>;
        set(arg0: number, arg1: E): E;
        iterator(): Internal.Iterator<E>;
        hashCode(): number;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        stream(): Internal.Stream<E>;
        clear(): void;
        spliterator(): Internal.Spliterator<E>;
        addAll(arg0: number, arg1: Internal.Collection_<any>): boolean;
        remove(arg0: number): E;
        equals(arg0: any): boolean;
        lastIndexOf(arg0: any): number;
    }
    type AbstractList_<E> = AbstractList<E>;
    class LootContextParamSet$Builder {
        constructor()
        optional(arg0: Internal.LootContextParam_<any>): this;
        build(): Internal.LootContextParamSet;
        required(arg0: Internal.LootContextParam_<any>): this;
    }
    type LootContextParamSet$Builder_ = LootContextParamSet$Builder;
    class DragonTakeoffPhase extends Internal.AbstractDragonPhaseInstance {
        constructor(arg0: Internal.EnderDragon_)
        getFlyTargetLocation(): Vec3;
        getPhase(): Internal.EnderDragonPhase<Internal.DragonTakeoffPhase>;
        begin(): void;
        doServerTick(): void;
        get flyTargetLocation(): Vec3
        get phase(): Internal.EnderDragonPhase<Internal.DragonTakeoffPhase>
    }
    type DragonTakeoffPhase_ = DragonTakeoffPhase;
    class CombatEntry {
        constructor(arg0: Internal.DamageSource_, arg1: number, arg2: number, arg3: number, arg4: string, arg5: number)
        getHealthBeforeDamage(): number;
        getHealthAfterDamage(): number;
        getFallDistance(): number;
        getLocation(): string;
        isCombatRelated(): boolean;
        getSource(): Internal.DamageSource;
        getTime(): number;
        getDamage(): number;
        getAttacker(): Internal.Entity;
        getAttackerName(): Internal.Component;
        get healthBeforeDamage(): number
        get healthAfterDamage(): number
        get fallDistance(): number
        get location(): string
        get combatRelated(): boolean
        get source(): Internal.DamageSource
        get time(): number
        get damage(): number
        get attacker(): Internal.Entity
        get attackerName(): Internal.Component
    }
    type CombatEntry_ = CombatEntry;
    class ClientboundContainerClosePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getContainerId(): number;
        isSkippable(): boolean;
        get containerId(): number
        get skippable(): boolean
    }
    type ClientboundContainerClosePacket_ = ClientboundContainerClosePacket;
    class PermissionGatherEvent$Nodes extends Internal.PermissionGatherEvent {
        constructor()
        addNodes(arg0: Internal.Iterable_<Internal.PermissionNode_<any>>): void;
        addNodes(...arg0: Internal.PermissionNode_<any>[]): void;
        getNodes(): Internal.Collection<Internal.PermissionNode<any>>;
        getListenerList(): Internal.ListenerList;
        get nodes(): Internal.Collection<Internal.PermissionNode<any>>
        get listenerList(): Internal.ListenerList
    }
    type PermissionGatherEvent$Nodes_ = PermissionGatherEvent$Nodes;
    interface ArmedModel {
        translateToHand(arg0: Internal.HumanoidArm_, arg1: Internal.PoseStack_): void;
    }
    type ArmedModel_ = ArmedModel;
    interface Cloneable {
    }
    type Cloneable_ = Cloneable;
    class ServerboundSeenAdvancementsPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.ServerboundSeenAdvancementsPacket$Action_, arg1: ResourceLocation_)
        handle(arg0: Internal.PacketListener_): void;
        static openedTab(arg0: Internal.Advancement_): Internal.ServerboundSeenAdvancementsPacket;
        write(arg0: Internal.FriendlyByteBuf_): void;
        static closedScreen(): Internal.ServerboundSeenAdvancementsPacket;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getAction(): Internal.ServerboundSeenAdvancementsPacket$Action;
        getTab(): ResourceLocation;
        isSkippable(): boolean;
        get action(): Internal.ServerboundSeenAdvancementsPacket$Action
        get tab(): ResourceLocation
        get skippable(): boolean
    }
    type ServerboundSeenAdvancementsPacket_ = ServerboundSeenAdvancementsPacket;
    class TheEndGatewayBlockEntity extends Internal.TheEndPortalBlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        static teleportEntity(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.Entity_, arg4: Internal.TheEndGatewayBlockEntity_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getUpdateTag(): Internal.CompoundTag;
        getCooldownPercent(arg0: number): number;
        static teleportTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.TheEndGatewayBlockEntity_): void;
        load(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        triggerEvent(arg0: number, arg1: number): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isSpawning(): boolean;
        getUpdatePacket(): Internal.ClientboundBlockEntityDataPacket;
        serializeNBT(): Internal.CompoundTag;
        getSpawnPercent(arg0: number): number;
        isCoolingDown(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        shouldRenderFace(arg0: Internal.Direction_): boolean;
        static beamAnimationTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.TheEndGatewayBlockEntity_): void;
        static canEntityTeleport(arg0: Internal.Entity_): boolean;
        setExitPosition(arg0: BlockPos_, arg1: boolean): void;
        getParticleAmount(): number;
        getRenderBoundingBox(): Internal.AABB;
        get updateTag(): Internal.CompoundTag
        get modelData(): Internal.IModelData
        get spawning(): boolean
        get updatePacket(): Internal.ClientboundBlockEntityDataPacket
        get coolingDown(): boolean
        get particleAmount(): number
        get renderBoundingBox(): Internal.AABB
    }
    type TheEndGatewayBlockEntity_ = TheEndGatewayBlockEntity;
    interface MultiBufferSource {
        immediate(arg0: Internal.BufferBuilder_): Internal.MultiBufferSource$BufferSource;
        getBuffer(arg0: Internal.RenderType_): Internal.VertexConsumer;
        immediateWithBuffers(arg0: Internal.Map_<Internal.RenderType_, Internal.BufferBuilder_>, arg1: Internal.BufferBuilder_): Internal.MultiBufferSource$BufferSource;
    }
    type MultiBufferSource_ = MultiBufferSource;
    interface SpawnGroupData {
    }
    type SpawnGroupData_ = SpawnGroupData;
    class ChronoField extends Internal.Enum<Internal.ChronoField> implements Internal.TemporalField {
        static valueOf(arg0: string): Internal.ChronoField;
        range(): Internal.ValueRange;
        toString(): string;
        checkValidIntValue(arg0: number): number;
        rangeRefinedBy(arg0: Internal.TemporalAccessor_): Internal.ValueRange;
        isSupportedBy(arg0: Internal.TemporalAccessor_): boolean;
        getDisplayName(arg0: Internal.Locale_): string;
        resolve(arg0: Internal.Map_<Internal.TemporalField_, number>, arg1: Internal.TemporalAccessor_, arg2: Internal.ResolverStyle_): Internal.TemporalAccessor;
        getBaseUnit(): Internal.TemporalUnit;
        static values(): Internal.ChronoField[];
        isTimeBased(): boolean;
        isDateBased(): boolean;
        adjustInto(arg0: R, arg1: number): R;
        checkValidValue(arg0: number): number;
        getRangeUnit(): Internal.TemporalUnit;
        getFrom(arg0: Internal.TemporalAccessor_): number;
        get baseUnit(): Internal.TemporalUnit
        get timeBased(): boolean
        get dateBased(): boolean
        get rangeUnit(): Internal.TemporalUnit
        readonly static "ALIGNED_DAY_OF_WEEK_IN_YEAR": Internal.ChronoField;
        readonly static "OFFSET_SECONDS": Internal.ChronoField;
        readonly static "SECOND_OF_DAY": Internal.ChronoField;
        readonly static "MILLI_OF_DAY": Internal.ChronoField;
        readonly static "CLOCK_HOUR_OF_DAY": Internal.ChronoField;
        readonly static "YEAR": Internal.ChronoField;
        readonly static "MICRO_OF_DAY": Internal.ChronoField;
        readonly static "ERA": Internal.ChronoField;
        readonly static "DAY_OF_WEEK": Internal.ChronoField;
        readonly static "MINUTE_OF_HOUR": Internal.ChronoField;
        readonly static "DAY_OF_MONTH": Internal.ChronoField;
        readonly static "PROLEPTIC_MONTH": Internal.ChronoField;
        readonly static "INSTANT_SECONDS": Internal.ChronoField;
        readonly static "EPOCH_DAY": Internal.ChronoField;
        readonly static "NANO_OF_DAY": Internal.ChronoField;
        readonly static "NANO_OF_SECOND": Internal.ChronoField;
        readonly static "HOUR_OF_AMPM": Internal.ChronoField;
        readonly static "MONTH_OF_YEAR": Internal.ChronoField;
        readonly static "ALIGNED_WEEK_OF_YEAR": Internal.ChronoField;
        readonly static "MICRO_OF_SECOND": Internal.ChronoField;
        readonly static "AMPM_OF_DAY": Internal.ChronoField;
        readonly static "HOUR_OF_DAY": Internal.ChronoField;
        readonly static "MILLI_OF_SECOND": Internal.ChronoField;
        readonly static "YEAR_OF_ERA": Internal.ChronoField;
        readonly static "MINUTE_OF_DAY": Internal.ChronoField;
        readonly static "CLOCK_HOUR_OF_AMPM": Internal.ChronoField;
        readonly static "DAY_OF_YEAR": Internal.ChronoField;
        readonly static "ALIGNED_WEEK_OF_MONTH": Internal.ChronoField;
        readonly static "SECOND_OF_MINUTE": Internal.ChronoField;
        readonly static "ALIGNED_DAY_OF_WEEK_IN_MONTH": Internal.ChronoField;
    }
    type ChronoField_ = "micro_of_second" | "proleptic_month" | "epoch_day" | "offset_seconds" | "aligned_week_of_year" | "ampm_of_day" | "milli_of_second" | "hour_of_ampm" | "aligned_day_of_week_in_year" | "hour_of_day" | "aligned_day_of_week_in_month" | "year_of_era" | "minute_of_hour" | ChronoField | "micro_of_day" | "second_of_minute" | "clock_hour_of_day" | "day_of_year" | "milli_of_day" | "minute_of_day" | "instant_seconds" | "day_of_week" | "aligned_week_of_month" | "nano_of_second" | "day_of_month" | "month_of_year" | "nano_of_day" | "second_of_day" | "year" | "era" | "clock_hour_of_ampm";
    class ClientPackSource implements Internal.RepositorySource {
        constructor(arg0: Internal.File_, arg1: any_)
        getVanillaPack(): Internal.VanillaPackResources;
        downloadAndSelectResourcePack(arg0: string, arg1: string, arg2: boolean): Internal.CompletableFuture<any>;
        clearServerPack(): void;
        loadPacks(arg0: Internal.Consumer_<Internal.Pack_>, arg1: Internal.Pack$PackConstructor_): void;
        setServerPack(arg0: Internal.File_, arg1: Internal.PackSource_): Internal.CompletableFuture<void>;
        get vanillaPack(): Internal.VanillaPackResources
        readonly static "BUILT_IN": Internal.PackMetadataSection;
    }
    type ClientPackSource_ = ClientPackSource;
    class SoundEngine {
        constructor(arg0: Internal.SoundManager_, arg1: Internal.Options_, arg2: Internal.ResourceManager_)
        updateSource(arg0: Internal.Camera_): void;
        play(arg0: Internal.SoundInstance_): void;
        queueTickingSound(arg0: Internal.TickableSoundInstance_): void;
        reload(): void;
        removeEventListener(arg0: Internal.SoundEventListener_): void;
        stopAll(): void;
        destroy(): void;
        addEventListener(arg0: Internal.SoundEventListener_): void;
        updateCategoryVolume(arg0: Internal.SoundSource_, arg1: number): void;
        resume(): void;
        stop(arg0: Internal.SoundInstance_): void;
        getAvailableSoundDevices(): Internal.List<string>;
        getDebugString(): string;
        requestPreload(arg0: Internal.Sound_): void;
        playDelayed(arg0: Internal.SoundInstance_, arg1: number): void;
        isActive(arg0: Internal.SoundInstance_): boolean;
        tick(arg0: boolean): void;
        pause(): void;
        stop(arg0: ResourceLocation_, arg1: Internal.SoundSource_): void;
        get availableSoundDevices(): Internal.List<string>
        get debugString(): string
        readonly static "MISSING_SOUND": "FOR THE DEBUG!";
        readonly static "OPEN_AL_SOFT_PREFIX": "OpenAL Soft on ";
        readonly static "OPEN_AL_SOFT_PREFIX_LENGTH": 15;
        readonly "soundManager": Internal.SoundManager;
    }
    type SoundEngine_ = SoundEngine;
    class SimpleCommandExceptionType implements Internal.CommandExceptionType {
        constructor(arg0: Internal.Message_)
        toString(): string;
        createWithContext(arg0: Internal.ImmutableStringReader_): Internal.CommandSyntaxException;
        create(): Internal.CommandSyntaxException;
    }
    type SimpleCommandExceptionType_ = SimpleCommandExceptionType;
    class VanillaGameEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.GameEvent_, arg3: BlockPos_)
        getLevel(): Internal.Level;
        isCancelable(): boolean;
        getEventPosition(): BlockPos;
        getCause(): Internal.Entity;
        getListenerList(): Internal.ListenerList;
        getVanillaEvent(): Internal.GameEvent;
        get level(): Internal.Level
        get cancelable(): boolean
        get eventPosition(): BlockPos
        get cause(): Internal.Entity
        get listenerList(): Internal.ListenerList
        get vanillaEvent(): Internal.GameEvent
    }
    type VanillaGameEvent_ = VanillaGameEvent;
    class GoalSelectorDebugRenderer implements Internal.DebugRenderer$SimpleDebugRenderer {
        constructor(arg0: Internal.Minecraft_)
        removeGoalSelector(arg0: number): void;
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource_, arg2: number, arg3: number, arg4: number): void;
        clear(): void;
        addGoalSelector(arg0: number, arg1: Internal.List_<Internal.GoalSelectorDebugRenderer$DebugGoal_>): void;
    }
    type GoalSelectorDebugRenderer_ = GoalSelectorDebugRenderer;
    class TerrainShaper extends Internal.Record {
        constructor(arg0: Internal.CubicSpline_<Internal.TerrainShaper$Point_>, arg1: Internal.CubicSpline_<Internal.TerrainShaper$Point_>, arg2: Internal.CubicSpline_<Internal.TerrainShaper$Point_>)
        static overworld(arg0: boolean): Internal.TerrainShaper;
        jaggedness(arg0: Internal.TerrainShaper$Point_): number;
        toString(): string;
        offset(arg0: Internal.TerrainShaper$Point_): number;
        factorSampler(): Internal.CubicSpline<Internal.TerrainShaper$Point>;
        jaggednessSampler(): Internal.CubicSpline<Internal.TerrainShaper$Point>;
        factor(arg0: Internal.TerrainShaper$Point_): number;
        addDebugBiomesToVisualizeSplinePoints(arg0: Internal.Consumer_<com.mojang.datafixers.util.Pair_<Internal.Climate$ParameterPoint_, Internal.ResourceKey_<Internal.Biome_>>>): void;
        hashCode(): number;
        offsetSampler(): Internal.CubicSpline<Internal.TerrainShaper$Point>;
        static peaksAndValleys(arg0: number): number;
        equals(arg0: any): boolean;
        static makePoint(arg0: Internal.DensityFunction$FunctionContext_): Internal.TerrainShaper$PointCustom;
        static makePoint(arg0: number, arg1: number, arg2: number): Internal.TerrainShaper$Point;
        readonly static "SPLINE_CUSTOM_CODEC": any;
        readonly static "CODEC": any;
    }
    type TerrainShaper_ = TerrainShaper;
    class ServerboundMoveVehiclePacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.Entity_)
        handle(arg0: Internal.PacketListener_): void;
        getX(): number;
        getY(): number;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getZ(): number;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getYRot(): number;
        getXRot(): number;
        isSkippable(): boolean;
        get x(): number
        get y(): number
        get z(): number
        get YRot(): number
        get XRot(): number
        get skippable(): boolean
    }
    type ServerboundMoveVehiclePacket_ = ServerboundMoveVehiclePacket;
    class ChunkRenderDispatcher$ChunkTaskResult extends Internal.Enum<Internal.ChunkRenderDispatcher$ChunkTaskResult> {
        static values(): Internal.ChunkRenderDispatcher$ChunkTaskResult[];
        static valueOf(arg0: string): Internal.ChunkRenderDispatcher$ChunkTaskResult;
        readonly static "SUCCESSFUL": Internal.ChunkRenderDispatcher$ChunkTaskResult;
        readonly static "CANCELLED": Internal.ChunkRenderDispatcher$ChunkTaskResult;
    }
    type ChunkRenderDispatcher$ChunkTaskResult_ = "successful" | ChunkRenderDispatcher$ChunkTaskResult | "cancelled";
    interface ConstantDesc {
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup_): any;
    }
    type ConstantDesc_ = ConstantDesc;
    class ObjectiveCriteria {
        getDefaultRenderType(): Internal.ObjectiveCriteria$RenderType;
        static byName(arg0: string): Internal.Optional<Internal.ObjectiveCriteria>;
        getName(): string;
        isReadOnly(): boolean;
        static getCustomCriteriaNames(): Internal.Set<string>;
        get defaultRenderType(): Internal.ObjectiveCriteria$RenderType
        get name(): string
        get readOnly(): boolean
        get customCriteriaNames(): Internal.Set<string>
        readonly static "TRIGGER": Internal.ObjectiveCriteria;
        readonly static "HEALTH": Internal.ObjectiveCriteria;
        readonly static "KILL_COUNT_PLAYERS": Internal.ObjectiveCriteria;
        readonly static "TEAM_KILL": any;
        readonly static "AIR": Internal.ObjectiveCriteria;
        readonly static "ARMOR": Internal.ObjectiveCriteria;
        readonly static "DUMMY": Internal.ObjectiveCriteria;
        readonly static "EXPERIENCE": Internal.ObjectiveCriteria;
        readonly static "KILL_COUNT_ALL": Internal.ObjectiveCriteria;
        readonly static "DEATH_COUNT": Internal.ObjectiveCriteria;
        readonly static "KILLED_BY_TEAM": any;
        readonly static "LEVEL": Internal.ObjectiveCriteria;
        readonly static "FOOD": Internal.ObjectiveCriteria;
    }
    type ObjectiveCriteria_ = ObjectiveCriteria;
    class StraightTrunkPlacer extends Internal.TrunkPlacer {
        constructor(arg0: number, arg1: number, arg2: number)
        placeTrunk(arg0: Internal.LevelSimulatedReader_, arg1: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>, arg2: Internal.Random_, arg3: number, arg4: BlockPos_, arg5: Internal.TreeConfiguration_): Internal.List<Internal.FoliagePlacer$FoliageAttachment>;
        readonly static "CODEC": any;
    }
    type StraightTrunkPlacer_ = StraightTrunkPlacer;
    abstract class HeightProvider {
        constructor()
        sample(arg0: Internal.Random_, arg1: Internal.WorldGenerationContext_): number;
        getType(): Internal.HeightProviderType<any>;
        get type(): Internal.HeightProviderType<any>
        readonly static "CODEC": any;
    }
    type HeightProvider_ = HeightProvider;
    class ClientboundSetTitlesAnimationPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: number, arg2: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getFadeIn(): number;
        getFadeOut(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getStay(): number;
        isSkippable(): boolean;
        get fadeIn(): number
        get fadeOut(): number
        get stay(): number
        get skippable(): boolean
    }
    type ClientboundSetTitlesAnimationPacket_ = ClientboundSetTitlesAnimationPacket;
    interface IdFunctionCall {
        execIdCall(arg0: Internal.IdFunctionObject_, arg1: Internal.Context_, arg2: Internal.Scriptable_, arg3: Internal.Scriptable_, arg4: any[]): any;
    }
    type IdFunctionCall_ = IdFunctionCall;
    class Type$Mu implements Internal.K1 {
        constructor()
    }
    type Type$Mu_ = Type$Mu;
    interface AttributeView {
        name(): string;
    }
    type AttributeView_ = AttributeView;
    class ClientboundLoginPacket extends Internal.Record implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: boolean, arg2: Internal.GameType_, arg3: Internal.GameType_, arg4: Internal.Set_<Internal.ResourceKey_<Internal.Level_>>, arg5: Internal.RegistryAccess$Frozen_, arg6: Internal.Holder_<Internal.DimensionType_>, arg7: Internal.ResourceKey_<Internal.Level_>, arg8: number, arg9: number, arg10: number, arg11: number, arg12: boolean, arg13: boolean, arg14: boolean, arg15: boolean)
        constructor(arg0: Internal.FriendlyByteBuf_)
        playerId(): number;
        handle(arg0: Internal.PacketListener_): void;
        dimension(): Internal.ResourceKey<Internal.Level>;
        write(arg0: Internal.FriendlyByteBuf_): void;
        toString(): string;
        seed(): number;
        chunkRadius(): number;
        isSkippable(): boolean;
        maxPlayers(): number;
        previousGameType(): Internal.GameType;
        gameType(): Internal.GameType;
        showDeathScreen(): boolean;
        hashCode(): number;
        reducedDebugInfo(): boolean;
        simulationDistance(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        hardcore(): boolean;
        dimensionType(): Internal.Holder<Internal.DimensionType>;
        registryHolder(): Internal.RegistryAccess$Frozen;
        levels(): Internal.Set<Internal.ResourceKey<Internal.Level>>;
        equals(arg0: any): boolean;
        isFlat(): boolean;
        isDebug(): boolean;
        get skippable(): boolean
        get flat(): boolean
        get debug(): boolean
    }
    type ClientboundLoginPacket_ = ClientboundLoginPacket;
    class BlockModificationEventJS extends Internal.EventJS {
        constructor()
        modify(predicate: BlockStatePredicate_, c: Internal.Consumer_<Internal.BlockModificationProperties_>): void;
    }
    type BlockModificationEventJS_ = BlockModificationEventJS;
    class MatchingBlocksPredicate extends Internal.StateTestingPredicate {
        constructor(arg0: Vec3i_, arg1: Internal.HolderSet_<Internal.Block_>)
        type(): Internal.BlockPredicateType<any>;
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        negate(): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        readonly static "CODEC": Internal.Codec<Internal.MatchingBlocksPredicate>;
    }
    type MatchingBlocksPredicate_ = MatchingBlocksPredicate;
    class DiskConfiguration extends Internal.Record implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.BlockState_, arg1: Internal.IntProvider_, arg2: number, arg3: Internal.List_<Internal.BlockState_>)
        radius(): Internal.IntProvider;
        hashCode(): number;
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        toString(): string;
        state(): Internal.BlockState;
        targets(): Internal.List<Internal.BlockState>;
        equals(arg0: any): boolean;
        halfHeight(): number;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
    }
    type DiskConfiguration_ = DiskConfiguration;
    class PackCompatibility extends Internal.Enum<Internal.PackCompatibility> {
        static forMetadata(arg0: Internal.PackMetadataSection_, arg1: Internal.PackType_): Internal.PackCompatibility;
        static valueOf(arg0: string): Internal.PackCompatibility;
        getConfirmation(): Internal.Component;
        isCompatible(): boolean;
        static values(): Internal.PackCompatibility[];
        getDescription(): Internal.Component;
        static forFormat(arg0: number, arg1: Internal.PackType_): Internal.PackCompatibility;
        get confirmation(): Internal.Component
        get compatible(): boolean
        get description(): Internal.Component
        readonly static "TOO_OLD": Internal.PackCompatibility;
        readonly static "COMPATIBLE": Internal.PackCompatibility;
        readonly static "TOO_NEW": Internal.PackCompatibility;
    }
    type PackCompatibility_ = "compatible" | PackCompatibility | "too_old" | "too_new";
    class LivingSpawnEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.Mob_, arg1: Internal.LevelAccessor_, arg2: number, arg3: number, arg4: number)
        getX(): number;
        getY(): number;
        getZ(): number;
        getListenerList(): Internal.ListenerList;
        getWorld(): Internal.LevelAccessor;
        get x(): number
        get y(): number
        get z(): number
        get listenerList(): Internal.ListenerList
        get world(): Internal.LevelAccessor
    }
    type LivingSpawnEvent_ = LivingSpawnEvent;
    class ItemInHandRenderer {
        constructor(arg0: Internal.Minecraft_)
        renderHandsWithItems(arg0: number, arg1: Internal.PoseStack_, arg2: Internal.MultiBufferSource$BufferSource_, arg3: Internal.LocalPlayer_, arg4: number): void;
        renderItem(arg0: Internal.LivingEntity_, arg1: Internal.ItemStack_, arg2: Internal.ItemTransforms$TransformType_, arg3: boolean, arg4: Internal.PoseStack_, arg5: Internal.MultiBufferSource_, arg6: number): void;
        itemUsed(arg0: Hand_): void;
        tick(): void;
    }
    type ItemInHandRenderer_ = ItemInHandRenderer;
    class PlayerEvent$LoadFromFile extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.File_, arg2: string)
        getListenerList(): Internal.ListenerList;
        getPlayerFile(arg0: string): Internal.File;
        getPlayerDirectory(): Internal.File;
        getPlayerUUID(): string;
        get listenerList(): Internal.ListenerList
        get playerDirectory(): Internal.File
        get playerUUID(): string
    }
    type PlayerEvent$LoadFromFile_ = PlayerEvent$LoadFromFile;
    class BlockModelShaper {
        constructor(arg0: Internal.ModelManager_)
        static stateToModelLocation(arg0: ResourceLocation_, arg1: Internal.BlockState_): Internal.ModelResourceLocation;
        getBlockModel(arg0: Internal.BlockState_): Internal.BakedModel;
        getModelManager(): Internal.ModelManager;
        static statePropertiesToString(arg0: Internal.Map_<Internal.Property_<any>, Internal.Comparable_<any>>): string;
        rebuildCache(): void;
        getParticleIcon(arg0: Internal.BlockState_): Internal.TextureAtlasSprite;
        static stateToModelLocation(arg0: Internal.BlockState_): Internal.ModelResourceLocation;
        getTexture(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_): Internal.TextureAtlasSprite;
        get modelManager(): Internal.ModelManager
    }
    type BlockModelShaper_ = BlockModelShaper;
    class BlockBehaviour$Properties {
        constructor(arg0: Internal.Material_, arg1: Internal.Function_<Internal.BlockState_, Internal.MaterialColor_>)
        static of(arg0: Internal.Material_, arg1: Internal.DyeColor_): Internal.BlockBehaviour$Properties;
        destroyTime(arg0: number): this;
        randomTicks(): this;
        speedFactor(arg0: number): this;
        static copy(arg0: Internal.BlockBehaviour_): Internal.BlockBehaviour$Properties;
        dropsLike(arg0: Internal.Block_): this;
        static of(arg0: Internal.Material_, arg1: Internal.Function_<Internal.BlockState_, Internal.MaterialColor_>): Internal.BlockBehaviour$Properties;
        explosionResistance(arg0: number): this;
        emissiveRendering(arg0: Internal.BlockBehaviour$StatePredicate_): this;
        instabreak(): this;
        isViewBlocking(arg0: Internal.BlockBehaviour$StatePredicate_): this;
        lootFrom(arg0: Internal.Supplier_<any>): this;
        requiresCorrectToolForDrops(): this;
        friction(arg0: number): this;
        isRedstoneConductor(arg0: Internal.BlockBehaviour$StatePredicate_): this;
        lightLevel(arg0: Internal.ToIntFunction_<Internal.BlockState_>): this;
        air(): this;
        jumpFactor(arg0: number): this;
        color(arg0: Internal.MaterialColor_): this;
        isValidSpawn(arg0: Internal.BlockBehaviour$StateArgumentPredicate_<Internal.EntityType_<any>>): this;
        noCollission(): this;
        noOcclusion(): this;
        sound(arg0: Internal.SoundType_): this;
        dynamicShape(): this;
        strength(arg0: number): this;
        strength(arg0: number, arg1: number): this;
        noDrops(): this;
        static of(arg0: Internal.Material_, arg1: Internal.MaterialColor_): Internal.BlockBehaviour$Properties;
        static of(arg0: Internal.Material_): Internal.BlockBehaviour$Properties;
        hasPostProcess(arg0: Internal.BlockBehaviour$StatePredicate_): this;
        isSuffocating(arg0: Internal.BlockBehaviour$StatePredicate_): this;
        "destroyTime": number;
        "jumpFactor": number;
        "explosionResistance": number;
        "drops": ResourceLocation;
        "isViewBlocking": Internal.BlockBehaviour$StatePredicate;
        "hasCollision": boolean;
        "lightEmission": Internal.ToIntFunction<Internal.BlockState>;
        "dynamicShape": boolean;
        "friction": number;
        "requiresCorrectToolForDrops": boolean;
        "isAir": boolean;
        "isRandomlyTicking": boolean;
        "speedFactor": number;
        "canOcclude": boolean;
        "emissiveRendering": Internal.BlockBehaviour$StatePredicate;
        "materialColor": Internal.Function<Internal.BlockState, Internal.MaterialColor>;
        "soundType": Internal.SoundType;
        "isValidSpawn": Internal.BlockBehaviour$StateArgumentPredicate<Internal.EntityType<any>>;
        "hasPostProcess": Internal.BlockBehaviour$StatePredicate;
        "material": Internal.Material;
        "isRedstoneConductor": Internal.BlockBehaviour$StatePredicate;
        "isSuffocating": Internal.BlockBehaviour$StatePredicate;
    }
    type BlockBehaviour$Properties_ = BlockBehaviour$Properties;
    class EndGatewayConfiguration implements Internal.FeatureConfiguration {
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        isExitExact(): boolean;
        static delayedExitSearch(): Internal.EndGatewayConfiguration;
        getExit(): Internal.Optional<BlockPos>;
        static knownExit(arg0: BlockPos_, arg1: boolean): Internal.EndGatewayConfiguration;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        get exitExact(): boolean
        get exit(): Internal.Optional<BlockPos>
        readonly static "CODEC": any;
    }
    type EndGatewayConfiguration_ = EndGatewayConfiguration;
    class EntityViewRenderEvent$CameraSetup extends Internal.EntityViewRenderEvent {
        constructor()
        constructor(arg0: Internal.GameRenderer_, arg1: Internal.Camera_, arg2: number, arg3: number, arg4: number, arg5: number)
        getRoll(): number;
        setPitch(arg0: number): void;
        getPitch(): number;
        getListenerList(): Internal.ListenerList;
        getYaw(): number;
        setRoll(arg0: number): void;
        setYaw(arg0: number): void;
        get roll(): number
        set pitch(arg0: number)
        get pitch(): number
        get listenerList(): Internal.ListenerList
        get yaw(): number
        set roll(arg0: number)
        set yaw(arg0: number)
    }
    type EntityViewRenderEvent$CameraSetup_ = EntityViewRenderEvent$CameraSetup;
    class LivingDamageEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.LivingEntity_, arg1: Internal.DamageSource_, arg2: number)
        isCancelable(): boolean;
        setAmount(arg0: number): void;
        getAmount(): number;
        getListenerList(): Internal.ListenerList;
        getSource(): Internal.DamageSource;
        get cancelable(): boolean
        set amount(arg0: number)
        get amount(): number
        get listenerList(): Internal.ListenerList
        get source(): Internal.DamageSource
    }
    type LivingDamageEvent_ = LivingDamageEvent;
    class Climate$ParameterPoint extends Internal.Record {
        constructor(arg0: Internal.Climate$Parameter_, arg1: Internal.Climate$Parameter_, arg2: Internal.Climate$Parameter_, arg3: Internal.Climate$Parameter_, arg4: Internal.Climate$Parameter_, arg5: Internal.Climate$Parameter_, arg6: number)
        depth(): Internal.Climate$Parameter;
        weirdness(): Internal.Climate$Parameter;
        hashCode(): number;
        toString(): string;
        erosion(): Internal.Climate$Parameter;
        temperature(): Internal.Climate$Parameter;
        continentalness(): Internal.Climate$Parameter;
        equals(arg0: any): boolean;
        humidity(): Internal.Climate$Parameter;
        offset(): number;
        readonly static "CODEC": any;
    }
    type Climate$ParameterPoint_ = Climate$ParameterPoint;
    interface Collector <T, A, R> {
        accumulator(): Internal.BiConsumer<A, T>;
        of(arg0: Internal.Supplier_<A>, arg1: Internal.BiConsumer_<A, T>, arg2: Internal.BinaryOperator_<A>, arg3: Internal.Function_<A, R>, ...arg4: Internal.Collector$Characteristics_[]): this;
        characteristics(): Internal.Set<Internal.Collector$Characteristics>;
        supplier(): Internal.Supplier<A>;
        finisher(): Internal.Function<A, R>;
        combiner(): Internal.BinaryOperator<A>;
        of(arg0: Internal.Supplier_<R>, arg1: Internal.BiConsumer_<R, T>, arg2: Internal.BinaryOperator_<R>, ...arg3: Internal.Collector$Characteristics_[]): Internal.Collector<T, R, R>;
    }
    type Collector_<T, A, R> = Collector<T, A, R>;
    class EntityItemPickupEvent extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.ItemEntity_)
        hasResult(): boolean;
        getItem(): Internal.ItemEntity;
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get item(): Internal.ItemEntity
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type EntityItemPickupEvent_ = EntityItemPickupEvent;
    interface CommonLevelAccessor extends Internal.LevelSimulatedRW, Internal.LevelReader, Internal.EntityGetter {
        getBlockTint(arg0: BlockPos_, arg1: Internal.ColorResolver_): number;
        getMinSection(): number;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_): Internal.Player;
        findFreePosition(arg0: Internal.Entity_, arg1: Internal.VoxelShape_, arg2: Vec3_, arg3: number, arg4: number, arg5: number): Internal.Optional<Vec3>;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        isUnobstructed(arg0: Internal.Entity_, arg1: Internal.VoxelShape_): boolean;
        getMaxSection(): number;
        getBrightness(arg0: Internal.LightLayer_, arg1: BlockPos_): number;
        getNearestPlayer(arg0: Internal.Entity_, arg1: number): Internal.Player;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getBlockStatesIfLoaded(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getSectionYFromSectionIndex(arg0: number): number;
        isEmptyBlock(arg0: BlockPos_): boolean;
        getMaxLocalRawBrightness(arg0: BlockPos_, arg1: number): number;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        getBlockCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        getRawBrightness(arg0: BlockPos_, arg1: number): number;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getHeightmapPos(arg0: Internal.Heightmap$Types_, arg1: BlockPos_): BlockPos;
        canSeeSky(arg0: BlockPos_): boolean;
        isUnobstructed(arg0: Internal.Entity_): boolean;
        getEntities(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.Entity>;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_): Internal.List<T>;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getBrightness(arg0: BlockPos_): number;
        getNearestEntity(arg0: Internal.List_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number): T;
        getPlayerByUUID(arg0: Internal.UUID_): Internal.Player;
        canSeeSkyFromBelowWater(arg0: BlockPos_): boolean;
        getSectionsCount(): number;
        getMinBuildHeight(): number;
        getSectionIndexFromSectionY(arg0: number): number;
        getNearbyPlayers(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: Internal.AABB_): Internal.List<Internal.Player>;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): Internal.Player;
        setBlock(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: number): boolean;
        noCollision(arg0: Internal.Entity_): boolean;
        getChunk(arg0: number, arg1: number, arg2: Internal.ChunkStatus_): Internal.ChunkAccess;
        hasChunkAt(arg0: number, arg1: number): boolean;
        getSectionIndex(arg0: number): number;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: number, arg2: number, arg3: number): Internal.Player;
        getMaxBuildHeight(): number;
        getNearbyEntities(arg0: Internal.Class_<T>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: Internal.AABB_): Internal.List<T>;
        hasChunksAt(arg0: BlockPos_, arg1: BlockPos_): boolean;
        destroyBlock(arg0: BlockPos_, arg1: boolean): boolean;
        addFreshEntity(arg0: Internal.Entity_): boolean;
        noCollision(arg0: Internal.AABB_): boolean;
        getChunk(arg0: number, arg1: number): Internal.ChunkAccess;
        isWaterAt(arg0: BlockPos_): boolean;
        getDirectSignal(arg0: BlockPos_, arg1: Internal.Direction_): number;
        getCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        destroyBlock(arg0: BlockPos_, arg1: boolean, arg2: Internal.Entity_): boolean;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        getEntityCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.VoxelShape>;
        collidesWithSuffocatingBlock(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getHeight(): number;
        getNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        noCollision(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getChunk(arg0: BlockPos_): Internal.ChunkAccess;
        isOutsideBuildHeight(arg0: number): boolean;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Predicate_<Internal.Entity_>): Internal.Player;
        getMaxLocalRawBrightness(arg0: BlockPos_): number;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getNearestEntity(arg0: Internal.Class_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number, arg6: Internal.AABB_): T;
        isUnobstructed(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.CollisionContext_): boolean;
        registryAccess(): Internal.RegistryAccess;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_, arg2: Internal.Predicate_<any>): Internal.List<T>;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        hasChunkAt(arg0: BlockPos_): boolean;
        getBiome(arg0: BlockPos_): Internal.Holder<Internal.Biome>;
        getChunkForCollisions(arg0: number, arg1: number): Internal.BlockGetter;
        containsAnyLiquid(arg0: Internal.AABB_): boolean;
        hasNearbyAlivePlayer(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getMaxLightLevel(): number;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: number, arg3: number, arg4: number): Internal.Player;
        get minSection(): number
        get maxSection(): number
        get sectionsCount(): number
        get minBuildHeight(): number
        get maxBuildHeight(): number
        get height(): number
        get maxLightLevel(): number
    }
    type CommonLevelAccessor_ = CommonLevelAccessor;
    interface IForgeLevel extends Internal.ICapabilityProvider {
        increaseMaxEntityRadius(arg0: number): number;
        getPartEntities(): Internal.Collection<Internal.PartEntity<any>>;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getMaxEntityRadius(): number;
        get partEntities(): Internal.Collection<Internal.PartEntity<any>>
        get maxEntityRadius(): number
    }
    type IForgeLevel_ = IForgeLevel;
    class RegistryEvent$IdMappingEvent$ModRemapping {
        readonly "oldId": number;
        readonly "registry": ResourceLocation;
        readonly "newId": number;
        readonly "key": ResourceLocation;
    }
    type RegistryEvent$IdMappingEvent$ModRemapping_ = RegistryEvent$IdMappingEvent$ModRemapping;
    class InteractionResult extends Internal.Enum<Internal.InteractionResult> {
        static values(): Internal.InteractionResult[];
        shouldSwing(): boolean;
        static sidedSuccess(arg0: boolean): Internal.InteractionResult;
        shouldAwardStats(): boolean;
        consumesAction(): boolean;
        static valueOf(arg0: string): Internal.InteractionResult;
        readonly static "PASS": Internal.InteractionResult;
        readonly static "CONSUME_PARTIAL": Internal.InteractionResult;
        readonly static "FAIL": Internal.InteractionResult;
        readonly static "CONSUME": Internal.InteractionResult;
        readonly static "SUCCESS": Internal.InteractionResult;
    }
    type InteractionResult_ = InteractionResult | "pass" | "consume" | "success" | "consume_partial" | "fail";
    class DragonSittingScanningPhase extends Internal.AbstractDragonSittingPhase {
        constructor(arg0: Internal.EnderDragon_)
        begin(): void;
        doServerTick(): void;
        getPhase(): Internal.EnderDragonPhase<Internal.DragonSittingScanningPhase>;
        get phase(): Internal.EnderDragonPhase<Internal.DragonSittingScanningPhase>
    }
    type DragonSittingScanningPhase_ = DragonSittingScanningPhase;
    abstract class DynamicLike <T> {
        constructor(arg0: Internal.DynamicOps_<T>)
        asMapOpt(arg0: Internal.Function_<Internal.Dynamic_<T>, K>, arg1: Internal.Function_<Internal.Dynamic_<T>, V>): Internal.DataResult<Internal.Map<K, V>>;
        createIntList(arg0: Internal.IntStream_): Internal.Dynamic<any>;
        createBoolean(arg0: boolean): Internal.Dynamic<T>;
        readMap(arg0: Internal.Decoder_<K>, arg1: Internal.Decoder_<V>): Internal.DataResult<Internal.List<com.mojang.datafixers.util.Pair<K, V>>>;
        getGeneric(arg0: T): Internal.DataResult<T>;
        getOps(): Internal.DynamicOps<T>;
        createNumeric(arg0: Internal.Number_): Internal.Dynamic<T>;
        asNumber(arg0: Internal.Number_): Internal.Number;
        asIntStream(): Internal.IntStream;
        asString(): Internal.DataResult<string>;
        createDouble(arg0: number): Internal.Dynamic<T>;
        asByte(arg0: number): number;
        asMap(arg0: Internal.Function_<Internal.Dynamic_<T>, K>, arg1: Internal.Function_<Internal.Dynamic_<T>, V>): Internal.Map<K, V>;
        getElementGeneric(arg0: T, arg1: T): T;
        asLong(arg0: number): number;
        getElement(arg0: string, arg1: T): T;
        getElement(arg0: string): Internal.DataResult<T>;
        asShort(arg0: number): number;
        asDouble(arg0: number): number;
        emptyMap(): Internal.Dynamic<T>;
        asFloat(arg0: number): number;
        asNumber(): Internal.DataResult<Internal.Number>;
        readMap(arg0: Internal.Decoder_<K>, arg1: Internal.Function_<K, Internal.Decoder_<V>>): Internal.DataResult<Internal.List<com.mojang.datafixers.util.Pair<K, V>>>;
        asString(arg0: string): string;
        createFloat(arg0: number): Internal.Dynamic<T>;
        asStream(): Internal.Stream<Internal.Dynamic<T>>;
        readList(arg0: Internal.Function_<any, any>): Internal.DataResult<Internal.List<E>>;
        get(arg0: string): Internal.OptionalDynamic<T>;
        createByte(arg0: number): Internal.Dynamic<T>;
        emptyList(): Internal.Dynamic<T>;
        asLongStreamOpt(): Internal.DataResult<Internal.LongStream>;
        readMap(arg0: Internal.DataResult_<R>, arg1: Internal.Function3_<R, Internal.Dynamic_<T>, Internal.Dynamic_<T>, Internal.DataResult_<R>>): Internal.DataResult<R>;
        asIntStreamOpt(): Internal.DataResult<Internal.IntStream>;
        asByteBuffer(): Internal.ByteBuffer;
        createList(arg0: Internal.Stream_<any>): Internal.Dynamic<T>;
        createLongList(arg0: Internal.LongStream_): Internal.Dynamic<any>;
        readList(arg0: Internal.Decoder_<E>): Internal.DataResult<Internal.List<E>>;
        asInt(arg0: number): number;
        createShort(arg0: number): Internal.Dynamic<T>;
        createString(arg0: string): Internal.Dynamic<T>;
        asBoolean(arg0: boolean): boolean;
        getElementGeneric(arg0: T): Internal.DataResult<T>;
        decode(arg0: Internal.Decoder_<any>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>;
        asList(arg0: Internal.Function_<Internal.Dynamic_<T>, U>): Internal.List<U>;
        createByteList(arg0: Internal.ByteBuffer_): Internal.Dynamic<any>;
        asByteBufferOpt(): Internal.DataResult<Internal.ByteBuffer>;
        createMap(arg0: Internal.Map_<any, any>): Internal.Dynamic<T>;
        asLongStream(): Internal.LongStream;
        asListOpt(arg0: Internal.Function_<Internal.Dynamic_<T>, U>): Internal.DataResult<Internal.List<U>>;
        asStreamOpt(): Internal.DataResult<Internal.Stream<Internal.Dynamic<T>>>;
        read(arg0: Internal.Decoder_<any>): Internal.DataResult<A>;
        asMapOpt(): Internal.DataResult<Internal.Stream<com.mojang.datafixers.util.Pair<Internal.Dynamic<T>, Internal.Dynamic<T>>>>;
        createLong(arg0: number): Internal.Dynamic<T>;
        createInt(arg0: number): Internal.Dynamic<T>;
        get ops(): Internal.DynamicOps<T>
    }
    type DynamicLike_<T> = DynamicLike<T>;
    abstract class AbstractIllager extends Internal.Raider {
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMobType(): Internal.MobType;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        canAttack(arg0: Internal.LivingEntity_): boolean;
        getArmPose(): Internal.AbstractIllager$IllagerArmPose;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get mobType(): Internal.MobType
        get stepHeight(): number
        get armPose(): Internal.AbstractIllager$IllagerArmPose
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type AbstractIllager_ = AbstractIllager;
    class ByteOrder {
        static nativeOrder(): Internal.ByteOrder;
        toString(): string;
        readonly static "BIG_ENDIAN": Internal.ByteOrder;
        readonly static "LITTLE_ENDIAN": Internal.ByteOrder;
    }
    type ByteOrder_ = ByteOrder;
    class LivingEvent$LivingVisibilityEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.LivingEntity_, arg1: Internal.Entity_, arg2: number)
        getVisibilityModifier(): number;
        getListenerList(): Internal.ListenerList;
        getLookingEntity(): Internal.Entity;
        modifyVisibility(arg0: number): void;
        get visibilityModifier(): number
        get listenerList(): Internal.ListenerList
        get lookingEntity(): Internal.Entity
    }
    type LivingEvent$LivingVisibilityEvent_ = LivingEvent$LivingVisibilityEvent;
    class StructurePiecesBuilder implements Internal.StructurePieceAccessor {
        constructor()
        addPiece(arg0: Internal.StructurePiece_): void;
        moveBelowSeaLevel(arg0: number, arg1: number, arg2: Internal.Random_, arg3: number): void;
        clear(): void;
        offsetPiecesVertically(arg0: number): void;
        moveInsideHeights(arg0: Internal.Random_, arg1: number, arg2: number): void;
        build(): Internal.PiecesContainer;
        findCollisionPiece(arg0: Internal.BoundingBox_): Internal.StructurePiece;
        isEmpty(): boolean;
        getBoundingBox(): Internal.BoundingBox;
        get empty(): boolean
        get boundingBox(): Internal.BoundingBox
    }
    type StructurePiecesBuilder_ = StructurePiecesBuilder;
    interface Long2ByteFunction extends Internal.LongToIntFunction, it.unimi.dsi.fastutil.Function<number, number> {
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Long2LongFunction;
        put(arg0: number, arg1: number): number;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2ByteFunction;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Long2FloatFunction;
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: number, arg1: number): number;
        andThenByte(arg0: Internal.Byte2ByteFunction_): this;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2ByteFunction;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2ByteFunction;
        andThenReference(arg0: Internal.Byte2ReferenceFunction_<any>): Internal.Long2ReferenceFunction<T>;
        get(arg0: number): number;
        composeReference(arg0: Internal.Reference2LongFunction_<any>): Internal.Reference2ByteFunction<T>;
        remove(arg0: number): number;
        containsKey(arg0: any): boolean;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Long2ShortFunction;
        defaultReturnValue(arg0: number): void;
        put(arg0: any, arg1: any): any;
        applyAsInt(arg0: number): number;
        defaultReturnValue(): number;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2ByteFunction;
        andThenObject(arg0: Internal.Byte2ObjectFunction_<any>): Internal.Long2ObjectFunction<T>;
        composeLong(arg0: Internal.Long2LongFunction_): this;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2ByteFunction;
        put(arg0: number, arg1: number): number;
        get(arg0: any): number;
        apply(arg0: number): number;
        containsKey(arg0: number): boolean;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2ByteFunction;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Long2CharFunction;
        getOrDefault(arg0: any, arg1: number): number;
        composeObject(arg0: Internal.Object2LongFunction_<any>): Internal.Object2ByteFunction<T>;
        size(): number;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Long2DoubleFunction;
        clear(): void;
        remove(arg0: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Long2IntFunction;
    }
    type Long2ByteFunction_ = Long2ByteFunction | ((arg0: number)=>number);
    interface BuiltInExceptionProvider {
        dispatcherParseException(): Internal.DynamicCommandExceptionType;
        readerExpectedInt(): Internal.SimpleCommandExceptionType;
        floatTooLow(): Internal.Dynamic2CommandExceptionType;
        readerInvalidEscape(): Internal.DynamicCommandExceptionType;
        readerInvalidBool(): Internal.DynamicCommandExceptionType;
        readerInvalidLong(): Internal.DynamicCommandExceptionType;
        readerInvalidDouble(): Internal.DynamicCommandExceptionType;
        readerInvalidInt(): Internal.DynamicCommandExceptionType;
        integerTooLow(): Internal.Dynamic2CommandExceptionType;
        longTooLow(): Internal.Dynamic2CommandExceptionType;
        floatTooHigh(): Internal.Dynamic2CommandExceptionType;
        readerExpectedLong(): Internal.SimpleCommandExceptionType;
        dispatcherUnknownCommand(): Internal.SimpleCommandExceptionType;
        integerTooHigh(): Internal.Dynamic2CommandExceptionType;
        readerExpectedFloat(): Internal.SimpleCommandExceptionType;
        readerExpectedSymbol(): Internal.DynamicCommandExceptionType;
        longTooHigh(): Internal.Dynamic2CommandExceptionType;
        readerExpectedEndOfQuote(): Internal.SimpleCommandExceptionType;
        doubleTooHigh(): Internal.Dynamic2CommandExceptionType;
        doubleTooLow(): Internal.Dynamic2CommandExceptionType;
        readerExpectedStartOfQuote(): Internal.SimpleCommandExceptionType;
        dispatcherUnknownArgument(): Internal.SimpleCommandExceptionType;
        readerExpectedBool(): Internal.SimpleCommandExceptionType;
        literalIncorrect(): Internal.DynamicCommandExceptionType;
        readerInvalidFloat(): Internal.DynamicCommandExceptionType;
        readerExpectedDouble(): Internal.SimpleCommandExceptionType;
        dispatcherExpectedArgumentSeparator(): Internal.SimpleCommandExceptionType;
    }
    type BuiltInExceptionProvider_ = BuiltInExceptionProvider;
    abstract class EffectRenderingInventoryScreen <T> extends Internal.AbstractContainerScreen<T> {
        constructor(arg0: T, arg1: Internal.Inventory_, arg2: Internal.Component_)
        charTyped(arg0: string, arg1: number): boolean;
        magicalSpecialHackyFocus(arg0: Internal.GuiEventListener_): void;
        render(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        setInitialFocus(arg0: Internal.GuiEventListener_): void;
        canSeeEffects(): boolean;
        changeFocus(arg0: boolean): boolean;
        keyReleased(arg0: number, arg1: number, arg2: number): boolean;
        getChildAt(arg0: number, arg1: number): Internal.Optional<Internal.GuiEventListener>;
        mouseMoved(arg0: number, arg1: number): void;
        mouseScrolled(arg0: number, arg1: number, arg2: number): boolean;
        set initialFocus(arg0: Internal.GuiEventListener_)
    }
    type EffectRenderingInventoryScreen_<T> = EffectRenderingInventoryScreen<T>;
    class BedBlockEntity extends Internal.BlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: Internal.DyeColor_)
        getColor(): Internal.DyeColor;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        serializeNBT(): Internal.CompoundTag;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getUpdatePacket(): Internal.Packet<any>;
        onLoad(): void;
        setColor(arg0: Internal.DyeColor_): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get color(): Internal.DyeColor
        get modelData(): Internal.IModelData
        get updatePacket(): Internal.Packet<any>
        set color(arg0: Internal.DyeColor_)
        get renderBoundingBox(): Internal.AABB
    }
    type BedBlockEntity_ = BedBlockEntity;
    class HoverEvent$EntityTooltipInfo {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.UUID_, arg2: Internal.Component_)
        static create(arg0: Internal.JsonElement_): Internal.HoverEvent$EntityTooltipInfo;
        hashCode(): number;
        getTooltipLines(): Internal.List<Internal.Component>;
        serialize(): Internal.JsonElement;
        equals(arg0: any): boolean;
        static create(arg0: Internal.Component_): Internal.HoverEvent$EntityTooltipInfo;
        get tooltipLines(): Internal.List<Internal.Component>
        readonly "id": Internal.UUID;
        readonly "name": Internal.Component;
        readonly "type": Internal.EntityType<any>;
    }
    type HoverEvent$EntityTooltipInfo_ = HoverEvent$EntityTooltipInfo;
    abstract class ThrowableProjectile extends Internal.Projectile {
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        tick(): void;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRenderAtSqrDistance(arg0: number): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type ThrowableProjectile_ = ThrowableProjectile;
    class WorldGenSettings {
        constructor(arg0: number, arg1: boolean, arg2: boolean, arg3: Internal.Registry_<Internal.LevelStem_>, arg4: Internal.Optional_<string>)
        constructor(arg0: number, arg1: boolean, arg2: boolean, arg3: Internal.Registry_<Internal.LevelStem_>)
        withSeed(arg0: boolean, arg1: Internal.OptionalLong_): this;
        static makeDefaultOverworld(arg0: Internal.RegistryAccess_, arg1: number): Internal.NoiseBasedChunkGenerator;
        static levelToLevelStem(arg0: Internal.ResourceKey_<Internal.Level_>): Internal.ResourceKey<Internal.LevelStem>;
        static withOverworld(arg0: Internal.Registry_<Internal.LevelStem_>, arg1: Internal.Holder_<Internal.DimensionType_>, arg2: Internal.ChunkGenerator_): Internal.Registry<Internal.LevelStem>;
        static parseSeed(arg0: string): Internal.OptionalLong;
        static makeOverworld(arg0: Internal.RegistryAccess_, arg1: number, arg2: Internal.ResourceKey_<Internal.NoiseGeneratorSettings_>): Internal.NoiseBasedChunkGenerator;
        isFlatWorld(): boolean;
        overworld(): Internal.ChunkGenerator;
        generateFeatures(): boolean;
        static makeDefault(arg0: Internal.RegistryAccess_): Internal.WorldGenSettings;
        withFeaturesToggled(): this;
        static withOverworld(arg0: Internal.Registry_<Internal.DimensionType_>, arg1: Internal.Registry_<Internal.LevelStem_>, arg2: Internal.ChunkGenerator_): Internal.Registry<Internal.LevelStem>;
        generateBonusChest(): boolean;
        seed(): number;
        levels(): Internal.ImmutableSet<Internal.ResourceKey<Internal.Level>>;
        static levelStemToLevel(arg0: Internal.ResourceKey_<Internal.LevelStem_>): Internal.ResourceKey<Internal.Level>;
        static makeOverworld(arg0: Internal.RegistryAccess_, arg1: number, arg2: Internal.ResourceKey_<Internal.NoiseGeneratorSettings_>, arg3: boolean): Internal.NoiseBasedChunkGenerator;
        dimensions(): Internal.Registry<Internal.LevelStem>;
        withBonusChest(): this;
        static demoSettings(arg0: Internal.RegistryAccess_): Internal.WorldGenSettings;
        withBonusChestToggled(): this;
        isOldCustomizedWorld(): boolean;
        static create(arg0: Internal.RegistryAccess_, arg1: Internal.DedicatedServerProperties$WorldGenProperties_): Internal.WorldGenSettings;
        static makeDefaultOverworld(arg0: Internal.RegistryAccess_, arg1: number, arg2: boolean): Internal.NoiseBasedChunkGenerator;
        isDebug(): boolean;
        get flatWorld(): boolean
        get oldCustomizedWorld(): boolean
        get debug(): boolean
        readonly "legacyCustomOptions": Internal.Optional<string>;
        readonly static "CODEC": any;
    }
    type WorldGenSettings_ = WorldGenSettings;
    interface TextFilter {
        leave(): void;
        processStreamMessage(arg0: string): Internal.CompletableFuture<Internal.TextFilter$FilteredText>;
        join(): void;
        processMessageBundle(arg0: Internal.List_<string>): Internal.CompletableFuture<Internal.List<Internal.TextFilter$FilteredText>>;
        readonly static "DUMMY": any;
    }
    type TextFilter_ = TextFilter;
    class ProtoChunk extends Internal.ChunkAccess {
        constructor(arg0: Internal.ChunkPos_, arg1: Internal.UpgradeData_, arg2: Internal.LevelChunkSection_[], arg3: any_<Internal.Block_>, arg4: any_<Internal.Fluid_>, arg5: Internal.LevelHeightAccessor_, arg6: Internal.Registry_<Internal.Biome_>, arg7: Internal.BlendingData_)
        constructor(arg0: Internal.ChunkPos_, arg1: Internal.UpgradeData_, arg2: Internal.LevelHeightAccessor_, arg3: Internal.Registry_<Internal.Biome_>, arg4: Internal.BlendingData_)
        getMinSection(): number;
        getBlockState(arg0: BlockPos_): Internal.BlockState;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        setStatus(arg0: Internal.ChunkStatus_): void;
        getMaxSection(): number;
        unpackFluidTicks(): Internal.LevelChunkTicks<Internal.Fluid>;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getSectionYFromSectionIndex(arg0: number): number;
        getBelowZeroRetrogen(): Internal.BelowZeroRetrogen;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        setLightEngine(arg0: Internal.LevelLightEngine_): void;
        setCarvingMask(arg0: CarvingGenerationStep_, arg1: Internal.CarvingMask_): void;
        static unpackOffsetCoordinates(arg0: number, arg1: number, arg2: Internal.ChunkPos_): BlockPos;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        getHeightAccessorForGeneration(): Internal.LevelHeightAccessor;
        setBlockEntity(arg0: Internal.BlockEntity_): void;
        addLight(arg0: BlockPos_): void;
        setBlockState(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: boolean): Internal.BlockState;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getBlockEntityNbtForSaving(arg0: BlockPos_): Internal.CompoundTag;
        setBelowZeroRetrogen(arg0: Internal.BelowZeroRetrogen_): void;
        addEntity(arg0: Internal.CompoundTag_): void;
        removeBlockEntity(arg0: BlockPos_): void;
        static packOffsetCoordinates(arg0: BlockPos_): number;
        getSectionsCount(): number;
        getSectionIndexFromSectionY(arg0: number): number;
        getBlockEntityNbts(): Internal.Map<BlockPos, Internal.CompoundTag>;
        getCarvingMask(arg0: CarvingGenerationStep_): Internal.CarvingMask;
        markPosForPostprocessing(arg0: BlockPos_): void;
        getEntities(): Internal.List<Internal.CompoundTag>;
        getLights(): Internal.Stream<BlockPos>;
        addPackedPostProcess(arg0: number, arg1: number): void;
        getSectionIndex(arg0: number): number;
        getTicksForSerialization(): Internal.ChunkAccess$TicksToSave;
        getMaxBuildHeight(): number;
        getOrCreateCarvingMask(arg0: CarvingGenerationStep_): Internal.CarvingMask;
        unpackBlockTicks(): Internal.LevelChunkTicks<Internal.Block>;
        getFluidTicks(): Internal.TickContainerAccess<Internal.Fluid>;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        addLight(arg0: number, arg1: number): void;
        getBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        getNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        getBlockTicks(): Internal.TickContainerAccess<Internal.Block>;
        isOutsideBuildHeight(arg0: number): boolean;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getFluidState(arg0: BlockPos_): Internal.FluidState;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        addEntity(arg0: Internal.Entity_): void;
        getBlockEntities(): Internal.Map<BlockPos, Internal.BlockEntity>;
        getStatus(): Internal.ChunkStatus;
        getMaxLightLevel(): number;
        setStartForFeature(arg0: Internal.ConfiguredStructureFeature_<any, any>, arg1: Internal.StructureStart_): void;
        getPackedLights(): Internal.ShortList[];
        get minSection(): number
        set status(arg0: Internal.ChunkStatus_)
        get maxSection(): number
        get belowZeroRetrogen(): Internal.BelowZeroRetrogen
        set lightEngine(arg0: Internal.LevelLightEngine_)
        get heightAccessorForGeneration(): Internal.LevelHeightAccessor
        set blockEntity(arg0: Internal.BlockEntity_)
        set belowZeroRetrogen(arg0: Internal.BelowZeroRetrogen_)
        get sectionsCount(): number
        get blockEntityNbts(): Internal.Map<BlockPos, Internal.CompoundTag>
        get entities(): Internal.List<Internal.CompoundTag>
        get lights(): Internal.Stream<BlockPos>
        get ticksForSerialization(): Internal.ChunkAccess$TicksToSave
        get maxBuildHeight(): number
        get fluidTicks(): Internal.TickContainerAccess<Internal.Fluid>
        get blockTicks(): Internal.TickContainerAccess<Internal.Block>
        get blockEntities(): Internal.Map<BlockPos, Internal.BlockEntity>
        get status(): Internal.ChunkStatus
        get maxLightLevel(): number
        get packedLights(): Internal.ShortList[]
    }
    type ProtoChunk_ = ProtoChunk;
    class CampfireCookingRecipe extends Internal.AbstractCookingRecipe {
        constructor(arg0: ResourceLocation_, arg1: string, arg2: Internal.Ingredient_, arg3: Internal.ItemStack_, arg4: number, arg5: number)
        isSpecial(): boolean;
        getSerializer(): Internal.RecipeSerializer<any>;
        getToastSymbol(): Internal.ItemStack;
        isIncomplete(): boolean;
        getRemainingItems(arg0: Internal.Container_): Internal.NonNullList<Internal.ItemStack>;
        get special(): boolean
        get serializer(): Internal.RecipeSerializer<any>
        get toastSymbol(): Internal.ItemStack
        get incomplete(): boolean
    }
    type CampfireCookingRecipe_ = CampfireCookingRecipe;
    class PartDefinition {
        bake(arg0: number, arg1: number): Internal.ModelPart;
        getChild(arg0: string): this;
        addOrReplaceChild(arg0: string, arg1: Internal.CubeListBuilder_, arg2: Internal.PartPose_): this;
    }
    type PartDefinition_ = PartDefinition;
    class RegistryAccess$RegistryData <E> extends Internal.Record {
        constructor(key: Internal.ResourceKey_<any>, codec: Internal.Codec_<E>, networkCodec: Internal.Codec_<E>)
        hashCode(): number;
        codec(): Internal.Codec<E>;
        toString(): string;
        key(): Internal.ResourceKey<any>;
        equals(arg0: any): boolean;
        sendToClient(): boolean;
        networkCodec(): Internal.Codec<E>;
    }
    type RegistryAccess$RegistryData_<E> = RegistryAccess$RegistryData<E>;
    class EventsJS$ScriptEventHandler {
    }
    type EventsJS$ScriptEventHandler_ = EventsJS$ScriptEventHandler;
    class MeshDefinition {
        constructor()
        getRoot(): Internal.PartDefinition;
        get root(): Internal.PartDefinition
    }
    type MeshDefinition_ = MeshDefinition;
    class LazyOptional <T> {
        orElseGet(arg0: Internal.NonNullSupplier_<any>): T;
        filter(arg0: Internal.NonNullPredicate_<any>): Internal.Optional<T>;
        orElseThrow(arg0: Internal.NonNullSupplier_<any>): T;
        cast(): Internal.LazyOptional<X>;
        invalidate(): void;
        ifPresent(arg0: Internal.NonNullConsumer_<any>): void;
        resolve(): Internal.Optional<T>;
        orElse(arg0: T): T;
        isPresent(): boolean;
        static of(arg0: Internal.NonNullSupplier_<T>): Internal.LazyOptional<T>;
        lazyMap(arg0: Internal.NonNullFunction_<any, any>): Internal.LazyOptional<U>;
        map(arg0: Internal.NonNullFunction_<any, any>): Internal.Optional<U>;
        addListener(arg0: Internal.NonNullConsumer_<Internal.LazyOptional_<T>>): void;
        static empty(): Internal.LazyOptional<T>;
        get present(): boolean
    }
    type LazyOptional_<T> = LazyOptional<T>;
    interface TemporalAccessor {
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        get(arg0: Internal.TemporalField_): number;
        getLong(arg0: Internal.TemporalField_): number;
        query(arg0: Internal.TemporalQuery_<R>): R;
        isSupported(arg0: Internal.TemporalField_): boolean;
    }
    type TemporalAccessor_ = TemporalAccessor;
    interface Functor <F, Mu> extends Internal.Kind1<F, Mu> {
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>): Internal.Products$P11<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>, arg13: Internal.App_<F, T14>, arg14: Internal.App_<F, T15>): Internal.Products$P15<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>): Internal.Products$P2<F, T1, T2>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>): Internal.Products$P10<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>;
        map(arg0: Internal.Function_<any, any>, arg1: Internal.App_<F, T>): Internal.App<F, R>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>): Internal.Products$P13<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>): Internal.Products$P9<F, T1, T2, T3, T4, T5, T6, T7, T8, T9>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>): Internal.Products$P4<F, T1, T2, T3, T4>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>;
        group(arg0: Internal.App_<F, T1>): Internal.Products$P1<F, T1>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>, arg13: Internal.App_<F, T14>): Internal.Products$P14<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>): Internal.Products$P12<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>;
        unbox(arg0: Internal.App_<Mu, F>): this;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>, arg13: Internal.App_<F, T14>, arg14: Internal.App_<F, T15>, arg15: Internal.App_<F, T16>): Internal.Products$P16<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>): Internal.Products$P3<F, T1, T2, T3>;
    }
    type Functor_<F, Mu> = Functor<F, Mu>;
    class GeodeBlockSettings {
        constructor(arg0: Internal.BlockStateProvider_, arg1: Internal.BlockStateProvider_, arg2: Internal.BlockStateProvider_, arg3: Internal.BlockStateProvider_, arg4: Internal.BlockStateProvider_, arg5: Internal.List_<Internal.BlockState_>, arg6: Internal.TagKey_<Internal.Block_>, arg7: Internal.TagKey_<Internal.Block_>)
        readonly "innerLayerProvider": Internal.BlockStateProvider;
        readonly "middleLayerProvider": Internal.BlockStateProvider;
        readonly "fillingProvider": Internal.BlockStateProvider;
        readonly "alternateInnerLayerProvider": Internal.BlockStateProvider;
        readonly "outerLayerProvider": Internal.BlockStateProvider;
        readonly "invalidBlocks": Internal.TagKey<Internal.Block>;
        readonly static "CODEC": any;
        readonly "innerPlacements": Internal.List<Internal.BlockState>;
        readonly "cannotReplace": Internal.TagKey<Internal.Block>;
    }
    type GeodeBlockSettings_ = GeodeBlockSettings;
    interface Object2DoubleFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToDoubleFunction<K> {
        put(arg0: K, arg1: number): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Object2LongFunction<K>;
        getOrDefault(arg0: any, arg1: any): any;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2DoubleFunction;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Object2ByteFunction<K>;
        andThenReference(arg0: Internal.Double2ReferenceFunction_<any>): Internal.Object2ReferenceFunction<K, T>;
        containsKey(arg0: any): boolean;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Object2FloatFunction<K>;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): this;
        put(arg0: any, arg1: any): any;
        defaultReturnValue(arg0: number): void;
        applyAsDouble(arg0: K): number;
        andThenObject(arg0: Internal.Double2ObjectFunction_<any>): Internal.Object2ObjectFunction<K, T>;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2DoubleFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        remove(arg0: any): number;
        getOrDefault(arg0: any, arg1: number): number;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2DoubleFunction;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2DoubleFunction;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2DoubleFunction;
        composeObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Object2DoubleFunction<T>;
        removeDouble(arg0: any): number;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Object2ShortFunction<K>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        defaultReturnValue(): number;
        apply(arg0: K): number;
        composeReference(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Reference2DoubleFunction<T>;
        size(): number;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2DoubleFunction;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2DoubleFunction;
        clear(): void;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Object2CharFunction<K>;
        getOrDefault(arg0: any, arg1: number): number;
        getDouble(arg0: any): number;
        put(arg0: K, arg1: number): number;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Object2IntFunction<K>;
        get(arg0: any): any;
    }
    type Object2DoubleFunction_<K> = ((arg0: any)=>number) | Object2DoubleFunction<K>;
    interface PermissionNode$PermissionResolver <T> {
        resolve(arg0: Internal.ServerPlayer_, arg1: Internal.UUID_, ...arg2: any_<any>[]): T;
    }
    type PermissionNode$PermissionResolver_<T> = ((arg0: Internal.ServerPlayer, arg1: Internal.UUID, ...arg2: any[])=>T) | PermissionNode$PermissionResolver<T>;
    class ModelManager extends Internal.SimplePreparableReloadListener<any> implements Internal.AutoCloseable {
        constructor(arg0: Internal.TextureManager_, arg1: Internal.BlockColors_, arg2: number)
        updateMaxMipLevel(arg0: number): void;
        getModel(arg0: ResourceLocation_): Internal.BakedModel;
        getModel(arg0: Internal.ModelResourceLocation_): Internal.BakedModel;
        getMissingModel(): Internal.BakedModel;
        requiresRender(arg0: Internal.BlockState_, arg1: Internal.BlockState_): boolean;
        getName(): string;
        close(): void;
        getBlockModelShaper(): Internal.BlockModelShaper;
        getAtlas(arg0: ResourceLocation_): Internal.TextureAtlas;
        get missingModel(): Internal.BakedModel
        get name(): string
        get blockModelShaper(): Internal.BlockModelShaper
    }
    type ModelManager_ = ModelManager;
    class ClientboundLightUpdatePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.ChunkPos_, arg1: Internal.LevelLightEngine_, arg2: Internal.BitSet_, arg3: Internal.BitSet_, arg4: boolean)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getX(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getZ(): number;
        getLightData(): Internal.ClientboundLightUpdatePacketData;
        isSkippable(): boolean;
        get x(): number
        get z(): number
        get lightData(): Internal.ClientboundLightUpdatePacketData
        get skippable(): boolean
    }
    type ClientboundLightUpdatePacket_ = ClientboundLightUpdatePacket;
    interface ShortComparator extends Internal.Comparator<number> {
        compare(arg0: number, arg1: number): number;
        thenComparing(arg0: Internal.Comparator_<any>): Internal.Comparator<number>;
        compare(arg0: any, arg1: any): number;
        thenComparing(arg0: Internal.Function_<any, any>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.Function_<any, any>, arg1: Internal.Comparator_<any>): Internal.Comparator<number>;
        thenComparingLong(arg0: Internal.ToLongFunction_<any>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.ShortComparator_): this;
        compare(arg0: number, arg1: number): number;
        thenComparingDouble(arg0: Internal.ToDoubleFunction_<any>): Internal.Comparator<number>;
        thenComparingInt(arg0: Internal.ToIntFunction_<any>): Internal.Comparator<number>;
        reversed(): this;
    }
    type ShortComparator_ = ShortComparator | ((arg0: number, arg1: number)=>number);
    interface Flushable {
        flush(): void;
    }
    type Flushable_ = Flushable;
    class ChunkRenderDispatcher$RenderChunk {
        constructor(arg0: Internal.ChunkRenderDispatcher_, arg1: number, arg2: number, arg3: number, arg4: number)
        getRelativeOrigin(arg0: Internal.Direction_): BlockPos;
        setNotDirty(): void;
        getOrigin(): BlockPos;
        compileSync(arg0: Internal.RenderRegionCache_): void;
        resortTransparency(arg0: Internal.RenderType_, arg1: Internal.ChunkRenderDispatcher_): boolean;
        setOrigin(arg0: number, arg1: number, arg2: number): void;
        getBuffer(arg0: Internal.RenderType_): Internal.VertexBuffer;
        isDirty(): boolean;
        getCompiledChunk(): Internal.ChunkRenderDispatcher$CompiledChunk;
        getBoundingBox(): Internal.AABB;
        rebuildChunkAsync(arg0: Internal.ChunkRenderDispatcher_, arg1: Internal.RenderRegionCache_): void;
        isDirtyFromPlayer(): boolean;
        setDirty(arg0: boolean): void;
        createCompileTask(arg0: Internal.RenderRegionCache_): Internal.ChunkRenderDispatcher$RenderChunk$ChunkCompileTask;
        hasAllNeighbors(): boolean;
        releaseBuffers(): void;
        get origin(): BlockPos
        get dirty(): boolean
        get compiledChunk(): Internal.ChunkRenderDispatcher$CompiledChunk
        get boundingBox(): Internal.AABB
        get dirtyFromPlayer(): boolean
        set dirty(arg0: boolean)
        readonly "index": number;
        readonly static "SIZE": 16;
        readonly "compiled": Internal.AtomicReference<Internal.ChunkRenderDispatcher$CompiledChunk>;
    }
    type ChunkRenderDispatcher$RenderChunk_ = ChunkRenderDispatcher$RenderChunk;
    abstract class FileStore {
        name(): string;
        getFileStoreAttributeView(arg0: Internal.Class_<V>): V;
        type(): string;
        getAttribute(arg0: string): any;
        getUsableSpace(): number;
        getUnallocatedSpace(): number;
        supportsFileAttributeView(arg0: string): boolean;
        supportsFileAttributeView(arg0: Internal.Class_<any>): boolean;
        getTotalSpace(): number;
        isReadOnly(): boolean;
        getBlockSize(): number;
        get usableSpace(): number
        get unallocatedSpace(): number
        get totalSpace(): number
        get readOnly(): boolean
        get blockSize(): number
    }
    type FileStore_ = FileStore;
    class NativeJavaObject implements Internal.SymbolScriptable, Internal.Wrapper, Internal.Scriptable {
        constructor()
        constructor(scope: Internal.Scriptable_, javaObject: any, staticType: Internal.Class_<any>)
        constructor(scope: Internal.Scriptable_, javaObject: any, staticType: Internal.Class_<any>, isAdapter: boolean)
        getClassName(): string;
        setParentScope(m: Internal.Scriptable_): void;
        get(name: string, start: Internal.Scriptable_): any;
        unwrap(): any;
        has(key: Internal.Symbol_, start: Internal.Scriptable_): boolean;
        getTypeOf(): Internal.MemberType;
        static createInterfaceAdapter(type: Internal.Class_<any>, so: Internal.ScriptableObject_): any;
        put(name: string, start: Internal.Scriptable_, value: any): void;
        getParentScope(): Internal.Scriptable;
        put(symbol: Internal.Symbol_, start: Internal.Scriptable_, value: any): void;
        delete(name: string): void;
        put(index: number, start: Internal.Scriptable_, value: any): void;
        hasInstance(value: Internal.Scriptable_): boolean;
        getDefaultValue(hint: Internal.Class_<any>): any;
        has(name: string, start: Internal.Scriptable_): boolean;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getAllIds(): any[];
        addCustomProperty(name: string, getter: Internal.CustomProperty_): void;
        delete(key: Internal.Symbol_): void;
        get(index: number, start: Internal.Scriptable_): any;
        static canConvert(data: Internal.SharedContextData_, fromObj: any, to: Internal.Class_<any>): boolean;
        getIds(): any[];
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        has(index: number, start: Internal.Scriptable_): boolean;
        getPrototype(): Internal.Scriptable;
        delete(index: number): void;
        setPrototype(m: Internal.Scriptable_): void;
        get(key: Internal.Symbol_, start: Internal.Scriptable_): any;
        get className(): string
        set parentScope(m: Internal.Scriptable_)
        get typeOf(): Internal.MemberType
        get parentScope(): Internal.Scriptable
        get allIds(): any[]
        get ids(): any[]
        get prototype(): Internal.Scriptable
        set prototype(m: Internal.Scriptable_)
    }
    type NativeJavaObject_ = NativeJavaObject;
    class CriticalHitEvent extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.Entity_, arg2: number, arg3: boolean)
        hasResult(): boolean;
        getTarget(): Internal.Entity;
        setDamageModifier(arg0: number): void;
        getListenerList(): Internal.ListenerList;
        isVanillaCritical(): boolean;
        getOldDamageModifier(): number;
        getDamageModifier(): number;
        get target(): Internal.Entity
        set damageModifier(arg0: number)
        get listenerList(): Internal.ListenerList
        get vanillaCritical(): boolean
        get oldDamageModifier(): number
        get damageModifier(): number
    }
    type CriticalHitEvent_ = CriticalHitEvent;
    class LoomMenu extends Internal.AbstractContainerMenu {
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: any_)
        constructor(arg0: number, arg1: Internal.Inventory_)
        stillValid(arg0: Internal.Player_): boolean;
        slotsChanged(arg0: Internal.Container_): void;
        getSelectedBannerPatternIndex(): number;
        clickMenuButton(arg0: Internal.Player_, arg1: number): boolean;
        getPatternSlot(): Internal.Slot;
        getDyeSlot(): Internal.Slot;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        registerUpdateListener(arg0: Internal.Runnable_): void;
        getResultSlot(): Internal.Slot;
        getBannerSlot(): Internal.Slot;
        removed(arg0: Internal.Player_): void;
        get selectedBannerPatternIndex(): number
        get patternSlot(): Internal.Slot
        get dyeSlot(): Internal.Slot
        get resultSlot(): Internal.Slot
        get bannerSlot(): Internal.Slot
    }
    type LoomMenu_ = LoomMenu;
    class LevelChunkSection {
        constructor(arg0: number, arg1: Internal.PalettedContainer_<Internal.BlockState_>, arg2: Internal.PalettedContainer_<Internal.Holder_<Internal.Biome_>>)
        constructor(arg0: number, arg1: Internal.Registry_<Internal.Biome_>)
        read(arg0: Internal.FriendlyByteBuf_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getSerializedSize(): number;
        hasOnlyAir(): boolean;
        isRandomlyTickingBlocks(): boolean;
        setBlockState(arg0: number, arg1: number, arg2: number, arg3: Internal.BlockState_): Internal.BlockState;
        getStates(): Internal.PalettedContainer<Internal.BlockState>;
        fillBiomesFromNoise(arg0: Internal.BiomeResolver_, arg1: Internal.Climate$Sampler_, arg2: number, arg3: number): void;
        bottomBlockY(): number;
        setBlockState(arg0: number, arg1: number, arg2: number, arg3: Internal.BlockState_, arg4: boolean): Internal.BlockState;
        maybeHas(arg0: Internal.Predicate_<Internal.BlockState_>): boolean;
        static getBottomBlockY(arg0: number): number;
        isRandomlyTickingFluids(): boolean;
        release(): void;
        acquire(): void;
        recalcBlockCounts(): void;
        getBiomes(): Internal.PalettedContainer<Internal.Holder<Internal.Biome>>;
        getBlockState(arg0: number, arg1: number, arg2: number): Internal.BlockState;
        getNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        getFluidState(arg0: number, arg1: number, arg2: number): Internal.FluidState;
        isRandomlyTicking(): boolean;
        get serializedSize(): number
        get randomlyTickingBlocks(): boolean
        get states(): Internal.PalettedContainer<Internal.BlockState>
        get randomlyTickingFluids(): boolean
        get biomes(): Internal.PalettedContainer<Internal.Holder<Internal.Biome>>
        get randomlyTicking(): boolean
        readonly static "BIOME_CONTAINER_BITS": 2;
        readonly static "SECTION_WIDTH": 16;
        readonly static "SECTION_SIZE": 4096;
        readonly static "SECTION_HEIGHT": 16;
    }
    type LevelChunkSection_ = LevelChunkSection;
    class InclusiveRange <T> extends Internal.Record {
        constructor(arg0: T, arg1: T)
        static create(arg0: T, arg1: T): Internal.DataResult<Internal.InclusiveRange<T>>;
        hashCode(): number;
        maxInclusive(): T;
        toString(): string;
        static codec(arg0: Internal.Codec_<T>, arg1: T, arg2: T): Internal.Codec<Internal.InclusiveRange<T>>;
        static codec(arg0: Internal.Codec_<T>): Internal.Codec<Internal.InclusiveRange<T>>;
        isValueInRange(arg0: T): boolean;
        contains(arg0: Internal.InclusiveRange_<T>): boolean;
        minInclusive(): T;
        equals(arg0: any): boolean;
        readonly static "INT": any;
    }
    type InclusiveRange_<T> = InclusiveRange<T>;
    interface RangedAttackMob {
        performRangedAttack(arg0: Internal.LivingEntity_, arg1: number): void;
    }
    type RangedAttackMob_ = RangedAttackMob;
    interface CarvingMask$Mask {
        test(arg0: number, arg1: number, arg2: number): boolean;
    }
    type CarvingMask$Mask_ = CarvingMask$Mask;
    class JsonObject extends Internal.JsonElement {
        constructor()
        keySet(): Internal.Set<string>;
        getAsJsonArray(arg0: string): Internal.JsonArray;
        get(arg0: string): Internal.JsonElement;
        getAsJsonPrimitive(arg0: string): Internal.JsonPrimitive;
        deepCopy(): this;
        addProperty(arg0: string, arg1: string): void;
        hashCode(): number;
        getAsJsonObject(arg0: string): this;
        size(): number;
        has(arg0: string): boolean;
        remove(arg0: string): Internal.JsonElement;
        addProperty(arg0: string, arg1: Internal.Number_): void;
        addProperty(arg0: string, arg1: boolean): void;
        add(arg0: string, arg1: Internal.JsonElement_): void;
        addProperty(arg0: string, arg1: string): void;
        equals(arg0: any): boolean;
        entrySet(): Internal.Set<Internal.Map$Entry<string, Internal.JsonElement>>;
    }
    type JsonObject_ = JsonObject;
    class FallingBlockEntity extends Internal.Entity {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        handler$zbg000$handleLand(ci: Internal.CallbackInfo_, block: Internal.Block_, blockPos2: BlockPos_, bl: boolean, bl2: boolean, d: number, blockState: Internal.BlockState_): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        getAddEntityPacket(): Internal.Packet<any>;
        onlyOpCanSetNbt(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        fillCrashReportCategory(arg0: Internal.CrashReportCategory_): void;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        displayFireAnimation(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        recreateFromPacket(arg0: Internal.ClientboundAddEntityPacket_): void;
        setStartPos(arg0: BlockPos_): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        getBlockState(): Internal.BlockState;
        callOnBrokenAfterFall(arg0: Internal.Block_, arg1: BlockPos_): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isPickable(): boolean;
        tick(): void;
        getStartPos(): BlockPos;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        setHurtsEntities(arg0: number, arg1: number): void;
        isAttackable(): boolean;
        static fall(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_): Internal.FallingBlockEntity;
        get stepHeight(): number
        get addEntityPacket(): Internal.Packet<any>
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        set startPos(arg0: BlockPos_)
        get blockState(): Internal.BlockState
        get pickable(): boolean
        get startPos(): BlockPos
        get attackable(): boolean
        "time": number;
        "dropItem": boolean;
        "blockData": Internal.CompoundTag;
    }
    type FallingBlockEntity_ = FallingBlockEntity;
    interface NarrationSupplier {
        updateNarration(arg0: Internal.NarrationElementOutput_): void;
    }
    type NarrationSupplier_ = NarrationSupplier;
    class PathfindingRenderer implements Internal.DebugRenderer$SimpleDebugRenderer {
        constructor()
        addPath(arg0: number, arg1: net.minecraft.world.level.pathfinder.Path_, arg2: number): void;
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource_, arg2: number, arg3: number, arg4: number): void;
        clear(): void;
        static renderPathLine(arg0: net.minecraft.world.level.pathfinder.Path_, arg1: number, arg2: number, arg3: number): void;
        static renderPath(arg0: net.minecraft.world.level.pathfinder.Path_, arg1: number, arg2: boolean, arg3: boolean, arg4: number, arg5: number, arg6: number): void;
    }
    type PathfindingRenderer_ = PathfindingRenderer;
    class Tilt extends Internal.Enum<Internal.Tilt> implements Internal.StringRepresentable {
        getSerializedName(): string;
        static valueOf(arg0: string): Internal.Tilt;
        static values(): Internal.Tilt[];
        causesVibration(): boolean;
        get serializedName(): string
        readonly static "NONE": Internal.Tilt;
        readonly static "UNSTABLE": Internal.Tilt;
        readonly static "PARTIAL": Internal.Tilt;
        readonly static "FULL": Internal.Tilt;
    }
    type Tilt_ = "unstable" | "partial" | "full" | Tilt | "none";
    class OutlineBufferSource implements Internal.MultiBufferSource {
        constructor(arg0: Internal.MultiBufferSource$BufferSource_)
        getBuffer(arg0: Internal.RenderType_): Internal.VertexConsumer;
        endOutlineBatch(): void;
        setColor(arg0: number, arg1: number, arg2: number, arg3: number): void;
    }
    type OutlineBufferSource_ = OutlineBufferSource;
    abstract class AbstractCollection <E> implements Internal.Collection<E> {
        add(arg0: E): boolean;
        toString(): string;
        forEach(arg0: Internal.Consumer_<any>): void;
        toArray(arg0: T[]): T[];
        remove(arg0: any): boolean;
        parallelStream(): Internal.Stream<E>;
        isEmpty(): boolean;
        toArray(): any[];
        iterator(): Internal.Iterator<E>;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        size(): number;
        stream(): Internal.Stream<E>;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        clear(): void;
        addAll(arg0: Internal.Collection_<any>): boolean;
        spliterator(): Internal.Spliterator<E>;
        contains(arg0: any): boolean;
        get empty(): boolean
    }
    type AbstractCollection_<E> = AbstractCollection<E>;
    interface BlockGetter extends Internal.LevelHeightAccessor, Internal.IForgeBlockGetter {
        isOutsideBuildHeight(arg0: number): boolean;
        getMinSection(): number;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getBlockState(arg0: BlockPos_): Internal.BlockState;
        getFluidState(arg0: BlockPos_): Internal.FluidState;
        getSectionIndex(arg0: number): number;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        getMaxSection(): number;
        getMaxBuildHeight(): number;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getSectionYFromSectionIndex(arg0: number): number;
        getSectionsCount(): number;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        getSectionIndexFromSectionY(arg0: number): number;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        getMaxLightLevel(): number;
        getBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        traverseBlocks(arg0: Vec3_, arg1: Vec3_, arg2: C, arg3: Internal.BiFunction_<C, BlockPos_, T>, arg4: Internal.Function_<C, T>): T;
        get minSection(): number
        get maxSection(): number
        get maxBuildHeight(): number
        get sectionsCount(): number
        get maxLightLevel(): number
    }
    type BlockGetter_ = BlockGetter;
    class LootPool$Builder implements Internal.FunctionUserBuilder<Internal.LootPool$Builder>, Internal.ConditionUserBuilder<Internal.LootPool$Builder> {
        constructor()
        setRolls(arg0: Internal.NumberProvider_): this;
        name(arg0: string): this;
        setBonusRolls(arg0: Internal.NumberProvider_): this;
        add(arg0: Internal.LootPoolEntryContainer$Builder_<any>): this;
        apply(arg0: Internal.LootItemFunction$Builder_): any;
        build(): Internal.LootPool;
        when(arg0: Internal.LootItemCondition$Builder_): this;
        unwrap(): this;
        set rolls(arg0: Internal.NumberProvider_)
        set bonusRolls(arg0: Internal.NumberProvider_)
    }
    type LootPool$Builder_ = LootPool$Builder;
    interface ItemBuilder$NameCallback {
        apply(arg0: Internal.ItemStackJS_): Internal.Component;
    }
    type ItemBuilder$NameCallback_ = ((arg0: Internal.ItemStackJS)=>Internal.Component_) | ItemBuilder$NameCallback;
    interface Readable {
        read(arg0: Internal.CharBuffer_): number;
    }
    type Readable_ = Readable;
    class ServerboundTeleportToEntityPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.UUID_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getEntity(arg0: Internal.ServerLevel_): Internal.Entity;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        isSkippable(): boolean;
        get skippable(): boolean
    }
    type ServerboundTeleportToEntityPacket_ = ServerboundTeleportToEntityPacket;
    class RecipeBookCategories extends Internal.Enum<Internal.RecipeBookCategories> implements Internal.IExtensibleEnum {
        static create(arg0: string, ...arg1: Internal.ItemStack_[]): Internal.RecipeBookCategories;
        init(): void;
        static valueOf(arg0: string): Internal.RecipeBookCategories;
        getIconItems(): Internal.List<Internal.ItemStack>;
        static values(): Internal.RecipeBookCategories[];
        static getCategories(arg0: Internal.RecipeBookType_): Internal.List<Internal.RecipeBookCategories>;
        get iconItems(): Internal.List<Internal.ItemStack>
        readonly static "CRAFTING_SEARCH": Internal.RecipeBookCategories;
        readonly static "SMOKER_SEARCH": Internal.RecipeBookCategories;
        readonly static "SMOKER_CATEGORIES": [Internal.RecipeBookCategories, Internal.RecipeBookCategories];
        readonly static "BLAST_FURNACE_SEARCH": Internal.RecipeBookCategories;
        readonly static "CRAFTING_BUILDING_BLOCKS": Internal.RecipeBookCategories;
        readonly static "STONECUTTER": Internal.RecipeBookCategories;
        readonly static "CRAFTING_MISC": Internal.RecipeBookCategories;
        readonly static "CRAFTING_REDSTONE": Internal.RecipeBookCategories;
        readonly static "SMOKER_FOOD": Internal.RecipeBookCategories;
        readonly static "AGGREGATE_CATEGORIES": {[key: Internal.RecipeBookCategories]: [Internal.RecipeBookCategories, Internal.RecipeBookCategories, Internal.RecipeBookCategories, Internal.RecipeBookCategories], [key: Internal.RecipeBookCategories]: [Internal.RecipeBookCategories], [key: Internal.RecipeBookCategories]: [Internal.RecipeBookCategories, Internal.RecipeBookCategories, Internal.RecipeBookCategories], [key: Internal.RecipeBookCategories]: [Internal.RecipeBookCategories, Internal.RecipeBookCategories]};
        readonly static "UNKNOWN": Internal.RecipeBookCategories;
        readonly static "CRAFTING_EQUIPMENT": Internal.RecipeBookCategories;
        readonly static "FURNACE_BLOCKS": Internal.RecipeBookCategories;
        readonly static "BLAST_FURNACE_MISC": Internal.RecipeBookCategories;
        readonly static "BLAST_FURNACE_CATEGORIES": [Internal.RecipeBookCategories, Internal.RecipeBookCategories, Internal.RecipeBookCategories];
        readonly static "CRAFTING_CATEGORIES": [Internal.RecipeBookCategories, Internal.RecipeBookCategories, Internal.RecipeBookCategories, Internal.RecipeBookCategories, Internal.RecipeBookCategories];
        readonly static "FURNACE_SEARCH": Internal.RecipeBookCategories;
        readonly static "FURNACE_MISC": Internal.RecipeBookCategories;
        readonly static "SMITHING": Internal.RecipeBookCategories;
        readonly static "FURNACE_FOOD": Internal.RecipeBookCategories;
        readonly static "CAMPFIRE": Internal.RecipeBookCategories;
        readonly static "FURNACE_CATEGORIES": [Internal.RecipeBookCategories, Internal.RecipeBookCategories, Internal.RecipeBookCategories, Internal.RecipeBookCategories];
        readonly static "BLAST_FURNACE_BLOCKS": Internal.RecipeBookCategories;
    }
    type RecipeBookCategories_ = "crafting_misc" | "smoker_search" | "furnace_misc" | "smithing" | "crafting_building_blocks" | "crafting_search" | RecipeBookCategories | "blast_furnace_misc" | "stonecutter" | "furnace_search" | "campfire" | "blast_furnace_search" | "smoker_food" | "blast_furnace_blocks" | "unknown" | "furnace_food" | "crafting_equipment" | "furnace_blocks" | "crafting_redstone";
    interface BiomeFilter extends Internal.Predicate<Internal.BiomeModifications$BiomeContext> {
        test(arg0: any): boolean;
        and(arg0: Internal.Predicate_<any>): Internal.Predicate<Internal.BiomeModifications$BiomeContext>;
        of(o: any): this;
        or(arg0: Internal.Predicate_<any>): Internal.Predicate<Internal.BiomeModifications$BiomeContext>;
        test(arg0: Internal.BiomeModifications$BiomeContext_): boolean;
        idFilter(s: string): this;
        negate(): Internal.Predicate<Internal.BiomeModifications$BiomeContext>;
        readonly static "ALWAYS_FALSE": any;
        readonly static "ALWAYS_TRUE": any;
    }
    type BiomeFilter_ = BiomeFilter | ((arg0: Internal.BiomeModifications$BiomeContext)=>boolean);
    class TickEvent$PlayerTickEvent extends Internal.TickEvent {
        constructor()
        constructor(arg0: Internal.TickEvent$Phase_, arg1: Internal.Player_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
        readonly "player": Internal.Player;
    }
    type TickEvent$PlayerTickEvent_ = TickEvent$PlayerTickEvent;
    abstract class Fireball extends Internal.AbstractHurtingProjectile implements Internal.ItemSupplier {
        constructor(arg0: Internal.EntityType_<any>, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.Level_)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.LivingEntity_, arg2: number, arg3: number, arg4: number, arg5: Internal.Level_)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getItem(): Internal.ItemStack;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        setItem(arg0: Internal.ItemStack_): void;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get item(): Internal.ItemStack
        get stepHeight(): number
        set item(arg0: Internal.ItemStack_)
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type Fireball_ = Fireball;
    interface URLStreamHandlerFactory {
        createURLStreamHandler(arg0: string): Internal.URLStreamHandler;
    }
    type URLStreamHandlerFactory_ = URLStreamHandlerFactory;
    class ServerPlayerJS extends Internal.PlayerJS<Internal.ServerPlayer> {
        constructor(data: Internal.ServerPlayerDataJS_, player: Internal.ServerPlayer_)
        isMiningBlock(): boolean;
        isAdvancementDone(id: ResourceLocation_): boolean;
        setGameMode(mode: string): void;
        getStats(): Internal.PlayerStatsJS;
        ban(banner: string, reason: string, expiresInMillis: number): void;
        sendData(channel: string, data: Internal.CompoundTag_): void;
        getSpawnLocation(): Internal.BlockContainerJS;
        unlockAdvancement(id: ResourceLocation_): void;
        setSelectedSlot(index: number): void;
        isOp(): boolean;
        kick(): void;
        getHasClientMod(): boolean;
        revokeAdvancement(id: ResourceLocation_): void;
        paint(renderer: Internal.CompoundTag_): void;
        setMouseItem(item: Internal.ItemStackJS_): void;
        setCreativeMode(mode: boolean): void;
        setSpawnLocation(c: Internal.BlockContainerJS_): void;
        kick(reason: Internal.Component_): void;
        get miningBlock(): boolean
        set gameMode(mode: string)
        get stats(): Internal.PlayerStatsJS
        get spawnLocation(): Internal.BlockContainerJS
        set selectedSlot(index: number)
        get op(): boolean
        get hasClientMod(): boolean
        set mouseItem(item: Internal.ItemStackJS_)
        set creativeMode(mode: boolean)
        set spawnLocation(c: Internal.BlockContainerJS_)
        readonly "server": Internal.ServerJS;
    }
    type ServerPlayerJS_ = ServerPlayerJS;
    class HoverEvent {
        constructor(arg0: Internal.HoverEvent$Action_<T>, arg1: T)
        hashCode(): number;
        static deserialize(arg0: Internal.JsonObject_): Internal.HoverEvent;
        toString(): string;
        getAction(): Internal.HoverEvent$Action<any>;
        serialize(): Internal.JsonObject;
        getValue(arg0: Internal.HoverEvent$Action_<T>): T;
        equals(arg0: any): boolean;
        get action(): Internal.HoverEvent$Action<any>
    }
    type HoverEvent_ = HoverEvent;
    class RecipeBookSettings {
        constructor()
        write(arg0: Internal.FriendlyByteBuf_): void;
        replaceFrom(arg0: Internal.RecipeBookSettings_): void;
        isOpen(arg0: Internal.RecipeBookType_): boolean;
        copy(): this;
        write(arg0: Internal.CompoundTag_): void;
        static read(arg0: Internal.FriendlyByteBuf_): Internal.RecipeBookSettings;
        setOpen(arg0: Internal.RecipeBookType_, arg1: boolean): void;
        static addTagsForType(arg0: Internal.RecipeBookType_, arg1: string, arg2: string): void;
        hashCode(): number;
        isFiltering(arg0: Internal.RecipeBookType_): boolean;
        static read(arg0: Internal.CompoundTag_): Internal.RecipeBookSettings;
        setFiltering(arg0: Internal.RecipeBookType_, arg1: boolean): void;
        equals(arg0: any): boolean;
    }
    type RecipeBookSettings_ = RecipeBookSettings;
    interface Annotation {
        hashCode(): number;
        toString(): string;
        annotationType(): Internal.Class<any>;
        equals(arg0: any): boolean;
    }
    type Annotation_ = Annotation;
    interface DataInput {
        readByte(): number;
        readFully(arg0: number[], arg1: number, arg2: number): void;
        readLong(): number;
        readUnsignedByte(): number;
        readUnsignedShort(): number;
        readFully(arg0: number[]): void;
        readDouble(): number;
        readInt(): number;
        readFloat(): number;
        readBoolean(): boolean;
        skipBytes(arg0: number): number;
        readLine(): string;
        readShort(): number;
        readUTF(): string;
        readChar(): string;
    }
    type DataInput_ = DataInput;
    class EntityViewRenderEvent$FieldOfView extends Internal.EntityViewRenderEvent {
        constructor()
        constructor(arg0: Internal.GameRenderer_, arg1: Internal.Camera_, arg2: number, arg3: number)
        setFOV(arg0: number): void;
        getListenerList(): Internal.ListenerList;
        getFOV(): number;
        set FOV(arg0: number)
        get listenerList(): Internal.ListenerList
        get FOV(): number
    }
    type EntityViewRenderEvent$FieldOfView_ = EntityViewRenderEvent$FieldOfView;
    abstract class AbstractFish extends Internal.WaterAnimal implements Internal.Bucketable {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        loadFromBucketTag(arg0: Internal.CompoundTag_): void;
        travel(arg0: Vec3_): void;
        setFromBucket(arg0: boolean): void;
        getStepHeight(): number;
        requiresCustomPersistence(): boolean;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        getMaxSpawnClusterSize(): number;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        saveToBucketTag(arg0: Internal.ItemStack_): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        removeWhenFarAway(arg0: number): boolean;
        fromBucket(): boolean;
        getPickupSound(): Internal.SoundEvent;
        foodEatenKJS(is: Internal.ItemStack_): void;
        set fromBucket(arg0: boolean)
        get stepHeight(): number
        get maxSpawnClusterSize(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get pickupSound(): Internal.SoundEvent
    }
    type AbstractFish_ = AbstractFish;
    class PolarBear extends Internal.Animal implements Internal.NeutralMob {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        playerDied(arg0: Internal.Player_): void;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        isAngry(): boolean;
        getStepHeight(): number;
        forgetCurrentTargetAndRefreshUniversalAnger(): void;
        asKJS(): Internal.EntityJS;
        startPersistentAngerTimer(): void;
        isFood(arg0: Internal.ItemStack_): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        addPersistentAngerSaveData(arg0: Internal.CompoundTag_): void;
        isMultipartEntity(): boolean;
        setRemainingPersistentAngerTime(arg0: number): void;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        isAngryAt(arg0: Internal.LivingEntity_): boolean;
        getDimensions(arg0: Internal.Pose_): Internal.EntityDimensions;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getRemainingPersistentAngerTime(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        getPersistentAngerTarget(): Internal.UUID;
        static checkPolarBearSpawnRules(arg0: Internal.EntityType_<Internal.PolarBear_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        readPersistentAngerSaveData(arg0: Internal.Level_, arg1: Internal.CompoundTag_): void;
        stopBeingAngry(): void;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        setStanding(arg0: boolean): void;
        setPersistentAngerTarget(arg0: Internal.UUID_): void;
        updatePersistentAnger(arg0: Internal.ServerLevel_, arg1: boolean): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        isAngryAtAllPlayers(arg0: Internal.Level_): boolean;
        getStandingAnimationScale(arg0: number): number;
        foodEatenKJS(is: Internal.ItemStack_): void;
        isStanding(): boolean;
        get angry(): boolean
        get stepHeight(): number
        get multipartEntity(): boolean
        set remainingPersistentAngerTime(arg0: number)
        get parts(): Internal.PartEntity<any>[]
        get remainingPersistentAngerTime(): number
        get persistentAngerTarget(): Internal.UUID
        set standing(arg0: boolean)
        set persistentAngerTarget(arg0: Internal.UUID_)
        get standing(): boolean
    }
    type PolarBear_ = PolarBear;
    interface Multiset <E> extends Internal.Collection<E> {
        remove(arg0: any, arg1: number): number;
        setCount(arg0: E, arg1: number): number;
        add(arg0: E): boolean;
        forEach(arg0: Internal.Consumer_<any>): void;
        parallelStream(): Internal.Stream<E>;
        elementSet(): Internal.Set<E>;
        entrySet(): Internal.Set<Internal.Multiset$Entry<E>>;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        count(arg0: any): number;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        setCount(arg0: E, arg1: number, arg2: number): boolean;
        add(arg0: E, arg1: number): number;
        contains(arg0: any): boolean;
        toString(): string;
        forEachEntry(arg0: Internal.ObjIntConsumer_<any>): void;
        remove(arg0: any): boolean;
        iterator(): Internal.Iterator<E>;
        hashCode(): number;
        size(): number;
        stream(): Internal.Stream<E>;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        spliterator(): Internal.Spliterator<E>;
        equals(arg0: any): boolean;
    }
    type Multiset_<E> = Multiset<E>;
    class CustomBossEvents {
        constructor()
        onPlayerConnect(arg0: Internal.ServerPlayer_): void;
        getIds(): Internal.Collection<ResourceLocation>;
        save(): Internal.CompoundTag;
        load(arg0: Internal.CompoundTag_): void;
        getEvents(): Internal.Collection<Internal.CustomBossEvent>;
        get(arg0: ResourceLocation_): Internal.CustomBossEvent;
        remove(arg0: Internal.CustomBossEvent_): void;
        create(arg0: ResourceLocation_, arg1: Internal.Component_): Internal.CustomBossEvent;
        onPlayerDisconnect(arg0: Internal.ServerPlayer_): void;
        get ids(): Internal.Collection<ResourceLocation>
        get events(): Internal.Collection<Internal.CustomBossEvent>
    }
    type CustomBossEvents_ = CustomBossEvents;
    abstract class Overlay extends Internal.GuiComponent implements Internal.Widget {
        constructor()
        isPauseScreen(): boolean;
        get pauseScreen(): boolean
    }
    type Overlay_ = Overlay;
    interface Function <T, R> {
        apply(arg0: T): R;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, R>;
        identity(): Internal.Function<T, T>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
    }
    type Function_<T, R> = ((arg0: T)=>R) | Function<T, R>;
    interface BiPredicate <T, U> {
        test(arg0: T, arg1: U): boolean;
        and(arg0: Internal.BiPredicate_<any, any>): this;
        negate(): this;
        or(arg0: Internal.BiPredicate_<any, any>): this;
    }
    type BiPredicate_<T, U> = BiPredicate<T, U> | ((arg0: T, arg1: U)=>boolean);
    interface MinecraftSessionService {
        fillProfileProperties(arg0: Internal.GameProfile_, arg1: boolean): Internal.GameProfile;
        joinServer(arg0: Internal.GameProfile_, arg1: string, arg2: string): void;
        getTextures(arg0: Internal.GameProfile_, arg1: boolean): Internal.Map<Internal.MinecraftProfileTexture$Type, Internal.MinecraftProfileTexture>;
        hasJoinedServer(arg0: Internal.GameProfile_, arg1: string, arg2: Internal.InetAddress_): Internal.GameProfile;
    }
    type MinecraftSessionService_ = MinecraftSessionService;
    interface Message {
        getString(): string;
        get string(): string
    }
    type Message_ = Message;
    interface EventLoopGroup extends Internal.EventExecutorGroup {
        register(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        register(arg0: io.netty.channel.Channel_): Internal.ChannelFuture;
        forEach(arg0: Internal.Consumer_<any>): void;
        register(arg0: io.netty.channel.Channel_, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        next(): Internal.EventLoop;
    }
    type EventLoopGroup_ = EventLoopGroup;
    interface PublicKey extends Internal.Key {
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "serialVersionUID": 7187392471159151072;
    }
    type PublicKey_ = PublicKey;
    class AlgorithmParameters {
        getAlgorithm(): string;
        getEncoded(arg0: string): number[];
        getParameterSpec(arg0: Internal.Class_<T>): T;
        toString(): string;
        init(arg0: Internal.AlgorithmParameterSpec_): void;
        static getInstance(arg0: string, arg1: Internal.Provider_): Internal.AlgorithmParameters;
        static getInstance(arg0: string): Internal.AlgorithmParameters;
        init(arg0: number[], arg1: string): void;
        getEncoded(): number[];
        static getInstance(arg0: string, arg1: string): Internal.AlgorithmParameters;
        init(arg0: number[]): void;
        getProvider(): Internal.Provider;
        get algorithm(): string
        get encoded(): number[]
        get provider(): Internal.Provider
    }
    type AlgorithmParameters_ = AlgorithmParameters;
    class LevelTicks <T> implements Internal.LevelTickAccess<T> {
        constructor(arg0: Internal.LongPredicate_, arg1: Internal.Supplier_<Internal.ProfilerFiller_>)
        clearArea(arg0: Internal.BoundingBox_): void;
        count(): number;
        copyArea(arg0: Internal.BoundingBox_, arg1: Vec3i_): void;
        schedule(arg0: Internal.ScheduledTick_<T>): void;
        addContainer(arg0: Internal.ChunkPos_, arg1: Internal.LevelChunkTicks_<T>): void;
        tick(arg0: number, arg1: number, arg2: Internal.BiConsumer_<BlockPos_, T>): void;
        hasScheduledTick(arg0: BlockPos_, arg1: T): boolean;
        willTickThisTick(arg0: BlockPos_, arg1: T): boolean;
        removeContainer(arg0: Internal.ChunkPos_): void;
    }
    type LevelTicks_<T> = LevelTicks<T>;
    class PiglinBruteSpecificSensor extends Internal.Sensor<Internal.LivingEntity> {
        constructor()
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
    }
    type PiglinBruteSpecificSensor_ = PiglinBruteSpecificSensor;
    class DragonDeathPhase extends Internal.AbstractDragonPhaseInstance {
        constructor(arg0: Internal.EnderDragon_)
        doClientTick(): void;
        getFlyTargetLocation(): Vec3;
        getFlySpeed(): number;
        begin(): void;
        doServerTick(): void;
        getPhase(): Internal.EnderDragonPhase<Internal.DragonDeathPhase>;
        get flyTargetLocation(): Vec3
        get flySpeed(): number
        get phase(): Internal.EnderDragonPhase<Internal.DragonDeathPhase>
    }
    type DragonDeathPhase_ = DragonDeathPhase;
    abstract class ForwardingMultimap <K, V> extends Internal.ForwardingObject implements Internal.Multimap<K, V> {
        putAll(arg0: Internal.Multimap_<any, any>): boolean;
        keySet(): Internal.Set<K>;
        removeAll(arg0: any): Internal.Collection<V>;
        get(arg0: K): Internal.Collection<V>;
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>;
        putAll(arg0: K, arg1: Internal.Iterable_<any>): boolean;
        values(): Internal.Collection<V>;
        containsValue(arg0: any): boolean;
        remove(arg0: any, arg1: any): boolean;
        isEmpty(): boolean;
        containsEntry(arg0: any, arg1: any): boolean;
        hashCode(): number;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        size(): number;
        replaceValues(arg0: K, arg1: Internal.Iterable_<any>): Internal.Collection<V>;
        put(arg0: K, arg1: V): boolean;
        clear(): void;
        keys(): Internal.Multiset<K>;
        equals(arg0: any): boolean;
        asMap(): Internal.Map<K, Internal.Collection<V>>;
        get empty(): boolean
    }
    type ForwardingMultimap_<K, V> = ForwardingMultimap<K, V>;
    class Axolotl extends Internal.Animal implements Internal.Bucketable, Internal.LerpingModel {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getBucketItemStack(): Internal.ItemStack;
        setFromBucket(arg0: boolean): void;
        getStepHeight(): number;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        isPlayingDead(): boolean;
        isPushedByFluid(): boolean;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        applySupportingEffects(arg0: Internal.Player_): void;
        getMaxHeadXRot(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getMeleeAttackRangeSqr(arg0: Internal.LivingEntity_): number;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        playAmbientSound(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getWalkTargetValue(arg0: BlockPos_, arg1: Internal.LevelReader_): number;
        canBreatheUnderwater(): boolean;
        baseTick(): void;
        alwaysAccepts(): boolean;
        rehydrate(): void;
        fromBucket(): boolean;
        getModelRotationValues(): Internal.Map<string, Internal.Vector3f>;
        foodEatenKJS(is: Internal.ItemStack_): void;
        static checkAxolotlSpawnRules(arg0: Internal.EntityType_<any>, arg1: Internal.ServerLevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        setPlayingDead(arg0: boolean): void;
        getMaxAirSupply(): number;
        loadFromBucketTag(arg0: Internal.CompoundTag_): void;
        getMobType(): Internal.MobType;
        travel(arg0: Vec3_): void;
        canBeSeenAsEnemy(): boolean;
        requiresCustomPersistence(): boolean;
        asKJS(): Internal.EntityJS;
        getVariant(): Internal.Axolotl$Variant;
        isFood(arg0: Internal.ItemStack_): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        getMaxHeadYRot(): number;
        serializeNBT(): Internal.Tag;
        checkSpawnObstruction(arg0: Internal.LevelReader_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        doHurtTarget(arg0: Internal.Entity_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        canBeLeashed(arg0: Internal.Player_): boolean;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        saveToBucketTag(arg0: Internal.ItemStack_): void;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        static onStopAttacking(arg0: Internal.Axolotl_): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getBrain(): Internal.Brain<Internal.Axolotl>;
        getClassification(arg0: boolean): Internal.MobCategory;
        removeWhenFarAway(arg0: number): boolean;
        getPickupSound(): Internal.SoundEvent;
        get bucketItemStack(): Internal.ItemStack
        set fromBucket(arg0: boolean)
        get stepHeight(): number
        get playingDead(): boolean
        get pushedByFluid(): boolean
        get maxHeadXRot(): number
        get modelRotationValues(): Internal.Map<string, Internal.Vector3f>
        set playingDead(arg0: boolean)
        get maxAirSupply(): number
        get mobType(): Internal.MobType
        get variant(): Internal.Axolotl$Variant
        get multipartEntity(): boolean
        get maxHeadYRot(): number
        get parts(): Internal.PartEntity<any>[]
        get brain(): Internal.Brain<Internal.Axolotl>
        get pickupSound(): Internal.SoundEvent
        readonly static "TOTAL_PLAYDEAD_TIME": 200;
        readonly static "PLAYER_REGEN_DETECTION_RANGE": 20.0;
        readonly static "RARE_VARIANT_CHANCE": 1200;
        readonly static "VARIANT_TAG": "Variant";
    }
    type Axolotl_ = Axolotl;
    class NearestLivingEntitySensor extends Internal.Sensor<Internal.LivingEntity> {
        constructor()
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
    }
    type NearestLivingEntitySensor_ = NearestLivingEntitySensor;
    class PineFoliagePlacer extends Internal.FoliagePlacer {
        constructor(arg0: Internal.IntProvider_, arg1: Internal.IntProvider_, arg2: Internal.IntProvider_)
        foliageRadius(arg0: Internal.Random_, arg1: number): number;
        foliageHeight(arg0: Internal.Random_, arg1: number, arg2: Internal.TreeConfiguration_): number;
        readonly static "CODEC": any;
    }
    type PineFoliagePlacer_ = PineFoliagePlacer;
    class PalettedContainer$Data <T> extends Internal.Record {
        configuration(): Internal.PalettedContainer$Configuration<T>;
        write(arg0: Internal.FriendlyByteBuf_): void;
        hashCode(): number;
        palette(): Internal.Palette<T>;
        getSerializedSize(): number;
        toString(): string;
        copyFrom(arg0: Internal.Palette_<T>, arg1: Internal.BitStorage_): void;
        storage(): Internal.BitStorage;
        equals(arg0: any): boolean;
        get serializedSize(): number
    }
    type PalettedContainer$Data_<T> = PalettedContainer$Data<T>;
    class MotiveBuilder extends Internal.BuilderBase<Internal.Motive> {
        constructor(i: ResourceLocation_)
        height(height: number): this;
        createObject(): any;
        width(width: number): this;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Motive>;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Motive>
    }
    type MotiveBuilder_ = MotiveBuilder;
    class TagNetworkSerialization$NetworkPayload {
        write(arg0: Internal.FriendlyByteBuf_): void;
        isEmpty(): boolean;
        static read(arg0: Internal.FriendlyByteBuf_): Internal.TagNetworkSerialization$NetworkPayload;
        get empty(): boolean
    }
    type TagNetworkSerialization$NetworkPayload_ = TagNetworkSerialization$NetworkPayload;
    class MobSpawnSettingsBuilder extends Internal.MobSpawnSettings$Builder {
        constructor(arg0: Internal.MobSpawnSettings_)
        disablePlayerSpawn(): this;
        getProbability(): number;
        getEntityTypes(): Internal.Set<Internal.EntityType<any>>;
        getSpawner(arg0: Internal.MobCategory_): Internal.List<Internal.MobSpawnSettings$SpawnerData>;
        getCost(arg0: Internal.EntityType_<any>): Internal.MobSpawnSettings$MobSpawnCost;
        getSpawnerTypes(): Internal.Set<Internal.MobCategory>;
        get probability(): number
        get entityTypes(): Internal.Set<Internal.EntityType<any>>
        get spawnerTypes(): Internal.Set<Internal.MobCategory>
    }
    type MobSpawnSettingsBuilder_ = MobSpawnSettingsBuilder;
    class AccessControlContext {
        constructor(arg0: Internal.AccessControlContext_, arg1: Internal.DomainCombiner_)
        constructor(arg0: Internal.ProtectionDomain_[])
        hashCode(): number;
        checkPermission(arg0: Internal.Permission_): void;
        equals(arg0: any): boolean;
        getDomainCombiner(): Internal.DomainCombiner;
        get domainCombiner(): Internal.DomainCombiner
    }
    type AccessControlContext_ = AccessControlContext;
    class RecursivePoint$RecursivePointType <A> extends com.mojang.datafixers.types.Type<A> {
        constructor(arg0: Internal.RecursiveTypeFamily_, arg1: number, arg2: Internal.Supplier_<com.mojang.datafixers.types.Type_<A>>)
        findChoiceType(arg0: string, arg1: number): Internal.Optional<Internal.TaggedChoice$TaggedChoiceType<any>>;
        toString(): string;
        all(arg0: Internal.TypeRewriteRule_, arg1: boolean, arg2: boolean): Internal.RewriteResult<A, any>;
        index(): number;
        findCheckedType(arg0: number): Internal.Optional<com.mojang.datafixers.types.Type<any>>;
        in(): Internal.View<A, A>;
        family(): Internal.RecursiveTypeFamily;
        hashCode(): number;
        findFieldTypeOpt(arg0: string): Internal.Optional<com.mojang.datafixers.types.Type<any>>;
        one(arg0: Internal.TypeRewriteRule_): Internal.Optional<Internal.RewriteResult<A, any>>;
        everywhere(arg0: Internal.TypeRewriteRule_, arg1: Internal.PointFreeRule_, arg2: boolean, arg3: boolean): Internal.Optional<Internal.RewriteResult<A, any>>;
        out(): Internal.View<A, A>;
        point(arg0: Internal.DynamicOps_<any>): Internal.Optional<A>;
        equals(arg0: any, arg1: boolean, arg2: boolean): boolean;
        updateMu(arg0: Internal.RecursiveTypeFamily_): com.mojang.datafixers.types.Type<any>;
        buildTemplate(): Internal.TypeTemplate;
        unfold(): com.mojang.datafixers.types.Type<A>;
        findTypeInChildren(arg0: com.mojang.datafixers.types.Type_<FT>, arg1: com.mojang.datafixers.types.Type_<FR>, arg2: Internal.Type$TypeMatcher_<FT, FR>, arg3: boolean): Internal.Either<Internal.TypedOptic<A, any, FT, FR>, Internal.Type$FieldNotFoundException>;
    }
    type RecursivePoint$RecursivePointType_<A> = RecursivePoint$RecursivePointType<A>;
    class BlockStateConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.BlockState_)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
        readonly "state": Internal.BlockState;
    }
    type BlockStateConfiguration_ = BlockStateConfiguration;
    class MobType {
        constructor()
        readonly static "ILLAGER": Internal.MobType;
        readonly static "WATER": Internal.MobType;
        readonly static "UNDEFINED": Internal.MobType;
        readonly static "UNDEAD": Internal.MobType;
        readonly static "ARTHROPOD": Internal.MobType;
    }
    type MobType_ = MobType;
    abstract class ChunkSource implements Internal.AutoCloseable, Internal.LightChunkGetter {
        constructor()
        getLoadedChunksCount(): number;
        gatherStats(): string;
        updateChunkForced(arg0: Internal.ChunkPos_, arg1: boolean): void;
        tick(arg0: Internal.BooleanSupplier_, arg1: boolean): void;
        getChunk(arg0: number, arg1: number, arg2: Internal.ChunkStatus_, arg3: boolean): Internal.ChunkAccess;
        hasChunk(arg0: number, arg1: number): boolean;
        setSpawnSettings(arg0: boolean, arg1: boolean): void;
        getChunk(arg0: number, arg1: number, arg2: boolean): Internal.LevelChunk;
        getChunkNow(arg0: number, arg1: number): Internal.LevelChunk;
        onLightUpdate(arg0: Internal.LightLayer_, arg1: Internal.SectionPos_): void;
        getChunkForLighting(arg0: number, arg1: number): Internal.BlockGetter;
        close(): void;
        getLightEngine(): Internal.LevelLightEngine;
        get loadedChunksCount(): number
        get lightEngine(): Internal.LevelLightEngine
    }
    type ChunkSource_ = ChunkSource;
    interface PieceGenerator <C> {
        generatePieces(arg0: Internal.StructurePiecesBuilder_, arg1: Internal.PieceGenerator$Context_<C>): void;
    }
    type PieceGenerator_<C> = ((arg0: Internal.StructurePiecesBuilder, arg1: Internal.PieceGenerator$Context<C>)=>void) | PieceGenerator<C>;
    abstract class AbstractSkeleton extends Internal.Monster implements Internal.RangedAttackMob {
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getMobType(): Internal.MobType;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        performRangedAttack(arg0: Internal.LivingEntity_, arg1: number): void;
        canFireProjectileWeapon(arg0: Internal.ProjectileWeaponItem_): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        isShaking(): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMyRidingOffset(): number;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        rideTick(): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        setItemSlot(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): void;
        reassessWeaponGoal(): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get mobType(): Internal.MobType
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get shaking(): boolean
        get myRidingOffset(): number
    }
    type AbstractSkeleton_ = AbstractSkeleton;
    interface SurfaceRules$RuleSource extends Internal.Function<Internal.SurfaceRules$Context, Internal.SurfaceRules$SurfaceRule> {
        bootstrap(arg0: Internal.Registry_<Internal.Codec_<any>>): Internal.Codec<any>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<Internal.SurfaceRules$Context, V>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, Internal.SurfaceRules$SurfaceRule>;
        codec(): Internal.Codec<any>;
        readonly static "CODEC": any;
    }
    type SurfaceRules$RuleSource_ = (()=>Internal.Codec_<any>) | SurfaceRules$RuleSource;
    class HasSturdyFacePredicate implements net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate {
        constructor(arg0: Vec3i_, arg1: Internal.Direction_)
        type(): Internal.BlockPredicateType<any>;
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: any, arg1: any): boolean;
        negate(): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: Internal.WorldGenLevel_, arg1: BlockPos_): boolean;
        readonly static "CODEC": any;
    }
    type HasSturdyFacePredicate_ = HasSturdyFacePredicate;
    abstract class StructurePiece {
        constructor(arg0: Internal.StructurePieceType_, arg1: Internal.CompoundTag_)
        static findCollisionPiece(arg0: Internal.List_<Internal.StructurePiece_>, arg1: Internal.BoundingBox_): Internal.StructurePiece;
        postProcess(arg0: Internal.WorldGenLevel_, arg1: Internal.StructureFeatureManager_, arg2: Internal.ChunkGenerator_, arg3: Internal.Random_, arg4: Internal.BoundingBox_, arg5: Internal.ChunkPos_, arg6: BlockPos_): void;
        move(arg0: number, arg1: number, arg2: number): void;
        isCloseToChunk(arg0: Internal.ChunkPos_, arg1: number): boolean;
        getGenDepth(): number;
        getOrientation(): Internal.Direction;
        addChildren(arg0: Internal.StructurePiece_, arg1: Internal.StructurePieceAccessor_, arg2: Internal.Random_): void;
        setOrientation(arg0: Internal.Direction_): void;
        createTag(arg0: Internal.StructurePieceSerializationContext_): Internal.CompoundTag;
        getType(): Internal.StructurePieceType;
        getBoundingBox(): Internal.BoundingBox;
        getRotation(): Internal.Rotation;
        getMirror(): Internal.Mirror;
        static createBoundingBox(arg0: Internal.Stream_<Internal.StructurePiece_>): Internal.BoundingBox;
        static reorient(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_): Internal.BlockState;
        getLocatorPosition(): BlockPos;
        getNoiseEffect(): Internal.NoiseEffect;
        get genDepth(): number
        get orientation(): Internal.Direction
        set orientation(arg0: Internal.Direction_)
        get type(): Internal.StructurePieceType
        get boundingBox(): Internal.BoundingBox
        get rotation(): Internal.Rotation
        get mirror(): Internal.Mirror
        get locatorPosition(): BlockPos
        get noiseEffect(): Internal.NoiseEffect
    }
    type StructurePiece_ = StructurePiece;
    abstract class ScreenEvent$MouseInputEvent extends Internal.ScreenEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number)
        getMouseX(): number;
        getListenerList(): Internal.ListenerList;
        getMouseY(): number;
        get mouseX(): number
        get listenerList(): Internal.ListenerList
        get mouseY(): number
    }
    type ScreenEvent$MouseInputEvent_ = ScreenEvent$MouseInputEvent;
    interface LongToIntFunction {
        applyAsInt(arg0: number): number;
    }
    type LongToIntFunction_ = LongToIntFunction | ((arg0: number)=>number);
    abstract class TypeParameter <T> extends Internal.TypeCapture<T> {
        hashCode(): number;
        toString(): string;
        equals(arg0: any): boolean;
    }
    type TypeParameter_<T> = TypeParameter<T>;
    class BiomeGenerationSettings {
        getCarvingStages(): Internal.Set<CarvingGenerationStep>;
        getFlowerFeatures(): Internal.List<Internal.ConfiguredFeature<any, any>>;
        features(): Internal.List<Internal.HolderSet<Internal.PlacedFeature>>;
        hasFeature(arg0: Internal.PlacedFeature_): boolean;
        getCarvers(arg0: CarvingGenerationStep_): Internal.Iterable<Internal.Holder<Internal.ConfiguredWorldCarver<any>>>;
        get carvingStages(): Internal.Set<CarvingGenerationStep>
        get flowerFeatures(): Internal.List<Internal.ConfiguredFeature<any, any>>
        readonly static "EMPTY": Internal.BiomeGenerationSettings;
        readonly static "CODEC": any;
    }
    type BiomeGenerationSettings_ = BiomeGenerationSettings;
    interface DirectoryStream$Filter <T> {
        accept(arg0: T): boolean;
    }
    type DirectoryStream$Filter_<T> = DirectoryStream$Filter<T> | ((arg0: T)=>boolean);
    abstract class Screen extends Internal.AbstractContainerEventHandler implements Internal.Widget {
        charTyped(arg0: string, arg1: number): boolean;
        afterMouseAction(): void;
        onFilesDrop(arg0: Internal.List_<Internal.Path_>): void;
        getMinecraft(): Internal.Minecraft;
        narrationEnabled(): void;
        mouseClicked(arg0: number, arg1: number, arg2: number): boolean;
        keyReleased(arg0: number, arg1: number, arg2: number): boolean;
        static isCut(arg0: number): boolean;
        addRenderableWidget(arg0: T): T;
        sendMessage(arg0: string, arg1: boolean): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<any>, arg2: number, arg3: number): void;
        afterMouseMove(): void;
        mouseMoved(arg0: number, arg1: number): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.Component_, arg2: number, arg3: number): void;
        magicalSpecialHackyFocus(arg0: Internal.GuiEventListener_): void;
        static isCopy(arg0: number): boolean;
        render(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: number, arg3: number): void;
        changeFocus(arg0: boolean): boolean;
        handleComponentClicked(arg0: Internal.Style_): boolean;
        tick(): void;
        keyPressed(arg0: number, arg1: number, arg2: number): boolean;
        isPauseScreen(): boolean;
        getTooltipFromItem(arg0: Internal.ItemStack_): Internal.List<Internal.Component>;
        removed(): void;
        children(): Internal.List<any>;
        getTitle(): Internal.Component;
        addRenderableOnly(arg0: T): T;
        static isSelectAll(arg0: number): boolean;
        getChildAt(arg0: number, arg1: number): Internal.Optional<Internal.GuiEventListener>;
        isMouseOver(arg0: number, arg1: number): boolean;
        renderBackground(arg0: Internal.PoseStack_, arg1: number): void;
        shouldCloseOnEsc(): boolean;
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<any>, arg2: number, arg3: number, arg4: Internal.ItemStack_): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number, arg5: Internal.Font_, arg6: Internal.ItemStack_): void;
        static hasAltDown(): boolean;
        mouseScrolled(arg0: number, arg1: number, arg2: number): boolean;
        renderDirtBackground(arg0: number): void;
        addWidget(arg0: T): T;
        onClose(): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number, arg5: Internal.ItemStack_): void;
        static hasShiftDown(): boolean;
        init(arg0: Internal.Minecraft_, arg1: number, arg2: number): void;
        renderBackground(arg0: Internal.PoseStack_): void;
        mouseDragged(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): boolean;
        getNarrationMessage(): Internal.Component;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number, arg5: Internal.Font_): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<any>, arg2: number, arg3: number, arg4: Internal.Font_): void;
        resize(arg0: Internal.Minecraft_, arg1: number, arg2: number): void;
        mouseReleased(arg0: number, arg1: number, arg2: number): boolean;
        static isPaste(arg0: number): boolean;
        sendMessage(arg0: string): void;
        static hasControlDown(): boolean;
        afterKeyboardAction(): void;
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<any>, arg2: number, arg3: number, arg4: Internal.Font_): void;
        static findNarratableWidget(arg0: Internal.List_<any>, arg1: Internal.NarratableEntry_): Internal.Screen$NarratableSearchResult;
        setInitialFocus(arg0: Internal.GuiEventListener_): void;
        handleDelayedNarration(): void;
        static wrapScreenError(arg0: Internal.Runnable_, arg1: string, arg2: string): void;
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<any>, arg2: number, arg3: number, arg4: Internal.Font_, arg5: Internal.ItemStack_): void;
        get minecraft(): Internal.Minecraft
        get pauseScreen(): boolean
        get title(): Internal.Component
        get narrationMessage(): Internal.Component
        set initialFocus(arg0: Internal.GuiEventListener_)
        "width": number;
        "passEvents": boolean;
        "height": number;
        readonly "renderables": Internal.List<Internal.Widget>;
        readonly "narratables": Internal.List<Internal.NarratableEntry>;
    }
    type Screen_ = Screen;
    interface Spliterator$OfPrimitive <T, T_CONS, T_SPLITR> extends Internal.Spliterator<T> {
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        trySplit(): Internal.Spliterator<any>;
        getComparator(): Internal.Comparator<any>;
        getExactSizeIfKnown(): number;
        forEachRemaining(arg0: T_CONS): void;
        hasCharacteristics(arg0: number): boolean;
        tryAdvance(arg0: T_CONS): boolean;
        get comparator(): Internal.Comparator<any>
        get exactSizeIfKnown(): number
    }
    type Spliterator$OfPrimitive_<T, T_CONS, T_SPLITR> = Spliterator$OfPrimitive<T, T_CONS, T_SPLITR>;
    interface RecvByteBufAllocator {
        newHandle(): Internal.RecvByteBufAllocator$Handle;
    }
    type RecvByteBufAllocator_ = RecvByteBufAllocator;
    class ServerboundSeenAdvancementsPacket$Action extends Internal.Enum<Internal.ServerboundSeenAdvancementsPacket$Action> {
        static values(): Internal.ServerboundSeenAdvancementsPacket$Action[];
        static valueOf(arg0: string): Internal.ServerboundSeenAdvancementsPacket$Action;
        readonly static "OPENED_TAB": Internal.ServerboundSeenAdvancementsPacket$Action;
        readonly static "CLOSED_SCREEN": Internal.ServerboundSeenAdvancementsPacket$Action;
    }
    type ServerboundSeenAdvancementsPacket$Action_ = "closed_screen" | ServerboundSeenAdvancementsPacket$Action | "opened_tab";
    class RecipeBook {
        constructor()
        contains(arg0: ResourceLocation_): boolean;
        copyOverData(arg0: Internal.RecipeBook_): void;
        removeHighlight(arg0: Internal.Recipe_<any>): void;
        isOpen(arg0: Internal.RecipeBookType_): boolean;
        remove(arg0: Internal.Recipe_<any>): void;
        add(arg0: Internal.Recipe_<any>): void;
        addHighlight(arg0: Internal.Recipe_<any>): void;
        setOpen(arg0: Internal.RecipeBookType_, arg1: boolean): void;
        willHighlight(arg0: Internal.Recipe_<any>): boolean;
        contains(arg0: Internal.Recipe_<any>): boolean;
        isFiltering(arg0: Internal.RecipeBookType_): boolean;
        setFiltering(arg0: Internal.RecipeBookType_, arg1: boolean): void;
        isFiltering(arg0: Internal.RecipeBookMenu_<any>): boolean;
        setBookSetting(arg0: Internal.RecipeBookType_, arg1: boolean, arg2: boolean): void;
        getBookSettings(): Internal.RecipeBookSettings;
        setBookSettings(arg0: Internal.RecipeBookSettings_): void;
        get bookSettings(): Internal.RecipeBookSettings
        set bookSettings(arg0: Internal.RecipeBookSettings_)
    }
    type RecipeBook_ = RecipeBook;
    class WallSide extends Internal.Enum<Internal.WallSide> implements Internal.StringRepresentable {
        static values(): Internal.WallSide[];
        toString(): string;
        getSerializedName(): string;
        static valueOf(arg0: string): Internal.WallSide;
        get serializedName(): string
        readonly static "LOW": Internal.WallSide;
        readonly static "TALL": Internal.WallSide;
        readonly static "NONE": Internal.WallSide;
    }
    type WallSide_ = "low" | WallSide | "tall" | "none";
    class ChatVisiblity extends Internal.Enum<Internal.ChatVisiblity> {
        static byId(arg0: number): Internal.ChatVisiblity;
        getKey(): string;
        static valueOf(arg0: string): Internal.ChatVisiblity;
        static values(): Internal.ChatVisiblity[];
        getId(): number;
        get key(): string
        get id(): number
        readonly static "HIDDEN": Internal.ChatVisiblity;
        readonly static "FULL": Internal.ChatVisiblity;
        readonly static "SYSTEM": Internal.ChatVisiblity;
    }
    type ChatVisiblity_ = "system" | "full" | "hidden" | ChatVisiblity;
    abstract class BiomeSource implements Internal.BiomeResolver {
        findBiomeHorizontal(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.Predicate_<Internal.Holder_<Internal.Biome_>>, arg6: Internal.Random_, arg7: boolean, arg8: Internal.Climate$Sampler_): com.mojang.datafixers.util.Pair<BlockPos, Internal.Holder<Internal.Biome>>;
        withSeed(arg0: number): this;
        possibleBiomes(): Internal.Set<Internal.Holder<Internal.Biome>>;
        getBiomesWithin(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Climate$Sampler_): Internal.Set<Internal.Holder<Internal.Biome>>;
        featuresPerStep(): Internal.List<Internal.BiomeSource$StepFeatureData>;
        addDebugInfo(arg0: Internal.List_<string>, arg1: BlockPos_, arg2: Internal.Climate$Sampler_): void;
        getNoiseBiome(arg0: number, arg1: number, arg2: number, arg3: Internal.Climate$Sampler_): Internal.Holder<Internal.Biome>;
        findBiomeHorizontal(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Predicate_<Internal.Holder_<Internal.Biome_>>, arg5: Internal.Random_, arg6: Internal.Climate$Sampler_): com.mojang.datafixers.util.Pair<BlockPos, Internal.Holder<Internal.Biome>>;
        readonly static "CODEC": any;
    }
    type BiomeSource_ = BiomeSource;
    class RenderStateShard$CullStateShard extends Internal.RenderStateShard$BooleanStateShard {
        constructor(arg0: boolean)
    }
    type RenderStateShard$CullStateShard_ = RenderStateShard$CullStateShard;
    class ServerOpList extends Internal.StoredUserList<Internal.GameProfile, any> {
        constructor(arg0: Internal.File_)
        getUserList(): string[];
        canBypassPlayerLimit(arg0: Internal.GameProfile_): boolean;
        get userList(): string[]
    }
    type ServerOpList_ = ServerOpList;
    interface MutableComponent extends Internal.ComponentKJS, Internal.Component {
        append(arg0: Internal.Component_): this;
        hasStyle(): boolean;
        darkRed(): this;
        visitSelf(arg0: Internal.FormattedText$StyledContentConsumer_<T>, arg1: Internal.Style_): Internal.Optional<T>;
        visit(arg0: Internal.FormattedText$ContentConsumer_<T>): Internal.Optional<T>;
        toJson(): Internal.JsonElement;
        visit(arg0: Internal.FormattedText$StyledContentConsumer_<T>, arg1: Internal.Style_): Internal.Optional<T>;
        visitSelf(arg0: Internal.FormattedText$ContentConsumer_<T>): Internal.Optional<T>;
        darkBlue(): this;
        obfuscated(value: boolean): this;
        getString(arg0: number): string;
        darkGreen(): this;
        bold(): this;
        color(c: Internal.Color_): this;
        underlined(): this;
        yellow(): this;
        withStyle(arg0: Internal.UnaryOperator_<Internal.Style_>): this;
        darkPurple(): this;
        blue(): this;
        hover(s: Internal.Component_): this;
        bold(value: boolean): this;
        withStyle(arg0: Internal.ChatFormatting_): this;
        aqua(): this;
        green(): this;
        black(): this;
        obfuscated(): this;
        strikethrough(value: boolean): this;
        insertion(s: string): this;
        red(): this;
        italic(): this;
        forEach(arg0: Internal.Consumer_<any>): void;
        component(): Internal.Component;
        click(s: Internal.ClickEvent_): this;
        underlined(value: boolean): this;
        self(): this;
        rawComponent(): this;
        gray(): this;
        font(s: ResourceLocation_): this;
        darkAqua(): this;
        getString(): string;
        darkGray(): this;
        spliterator(): Internal.Spliterator<Internal.Component>;
        iterator(): Internal.Iterator<any>;
        noColor(): this;
        setStyle(arg0: Internal.Style_): this;
        withStyle(arg0: Internal.Style_): this;
        strikethrough(): this;
        gold(): this;
        white(): this;
        hasSiblings(): boolean;
        italic(value: boolean): this;
        withStyle(...arg0: Internal.ChatFormatting_[]): this;
        rawCopy(): this;
        toFlatList(arg0: Internal.Style_): Internal.List<Internal.Component>;
        lightPurple(): this;
        get string(): string
        set style(arg0: Internal.Style_)
    }
    type MutableComponent_ = MutableComponent;
    abstract class NearestVisibleLivingEntitySensor extends Internal.Sensor<Internal.LivingEntity> {
        constructor()
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
    }
    type NearestVisibleLivingEntitySensor_ = NearestVisibleLivingEntitySensor;
    abstract class URLConnection {
        setIfModifiedSince(arg0: number): void;
        getHeaderFieldLong(arg0: string, arg1: number): number;
        getContentLengthLong(): number;
        static getDefaultRequestProperty(arg0: string): string;
        getConnectTimeout(): number;
        static setFileNameMap(arg0: Internal.FileNameMap_): void;
        getRequestProperty(arg0: string): string;
        setDoInput(arg0: boolean): void;
        setUseCaches(arg0: boolean): void;
        setDoOutput(arg0: boolean): void;
        getContentLength(): number;
        static setDefaultAllowUserInteraction(arg0: boolean): void;
        getContent(arg0: Internal.Class_<any>[]): any;
        getIfModifiedSince(): number;
        getUseCaches(): boolean;
        getHeaderField(arg0: string): string;
        getContent(): any;
        getURL(): Internal.URL;
        getDoOutput(): boolean;
        static getDefaultUseCaches(arg0: string): boolean;
        setConnectTimeout(arg0: number): void;
        getDoInput(): boolean;
        connect(): void;
        getReadTimeout(): number;
        getRequestProperties(): Internal.Map<string, Internal.List<string>>;
        getHeaderField(arg0: number): string;
        getContentEncoding(): string;
        static setDefaultRequestProperty(arg0: string, arg1: string): void;
        setAllowUserInteraction(arg0: boolean): void;
        getInputStream(): Internal.InputStream;
        getDate(): number;
        static guessContentTypeFromStream(arg0: Internal.InputStream_): string;
        setReadTimeout(arg0: number): void;
        static getDefaultAllowUserInteraction(): boolean;
        getOutputStream(): Internal.OutputStream;
        getPermission(): Internal.Permission;
        getHeaderFieldInt(arg0: string, arg1: number): number;
        getLastModified(): number;
        static getFileNameMap(): Internal.FileNameMap;
        getDefaultUseCaches(): boolean;
        getAllowUserInteraction(): boolean;
        addRequestProperty(arg0: string, arg1: string): void;
        toString(): string;
        getHeaderFields(): Internal.Map<string, Internal.List<string>>;
        getHeaderFieldKey(arg0: number): string;
        static setContentHandlerFactory(arg0: Internal.ContentHandlerFactory_): void;
        setRequestProperty(arg0: string, arg1: string): void;
        getExpiration(): number;
        setDefaultUseCaches(arg0: boolean): void;
        getHeaderFieldDate(arg0: string, arg1: number): number;
        static setDefaultUseCaches(arg0: string, arg1: boolean): void;
        getContentType(): string;
        static guessContentTypeFromName(arg0: string): string;
        set ifModifiedSince(arg0: number)
        get contentLengthLong(): number
        get connectTimeout(): number
        set fileNameMap(arg0: Internal.FileNameMap_)
        set doInput(arg0: boolean)
        set useCaches(arg0: boolean)
        set doOutput(arg0: boolean)
        get contentLength(): number
        set defaultAllowUserInteraction(arg0: boolean)
        get ifModifiedSince(): number
        get useCaches(): boolean
        get content(): any
        get URL(): Internal.URL
        get doOutput(): boolean
        set connectTimeout(arg0: number)
        get doInput(): boolean
        get readTimeout(): number
        get requestProperties(): Internal.Map<string, Internal.List<string>>
        get contentEncoding(): string
        set allowUserInteraction(arg0: boolean)
        get inputStream(): Internal.InputStream
        get date(): number
        set readTimeout(arg0: number)
        get defaultAllowUserInteraction(): boolean
        get outputStream(): Internal.OutputStream
        get permission(): Internal.Permission
        get lastModified(): number
        get fileNameMap(): Internal.FileNameMap
        get defaultUseCaches(): boolean
        get allowUserInteraction(): boolean
        get headerFields(): Internal.Map<string, Internal.List<string>>
        set contentHandlerFactory(arg0: Internal.ContentHandlerFactory_)
        get expiration(): number
        set defaultUseCaches(arg0: boolean)
        get contentType(): string
    }
    type URLConnection_ = URLConnection;
    interface ObjectIterator <K> extends Internal.Iterator<K> {
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        skip(arg0: number): number;
    }
    type ObjectIterator_<K> = ObjectIterator<K>;
    class ModuleDescriptor$Opens$Modifier extends Internal.Enum<Internal.ModuleDescriptor$Opens$Modifier> {
        static valueOf(arg0: string): Internal.ModuleDescriptor$Opens$Modifier;
        static values(): Internal.ModuleDescriptor$Opens$Modifier[];
        readonly static "MANDATED": Internal.ModuleDescriptor$Opens$Modifier;
        readonly static "SYNTHETIC": Internal.ModuleDescriptor$Opens$Modifier;
    }
    type ModuleDescriptor$Opens$Modifier_ = "mandated" | ModuleDescriptor$Opens$Modifier | "synthetic";
    class RandomPatchConfiguration extends Internal.Record implements Internal.FeatureConfiguration {
        constructor(arg0: number, arg1: number, arg2: number, arg3: Internal.Holder_<Internal.PlacedFeature_>)
        tries(): number;
        hashCode(): number;
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        ySpread(): number;
        toString(): string;
        feature(): Internal.Holder<Internal.PlacedFeature>;
        equals(arg0: any): boolean;
        xzSpread(): number;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
    }
    type RandomPatchConfiguration_ = RandomPatchConfiguration;
    interface IForgeEnchantment {
        getDamageBonus(arg0: number, arg1: Internal.MobType_, arg2: Internal.ItemStack_): number;
    }
    type IForgeEnchantment_ = IForgeEnchantment;
    class ModuleLayer$Controller {
        addExports(arg0: Internal.Module_, arg1: string, arg2: Internal.Module_): this;
        layer(): Internal.ModuleLayer;
        addOpens(arg0: Internal.Module_, arg1: string, arg2: Internal.Module_): this;
        addReads(arg0: Internal.Module_, arg1: Internal.Module_): this;
    }
    type ModuleLayer$Controller_ = ModuleLayer$Controller;
    class ModCheck$Confidence extends Internal.Enum<Internal.ModCheck$Confidence> {
        static values(): Internal.ModCheck$Confidence[];
        static valueOf(arg0: string): Internal.ModCheck$Confidence;
        readonly static "VERY_LIKELY": Internal.ModCheck$Confidence;
        readonly static "DEFINITELY": Internal.ModCheck$Confidence;
        readonly static "PROBABLY_NOT": Internal.ModCheck$Confidence;
    }
    type ModCheck$Confidence_ = "definitely" | "very_likely" | ModCheck$Confidence | "probably_not";
    abstract class BlockBehaviour$BlockStateBase extends Internal.StateHolder<Internal.Block, Internal.BlockState> implements Internal.BlockStateKJS {
        canOcclude(): boolean;
        updateNeighbourShapes(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: number): void;
        getShape(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.CollisionContext_): Internal.VoxelShape;
        getSignal(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): number;
        getLightBlock(arg0: Internal.BlockGetter_, arg1: BlockPos_): number;
        getLightEmission(): number;
        updateNeighbourShapes(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: number, arg3: number): void;
        getTicker(arg0: Internal.Level_, arg1: Internal.BlockEntityType_<T>): Internal.BlockEntityTicker<T>;
        getInteractionShape(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.VoxelShape;
        setRequiresToolKJS(arg0: boolean): void;
        is(arg0: Internal.TagKey_<Internal.Block_>): boolean;
        setMaterialKJS(arg0: Internal.Material_): void;
        initCache(): void;
        useShapeForLightOcclusion(): boolean;
        isRandomlyTicking(): boolean;
        isSolidRender(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        isPathfindable(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.PathComputationType_): boolean;
        getVisualShape(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.CollisionContext_): Internal.VoxelShape;
        rotate(arg0: Internal.Rotation_): Internal.BlockState;
        canSurvive(arg0: Internal.LevelReader_, arg1: BlockPos_): boolean;
        getMapColor(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.MaterialColor;
        is(arg0: Internal.HolderSet_<Internal.Block_>): boolean;
        onRemove(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: boolean): void;
        isFaceSturdy(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        getSeed(arg0: BlockPos_): number;
        getMenuProvider(arg0: Internal.Level_, arg1: BlockPos_): Internal.MenuProvider;
        getBlockSupportShape(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.VoxelShape;
        onPlace(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: boolean): void;
        getBlock(): Internal.Block;
        tick(arg0: Internal.ServerLevel_, arg1: BlockPos_, arg2: Internal.Random_): void;
        getCollisionShape(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.CollisionContext_): Internal.VoxelShape;
        getOcclusionShape(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.VoxelShape;
        is(arg0: Internal.Block_): boolean;
        isViewBlocking(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        getFluidState(): Internal.FluidState;
        setDestroySpeedKJS(arg0: number): void;
        getShape(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.VoxelShape;
        emissiveRendering(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        getTags(): Internal.Stream<Internal.TagKey<Internal.Block>>;
        mirror(arg0: Internal.Mirror_): Internal.BlockState;
        isAir(): boolean;
        getDirectSignal(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): number;
        getDestroySpeed(arg0: Internal.BlockGetter_, arg1: BlockPos_): number;
        hasBlockEntity(): boolean;
        isValidSpawn(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.EntityType_<any>): boolean;
        hasAnalogOutputSignal(): boolean;
        hasLargeCollisionShape(): boolean;
        spawnAfterBreak(arg0: Internal.ServerLevel_, arg1: BlockPos_, arg2: Internal.ItemStack_): void;
        getRenderShape(): Internal.RenderShape;
        getDestroyProgress(arg0: Internal.Player_, arg1: Internal.BlockGetter_, arg2: BlockPos_): number;
        updateShape(arg0: Internal.Direction_, arg1: Internal.BlockState_, arg2: Internal.LevelAccessor_, arg3: BlockPos_, arg4: BlockPos_): Internal.BlockState;
        getMaterial(): Internal.Material;
        isSuffocating(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        getPistonPushReaction(): Internal.PushReaction;
        skipRendering(arg0: Internal.BlockState_, arg1: Internal.Direction_): boolean;
        isFaceSturdy(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_, arg3: Internal.SupportType_): boolean;
        is(arg0: Internal.TagKey_<Internal.Block_>, arg1: Internal.Predicate_<Internal.BlockBehaviour$BlockStateBase_>): boolean;
        hasPostProcess(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        setLightEmissionKJS(arg0: number): void;
        neighborChanged(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Block_, arg3: BlockPos_, arg4: boolean): void;
        updateIndirectNeighbourShapes(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: number, arg3: number): void;
        getFaceOcclusionShape(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): Internal.VoxelShape;
        isRedstoneConductor(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        entityInside(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Entity_): void;
        getShadeBrightness(arg0: Internal.BlockGetter_, arg1: BlockPos_): number;
        getAnalogOutputSignal(arg0: Internal.Level_, arg1: BlockPos_): number;
        use(arg0: Internal.Level_, arg1: Internal.Player_, arg2: Hand_, arg3: Internal.BlockHitResult_): Internal.InteractionResult;
        updateIndirectNeighbourShapes(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: number): void;
        entityCanStandOn(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Entity_): boolean;
        propagatesSkylightDown(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        onProjectileHit(arg0: Internal.Level_, arg1: Internal.BlockState_, arg2: Internal.BlockHitResult_, arg3: Internal.Projectile_): void;
        isCollisionShapeFullBlock(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        getCollisionShape(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.VoxelShape;
        getSoundType(): Internal.SoundType;
        getOffset(arg0: Internal.BlockGetter_, arg1: BlockPos_): Vec3;
        entityCanStandOnFace(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Entity_, arg3: Internal.Direction_): boolean;
        triggerEvent(arg0: Internal.Level_, arg1: BlockPos_, arg2: number, arg3: number): boolean;
        canBeReplaced(arg0: Internal.Fluid_): boolean;
        requiresCorrectToolForDrops(): boolean;
        isSignalSource(): boolean;
        getDrops(arg0: Internal.LootContext$Builder_): Internal.List<Internal.ItemStack>;
        canBeReplaced(arg0: Internal.BlockPlaceContext_): boolean;
        randomTick(arg0: Internal.ServerLevel_, arg1: BlockPos_, arg2: Internal.Random_): void;
        attack(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Player_): void;
        get lightEmission(): number
        set requiresToolKJS(arg0: boolean)
        set materialKJS(arg0: Internal.Material_)
        get randomlyTicking(): boolean
        get block(): Internal.Block
        get fluidState(): Internal.FluidState
        set destroySpeedKJS(arg0: number)
        get tags(): Internal.Stream<Internal.TagKey<Internal.Block>>
        get air(): boolean
        get renderShape(): Internal.RenderShape
        get material(): Internal.Material
        get pistonPushReaction(): Internal.PushReaction
        set lightEmissionKJS(arg0: number)
        get soundType(): Internal.SoundType
        get signalSource(): boolean
    }
    type BlockBehaviour$BlockStateBase_ = BlockBehaviour$BlockStateBase;
    class RuntimeException extends Internal.Exception {
        constructor()
        constructor(arg0: string, arg1: Internal.Throwable_)
        constructor(arg0: Internal.Throwable_)
        constructor(arg0: string)
    }
    type RuntimeException_ = RuntimeException;
    class AlternativeLootItemCondition$Builder implements Internal.LootItemCondition$Builder {
        constructor(...arg0: Internal.LootItemCondition$Builder_[])
        build(): Internal.LootItemCondition;
        or(arg0: Internal.LootItemCondition$Builder_): this;
        invert(): Internal.LootItemCondition$Builder;
    }
    type AlternativeLootItemCondition$Builder_ = AlternativeLootItemCondition$Builder;
    class MultipartBlockStateGenerator {
        constructor()
        part(when: string, model: string): void;
        part(when: string, consumer: Internal.Consumer_<Internal.MultipartBlockStateGenerator$Part_>): void;
        toJson(): Internal.JsonObject;
    }
    type MultipartBlockStateGenerator_ = MultipartBlockStateGenerator;
    class ModelGenerator$Face {
        constructor()
        tintindex(i: number): this;
        uv(u0: number, v0: number, u1: number, v1: number): this;
        cull(d: Internal.Direction_): this;
        cull(): this;
        toJson(): Internal.JsonObject;
        tex(t: string): this;
    }
    type ModelGenerator$Face_ = ModelGenerator$Face;
    class Ghast extends Internal.FlyingMob implements Internal.Enemy {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        static checkGhastSpawnRules(arg0: Internal.EntityType_<Internal.Ghast_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        getExplosionPower(): number;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        isCharging(): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        getMaxSpawnClusterSize(): number;
        getSoundSource(): Internal.SoundSource;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setCharging(arg0: boolean): void;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get explosionPower(): number
        get stepHeight(): number
        get charging(): boolean
        get maxSpawnClusterSize(): number
        get soundSource(): Internal.SoundSource
        get multipartEntity(): boolean
        set charging(arg0: boolean)
        get parts(): Internal.PartEntity<any>[]
    }
    type Ghast_ = Ghast;
    class ThreeLayersFeatureSize extends Internal.FeatureSize {
        constructor(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.OptionalInt_)
        getSizeAtHeight(arg0: number, arg1: number): number;
        readonly static "CODEC": any;
    }
    type ThreeLayersFeatureSize_ = ThreeLayersFeatureSize;
    abstract class RecipeJS {
        constructor()
        getGroup(): string;
        getUniqueId(): string;
        getInputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        customIngredientAction(filter: Internal.IngredientActionFilter_, id: string): this;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getType(): string;
        stage(s: string): this;
        merge(data: any): this;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean): boolean;
        group(g: string): this;
        createRecipe(): Internal.Recipe<any>;
        modifyResult(callback: Internal.ModifyRecipeResultCallback_): this;
        id(_id: ResourceLocation_): this;
        hasInput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        serializeIngredientStack(in_: Internal.IngredientStackJS_): Internal.JsonElement;
        dontAdd(): void;
        serializeJson(): void;
        getFromToString(): string;
        getOutputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        create(arg0: Internal.ListJS_): void;
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        parseIngredientItem(o: any): Internal.IngredientJS;
        hasOutput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean, func: Internal.BiFunction_<Internal.IngredientJS_, Internal.IngredientJS_, Internal.IngredientJS_>): boolean;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        ingredientAction(filter: Internal.IngredientActionFilter_, action: Internal.IngredientAction_): this;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS_, newIngredient: Internal.IngredientJS_): Internal.IngredientJS;
        serialize(): void;
        getPath(): string;
        keepIngredient(filter: Internal.IngredientActionFilter_): this;
        getMod(): string;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        toString(): string;
        serializeNBTAsJson(): boolean;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS_, newStack: Internal.ItemStackJS_): Internal.ItemStackJS;
        damageIngredient(filter: Internal.IngredientActionFilter_): this;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean, func: Internal.BiFunction_<Internal.ItemStackJS_, Internal.ItemStackJS_, Internal.ItemStackJS_>): boolean;
        getId(): string;
        replaceIngredient(filter: Internal.IngredientActionFilter_, item: Internal.ItemStackJS_): this;
        save(): void;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean): boolean;
        setGroup(g: string): void;
        resultFromRecipeJson(json: Internal.JsonObject_): Internal.ItemStackJS;
        getOrCreateId(): ResourceLocation;
        damageIngredient(filter: Internal.IngredientActionFilter_, damage: number): this;
        deserializeJson(): void;
        parseResultItem(o: any): Internal.ItemStackJS;
        serializeItemStack(stack: Internal.ItemStackJS_): Internal.JsonElement;
        deserialize(): void;
        get group(): string
        get uniqueId(): string
        get originalRecipeResult(): Internal.ItemStackJS
        get type(): string
        get fromToString(): string
        get path(): string
        get mod(): string
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        get id(): string
        set group(g: string)
        get orCreateId(): ResourceLocation
        "serializeInputs": boolean;
        readonly "outputItems": Internal.List<Internal.ItemStackJS>;
        "originalJson": Internal.JsonObject;
        "json": Internal.JsonObject;
        "serializeOutputs": boolean;
        static "currentRecipe": Internal.RecipeJS;
        static "itemErrors": false;
        readonly "inputItems": Internal.List<Internal.IngredientJS>;
        "id": ResourceLocation;
        "originalRecipe": Internal.Recipe<any>;
        "type": Internal.RecipeTypeJS;
    }
    type RecipeJS_ = RecipeJS;
    class EntityEvent$Size extends Internal.EntityEvent {
        constructor()
        constructor(arg0: Internal.Entity_, arg1: Internal.Pose_, arg2: Internal.EntityDimensions_, arg3: Internal.EntityDimensions_, arg4: number, arg5: number)
        constructor(arg0: Internal.Entity_, arg1: Internal.Pose_, arg2: Internal.EntityDimensions_, arg3: number)
        setNewSize(arg0: Internal.EntityDimensions_): void;
        getPose(): Internal.Pose;
        getListenerList(): Internal.ListenerList;
        setNewEyeHeight(arg0: number): void;
        getOldEyeHeight(): number;
        getNewSize(): Internal.EntityDimensions;
        getOldSize(): Internal.EntityDimensions;
        setNewSize(arg0: Internal.EntityDimensions_, arg1: boolean): void;
        getNewEyeHeight(): number;
        set newSize(arg0: Internal.EntityDimensions_)
        get pose(): Internal.Pose
        get listenerList(): Internal.ListenerList
        set newEyeHeight(arg0: number)
        get oldEyeHeight(): number
        get newSize(): Internal.EntityDimensions
        get oldSize(): Internal.EntityDimensions
        get newEyeHeight(): number
    }
    type EntityEvent$Size_ = EntityEvent$Size;
    class TrappedChestBlockEntity extends Internal.ChestBlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getMaxStackSize(): number;
        countItem(arg0: Internal.Item_): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get modelData(): Internal.IModelData
        get maxStackSize(): number
        get renderBoundingBox(): Internal.AABB
    }
    type TrappedChestBlockEntity_ = TrappedChestBlockEntity;
    class RenderStateShard$DepthTestStateShard extends Internal.RenderStateShard {
        constructor(arg0: string, arg1: number)
        toString(): string;
    }
    type RenderStateShard$DepthTestStateShard_ = RenderStateShard$DepthTestStateShard;
    class Variant extends Internal.Enum<Internal.Variant> {
        static values(): Internal.Variant[];
        static valueOf(arg0: string): Internal.Variant;
        static byId(arg0: number): Internal.Variant;
        getId(): number;
        get id(): number
        readonly static "WHITE": Internal.Variant;
        readonly static "BLACK": Internal.Variant;
        readonly static "CREAMY": Internal.Variant;
        readonly static "BROWN": Internal.Variant;
        readonly static "GRAY": Internal.Variant;
        readonly static "CHESTNUT": Internal.Variant;
        readonly static "DARKBROWN": Internal.Variant;
    }
    type Variant_ = Variant | "darkbrown" | "white" | "brown" | "gray" | "black" | "creamy" | "chestnut";
    class ChunkEvent$Load extends Internal.ChunkEvent {
        constructor()
        constructor(arg0: Internal.ChunkAccess_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ChunkEvent$Load_ = ChunkEvent$Load;
    class LevelChunk$EntityCreationType extends Internal.Enum<Internal.LevelChunk$EntityCreationType> {
        static valueOf(arg0: string): Internal.LevelChunk$EntityCreationType;
        static values(): Internal.LevelChunk$EntityCreationType[];
        readonly static "IMMEDIATE": Internal.LevelChunk$EntityCreationType;
        readonly static "QUEUED": Internal.LevelChunk$EntityCreationType;
        readonly static "CHECK": Internal.LevelChunk$EntityCreationType;
    }
    type LevelChunk$EntityCreationType_ = "check" | "immediate" | LevelChunk$EntityCreationType | "queued";
    class LiteralCommandNode <S> extends Internal.CommandNode<S> {
        constructor(arg0: string, arg1: Internal.Command_<S>, arg2: Internal.Predicate_<S>, arg3: Internal.CommandNode_<S>, arg4: Internal.RedirectModifier_<S>, arg5: boolean)
        isValidInput(arg0: string): boolean;
        hashCode(): number;
        getExamples(): Internal.Collection<string>;
        toString(): string;
        parse(arg0: Internal.StringReader_, arg1: Internal.CommandContextBuilder_<S>): void;
        getName(): string;
        createBuilder(): Internal.ArgumentBuilder<any, any>;
        listSuggestions(arg0: Internal.CommandContext_<S>, arg1: Internal.SuggestionsBuilder_): Internal.CompletableFuture<Internal.Suggestions>;
        getUsageText(): string;
        equals(arg0: any): boolean;
        getLiteral(): string;
        get examples(): Internal.Collection<string>
        get name(): string
        get usageText(): string
        get literal(): string
    }
    type LiteralCommandNode_<S> = LiteralCommandNode<S>;
    class TextureAtlas extends Internal.AbstractTexture implements Internal.Tickable {
        constructor(arg0: ResourceLocation_)
        prepareToStitch(arg0: Internal.ResourceManager_, arg1: Internal.Stream_<ResourceLocation_>, arg2: Internal.ProfilerFiller_, arg3: number): Internal.TextureAtlas$Preparations;
        getSprite(arg0: ResourceLocation_): Internal.TextureAtlasSprite;
        location(): ResourceLocation;
        updateFilter(arg0: Internal.TextureAtlas$Preparations_): void;
        load(arg0: Internal.ResourceManager_): void;
        cycleAnimationFrames(): void;
        clearTextureData(): void;
        tick(): void;
        reload(arg0: Internal.TextureAtlas$Preparations_): void;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "LOCATION_BLOCKS": ResourceLocation;
        readonly "texturesByName": Internal.Map<ResourceLocation, Internal.TextureAtlasSprite>;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "LOCATION_PARTICLES": ResourceLocation;
    }
    type TextureAtlas_ = TextureAtlas;
    interface Byte2LongFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntToLongFunction {
        put(arg0: number, arg1: number): number;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2LongFunction;
        remove(arg0: number): number;
        getOrDefault(arg0: any, arg1: any): any;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2LongFunction;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Byte2ShortFunction;
        andThenObject(arg0: Internal.Long2ObjectFunction_<any>): Internal.Byte2ObjectFunction<T>;
        get(arg0: any): number;
        containsKey(arg0: any): boolean;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Byte2ByteFunction;
        composeObject(arg0: Internal.Object2ByteFunction_<any>): Internal.Object2LongFunction<T>;
        composeReference(arg0: Internal.Reference2ByteFunction_<any>): Internal.Reference2LongFunction<T>;
        put(arg0: any, arg1: any): any;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Byte2IntFunction;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Byte2FloatFunction;
        containsKey(arg0: number): boolean;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Byte2CharFunction;
        getOrDefault(arg0: number, arg1: number): number;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2LongFunction;
        put(arg0: number, arg1: number): number;
        defaultReturnValue(): number;
        andThenReference(arg0: Internal.Long2ReferenceFunction_<any>): Internal.Byte2ReferenceFunction<T>;
        get(arg0: number): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        getOrDefault(arg0: any, arg1: number): number;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Byte2DoubleFunction;
        andThenLong(arg0: Internal.Long2LongFunction_): this;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2LongFunction;
        size(): number;
        composeByte(arg0: Internal.Byte2ByteFunction_): this;
        apply(arg0: number): number;
        clear(): void;
        applyAsLong(arg0: number): number;
        remove(arg0: any): any;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2LongFunction;
        defaultReturnValue(arg0: number): void;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2LongFunction;
    }
    type Byte2LongFunction_ = Byte2LongFunction | ((arg0: number)=>number);
    class MapItemSavedData extends Internal.SavedData {
        isTrackedCountOverLimit(arg0: number): boolean;
        static createForClient(arg0: number, arg1: boolean, arg2: Internal.ResourceKey_<Internal.Level_>): Internal.MapItemSavedData;
        updateColor(arg0: number, arg1: number, arg2: number): boolean;
        static addTargetDecoration(arg0: Internal.ItemStack_, arg1: BlockPos_, arg2: string, arg3: Internal.MapDecoration$Type_): void;
        removedFromFrame(arg0: BlockPos_, arg1: number): void;
        getDecorations(): Internal.Iterable<Internal.MapDecoration>;
        addClientSideDecorations(arg0: Internal.List_<Internal.MapDecoration_>): void;
        getHoldingPlayer(arg0: Internal.Player_): Internal.MapItemSavedData$HoldingPlayer;
        tickCarriedBy(arg0: Internal.Player_, arg1: Internal.ItemStack_): void;
        setColor(arg0: number, arg1: number, arg2: number): void;
        save(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        toggleBanner(arg0: Internal.LevelAccessor_, arg1: BlockPos_): boolean;
        isExplorationMap(): boolean;
        checkBanners(arg0: Internal.BlockGetter_, arg1: number, arg2: number): void;
        scaled(arg0: number): this;
        getUpdatePacket(arg0: number, arg1: Internal.Player_): Internal.Packet<any>;
        locked(): this;
        getBanners(): Internal.Collection<Internal.MapBanner>;
        static load(arg0: Internal.CompoundTag_): Internal.MapItemSavedData;
        static createFresh(arg0: number, arg1: number, arg2: number, arg3: boolean, arg4: boolean, arg5: Internal.ResourceKey_<Internal.Level_>): Internal.MapItemSavedData;
        get decorations(): Internal.Iterable<Internal.MapDecoration>
        get explorationMap(): boolean
        get banners(): Internal.Collection<Internal.MapBanner>
        "colors": number[];
        readonly static "MAX_SCALE": 4;
        readonly "scale": number;
        readonly "z": number;
        readonly "locked": boolean;
        readonly "x": number;
        readonly "dimension": Internal.ResourceKey<Internal.Level>;
        readonly static "TRACKED_DECORATION_LIMIT": 256;
    }
    type MapItemSavedData_ = MapItemSavedData;
    class PackMetadataSection {
        constructor(arg0: Internal.Component_, arg1: number, arg2: Internal.Map_<Internal.PackType_, number>)
        constructor(arg0: Internal.Component_, arg1: number)
        getPackFormat(): number;
        getPackFormat(arg0: Internal.PackType_): number;
        getDescription(): Internal.Component;
        get packFormat(): number
        get description(): Internal.Component
        readonly static "SERIALIZER": Internal.PackMetadataSectionSerializer;
    }
    type PackMetadataSection_ = PackMetadataSection;
    class ReplaceBlockConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.BlockState_, arg1: Internal.BlockState_)
        constructor(arg0: Internal.List_<Internal.OreConfiguration$TargetBlockState_>)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
        readonly "targetStates": Internal.List<Internal.OreConfiguration$TargetBlockState>;
    }
    type ReplaceBlockConfiguration_ = ReplaceBlockConfiguration;
    class BufferBuilder$DrawState {
        mode(): Internal.VertexFormat$Mode;
        indexOnly(): boolean;
        sequentialIndex(): boolean;
        indexCount(): number;
        format(): Internal.VertexFormat;
        indexType(): Internal.VertexFormat$IndexType;
        vertexBufferSize(): number;
        bufferSize(): number;
        vertexCount(): number;
    }
    type BufferBuilder$DrawState_ = BufferBuilder$DrawState;
    interface Object2FloatFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToDoubleFunction<K> {
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Object2CharFunction<K>;
        getOrDefault(arg0: any, arg1: any): any;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2FloatFunction;
        removeFloat(arg0: any): number;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Object2ShortFunction<K>;
        defaultReturnValue(arg0: number): void;
        getOrDefault(arg0: any, arg1: number): number;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Object2ByteFunction<K>;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2FloatFunction;
        andThenReference(arg0: Internal.Float2ReferenceFunction_<any>): Internal.Object2ReferenceFunction<K, T>;
        put(arg0: any, arg1: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        applyAsDouble(arg0: K): number;
        put(arg0: K, arg1: number): number;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2FloatFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2FloatFunction;
        defaultReturnValue(): number;
        getFloat(arg0: any): number;
        remove(arg0: any): number;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        getOrDefault(arg0: any, arg1: number): number;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2FloatFunction;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2FloatFunction;
        size(): number;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2FloatFunction;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Object2LongFunction<K>;
        clear(): void;
        composeObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Object2FloatFunction<T>;
        andThenObject(arg0: Internal.Float2ObjectFunction_<any>): Internal.Object2ObjectFunction<K, T>;
        put(arg0: K, arg1: number): number;
        get(arg0: any): any;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Object2IntFunction<K>;
        composeReference(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Reference2FloatFunction<T>;
        andThenFloat(arg0: Internal.Float2FloatFunction_): this;
    }
    type Object2FloatFunction_<K> = ((arg0: any)=>number) | Object2FloatFunction<K>;
    class ChunkEvent$Unload extends Internal.ChunkEvent {
        constructor()
        constructor(arg0: Internal.ChunkAccess_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ChunkEvent$Unload_ = ChunkEvent$Unload;
    class AddSpawnProperties {
        constructor()
        setEntity(s: string): void;
        setCategory(s: string): void;
        set entity(s: string)
        set category(s: string)
        "minCount": number;
        "_category": Internal.MobCategory;
        "_entity": Internal.EntityType<any>;
        "biomes": Internal.BiomeFilter;
        "maxCount": number;
        "weight": number;
    }
    type AddSpawnProperties_ = AddSpawnProperties;
    abstract class AbstractCookingRecipe implements Internal.Recipe<Internal.Container> {
        constructor(arg0: Internal.RecipeType_<any>, arg1: ResourceLocation_, arg2: string, arg3: Internal.Ingredient_, arg4: Internal.ItemStack_, arg5: number, arg6: number)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        isSpecial(): boolean;
        getExperience(): number;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        getCookingTime(): number;
        getId(): ResourceLocation;
        isIncomplete(): boolean;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getResultItem(): Internal.ItemStack;
        getRemainingItems(arg0: Internal.Container_): Internal.NonNullList<Internal.ItemStack>;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get special(): boolean
        get experience(): number
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get cookingTime(): number
        get id(): ResourceLocation
        get incomplete(): boolean
        get resultItem(): Internal.ItemStack
    }
    type AbstractCookingRecipe_ = AbstractCookingRecipe;
    class MatchingBlockTagPredicate extends Internal.StateTestingPredicate {
        type(): Internal.BlockPredicateType<any>;
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        negate(): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        readonly static "CODEC": any;
    }
    type MatchingBlockTagPredicate_ = MatchingBlockTagPredicate;
    class SharedSuggestionProvider$ElementSuggestionType extends Internal.Enum<Internal.SharedSuggestionProvider$ElementSuggestionType> {
        static values(): Internal.SharedSuggestionProvider$ElementSuggestionType[];
        shouldSuggestElements(): boolean;
        shouldSuggestTags(): boolean;
        static valueOf(arg0: string): Internal.SharedSuggestionProvider$ElementSuggestionType;
        readonly static "ALL": Internal.SharedSuggestionProvider$ElementSuggestionType;
        readonly static "TAGS": Internal.SharedSuggestionProvider$ElementSuggestionType;
        readonly static "ELEMENTS": Internal.SharedSuggestionProvider$ElementSuggestionType;
    }
    type SharedSuggestionProvider$ElementSuggestionType_ = "elements" | "tags" | SharedSuggestionProvider$ElementSuggestionType | "all";
    class ServerFunctionManager {
        constructor(arg0: Internal.MinecraftServer_, arg1: Internal.ServerFunctionLibrary_)
        getFunctionNames(): Internal.Iterable<ResourceLocation>;
        replaceLibrary(arg0: Internal.ServerFunctionLibrary_): void;
        getTagNames(): Internal.Iterable<ResourceLocation>;
        getDispatcher(): Internal.CommandDispatcher<Internal.CommandSourceStack>;
        getGameLoopSender(): Internal.CommandSourceStack;
        execute(arg0: Internal.CommandFunction_, arg1: Internal.CommandSourceStack_): number;
        getCommandLimit(): number;
        getTag(arg0: ResourceLocation_): net.minecraft.tags.Tag<Internal.CommandFunction>;
        get(arg0: ResourceLocation_): Internal.Optional<Internal.CommandFunction>;
        execute(arg0: Internal.CommandFunction_, arg1: Internal.CommandSourceStack_, arg2: Internal.ServerFunctionManager$TraceCallbacks_): number;
        tick(): void;
        get functionNames(): Internal.Iterable<ResourceLocation>
        get tagNames(): Internal.Iterable<ResourceLocation>
        get dispatcher(): Internal.CommandDispatcher<Internal.CommandSourceStack>
        get gameLoopSender(): Internal.CommandSourceStack
        get commandLimit(): number
    }
    type ServerFunctionManager_ = ServerFunctionManager;
    interface BlockEntityRenderer <T> {
        getViewDistance(): number;
        render(arg0: T, arg1: number, arg2: Internal.PoseStack_, arg3: Internal.MultiBufferSource_, arg4: number, arg5: number): void;
        shouldRender(arg0: T, arg1: Vec3_): boolean;
        shouldRenderOffScreen(arg0: T): boolean;
        get viewDistance(): number
    }
    type BlockEntityRenderer_<T> = BlockEntityRenderer<T>;
    class AttributeSupplier$Builder {
        constructor()
        constructor(arg0: Internal.AttributeSupplier_)
        hasAttribute(arg0: Internal.Attribute_): boolean;
        add(arg0: Internal.Attribute_, arg1: number): this;
        build(): Internal.AttributeSupplier;
        combine(arg0: Internal.AttributeSupplier$Builder_): void;
        add(arg0: Internal.Attribute_): this;
    }
    type AttributeSupplier$Builder_ = AttributeSupplier$Builder;
    interface FloatIterator extends Internal.PrimitiveIterator<number, Internal.FloatConsumer> {
        forEachRemaining(arg0: any): void;
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): any;
        forEachRemaining(arg0: Internal.FloatConsumer_): void;
        skip(arg0: number): number;
        nextFloat(): number;
        forEachRemaining(arg0: Internal.DoubleConsumer_): void;
    }
    type FloatIterator_ = FloatIterator;
    class BiasedToBottomHeight extends Internal.HeightProvider {
        toString(): string;
        sample(arg0: Internal.Random_, arg1: Internal.WorldGenerationContext_): number;
        static of(arg0: Internal.VerticalAnchor_, arg1: Internal.VerticalAnchor_, arg2: number): Internal.BiasedToBottomHeight;
        getType(): Internal.HeightProviderType<any>;
        get type(): Internal.HeightProviderType<any>
        readonly static "CODEC": any;
    }
    type BiasedToBottomHeight_ = BiasedToBottomHeight;
    class ChannelOutboundBuffer {
        isWritable(): boolean;
        remove(): boolean;
        forEachFlushedMessage(arg0: Internal.ChannelOutboundBuffer$MessageProcessor_): void;
        totalPendingWriteBytes(): number;
        bytesBeforeUnwritable(): number;
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        isEmpty(): boolean;
        addMessage(arg0: any, arg1: number, arg2: Internal.ChannelPromise_): void;
        progress(arg0: number): void;
        removeBytes(arg0: number): void;
        nioBufferCount(): number;
        setUserDefinedWritability(arg0: number, arg1: boolean): void;
        nioBuffers(): Internal.ByteBuffer[];
        currentProgress(): number;
        size(): number;
        recycle(): void;
        current(): any;
        nioBufferSize(): number;
        addFlush(): void;
        bytesBeforeWritable(): number;
        remove(arg0: Internal.Throwable_): boolean;
        getUserDefinedWritability(arg0: number): boolean;
        get writable(): boolean
        get empty(): boolean
    }
    type ChannelOutboundBuffer_ = ChannelOutboundBuffer;
    interface ParticleProvider <T> {
        createParticle(arg0: T, arg1: Internal.ClientLevel_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): Internal.Particle;
    }
    type ParticleProvider_<T> = ParticleProvider<T>;
    class EnderDragonPart extends Internal.PartEntity<Internal.EnderDragon> {
        constructor(arg0: Internal.EnderDragon_, arg1: string, arg2: number, arg3: number)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        isPickable(): boolean;
        is(arg0: Internal.Entity_): boolean;
        asKJS(): Internal.EntityJS;
        shouldBeSaved(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getAddEntityPacket(): Internal.Packet<any>;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getDimensions(arg0: Internal.Pose_): Internal.EntityDimensions;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        get pickable(): boolean
        get addEntityPacket(): Internal.Packet<any>
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        readonly "name": string;
        readonly "parentMob": Internal.EnderDragon;
    }
    type EnderDragonPart_ = EnderDragonPart;
    abstract class Writer implements Internal.Closeable, Internal.Appendable, Internal.Flushable {
        flush(): void;
        write(arg0: number): void;
        write(arg0: string): void;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): this;
        append(arg0: Internal.CharSequence_): Internal.Appendable;
        close(): void;
        write(arg0: string[]): void;
        write(arg0: string, arg1: number, arg2: number): void;
        write(arg0: string[], arg1: number, arg2: number): void;
        append(arg0: string): this;
        static nullWriter(): Internal.Writer;
    }
    type Writer_ = Writer;
    class Motive extends Internal.ForgeRegistryEntry<Internal.Motive> {
        constructor(arg0: number, arg1: number)
        getWidth(): number;
        getHeight(): number;
        get width(): number
        get height(): number
        readonly static "WANDERER": Internal.Motive;
        readonly static "BOMB": Internal.Motive;
        readonly static "POINTER": Internal.Motive;
        readonly static "POOL": Internal.Motive;
        readonly static "AZTEC2": Internal.Motive;
        readonly static "WASTELAND": Internal.Motive;
        readonly static "PIGSCENE": Internal.Motive;
        readonly static "VOID": Internal.Motive;
        readonly static "GRAHAM": Internal.Motive;
        readonly static "STAGE": Internal.Motive;
        readonly static "KEBAB": Internal.Motive;
        readonly static "WITHER": Internal.Motive;
        readonly static "DONKEY_KONG": Internal.Motive;
        readonly static "AZTEC": Internal.Motive;
        readonly static "BURNING_SKULL": Internal.Motive;
        readonly static "SKELETON": Internal.Motive;
        readonly static "SKULL_AND_ROSES": Internal.Motive;
        readonly static "FIGHTERS": Internal.Motive;
        readonly static "SUNSET": Internal.Motive;
        readonly static "CREEBET": Internal.Motive;
        readonly static "PLANT": Internal.Motive;
        readonly static "BUST": Internal.Motive;
        readonly static "ALBAN": Internal.Motive;
        readonly static "COURBET": Internal.Motive;
        readonly static "SEA": Internal.Motive;
        readonly static "MATCH": Internal.Motive;
    }
    type Motive_ = Motive | Special.Motive;
    class WorldgenAddEventJS extends Internal.StartupEventJS {
        constructor()
        static getAnchors(): Internal.ClassWrapper<Internal.VerticalAnchor>;
        addOre(p: Internal.Consumer_<Internal.AddOreProperties_>): void;
        addLake(p: Internal.Consumer_<Internal.AddLakeProperties_>): void;
        addSpawn(filter: Internal.BiomeFilter_, category: Internal.MobCategory_, spawn: string): void;
        addSpawn(category: Internal.MobCategory_, spawn: string): void;
        addSpawn(p: Internal.Consumer_<Internal.AddSpawnProperties_>): void;
        addFeatureJson(filter: Internal.BiomeFilter_, id: ResourceLocation_, json: Internal.JsonObject_): void;
        addFeatureJson(filter: Internal.BiomeFilter_, json: Internal.JsonObject_): void;
        get anchors(): Internal.ClassWrapper<Internal.VerticalAnchor>
    }
    type WorldgenAddEventJS_ = WorldgenAddEventJS;
    class MobSpawnSettings$MobSpawnCost {
        getCharge(): number;
        getEnergyBudget(): number;
        get charge(): number
        get energyBudget(): number
        readonly static "CODEC": any;
    }
    type MobSpawnSettings$MobSpawnCost_ = MobSpawnSettings$MobSpawnCost;
    class ClientboundTakeItemEntityPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: number, arg2: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getItemId(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getPlayerId(): number;
        getAmount(): number;
        isSkippable(): boolean;
        get itemId(): number
        get playerId(): number
        get amount(): number
        get skippable(): boolean
    }
    type ClientboundTakeItemEntityPacket_ = ClientboundTakeItemEntityPacket;
    class LivingEntityHurtEventJS extends Internal.LivingEntityEventJS {
        constructor(entity: Internal.LivingEntity_, source: Internal.DamageSource_, amount: number)
        getEntity(): Internal.EntityJS;
        canCancel(): boolean;
        getSource(): Internal.DamageSource;
        getDamage(): number;
        get entity(): Internal.EntityJS
        get source(): Internal.DamageSource
        get damage(): number
    }
    type LivingEntityHurtEventJS_ = LivingEntityHurtEventJS;
    interface ContainerListener {
        containerChanged(arg0: Internal.Container_): void;
    }
    type ContainerListener_ = ContainerListener;
    interface Tag {
        getAsString(): string;
        getType(): Internal.TagType<any>;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        toString(): string;
        copy(): this;
        write(arg0: Internal.DataOutput_): void;
        getId(): number;
        accept(arg0: Internal.StreamTagVisitor_): Internal.StreamTagVisitor$ValueResult;
        accept(arg0: Internal.TagVisitor_): void;
        get asString(): string
        get type(): Internal.TagType<any>
        get id(): number
        readonly static "OBJECT_REFERENCE": 32;
        readonly static "TAG_FLOAT": 5;
        readonly static "TAG_BYTE_ARRAY": 7;
        readonly static "OBJECT_HEADER": 64;
        readonly static "TAG_BYTE": 1;
        readonly static "TAG_INT_ARRAY": 11;
        readonly static "TAG_LONG_ARRAY": 12;
        readonly static "TAG_ANY_NUMERIC": 99;
        readonly static "MAX_DEPTH": 512;
        readonly static "TAG_LIST": 9;
        readonly static "STRING_SIZE": 224;
        readonly static "TAG_INT": 3;
        readonly static "TAG_SHORT": 2;
        readonly static "TAG_COMPOUND": 10;
        readonly static "TAG_STRING": 8;
        readonly static "TAG_END": 0;
        readonly static "ARRAY_HEADER": 96;
        readonly static "TAG_LONG": 4;
        readonly static "TAG_DOUBLE": 6;
    }
    type Tag_ = Tag;
    class WorldEvent$Save extends Internal.WorldEvent {
        constructor()
        constructor(arg0: Internal.LevelAccessor_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type WorldEvent$Save_ = WorldEvent$Save;
    class Spider extends Internal.Monster {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getMobType(): Internal.MobType;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        canBeAffected(arg0: Internal.MobEffectInstance_): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getPassengersRidingOffset(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        makeStuckInBlock(arg0: Internal.BlockState_, arg1: Vec3_): void;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        setClimbing(arg0: boolean): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        isClimbing(): boolean;
        onClimbable(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get mobType(): Internal.MobType
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get passengersRidingOffset(): number
        set climbing(arg0: boolean)
        get climbing(): boolean
    }
    type Spider_ = Spider;
    class StonecuttingRecipeJS extends Internal.RecipeJS {
        constructor()
        create(args: Internal.ListJS_): void;
        serialize(): void;
        deserialize(): void;
    }
    type StonecuttingRecipeJS_ = StonecuttingRecipeJS;
    abstract class IdScriptableObject extends Internal.ScriptableObject implements Internal.IdFunctionCall {
        constructor()
        constructor(scope: Internal.Scriptable_, prototype: Internal.Scriptable_)
        initPrototypeValue(id: number, key: Internal.Symbol_, value: any, attributes: number): void;
        put(key: Internal.Symbol_, start: Internal.Scriptable_, value: any): void;
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void;
        delete(name: string): void;
        getAttributes(key: Internal.Symbol_): number;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        has(name: string, start: Internal.Scriptable_): boolean;
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable_, sealed: boolean): Internal.IdFunctionObject;
        get(name: string, start: Internal.Scriptable_): any;
        delete(key: Internal.Symbol_): void;
        initPrototypeConstructor(f: Internal.IdFunctionObject_): void;
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        defineOwnProperty(cx: Internal.Context_, key: any, desc: Internal.ScriptableObject_): void;
        hasPrototypeMap(): boolean;
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject;
        has(key: Internal.Symbol_, start: Internal.Scriptable_): boolean;
        execIdCall(f: Internal.IdFunctionObject_, cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol_, functionName: string, arity: number): Internal.IdFunctionObject;
        setAttributes(name: string, attributes: number): void;
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject;
        get(key: Internal.Symbol_, start: Internal.Scriptable_): any;
        put(name: string, start: Internal.Scriptable_, value: any): void;
        getAttributes(name: string): number;
        activatePrototypeMap(maxPrototypeId: number): void;
    }
    type IdScriptableObject_ = IdScriptableObject;
    class ItemColors {
        constructor()
        register(arg0: Internal.ItemColor_, ...arg1: Internal.ItemLike_[]): void;
        getColor(arg0: Internal.ItemStack_, arg1: number): number;
        static createDefault(arg0: Internal.BlockColors_): Internal.ItemColors;
    }
    type ItemColors_ = ItemColors;
    class InputEvent$RawMouseEvent extends Internal.InputEvent {
        constructor()
        constructor(arg0: number, arg1: number, arg2: number)
        isCancelable(): boolean;
        getButton(): number;
        getModifiers(): number;
        getListenerList(): Internal.ListenerList;
        getAction(): number;
        get cancelable(): boolean
        get button(): number
        get modifiers(): number
        get listenerList(): Internal.ListenerList
        get action(): number
    }
    type InputEvent$RawMouseEvent_ = InputEvent$RawMouseEvent;
    class PoseStack {
        constructor()
        last(): Internal.PoseStack$Pose;
        mulPose(arg0: Internal.Quaternion_): void;
        pushPose(): void;
        popPose(): void;
        translate(arg0: number, arg1: number, arg2: number): void;
        setIdentity(): void;
        mulPoseMatrix(arg0: Internal.Matrix4f_): void;
        scale(arg0: number, arg1: number, arg2: number): void;
        clear(): boolean;
    }
    type PoseStack_ = PoseStack;
    class RecipeTypeRegistryEventJS extends Internal.EventJS {
        constructor(m: Internal.Map_<ResourceLocation_, Internal.RecipeTypeJS_>)
        registerShapeless(id: ResourceLocation_): void;
        ignore(id: ResourceLocation_): void;
        registerShaped(id: ResourceLocation_): void;
        register(id: ResourceLocation_, f: Internal.Supplier_<Internal.RecipeJS_>): void;
        register(type: Internal.RecipeTypeJS_): void;
    }
    type RecipeTypeRegistryEventJS_ = RecipeTypeRegistryEventJS;
    class ExtendedServerListData {
        constructor(arg0: string, arg1: boolean, arg2: number, arg3: string, arg4: boolean)
        constructor(arg0: string, arg1: boolean, arg2: number, arg3: string)
        "extraReason": string;
        readonly "type": string;
        "numberOfMods": number;
        readonly "truncated": boolean;
        readonly "isCompatible": boolean;
    }
    type ExtendedServerListData_ = ExtendedServerListData;
    interface JsonSerializationContext {
        serialize(arg0: any): Internal.JsonElement;
        serialize(arg0: any, arg1: Internal.Type_): Internal.JsonElement;
    }
    type JsonSerializationContext_ = JsonSerializationContext;
    class Vindicator extends Internal.AbstractIllager {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setCustomName(arg0: Internal.Component_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        isAlliedTo(arg0: Internal.Entity_): boolean;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        getArmPose(): Internal.AbstractIllager$IllagerArmPose;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getCelebrateSound(): Internal.SoundEvent;
        shouldRiderSit(): boolean;
        applyRaidBuffs(arg0: number, arg1: boolean): void;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        set customName(arg0: Internal.Component_)
        get stepHeight(): number
        get armPose(): Internal.AbstractIllager$IllagerArmPose
        get multipartEntity(): boolean
        get celebrateSound(): Internal.SoundEvent
        get parts(): Internal.PartEntity<any>[]
    }
    type Vindicator_ = Vindicator;
    class Fox extends Internal.Animal {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        setIsInterested(arg0: boolean): void;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): this;
        getStepHeight(): number;
        static isPathClear(arg0: Internal.Fox_, arg1: Internal.LivingEntity_): boolean;
        asKJS(): Internal.EntityJS;
        setIsPouncing(arg0: boolean): void;
        isPouncing(): boolean;
        isFood(arg0: Internal.ItemStack_): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setSitting(arg0: boolean): void;
        isSleeping(): boolean;
        canRiderInteract(): boolean;
        setTarget(arg0: Internal.LivingEntity_): void;
        getCrouchAmount(arg0: number): number;
        isJumping(): boolean;
        isMultipartEntity(): boolean;
        isInterested(): boolean;
        getEatingSound(arg0: Internal.ItemStack_): Internal.SoundEvent;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        isFullyCrouched(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        canTakeItem(arg0: Internal.ItemStack_): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        setIsCrouching(arg0: boolean): void;
        isCrouching(): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        playAmbientSound(): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        canHoldItem(arg0: Internal.ItemStack_): boolean;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        getFoxType(): Internal.Fox$Type;
        getHeadRollAngle(arg0: number): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        isSitting(): boolean;
        isFaceplanted(): boolean;
        getLeashOffset(): Vec3;
        getClassification(arg0: boolean): Internal.MobCategory;
        static checkFoxSpawnRules(arg0: Internal.EntityType_<Internal.Fox_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        set isInterested(arg0: boolean)
        get stepHeight(): number
        set isPouncing(arg0: boolean)
        get pouncing(): boolean
        set sitting(arg0: boolean)
        get sleeping(): boolean
        set target(arg0: Internal.LivingEntity_)
        get jumping(): boolean
        get multipartEntity(): boolean
        get interested(): boolean
        get fullyCrouched(): boolean
        get parts(): Internal.PartEntity<any>[]
        set isCrouching(arg0: boolean)
        get crouching(): boolean
        get foxType(): Internal.Fox$Type
        get sitting(): boolean
        get faceplanted(): boolean
        get leashOffset(): Vec3
        readonly static "FLAG_POUNCING": 16;
        readonly static "FLAG_CROUCHING": 4;
        readonly static "FLAG_INTERESTED": 8;
    }
    type Fox_ = Fox;
    class SimpleStateProvider extends Internal.BlockStateProvider {
        getState(arg0: Internal.Random_, arg1: BlockPos_): Internal.BlockState;
        readonly static "CODEC": any;
    }
    type SimpleStateProvider_ = SimpleStateProvider;
    interface Long2BooleanFunction extends it.unimi.dsi.fastutil.Function<number, boolean>, Internal.LongPredicate {
        remove(arg0: number): boolean;
        put(arg0: number, arg1: boolean): boolean;
        composeReference(arg0: Internal.Reference2LongFunction_<any>): Internal.Reference2BooleanFunction<T>;
        test(arg0: number): boolean;
        getOrDefault(arg0: any, arg1: any): any;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2BooleanFunction;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Long2LongFunction;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2BooleanFunction;
        containsKey(arg0: any): boolean;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Long2CharFunction;
        composeObject(arg0: Internal.Object2LongFunction_<any>): Internal.Object2BooleanFunction<T>;
        or(arg0: Internal.LongPredicate_): Internal.LongPredicate;
        get(arg0: any): boolean;
        apply(arg0: number): boolean;
        andThenReference(arg0: Internal.Boolean2ReferenceFunction_<any>): Internal.Long2ReferenceFunction<T>;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Long2FloatFunction;
        put(arg0: any, arg1: any): any;
        get(arg0: number): boolean;
        and(arg0: Internal.LongPredicate_): Internal.LongPredicate;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Long2ByteFunction;
        defaultReturnValue(): boolean;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        negate(): Internal.LongPredicate;
        composeLong(arg0: Internal.Long2LongFunction_): this;
        getOrDefault(arg0: any, arg1: boolean): boolean;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2BooleanFunction;
        andThenObject(arg0: Internal.Boolean2ObjectFunction_<any>): Internal.Long2ObjectFunction<T>;
        containsKey(arg0: number): boolean;
        getOrDefault(arg0: number, arg1: boolean): boolean;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2BooleanFunction;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Long2ShortFunction;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Long2DoubleFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, boolean>;
        put(arg0: number, arg1: boolean): boolean;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Long2IntFunction;
        size(): number;
        clear(): void;
        remove(arg0: any): any;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2BooleanFunction;
        defaultReturnValue(arg0: boolean): void;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2BooleanFunction;
    }
    type Long2BooleanFunction_ = Long2BooleanFunction | ((arg0: number)=>boolean);
    class Blaze extends Internal.Monster {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        deserializeNBT(arg0: Internal.Tag_): void;
        aiStep(): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getBrightness(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        isSensitiveToWater(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        isOnFire(): boolean;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get brightness(): number
        get stepHeight(): number
        get sensitiveToWater(): boolean
        get multipartEntity(): boolean
        get onFire(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type Blaze_ = Blaze;
    class BlockSnapshot {
        restore(arg0: boolean): boolean;
        getCurrentBlock(): Internal.BlockState;
        toString(): string;
        getFlag(): number;
        restoreToLocation(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: boolean, arg3: boolean): boolean;
        restore(): boolean;
        getPos(): BlockPos;
        hashCode(): number;
        restore(arg0: boolean, arg1: boolean): boolean;
        getBlockEntity(): Internal.BlockEntity;
        static create(arg0: Internal.ResourceKey_<Internal.Level_>, arg1: Internal.LevelAccessor_, arg2: BlockPos_, arg3: number): Internal.BlockSnapshot;
        getTag(): Internal.CompoundTag;
        getReplacedBlock(): Internal.BlockState;
        equals(arg0: any): boolean;
        getLevel(): Internal.LevelAccessor;
        static create(arg0: Internal.ResourceKey_<Internal.Level_>, arg1: Internal.LevelAccessor_, arg2: BlockPos_): Internal.BlockSnapshot;
        get currentBlock(): Internal.BlockState
        get flag(): number
        get pos(): BlockPos
        get blockEntity(): Internal.BlockEntity
        get tag(): Internal.CompoundTag
        get replacedBlock(): Internal.BlockState
        get level(): Internal.LevelAccessor
    }
    type BlockSnapshot_ = BlockSnapshot;
    interface SetMultimap <K, V> extends Internal.Multimap<K, V> {
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        removeAll(arg0: any): Internal.Set<V>;
        entries(): Internal.Collection<any>;
        get(arg0: K): Internal.Set<V>;
        equals(arg0: any): boolean;
        replaceValues(arg0: K, arg1: Internal.Iterable_<any>): Internal.Set<V>;
        asMap(): Internal.Map<K, Internal.Collection<V>>;
    }
    type SetMultimap_<K, V> = SetMultimap<K, V>;
    class LivingHurtEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.LivingEntity_, arg1: Internal.DamageSource_, arg2: number)
        isCancelable(): boolean;
        setAmount(arg0: number): void;
        getAmount(): number;
        getListenerList(): Internal.ListenerList;
        getSource(): Internal.DamageSource;
        get cancelable(): boolean
        set amount(arg0: number)
        get amount(): number
        get listenerList(): Internal.ListenerList
        get source(): Internal.DamageSource
    }
    type LivingHurtEvent_ = LivingHurtEvent;
    class MethodType implements Internal.Constable, Internal.TypeDescriptor$OfMethod<Internal.Class<any>, Internal.MethodType>, Internal.Serializable {
        appendParameterTypes(arg0: Internal.List_<Internal.Class_<any>>): this;
        describeConstable(): Internal.Optional<Internal.MethodTypeDesc>;
        descriptorString(): string;
        static genericMethodType(arg0: number, arg1: boolean): Internal.MethodType;
        changeParameterType(arg0: number, arg1: Internal.TypeDescriptor$OfField_<any>): Internal.TypeDescriptor$OfMethod<any, any>;
        unwrap(): this;
        appendParameterTypes(...arg0: Internal.Class_<any>[]): this;
        insertParameterTypes(arg0: number, arg1: Internal.List_<Internal.Class_<any>>): this;
        changeReturnType(arg0: Internal.Class_<any>): this;
        generic(): this;
        parameterType(arg0: number): Internal.Class<any>;
        parameterList(): Internal.List<Internal.Class<any>>;
        hasPrimitives(): boolean;
        static genericMethodType(arg0: number): Internal.MethodType;
        toString(): string;
        static methodType(arg0: Internal.Class_<any>, arg1: Internal.List_<Internal.Class_<any>>): Internal.MethodType;
        dropParameterTypes(arg0: number, arg1: number): Internal.TypeDescriptor$OfMethod<any, any>;
        static methodType(arg0: Internal.Class_<any>, arg1: Internal.Class_<any>, ...arg2: Internal.Class_<any>[]): Internal.MethodType;
        parameterCount(): number;
        static methodType(arg0: Internal.Class_<any>, arg1: Internal.MethodType_): Internal.MethodType;
        returnType(): Internal.Class<any>;
        toMethodDescriptorString(): string;
        static fromMethodDescriptorString(arg0: string, arg1: Internal.ClassLoader_): Internal.MethodType;
        insertParameterTypes(arg0: number, arg1: Internal.TypeDescriptor$OfField_<any>[]): Internal.TypeDescriptor$OfMethod<any, any>;
        insertParameterTypes(arg0: number, ...arg1: Internal.Class_<any>[]): this;
        hashCode(): number;
        static methodType(arg0: Internal.Class_<any>): Internal.MethodType;
        wrap(): this;
        changeParameterType(arg0: number, arg1: Internal.Class_<any>): this;
        static methodType(arg0: Internal.Class_<any>, arg1: Internal.Class_<any>): Internal.MethodType;
        erase(): this;
        changeReturnType(arg0: Internal.TypeDescriptor$OfField_<any>): Internal.TypeDescriptor$OfMethod<any, any>;
        lastParameterType(): Internal.Class<any>;
        static methodType(arg0: Internal.Class_<any>, arg1: Internal.Class_<any>[]): Internal.MethodType;
        equals(arg0: any): boolean;
        hasWrappers(): boolean;
        parameterArray(): Internal.Class<any>[];
    }
    type MethodType_ = MethodType;
    interface ChannelConfig {
        setOption(arg0: Internal.ChannelOption_<T>, arg1: T): boolean;
        getRecvByteBufAllocator(): T;
        setWriteBufferLowWaterMark(arg0: number): this;
        getOption(arg0: Internal.ChannelOption_<T>): T;
        isAutoClose(): boolean;
        setAutoRead(arg0: boolean): this;
        isAutoRead(): boolean;
        getMaxMessagesPerRead(): number;
        setAutoClose(arg0: boolean): this;
        setMessageSizeEstimator(arg0: Internal.MessageSizeEstimator_): this;
        setWriteBufferWaterMark(arg0: Internal.WriteBufferWaterMark_): this;
        setWriteSpinCount(arg0: number): this;
        getOptions(): Internal.Map<Internal.ChannelOption<any>, any>;
        setAllocator(arg0: Internal.ByteBufAllocator_): this;
        setRecvByteBufAllocator(arg0: Internal.RecvByteBufAllocator_): this;
        getConnectTimeoutMillis(): number;
        getWriteSpinCount(): number;
        setMaxMessagesPerRead(arg0: number): this;
        setOptions(arg0: Internal.Map_<Internal.ChannelOption_<any>, any>): boolean;
        getMessageSizeEstimator(): Internal.MessageSizeEstimator;
        getWriteBufferHighWaterMark(): number;
        getAllocator(): Internal.ByteBufAllocator;
        getWriteBufferLowWaterMark(): number;
        setWriteBufferHighWaterMark(arg0: number): this;
        setConnectTimeoutMillis(arg0: number): this;
        getWriteBufferWaterMark(): Internal.WriteBufferWaterMark;
        get recvByteBufAllocator(): T
        set writeBufferLowWaterMark(arg0: number)
        get autoClose(): boolean
        set autoRead(arg0: boolean)
        get autoRead(): boolean
        get maxMessagesPerRead(): number
        set autoClose(arg0: boolean)
        set messageSizeEstimator(arg0: Internal.MessageSizeEstimator_)
        set writeBufferWaterMark(arg0: Internal.WriteBufferWaterMark_)
        set writeSpinCount(arg0: number)
        get options(): Internal.Map<Internal.ChannelOption<any>, any>
        set allocator(arg0: Internal.ByteBufAllocator_)
        set recvByteBufAllocator(arg0: Internal.RecvByteBufAllocator_)
        get connectTimeoutMillis(): number
        get writeSpinCount(): number
        set maxMessagesPerRead(arg0: number)
        set options(arg0: Internal.Map_<Internal.ChannelOption_<any>, any>)
        get messageSizeEstimator(): Internal.MessageSizeEstimator
        get writeBufferHighWaterMark(): number
        get allocator(): Internal.ByteBufAllocator
        get writeBufferLowWaterMark(): number
        set writeBufferHighWaterMark(arg0: number)
        set connectTimeoutMillis(arg0: number)
        get writeBufferWaterMark(): Internal.WriteBufferWaterMark
    }
    type ChannelConfig_ = ChannelConfig;
    class KeyMapping implements Internal.Comparable<Internal.KeyMapping>, Internal.IForgeKeyMapping {
        constructor(arg0: string, arg1: Internal.IKeyConflictContext_, arg2: Internal.KeyModifier_, arg3: Internal.InputConstants$Key_, arg4: string)
        constructor(arg0: string, arg1: Internal.IKeyConflictContext_, arg2: Internal.KeyModifier_, arg3: Internal.InputConstants$Type_, arg4: number, arg5: string)
        constructor(arg0: string, arg1: Internal.IKeyConflictContext_, arg2: Internal.InputConstants$Type_, arg3: number, arg4: string)
        constructor(arg0: string, arg1: number, arg2: string)
        constructor(arg0: string, arg1: Internal.InputConstants$Type_, arg2: number, arg3: string)
        constructor(arg0: string, arg1: Internal.IKeyConflictContext_, arg2: Internal.InputConstants$Key_, arg3: string)
        static resetMapping(): void;
        isConflictContextAndModifierActive(): boolean;
        compareTo(arg0: any): number;
        static set(arg0: Internal.InputConstants$Key_, arg1: boolean): void;
        isUnbound(): boolean;
        setKeyConflictContext(arg0: Internal.IKeyConflictContext_): void;
        matchesMouse(arg0: number): boolean;
        static createNameSupplier(arg0: string): Internal.Supplier<Internal.Component>;
        setKeyModifierAndCode(arg0: Internal.KeyModifier_, arg1: Internal.InputConstants$Key_): void;
        getKeyConflictContext(): Internal.IKeyConflictContext;
        saveString(): string;
        getKey(): Internal.InputConstants$Key;
        getName(): string;
        hasKeyModifierConflict(arg0: Internal.KeyMapping_): boolean;
        same(arg0: Internal.KeyMapping_): boolean;
        isActiveAndMatches(arg0: Internal.InputConstants$Key_): boolean;
        static click(arg0: Internal.InputConstants$Key_): void;
        setDown(arg0: boolean): void;
        setToDefault(): void;
        getDefaultKey(): Internal.InputConstants$Key;
        static releaseAll(): void;
        setKey(arg0: Internal.InputConstants$Key_): void;
        getDefaultKeyModifier(): Internal.KeyModifier;
        isDefault(): boolean;
        getKeyModifier(): Internal.KeyModifier;
        compareTo(arg0: Internal.KeyMapping_): number;
        getCategory(): string;
        isDown(): boolean;
        matches(arg0: number, arg1: number): boolean;
        getTranslatedKeyMessage(): Internal.Component;
        static setAll(): void;
        consumeClick(): boolean;
        get conflictContextAndModifierActive(): boolean
        get unbound(): boolean
        set keyConflictContext(arg0: Internal.IKeyConflictContext_)
        get keyConflictContext(): Internal.IKeyConflictContext
        get key(): Internal.InputConstants$Key
        get name(): string
        set down(arg0: boolean)
        get defaultKey(): Internal.InputConstants$Key
        set key(arg0: Internal.InputConstants$Key_)
        get defaultKeyModifier(): Internal.KeyModifier
        get default(): boolean
        get keyModifier(): Internal.KeyModifier
        get category(): string
        get down(): boolean
        get translatedKeyMessage(): Internal.Component
        readonly static "CATEGORY_GAMEPLAY": "key.categories.gameplay";
        readonly static "CATEGORY_MOVEMENT": "key.categories.movement";
        readonly static "CATEGORY_INVENTORY": "key.categories.inventory";
        readonly static "CATEGORY_MISC": "key.categories.misc";
        readonly static "CATEGORY_INTERFACE": "key.categories.ui";
        readonly static "CATEGORY_CREATIVE": "key.categories.creative";
        readonly static "CATEGORY_MULTIPLAYER": "key.categories.multiplayer";
    }
    type KeyMapping_ = KeyMapping;
    class ArmorItemBuilder extends Internal.ItemBuilder {
        modifyTier(callback: Internal.Consumer_<Internal.MutableArmorTier_>): this;
        tier(t: Internal.ArmorMaterial_): this;
        createObject(): any;
        "armorTier": Internal.MutableArmorTier;
        readonly "equipmentSlot": EquipmentSlot;
    }
    type ArmorItemBuilder_ = ArmorItemBuilder;
    interface ParticleOptions$Deserializer <T> {
        fromCommand(arg0: Internal.ParticleType_<T>, arg1: Internal.StringReader_): T;
        fromNetwork(arg0: Internal.ParticleType_<T>, arg1: Internal.FriendlyByteBuf_): T;
    }
    type ParticleOptions$Deserializer_<T> = ParticleOptions$Deserializer<T>;
    class BushFoliagePlacer extends Internal.BlobFoliagePlacer {
        constructor(arg0: Internal.IntProvider_, arg1: Internal.IntProvider_, arg2: number)
        readonly static "CODEC": any;
    }
    type BushFoliagePlacer_ = BushFoliagePlacer;
    class CommandContextBuilder <S> {
        constructor(arg0: Internal.CommandDispatcher_<S>, arg1: S, arg2: Internal.CommandNode_<S>, arg3: number)
        getNodes(): Internal.List<Internal.ParsedCommandNode<S>>;
        withArgument(arg0: string, arg1: Internal.ParsedArgument_<S, any>): this;
        getArguments(): Internal.Map<string, Internal.ParsedArgument<S, any>>;
        copy(): this;
        withChild(arg0: Internal.CommandContextBuilder_<S>): this;
        findSuggestionContext(arg0: number): Internal.SuggestionContext<S>;
        getDispatcher(): Internal.CommandDispatcher<S>;
        withCommand(arg0: Internal.Command_<S>): this;
        getSource(): S;
        withSource(arg0: S): this;
        getRootNode(): Internal.CommandNode<S>;
        withNode(arg0: Internal.CommandNode_<S>, arg1: Internal.StringRange_): this;
        getCommand(): Internal.Command<S>;
        getLastChild(): this;
        getChild(): this;
        getRange(): Internal.StringRange;
        build(arg0: string): Internal.CommandContext<S>;
        get nodes(): Internal.List<Internal.ParsedCommandNode<S>>
        get arguments(): Internal.Map<string, Internal.ParsedArgument<S, any>>
        get dispatcher(): Internal.CommandDispatcher<S>
        get source(): S
        get rootNode(): Internal.CommandNode<S>
        get command(): Internal.Command<S>
        get lastChild(): Internal.CommandContextBuilder<S>
        get child(): Internal.CommandContextBuilder<S>
        get range(): Internal.StringRange
    }
    type CommandContextBuilder_<S> = CommandContextBuilder<S>;
    class BossEvent$BossBarColor extends Internal.Enum<Internal.BossEvent$BossBarColor> {
        getFormatting(): Internal.ChatFormatting;
        static byName(arg0: string): Internal.BossEvent$BossBarColor;
        getName(): string;
        static values(): Internal.BossEvent$BossBarColor[];
        static valueOf(arg0: string): Internal.BossEvent$BossBarColor;
        get formatting(): Internal.ChatFormatting
        get name(): string
        readonly static "PINK": Internal.BossEvent$BossBarColor;
        readonly static "BLUE": Internal.BossEvent$BossBarColor;
        readonly static "RED": Internal.BossEvent$BossBarColor;
        readonly static "PURPLE": Internal.BossEvent$BossBarColor;
        readonly static "WHITE": Internal.BossEvent$BossBarColor;
        readonly static "GREEN": Internal.BossEvent$BossBarColor;
        readonly static "YELLOW": Internal.BossEvent$BossBarColor;
    }
    type BossEvent$BossBarColor_ = "white" | "yellow" | BossEvent$BossBarColor | "red" | "purple" | "pink" | "blue" | "green";
    class DrawSelectionEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.LevelRenderer_, arg1: Internal.Camera_, arg2: Internal.HitResult_, arg3: number, arg4: Internal.PoseStack_, arg5: Internal.MultiBufferSource_)
        getTarget(): Internal.HitResult;
        getPoseStack(): Internal.PoseStack;
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        getCamera(): Internal.Camera;
        getPartialTicks(): number;
        getMultiBufferSource(): Internal.MultiBufferSource;
        getLevelRenderer(): Internal.LevelRenderer;
        get target(): Internal.HitResult
        get poseStack(): Internal.PoseStack
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
        get camera(): Internal.Camera
        get partialTicks(): number
        get multiBufferSource(): Internal.MultiBufferSource
        get levelRenderer(): Internal.LevelRenderer
    }
    type DrawSelectionEvent_ = DrawSelectionEvent;
    abstract class StoredUserList <K, V> {
        constructor(arg0: Internal.File_)
        getFile(): Internal.File;
        getUserList(): string[];
        getEntries(): Internal.Collection<V>;
        remove(arg0: K): void;
        get(arg0: K): V;
        remove(arg0: Internal.StoredUserEntry_<K>): void;
        load(): void;
        isEmpty(): boolean;
        save(): void;
        add(arg0: V): void;
        get file(): Internal.File
        get userList(): string[]
        get entries(): Internal.Collection<V>
        get empty(): boolean
    }
    type StoredUserList_<K, V> = StoredUserList<K, V>;
    interface InjectedItemExtension extends Internal.InjectedRegistryEntryExtension<Internal.Item> {
        arch$registryName(): ResourceLocation;
        arch$holder(): Internal.Holder<Internal.Item>;
    }
    type InjectedItemExtension_ = InjectedItemExtension;
    class PlayerEvent$StopTracking extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.Entity_)
        getTarget(): Internal.Entity;
        getListenerList(): Internal.ListenerList;
        get target(): Internal.Entity
        get listenerList(): Internal.ListenerList
    }
    type PlayerEvent$StopTracking_ = PlayerEvent$StopTracking;
    class BeaconBlockEntity extends Internal.BlockEntity implements Internal.MenuProvider {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        getDisplayName(): Internal.Component;
        static tick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BeaconBlockEntity_): void;
        getModelData(): Internal.IModelData;
        getBeamSections(): Internal.List<Internal.BeaconBlockEntity$BeaconBeamSection>;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getUpdateTag(): Internal.CompoundTag;
        setRemoved(): void;
        setCustomName(arg0: Internal.Component_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        setLevel(arg0: Internal.Level_): void;
        serializeNBT(): Internal.CompoundTag;
        static playSound(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.SoundEvent_): void;
        createMenu(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Player_): Internal.AbstractContainerMenu;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        load(arg0: Internal.CompoundTag_): void;
        getUpdatePacket(): Internal.Packet<any>;
        onLoad(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get displayName(): Internal.Component
        get modelData(): Internal.IModelData
        get beamSections(): Internal.List<Internal.BeaconBlockEntity$BeaconBeamSection>
        get updateTag(): Internal.CompoundTag
        set customName(arg0: Internal.Component_)
        set level(arg0: Internal.Level_)
        get updatePacket(): Internal.Packet<any>
        get renderBoundingBox(): Internal.AABB
        readonly static "DATA_SECONDARY": 2;
        readonly static "NUM_DATA_VALUES": 3;
        readonly static "DATA_PRIMARY": 1;
        readonly static "DATA_LEVELS": 0;
        readonly static "BEACON_EFFECTS": any;
    }
    type BeaconBlockEntity_ = BeaconBlockEntity;
    class EntityModelSet implements Internal.ResourceManagerReloadListener {
        constructor()
        getName(): string;
        onResourceManagerReload(arg0: Internal.ResourceManager_): void;
        bakeLayer(arg0: Internal.ModelLayerLocation_): Internal.ModelPart;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        get name(): string
    }
    type EntityModelSet_ = EntityModelSet;
    interface IForgeBlockGetter {
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
    }
    type IForgeBlockGetter_ = IForgeBlockGetter;
    interface Commands$ParseFunction {
        parse(arg0: Internal.StringReader_): void;
    }
    type Commands$ParseFunction_ = ((arg0: Internal.StringReader)=>void) | Commands$ParseFunction;
    class Pose extends Internal.Enum<Internal.Pose> {
        static valueOf(arg0: string): Internal.Pose;
        static values(): Internal.Pose[];
        readonly static "LONG_JUMPING": Internal.Pose;
        readonly static "FALL_FLYING": Internal.Pose;
        readonly static "SPIN_ATTACK": Internal.Pose;
        readonly static "CROUCHING": Internal.Pose;
        readonly static "STANDING": Internal.Pose;
        readonly static "SWIMMING": Internal.Pose;
        readonly static "DYING": Internal.Pose;
        readonly static "SLEEPING": Internal.Pose;
    }
    type Pose_ = "fall_flying" | "long_jumping" | "dying" | Pose | "spin_attack" | "swimming" | "crouching" | "sleeping" | "standing";
    abstract class StoredUserEntry <T> {
        constructor(arg0: T)
    }
    type StoredUserEntry_<T> = StoredUserEntry<T>;
    interface Char2CharFunction extends Internal.IntUnaryOperator, it.unimi.dsi.fastutil.Function<string, string> {
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Char2FloatFunction;
        getOrDefault(arg0: any, arg1: string): string;
        remove(arg0: string): string;
        getOrDefault(arg0: any, arg1: any): any;
        defaultReturnValue(): string;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Char2ByteFunction;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: string, arg1: string): string;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Char2IntFunction;
        andThenReference(arg0: Internal.Char2ReferenceFunction_<any>): Internal.Char2ReferenceFunction<T>;
        remove(arg0: any): string;
        containsKey(arg0: string): boolean;
        containsKey(arg0: any): boolean;
        getOrDefault(arg0: string, arg1: string): string;
        andThenObject(arg0: Internal.Char2ObjectFunction_<any>): Internal.Char2ObjectFunction<T>;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Char2LongFunction;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeChar(arg0: Internal.Char2CharFunction_): this;
        defaultReturnValue(arg0: string): void;
        applyAsInt(arg0: number): number;
        composeObject(arg0: Internal.Object2CharFunction_<any>): Internal.Object2CharFunction<T>;
        put(arg0: any, arg1: any): any;
        composeReference(arg0: Internal.Reference2CharFunction_<any>): Internal.Reference2CharFunction<T>;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2CharFunction;
        andThenChar(arg0: Internal.Char2CharFunction_): this;
        put(arg0: string, arg1: string): string;
        apply(arg0: string): string;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2CharFunction;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2CharFunction;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Char2ShortFunction;
        size(): number;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2CharFunction;
        identity(): this;
        clear(): void;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2CharFunction;
        get(arg0: string): string;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, string>;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2CharFunction;
        get(arg0: any): any;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<string, T>;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Char2DoubleFunction;
    }
    type Char2CharFunction_ = ((arg0: string)=>string) | Char2CharFunction;
    class JukeboxBlockEntity extends Internal.BlockEntity implements Internal.Clearable {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        getRecord(): Internal.ItemStack;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        serializeNBT(): Internal.CompoundTag;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        load(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        setRecord(arg0: Internal.ItemStack_): void;
        clearContent(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get modelData(): Internal.IModelData
        get record(): Internal.ItemStack
        set record(arg0: Internal.ItemStack_)
        get renderBoundingBox(): Internal.AABB
    }
    type JukeboxBlockEntity_ = JukeboxBlockEntity;
    class RequiredArgumentBuilder <S, T> extends Internal.ArgumentBuilder<S, Internal.RequiredArgumentBuilder<S, T>> {
        getType(): Internal.ArgumentType<T>;
        getName(): string;
        static argument(arg0: string, arg1: Internal.ArgumentType_<T>): Internal.RequiredArgumentBuilder<S, T>;
        build(): Internal.ArgumentCommandNode<S, T>;
        suggests(arg0: Internal.SuggestionProvider_<S>): this;
        getSuggestionsProvider(): Internal.SuggestionProvider<S>;
        get type(): Internal.ArgumentType<T>
        get name(): string
        get suggestionsProvider(): Internal.SuggestionProvider<S>
    }
    type RequiredArgumentBuilder_<S, T> = RequiredArgumentBuilder<S, T>;
    class ReplaceablePredicate extends Internal.StateTestingPredicate {
        constructor(arg0: Vec3i_)
        type(): Internal.BlockPredicateType<any>;
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        negate(): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        readonly static "CODEC": Internal.Codec<Internal.ReplaceablePredicate>;
    }
    type ReplaceablePredicate_ = ReplaceablePredicate;
    interface IForgeMobEffect {
        getCurativeItems(): Internal.List<Internal.ItemStack>;
        getSortOrder(arg0: Internal.MobEffectInstance_): number;
        get curativeItems(): Internal.List<Internal.ItemStack>
    }
    type IForgeMobEffect_ = IForgeMobEffect;
    class RegistryObjectBuilderTypes$BuilderType <T> extends Internal.Record {
        constructor(type: string, builderClass: Internal.Class_<any>, factory: Internal.RegistryObjectBuilderTypes$BuilderFactory_<T>)
        hashCode(): number;
        type(): string;
        toString(): string;
        factory(): Internal.RegistryObjectBuilderTypes$BuilderFactory<T>;
        builderClass(): Internal.Class<any>;
        equals(o: any): boolean;
    }
    type RegistryObjectBuilderTypes$BuilderType_<T> = RegistryObjectBuilderTypes$BuilderType<T>;
    interface CropBlockBuilder$SurviveCallback {
        survive(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): boolean;
    }
    type CropBlockBuilder$SurviveCallback_ = CropBlockBuilder$SurviveCallback | ((arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos)=>boolean);
    class NarratorStatus extends Internal.Enum<Internal.NarratorStatus> {
        static valueOf(arg0: string): Internal.NarratorStatus;
        getName(): Internal.Component;
        static byId(arg0: number): Internal.NarratorStatus;
        static values(): Internal.NarratorStatus[];
        getId(): number;
        get name(): Internal.Component
        get id(): number
        readonly static "SYSTEM": Internal.NarratorStatus;
        readonly static "ALL": Internal.NarratorStatus;
        readonly static "CHAT": Internal.NarratorStatus;
        readonly static "OFF": Internal.NarratorStatus;
    }
    type NarratorStatus_ = "chat" | NarratorStatus | "off" | "system" | "all";
    class UniformInt extends Internal.IntProvider {
        getMinValue(): number;
        getType(): Internal.IntProviderType<any>;
        toString(): string;
        getMaxValue(): number;
        sample(arg0: Internal.Random_): number;
        static of(arg0: number, arg1: number): Internal.UniformInt;
        get minValue(): number
        get type(): Internal.IntProviderType<any>
        get maxValue(): number
        readonly static "CODEC": any;
    }
    type UniformInt_ = UniformInt;
    interface FormattedText {
        of(arg0: string, arg1: Internal.Style_): this;
        composite(...arg0: Internal.FormattedText_[]): this;
        visit(arg0: Internal.FormattedText$StyledContentConsumer_<T>, arg1: Internal.Style_): Internal.Optional<T>;
        of(arg0: string): this;
        visit(arg0: Internal.FormattedText$ContentConsumer_<T>): Internal.Optional<T>;
        composite(arg0: Internal.List_<any>): this;
        getString(): string;
        get string(): string
        readonly static "EMPTY": any;
        readonly static "STOP_ITERATION": Internal.Optional<any>;
    }
    type FormattedText_ = FormattedText;
    class EndTag implements Internal.Tag {
        getAsString(): string;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        toString(): string;
        copy(): Internal.Tag;
        write(arg0: Internal.DataOutput_): void;
        getId(): number;
        accept(arg0: Internal.StreamTagVisitor_): Internal.StreamTagVisitor$ValueResult;
        getType(): Internal.TagType<Internal.EndTag>;
        accept(arg0: Internal.TagVisitor_): void;
        get asString(): string
        get id(): number
        get type(): Internal.TagType<Internal.EndTag>
        readonly static "INSTANCE": Internal.EndTag;
        readonly static "TYPE": any;
    }
    type EndTag_ = EndTag;
    interface FormattedCharSequence {
        codepoint(arg0: number, arg1: Internal.Style_): this;
        fromPair(arg0: Internal.FormattedCharSequence_, arg1: Internal.FormattedCharSequence_): this;
        forward(arg0: string, arg1: Internal.Style_): this;
        forward(arg0: string, arg1: Internal.Style_, arg2: Internal.Int2IntFunction_): this;
        decorateOutput(arg0: Internal.FormattedCharSink_, arg1: Internal.Int2IntFunction_): Internal.FormattedCharSink;
        composite(arg0: Internal.List_<Internal.FormattedCharSequence_>): this;
        composite(arg0: Internal.FormattedCharSequence_): this;
        composite(...arg0: Internal.FormattedCharSequence_[]): this;
        accept(arg0: Internal.FormattedCharSink_): boolean;
        backward(arg0: string, arg1: Internal.Style_): this;
        composite(arg0: Internal.FormattedCharSequence_, arg1: Internal.FormattedCharSequence_): this;
        fromList(arg0: Internal.List_<Internal.FormattedCharSequence_>): this;
        composite(): this;
        backward(arg0: string, arg1: Internal.Style_, arg2: Internal.Int2IntFunction_): this;
        readonly static "EMPTY": any;
    }
    type FormattedCharSequence_ = FormattedCharSequence | ((arg0: Internal.FormattedCharSink)=>boolean);
    interface LootItemFunction$Builder {
        build(): Internal.LootItemFunction;
    }
    type LootItemFunction$Builder_ = LootItemFunction$Builder;
    interface VertexConsumer extends Internal.IForgeVertexConsumer {
        uv2(arg0: number): this;
        color(arg0: number, arg1: number, arg2: number, arg3: number): this;
        endVertex(): void;
        color(arg0: number): this;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void;
        normal(arg0: number, arg1: number, arg2: number): this;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void;
        overlayCoords(arg0: number): this;
        vertex(arg0: number, arg1: number, arg2: number): this;
        color(arg0: number, arg1: number, arg2: number, arg3: number): this;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number[], arg7: number, arg8: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
        overlayCoords(arg0: number, arg1: number): this;
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer_): number;
        applyBakedNormals(arg0: Internal.Vector3f_, arg1: Internal.ByteBuffer_, arg2: Internal.Matrix3f_): void;
        normal(arg0: Internal.Matrix3f_, arg1: number, arg2: number, arg3: number): this;
        defaultColor(arg0: number, arg1: number, arg2: number, arg3: number): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        uv2(arg0: number, arg1: number): this;
        vertex(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number, arg11: number, arg12: number, arg13: number): void;
        getVertexFormat(): Internal.VertexFormat;
        vertex(arg0: Internal.Matrix4f_, arg1: number, arg2: number, arg3: number): this;
        uv(arg0: number, arg1: number): this;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void;
        unsetDefaultColor(): void;
        get vertexFormat(): Internal.VertexFormat
    }
    type VertexConsumer_ = VertexConsumer;
    class CaveCarverConfiguration extends Internal.CarverConfiguration {
        constructor(arg0: number, arg1: Internal.HeightProvider_, arg2: Internal.FloatProvider_, arg3: Internal.VerticalAnchor_, arg4: boolean, arg5: Internal.FloatProvider_, arg6: Internal.FloatProvider_, arg7: Internal.FloatProvider_)
        constructor(arg0: number, arg1: Internal.HeightProvider_, arg2: Internal.FloatProvider_, arg3: Internal.VerticalAnchor_, arg4: Internal.CarverDebugSettings_, arg5: Internal.FloatProvider_, arg6: Internal.FloatProvider_, arg7: Internal.FloatProvider_)
        constructor(arg0: Internal.CarverConfiguration_, arg1: Internal.FloatProvider_, arg2: Internal.FloatProvider_, arg3: Internal.FloatProvider_)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "horizontalRadiusMultiplier": Internal.FloatProvider;
        readonly "verticalRadiusMultiplier": Internal.FloatProvider;
        readonly static "CODEC": any;
    }
    type CaveCarverConfiguration_ = CaveCarverConfiguration;
    class HolderSet$Named <T> extends Internal.HolderSet$ListBacked<T> {
        constructor(arg0: Internal.Registry_<T>, arg1: Internal.TagKey_<T>)
        isValidInRegistry(arg0: Internal.Registry_<T>): boolean;
        unwrap(): Internal.Either<Internal.TagKey<T>, Internal.List<Internal.Holder<T>>>;
        contains(arg0: Internal.Holder_<T>): boolean;
        toString(): string;
        forEach(arg0: Internal.Consumer_<any>): void;
        bind(arg0: Internal.List_<Internal.Holder_<T>>): void;
        key(): Internal.TagKey<T>;
    }
    type HolderSet$Named_<T> = HolderSet$Named<T>;
    class SeagrassFeature extends Internal.Feature<Internal.ProbabilityFeatureConfiguration> {
        constructor(arg0: Internal.Codec_<Internal.ProbabilityFeatureConfiguration_>)
        place(arg0: Internal.FeaturePlaceContext_<Internal.ProbabilityFeatureConfiguration_>): boolean;
    }
    type SeagrassFeature_ = SeagrassFeature;
    interface LayerLightEventListener extends Internal.LightEventListener {
        getDataLayerData(arg0: Internal.SectionPos_): Internal.DataLayer;
        getLightValue(arg0: BlockPos_): number;
        updateSectionStatus(arg0: BlockPos_, arg1: boolean): void;
    }
    type LayerLightEventListener_ = LayerLightEventListener;
    class PainterUpdatedEventJS extends Internal.ClientEventJS {
        constructor()
    }
    type PainterUpdatedEventJS_ = PainterUpdatedEventJS;
    interface LightEventListener {
        checkBlock(arg0: BlockPos_): void;
        runUpdates(arg0: number, arg1: boolean, arg2: boolean): number;
        updateSectionStatus(arg0: BlockPos_, arg1: boolean): void;
        hasLightWork(): boolean;
        enableLightSources(arg0: Internal.ChunkPos_, arg1: boolean): void;
        onBlockEmissionIncrease(arg0: BlockPos_, arg1: number): void;
        updateSectionStatus(arg0: Internal.SectionPos_, arg1: boolean): void;
    }
    type LightEventListener_ = LightEventListener;
    class ShapelessRecipeJS extends Internal.RecipeJS {
        constructor()
        create(args: Internal.ListJS_): void;
        serialize(): void;
        deserialize(): void;
    }
    type ShapelessRecipeJS_ = ShapelessRecipeJS;
    class RecordCodecBuilder$Mu <O> implements Internal.K1 {
        constructor()
    }
    type RecordCodecBuilder$Mu_<O> = RecordCodecBuilder$Mu<O>;
    class RenderGameOverlayEvent$Post extends Internal.RenderGameOverlayEvent {
        constructor()
        constructor(arg0: Internal.PoseStack_, arg1: Internal.RenderGameOverlayEvent_, arg2: Internal.RenderGameOverlayEvent$ElementType_)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type RenderGameOverlayEvent$Post_ = RenderGameOverlayEvent$Post;
    class EpollEventLoopGroup extends Internal.MultithreadEventLoopGroup {
        constructor()
        constructor(arg0: number, arg1: any_, arg2: number)
        constructor(arg0: number)
        constructor(arg0: number, arg1: any_, arg2: any_)
        constructor(arg0: number, arg1: Internal.Executor_, arg2: any_, arg3: any_, arg4: any_)
        constructor(arg0: any_)
        constructor(arg0: number, arg1: Internal.Executor_, arg2: any_, arg3: any_, arg4: any_, arg5: any_)
        constructor(arg0: number, arg1: Internal.Executor_, arg2: any_, arg3: any_)
        constructor(arg0: number, arg1: Internal.Executor_, arg2: any_)
        constructor(arg0: number, arg1: any_, arg2: number, arg3: any_)
        constructor(arg0: number, arg1: Internal.Executor_, arg2: any_, arg3: any_, arg4: any_, arg5: any_, arg6: any_)
        constructor(arg0: number, arg1: Internal.Executor_)
        constructor(arg0: number, arg1: any_)
        constructor(arg0: number, arg1: any_)
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        setIoRatio(arg0: number): void;
        set ioRatio(arg0: number)
    }
    type EpollEventLoopGroup_ = EpollEventLoopGroup;
    class GenericEvent <T> extends Internal.Event implements Internal.IGenericEvent<T> {
        constructor()
        getGenericType(): Internal.Type;
        get genericType(): Internal.Type
    }
    type GenericEvent_<T> = GenericEvent<T>;
    class ConfiguredWorldCarver <WC> extends Internal.Record {
        constructor(arg0: Internal.WorldCarver_<WC>, arg1: WC)
        hashCode(): number;
        toString(): string;
        worldCarver(): Internal.WorldCarver<WC>;
        config(): WC;
        carve(arg0: Internal.CarvingContext_, arg1: Internal.ChunkAccess_, arg2: Internal.Function_<BlockPos_, Internal.Holder_<Internal.Biome_>>, arg3: Internal.Random_, arg4: Internal.Aquifer_, arg5: Internal.ChunkPos_, arg6: Internal.CarvingMask_): boolean;
        equals(arg0: any): boolean;
        isStartChunk(arg0: Internal.Random_): boolean;
        readonly static "DIRECT_CODEC": any;
        readonly static "CODEC": any;
        readonly static "LIST_CODEC": any;
    }
    type ConfiguredWorldCarver_<WC> = Special.ConfiguredWorldCarver | ConfiguredWorldCarver<WC>;
    class ChannelMetadata {
        constructor(arg0: boolean, arg1: number)
        constructor(arg0: boolean)
        hasDisconnect(): boolean;
        defaultMaxMessagesPerRead(): number;
    }
    type ChannelMetadata_ = ChannelMetadata;
    class DispenserBlockEntity extends Internal.RandomizableContainerBlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        stopOpen(arg0: Internal.Player_): void;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getMaxStackSize(): number;
        countItem(arg0: Internal.Item_): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        getRandomSlot(): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        load(arg0: Internal.CompoundTag_): void;
        addItem(arg0: Internal.ItemStack_): number;
        onLoad(): void;
        getContainerSize(): number;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get modelData(): Internal.IModelData
        get maxStackSize(): number
        get randomSlot(): number
        get containerSize(): number
        get renderBoundingBox(): Internal.AABB
        readonly static "CONTAINER_SIZE": 9;
    }
    type DispenserBlockEntity_ = DispenserBlockEntity;
    class EffectInstance implements Internal.Effect, Internal.AutoCloseable {
        constructor(arg0: Internal.ResourceManager_, arg1: string)
        markDirty(): void;
        static getOrCreate(arg0: Internal.ResourceManager_, arg1: Internal.Program$Type_, arg2: string): Internal.EffectProgram;
        static parseBlendNode(arg0: Internal.JsonObject_): Internal.BlendMode;
        attachToProgram(): void;
        getVertexProgram(): Internal.Program;
        apply(): void;
        getFragmentProgram(): Internal.Program;
        getUniform(arg0: string): Internal.Uniform;
        clear(): void;
        getName(): string;
        close(): void;
        safeGetUniform(arg0: string): Internal.AbstractUniform;
        setSampler(arg0: string, arg1: Internal.IntSupplier_): void;
        getId(): number;
        get vertexProgram(): Internal.Program
        get fragmentProgram(): Internal.Program
        get name(): string
        get id(): number
    }
    type EffectInstance_ = EffectInstance;
    interface ScatteringByteChannel extends Internal.ReadableByteChannel {
        read(arg0: Internal.ByteBuffer_[], arg1: number, arg2: number): number;
        read(arg0: Internal.ByteBuffer_[]): number;
    }
    type ScatteringByteChannel_ = ScatteringByteChannel;
    class SlabType extends Internal.Enum<Internal.SlabType> implements Internal.StringRepresentable {
        toString(): string;
        static values(): Internal.SlabType[];
        getSerializedName(): string;
        static valueOf(arg0: string): Internal.SlabType;
        get serializedName(): string
        readonly static "TOP": Internal.SlabType;
        readonly static "DOUBLE": Internal.SlabType;
        readonly static "BOTTOM": Internal.SlabType;
    }
    type SlabType_ = "double" | SlabType | "bottom" | "top";
    interface WatchEvent <T> {
        context(): T;
        count(): number;
        kind(): Internal.WatchEvent$Kind<T>;
    }
    type WatchEvent_<T> = WatchEvent<T>;
    interface LootItemCondition extends Internal.Predicate<Internal.LootContext>, Internal.LootContextUser {
        negate(): Internal.Predicate<Internal.LootContext>;
        getReferencedContextParams(): Internal.Set<Internal.LootContextParam<any>>;
        or(arg0: Internal.Predicate_<any>): Internal.Predicate<Internal.LootContext>;
        and(arg0: Internal.Predicate_<any>): Internal.Predicate<Internal.LootContext>;
        getType(): Internal.LootItemConditionType;
        validate(arg0: Internal.ValidationContext_): void;
        get referencedContextParams(): Internal.Set<Internal.LootContextParam<any>>
        get type(): Internal.LootItemConditionType
    }
    type LootItemCondition_ = (()=>Internal.LootItemConditionType_) | LootItemCondition;
    class TickPriority extends Internal.Enum<Internal.TickPriority> {
        static valueOf(arg0: string): Internal.TickPriority;
        getValue(): number;
        static byValue(arg0: number): Internal.TickPriority;
        static values(): Internal.TickPriority[];
        get value(): number
        readonly static "NORMAL": Internal.TickPriority;
        readonly static "EXTREMELY_LOW": Internal.TickPriority;
        readonly static "VERY_HIGH": Internal.TickPriority;
        readonly static "LOW": Internal.TickPriority;
        readonly static "HIGH": Internal.TickPriority;
        readonly static "EXTREMELY_HIGH": Internal.TickPriority;
        readonly static "VERY_LOW": Internal.TickPriority;
    }
    type TickPriority_ = "normal" | "high" | "extremely_high" | "very_high" | "low" | "very_low" | "extremely_low" | TickPriority;
    class ClientboundPlayerPositionPacket$RelativeArgument extends Internal.Enum<Internal.ClientboundPlayerPositionPacket$RelativeArgument> {
        static valueOf(arg0: string): Internal.ClientboundPlayerPositionPacket$RelativeArgument;
        static unpack(arg0: number): Internal.Set<Internal.ClientboundPlayerPositionPacket$RelativeArgument>;
        static values(): Internal.ClientboundPlayerPositionPacket$RelativeArgument[];
        static pack(arg0: Internal.Set_<Internal.ClientboundPlayerPositionPacket$RelativeArgument_>): number;
        readonly static "Y": Internal.ClientboundPlayerPositionPacket$RelativeArgument;
        readonly static "Z": Internal.ClientboundPlayerPositionPacket$RelativeArgument;
        readonly static "X": Internal.ClientboundPlayerPositionPacket$RelativeArgument;
        readonly static "Y_ROT": Internal.ClientboundPlayerPositionPacket$RelativeArgument;
        readonly static "X_ROT": Internal.ClientboundPlayerPositionPacket$RelativeArgument;
    }
    type ClientboundPlayerPositionPacket$RelativeArgument_ = "z" | ClientboundPlayerPositionPacket$RelativeArgument | "y" | "x" | "y_rot" | "x_rot";
    class NotPredicate implements net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate {
        constructor(arg0: net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_)
        type(): Internal.BlockPredicateType<any>;
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: any, arg1: any): boolean;
        negate(): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: Internal.WorldGenLevel_, arg1: BlockPos_): boolean;
        readonly static "CODEC": Internal.Codec<Internal.NotPredicate>;
    }
    type NotPredicate_ = NotPredicate;
    class Game implements Internal.RunningGame {
        constructor(arg0: Internal.Minecraft_)
        getPerformanceMetrics(): Internal.PerformanceMetrics;
        setSessionEventListener(arg0: Internal.SessionEventListener_): void;
        getSelectedLanguage(): com.mojang.bridge.game.Language;
        onStartGameSession(): void;
        getCurrentSession(): Internal.GameSession;
        getVersion(): Internal.GameVersion;
        onLeaveGameSession(): void;
        get performanceMetrics(): Internal.PerformanceMetrics
        set sessionEventListener(arg0: Internal.SessionEventListener_)
        get selectedLanguage(): com.mojang.bridge.game.Language
        get currentSession(): Internal.GameSession
        get version(): Internal.GameVersion
    }
    type Game_ = Game;
    interface Reference2BooleanFunction <K> extends it.unimi.dsi.fastutil.Function<K, boolean>, Internal.Predicate<K> {
        test(arg0: K): boolean;
        getOrDefault(arg0: any, arg1: any): any;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Reference2DoubleFunction<K>;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Reference2FloatFunction<K>;
        andThenReference(arg0: Internal.Boolean2ReferenceFunction_<any>): Internal.Reference2ReferenceFunction<K, T>;
        composeReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Reference2BooleanFunction<T>;
        containsKey(arg0: any): boolean;
        removeBoolean(arg0: any): boolean;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2BooleanFunction;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Reference2ByteFunction<K>;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Reference2IntFunction<K>;
        or(arg0: Internal.Predicate_<any>): Internal.Predicate<K>;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Reference2CharFunction<K>;
        put(arg0: any, arg1: any): any;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Reference2ShortFunction<K>;
        apply(arg0: K): boolean;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2BooleanFunction;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2BooleanFunction;
        defaultReturnValue(): boolean;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2BooleanFunction;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2BooleanFunction;
        getOrDefault(arg0: any, arg1: boolean): boolean;
        remove(arg0: any): boolean;
        andThenObject(arg0: Internal.Boolean2ObjectFunction_<any>): Internal.Reference2ObjectFunction<K, T>;
        composeObject(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Object2BooleanFunction<T>;
        getOrDefault(arg0: any, arg1: boolean): boolean;
        put(arg0: K, arg1: boolean): boolean;
        put(arg0: K, arg1: boolean): boolean;
        getBoolean(arg0: any): boolean;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2BooleanFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, boolean>;
        and(arg0: Internal.Predicate_<any>): Internal.Predicate<K>;
        size(): number;
        negate(): Internal.Predicate<K>;
        clear(): void;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2BooleanFunction;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Reference2LongFunction<K>;
        get(arg0: any): any;
        defaultReturnValue(arg0: boolean): void;
    }
    type Reference2BooleanFunction_<K> = ((arg0: any)=>boolean) | Reference2BooleanFunction<K>;
    class PlayerContainerEvent$Close extends Internal.PlayerContainerEvent {
        constructor(arg0: Internal.Player_, arg1: Internal.AbstractContainerMenu_)
        constructor()
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type PlayerContainerEvent$Close_ = PlayerContainerEvent$Close;
    abstract class LivingEntityEventJS extends Internal.EntityEventJS {
        constructor()
    }
    type LivingEntityEventJS_ = LivingEntityEventJS;
    class FOVModifierEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.Player_, arg1: number)
        getListenerList(): Internal.ListenerList;
        getEntity(): Internal.Player;
        setNewfov(arg0: number): void;
        getNewfov(): number;
        getFov(): number;
        get listenerList(): Internal.ListenerList
        get entity(): Internal.Player
        set newfov(arg0: number)
        get newfov(): number
        get fov(): number
    }
    type FOVModifierEvent_ = FOVModifierEvent;
    abstract class AbstractChronology implements Internal.Chronology {
        dateNow(arg0: Internal.ZoneId_): Internal.ChronoLocalDate;
        period(arg0: number, arg1: number, arg2: number): Internal.ChronoPeriod;
        toString(): string;
        epochSecond(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.ZoneOffset_): number;
        localDateTime(arg0: Internal.TemporalAccessor_): Internal.ChronoLocalDateTime<any>;
        zonedDateTime(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.ChronoZonedDateTime<any>;
        dateYearDay(arg0: Internal.Era_, arg1: number, arg2: number): Internal.ChronoLocalDate;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        compareTo(arg0: any): number;
        zonedDateTime(arg0: Internal.TemporalAccessor_): Internal.ChronoZonedDateTime<any>;
        resolveDate(arg0: Internal.Map_<Internal.TemporalField_, number>, arg1: Internal.ResolverStyle_): Internal.ChronoLocalDate;
        hashCode(): number;
        dateNow(arg0: Internal.Clock_): Internal.ChronoLocalDate;
        compareTo(arg0: Internal.Chronology_): number;
        date(arg0: Internal.Era_, arg1: number, arg2: number, arg3: number): Internal.ChronoLocalDate;
        epochSecond(arg0: Internal.Era_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneOffset_): number;
        equals(arg0: any): boolean;
        dateNow(): Internal.ChronoLocalDate;
    }
    type AbstractChronology_ = AbstractChronology;
    class ClientboundPlayerPositionPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.Set_<Internal.ClientboundPlayerPositionPacket$RelativeArgument_>, arg6: number, arg7: boolean)
        handle(arg0: Internal.PacketListener_): void;
        getX(): number;
        getY(): number;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getZ(): number;
        getRelativeArguments(): Internal.Set<Internal.ClientboundPlayerPositionPacket$RelativeArgument>;
        getYRot(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getXRot(): number;
        requestDismountVehicle(): boolean;
        isSkippable(): boolean;
        getId(): number;
        get x(): number
        get y(): number
        get z(): number
        get relativeArguments(): Internal.Set<Internal.ClientboundPlayerPositionPacket$RelativeArgument>
        get YRot(): number
        get XRot(): number
        get skippable(): boolean
        get id(): number
    }
    type ClientboundPlayerPositionPacket_ = ClientboundPlayerPositionPacket;
    abstract class Mob extends Internal.LivingEntity {
        getLookControl(): Internal.LookControl;
        static checkMobSpawnRules(arg0: Internal.EntityType_<any>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        static getEquipmentForSlot(arg0: EquipmentSlot_, arg1: number): Internal.Item;
        isWithinRestriction(arg0: BlockPos_): boolean;
        setTarget(arg0: Internal.LivingEntity_): void;
        getMaxSpawnClusterSize(): number;
        getPathfindingMalus(arg0: Internal.BlockPathTypes_): number;
        setLeashedTo(arg0: Internal.Entity_, arg1: boolean): void;
        canReplaceEqualItem(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getMeleeAttackRangeSqr(arg0: Internal.LivingEntity_): number;
        convertTo(arg0: Internal.EntityType_<T>, arg1: boolean): T;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        dropLeash(arg0: boolean, arg1: boolean): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        clearRestriction(): void;
        isWithinRestriction(): boolean;
        setXxa(arg0: number): void;
        baseTick(): void;
        alwaysAccepts(): boolean;
        setDelayedLeashHolderId(arg0: number): void;
        getPickResult(): Internal.ItemStack;
        foodEatenKJS(is: Internal.ItemStack_): void;
        isAggressive(): boolean;
        setYya(arg0: number): void;
        isLeashed(): boolean;
        setDropChance(arg0: EquipmentSlot_, arg1: number): void;
        asKJS(): Internal.EntityJS;
        setBaby(arg0: boolean): void;
        canRiderInteract(): boolean;
        getMaxHeadYRot(): number;
        getLeashHolder(): Internal.Entity;
        shouldRiderSit(): boolean;
        getSensing(): Internal.Sensing;
        getTarget(): Internal.LivingEntity;
        canTakeItem(arg0: Internal.ItemStack_): boolean;
        restrictTo(arg0: BlockPos_, arg1: number): void;
        canBeLeashed(arg0: Internal.Player_): boolean;
        setPathfindingMalus(arg0: Internal.BlockPathTypes_, arg1: number): void;
        aiStep(): void;
        setAggressive(arg0: boolean): void;
        getLootTable(): ResourceLocation;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        removeFreeWill(): void;
        wantsToPickUp(arg0: Internal.ItemStack_): boolean;
        getItemBySlot(arg0: EquipmentSlot_): Internal.ItemStack;
        getMoveControl(): Internal.MoveControl;
        removeWhenFarAway(arg0: number): boolean;
        equipItemIfPossible(arg0: Internal.ItemStack_): boolean;
        ate(): void;
        getStepHeight(): number;
        getNavigation(): Internal.PathNavigation;
        isControlledByLocalInstance(): boolean;
        setPersistenceRequired(): void;
        isEffectiveAi(): boolean;
        startRiding(arg0: Internal.Entity_, arg1: boolean): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getMainArm(): Internal.HumanoidArm;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        checkSpawnRules(arg0: Internal.LevelAccessor_, arg1: Internal.MobSpawnType_): boolean;
        spawnAnim(): void;
        isMaxGroupSizeReached(arg0: number): boolean;
        setZza(arg0: number): void;
        getMaxHeadXRot(): number;
        playAmbientSound(): void;
        checkDespawn(): void;
        tick(): void;
        lookAt(arg0: Internal.Entity_, arg1: number, arg2: number): void;
        getJumpControl(): Internal.JumpControl;
        setCanPickUpLoot(arg0: boolean): void;
        setNoAi(arg0: boolean): void;
        canAttackType(arg0: Internal.EntityType_<any>): boolean;
        getHandSlots(): Internal.Iterable<Internal.ItemStack>;
        getArmorSlots(): Internal.Iterable<Internal.ItemStack>;
        canPickUpLoot(): boolean;
        interact(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        setLeftHanded(arg0: boolean): void;
        setSpeed(arg0: number): void;
        static createMobAttributes(): Internal.AttributeSupplier$Builder;
        requiresCustomPersistence(): boolean;
        canFireProjectileWeapon(arg0: Internal.ProjectileWeaponItem_): boolean;
        isMultipartEntity(): boolean;
        hasRestriction(): boolean;
        serializeNBT(): Internal.Tag;
        checkSpawnObstruction(arg0: Internal.LevelReader_): boolean;
        getMaxFallDistance(): number;
        getRestrictRadius(): number;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        isNoAi(): boolean;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        getAmbientSoundInterval(): number;
        deserializeNBT(arg0: Internal.Tag_): void;
        canBeControlledByRider(): boolean;
        getRestrictCenter(): BlockPos;
        isLeftHanded(): boolean;
        isPersistenceRequired(): boolean;
        canHoldItem(arg0: Internal.ItemStack_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        canCutCorner(arg0: Internal.BlockPathTypes_): boolean;
        getHeadRotSpeed(): number;
        setItemSlot(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): void;
        setGuaranteedDrop(arg0: EquipmentSlot_): void;
        get lookControl(): Internal.LookControl
        set target(arg0: Internal.LivingEntity_)
        get maxSpawnClusterSize(): number
        get withinRestriction(): boolean
        set xxa(arg0: number)
        set delayedLeashHolderId(arg0: number)
        get pickResult(): Internal.ItemStack
        get aggressive(): boolean
        set yya(arg0: number)
        get leashed(): boolean
        set baby(arg0: boolean)
        get maxHeadYRot(): number
        get leashHolder(): Internal.Entity
        get sensing(): Internal.Sensing
        get target(): Internal.LivingEntity
        set aggressive(arg0: boolean)
        get lootTable(): ResourceLocation
        get moveControl(): Internal.MoveControl
        get stepHeight(): number
        get navigation(): Internal.PathNavigation
        get controlledByLocalInstance(): boolean
        get effectiveAi(): boolean
        get mainArm(): Internal.HumanoidArm
        set zza(arg0: number)
        get maxHeadXRot(): number
        get jumpControl(): Internal.JumpControl
        set canPickUpLoot(arg0: boolean)
        set noAi(arg0: boolean)
        get handSlots(): Internal.Iterable<Internal.ItemStack>
        get armorSlots(): Internal.Iterable<Internal.ItemStack>
        set leftHanded(arg0: boolean)
        set speed(arg0: number)
        get multipartEntity(): boolean
        get maxFallDistance(): number
        get restrictRadius(): number
        get parts(): Internal.PartEntity<any>[]
        get noAi(): boolean
        get ambientSoundInterval(): number
        get restrictCenter(): BlockPos
        get leftHanded(): boolean
        get persistenceRequired(): boolean
        get headRotSpeed(): number
        set guaranteedDrop(arg0: EquipmentSlot_)
        readonly static "MAX_PICKUP_LOOT_CHANCE": 0.55;
        readonly static "LEASH_TAG": "Leash";
        readonly static "DEFAULT_EQUIPMENT_DROP_CHANCE": 0.085;
        readonly "goalSelector": Internal.GoalSelector;
        readonly static "MAX_ENCHANTED_WEAPON_CHANCE": 0.25;
        readonly static "MAX_ENCHANTED_ARMOR_CHANCE": 0.5;
        readonly static "UPDATE_GOAL_SELECTOR_EVERY_N_TICKS": 2;
        "ambientSoundTime": number;
        readonly static "MAX_WEARING_ARMOR_CHANCE": 0.15;
        readonly "targetSelector": Internal.GoalSelector;
    }
    type Mob_ = Mob;
    interface FamilyOptic <A, B> {
        apply(arg0: number): Internal.OpticParts<A, B>;
    }
    type FamilyOptic_<A, B> = FamilyOptic<A, B>;
    class TheEndPortalBlockEntity extends Internal.BlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        shouldRenderFace(arg0: Internal.Direction_): boolean;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        serializeNBT(): Internal.CompoundTag;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get modelData(): Internal.IModelData
        get renderBoundingBox(): Internal.AABB
    }
    type TheEndPortalBlockEntity_ = TheEndPortalBlockEntity;
    class DoubleTag extends Internal.NumericTag {
        getType(): Internal.TagType<Internal.DoubleTag>;
        getAsDouble(): number;
        accept(arg0: Internal.TagVisitor_): void;
        getAsLong(): number;
        getAsFloat(): number;
        hashCode(): number;
        getAsString(): string;
        getAsInt(): number;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        getAsByte(): number;
        getAsNumber(): Internal.Number;
        write(arg0: Internal.DataOutput_): void;
        copy(): this;
        getId(): number;
        getAsShort(): number;
        static valueOf(arg0: number): Internal.DoubleTag;
        equals(arg0: any): boolean;
        accept(arg0: Internal.StreamTagVisitor_): Internal.StreamTagVisitor$ValueResult;
        get type(): Internal.TagType<Internal.DoubleTag>
        get asDouble(): number
        get asLong(): number
        get asFloat(): number
        get asString(): string
        get asInt(): number
        get asByte(): number
        get asNumber(): Internal.Number
        get id(): number
        get asShort(): number
        readonly static "ZERO": Internal.DoubleTag;
        readonly static "TYPE": any;
    }
    type DoubleTag_ = DoubleTag;
    class BiomeLoadingEvent extends Internal.Event {
        constructor()
        constructor(arg0: ResourceLocation_, arg1: Internal.Biome$ClimateSettings_, arg2: Internal.Biome$BiomeCategory_, arg3: Internal.BiomeSpecialEffects_, arg4: Internal.BiomeGenerationSettingsBuilder_, arg5: Internal.MobSpawnSettingsBuilder_)
        getClimate(): Internal.Biome$ClimateSettings;
        setEffects(arg0: Internal.BiomeSpecialEffects_): void;
        setClimate(arg0: Internal.Biome$ClimateSettings_): void;
        getEffects(): Internal.BiomeSpecialEffects;
        getListenerList(): Internal.ListenerList;
        getName(): ResourceLocation;
        setCategory(arg0: Internal.Biome$BiomeCategory_): void;
        getSpawns(): Internal.MobSpawnSettingsBuilder;
        getGeneration(): Internal.BiomeGenerationSettingsBuilder;
        getCategory(): Internal.Biome$BiomeCategory;
        get climate(): Internal.Biome$ClimateSettings
        set effects(arg0: Internal.BiomeSpecialEffects_)
        set climate(arg0: Internal.Biome$ClimateSettings_)
        get effects(): Internal.BiomeSpecialEffects
        get listenerList(): Internal.ListenerList
        get name(): ResourceLocation
        set category(arg0: Internal.Biome$BiomeCategory_)
        get spawns(): Internal.MobSpawnSettingsBuilder
        get generation(): Internal.BiomeGenerationSettingsBuilder
        get category(): Internal.Biome$BiomeCategory
    }
    type BiomeLoadingEvent_ = BiomeLoadingEvent;
    class ConditionalFunction implements Internal.FunctionContainer, Internal.ConditionContainer {
        constructor()
        enchantWithLevels(levels: Internal.NumberProvider_, treasure: boolean): Internal.FunctionContainer;
        addFunction(arg0: Internal.JsonObject_): Internal.FunctionContainer;
        enchantRandomly(enchantments: ResourceLocation_[]): Internal.FunctionContainer;
        furnaceSmelt(): Internal.FunctionContainer;
        entityProperties(entity: Internal.LootContext$EntityTarget_, properties: Internal.JsonObject_): Internal.ConditionContainer;
        lootingEnchant(count: Internal.NumberProvider_, limit: number): Internal.FunctionContainer;
        addConditionalFunction(func: Internal.Consumer_<Internal.ConditionalFunction_>): Internal.FunctionContainer;
        randomChance(chance: number): Internal.ConditionContainer;
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer;
        name(name: Internal.Component_, entity: Internal.LootContext$EntityTarget_): Internal.FunctionContainer;
        killedByPlayer(): Internal.ConditionContainer;
        damage(damage: Internal.NumberProvider_): Internal.FunctionContainer;
        nbt(tag: Internal.CompoundTag_): Internal.FunctionContainer;
        entityScores(entity: Internal.LootContext$EntityTarget_, scores: Internal.Map_<string, any>): Internal.ConditionContainer;
        survivesExplosion(): Internal.ConditionContainer;
        count(count: Internal.NumberProvider_): Internal.FunctionContainer;
        copyName(source: Internal.CopyNameFunction$NameSource_): Internal.FunctionContainer;
        addCondition(arg0: Internal.JsonObject_): Internal.ConditionContainer;
        lootTable(table: ResourceLocation_, seed: number): Internal.FunctionContainer;
        name(name: Internal.Component_): Internal.FunctionContainer;
        "function": Internal.JsonObject;
        "conditions": Internal.JsonArray;
    }
    type ConditionalFunction_ = ConditionalFunction;
    interface BiFunction <T, U, R> {
        andThen(arg0: Internal.Function_<any, any>): Internal.BiFunction<T, U, V>;
        apply(arg0: T, arg1: U): R;
    }
    type BiFunction_<T, U, R> = BiFunction<T, U, R> | ((arg0: T, arg1: U)=>R);
    interface Boolean2IntFunction extends it.unimi.dsi.fastutil.Function<boolean, number> {
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2IntFunction;
        andThenObject(arg0: Internal.Int2ObjectFunction_<any>): Internal.Boolean2ObjectFunction<T>;
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        defaultReturnValue(): number;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2IntFunction;
        put(arg0: boolean, arg1: number): number;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Boolean2LongFunction;
        andThenInt(arg0: Internal.Int2IntFunction_): this;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Boolean2DoubleFunction;
        getOrDefault(arg0: boolean, arg1: number): number;
        remove(arg0: boolean): number;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2IntFunction;
        containsKey(arg0: any): boolean;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Boolean2ShortFunction;
        andThenReference(arg0: Internal.Int2ReferenceFunction_<any>): Internal.Boolean2ReferenceFunction<T>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): number;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Boolean2FloatFunction;
        getOrDefault(arg0: any, arg1: number): number;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2IntFunction;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2IntFunction;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2IntFunction;
        composeReference(arg0: Internal.Reference2BooleanFunction_<any>): Internal.Reference2IntFunction<T>;
        composeObject(arg0: Internal.Object2BooleanFunction_<any>): Internal.Object2IntFunction<T>;
        containsKey(arg0: boolean): boolean;
        get(arg0: boolean): number;
        size(): number;
        put(arg0: boolean, arg1: number): number;
        defaultReturnValue(arg0: number): void;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2IntFunction;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Boolean2CharFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<boolean, T>;
        clear(): void;
        apply(arg0: boolean): number;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Boolean2ByteFunction;
    }
    type Boolean2IntFunction_ = Boolean2IntFunction | ((arg0: boolean)=>number);
    class ConsoleJS {
        constructor(m: Internal.ScriptType_, log: Internal.Logger_)
        resetFile(): void;
        errorf(message: string, ...args: any[]): void;
        log(message: any): void;
        group(): void;
        static getCurrent(def: Internal.ConsoleJS_): Internal.ConsoleJS;
        warn(message: string, throwable: Internal.Throwable_, skip: Internal.Pattern_): void;
        warnf(message: string, ...args: any[]): void;
        shouldPrintDebug(): boolean;
        getDebugEnabled(): boolean;
        flush(): void;
        getWriteToFile(): boolean;
        getMuted(): boolean;
        debug(message: any): void;
        setDebugEnabled(m: boolean): void;
        error(message: string, throwable: Internal.Throwable_, skip: Internal.Pattern_): void;
        getLogger(): Internal.Logger;
        getScriptLine(): number;
        setMuted(m: boolean): void;
        printObject(o: any, tree: boolean): void;
        warn(message: string, throwable: Internal.Throwable_): void;
        printClass(className: string): void;
        printObject(o: any): void;
        printStackTrace(throwable: Internal.Throwable_, skip: Internal.Pattern_): void;
        infof(message: any, ...args: any[]): void;
        trace(): void;
        setLineNumber(b: boolean): void;
        warn(message: any): void;
        printClass(className: string, tree: boolean): void;
        debugf(message: string, ...args: any[]): void;
        info(message: any): void;
        setWriteToFile(m: boolean): void;
        groupEnd(): void;
        error(message: any): void;
        error(message: string, throwable: Internal.Throwable_): void;
        get debugEnabled(): boolean
        get writeToFile(): boolean
        get muted(): boolean
        set debugEnabled(m: boolean)
        get logger(): Internal.Logger
        get scriptLine(): number
        set muted(m: boolean)
        set lineNumber(b: boolean)
        set writeToFile(m: boolean)
        static "SERVER": Internal.ConsoleJS;
        static "CLIENT": Internal.ConsoleJS;
        static "STARTUP": Internal.ConsoleJS;
    }
    type ConsoleJS_ = ConsoleJS;
    class MinecartCommandBlock extends Internal.AbstractMinecart {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        isPoweredCart(): boolean;
        activateMinecart(arg0: number, arg1: number, arg2: number, arg3: boolean): void;
        getCurrentRailPosition(): BlockPos;
        getMaxCartSpeedOnRail(): number;
        interact(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        getSlopeAdjustment(): number;
        shouldDoRailFunctions(): boolean;
        onlyOpCanSetNbt(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        canBeRidden(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getDefaultDisplayBlockState(): Internal.BlockState;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCommandBlock(): Internal.BaseCommandBlock;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getCartItem(): Internal.ItemStack;
        getMinecartType(): Internal.AbstractMinecart$Type;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getComparatorLevel(): number;
        get poweredCart(): boolean
        get currentRailPosition(): BlockPos
        get maxCartSpeedOnRail(): number
        get stepHeight(): number
        get slopeAdjustment(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get defaultDisplayBlockState(): Internal.BlockState
        get commandBlock(): Internal.BaseCommandBlock
        get cartItem(): Internal.ItemStack
        get minecartType(): Internal.AbstractMinecart$Type
        get comparatorLevel(): number
    }
    type MinecartCommandBlock_ = MinecartCommandBlock;
    interface OrderedEventExecutor extends Internal.EventExecutor {
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
    }
    type OrderedEventExecutor_ = OrderedEventExecutor;
    interface LongPredicate {
        negate(): this;
        or(arg0: Internal.LongPredicate_): this;
        test(arg0: number): boolean;
        and(arg0: Internal.LongPredicate_): this;
    }
    type LongPredicate_ = ((arg0: number)=>boolean) | LongPredicate;
    class Squid extends Internal.WaterAnimal {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        travel(arg0: Vec3_): void;
        canBeLeashed(arg0: Internal.Player_): boolean;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        setMovementVector(arg0: number, arg1: number, arg2: number): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        hasMovementVector(): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        "zBodyRotO": number;
        "tentacleMovement": number;
        "zBodyRot": number;
        "oldTentacleMovement": number;
        "tentacleAngle": number;
        "xBodyRot": number;
        "oldTentacleAngle": number;
        "xBodyRotO": number;
    }
    type Squid_ = Squid;
    interface Destroyable {
        destroy(): void;
        isDestroyed(): boolean;
        get destroyed(): boolean
    }
    type Destroyable_ = Destroyable;
    abstract class ChannelHandlerAdapter implements Internal.ChannelHandler {
        constructor()
        isSharable(): boolean;
        exceptionCaught(arg0: Internal.ChannelHandlerContext_, arg1: Internal.Throwable_): void;
        handlerAdded(arg0: Internal.ChannelHandlerContext_): void;
        handlerRemoved(arg0: Internal.ChannelHandlerContext_): void;
        get sharable(): boolean
    }
    type ChannelHandlerAdapter_ = ChannelHandlerAdapter;
    class ChatType extends Internal.Enum<Internal.ChatType> {
        static getForIndex(arg0: number): Internal.ChatType;
        getIndex(): number;
        static values(): Internal.ChatType[];
        static valueOf(arg0: string): Internal.ChatType;
        shouldInterrupt(): boolean;
        get index(): number
        readonly static "CHAT": Internal.ChatType;
        readonly static "GAME_INFO": Internal.ChatType;
        readonly static "SYSTEM": Internal.ChatType;
    }
    type ChatType_ = "chat" | ChatType | "system" | "game_info";
    interface EventLoop extends Internal.OrderedEventExecutor, Internal.EventLoopGroup {
        forEach(arg0: Internal.Consumer_<any>): void;
        parent(): Internal.EventLoopGroup;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
    }
    type EventLoop_ = EventLoop;
    class CustomStatBuilder extends Internal.BuilderBase<ResourceLocation> {
        constructor(i: ResourceLocation_)
        createObject(): any;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<ResourceLocation>;
        get registryType(): Internal.RegistryObjectBuilderTypes<ResourceLocation>
    }
    type CustomStatBuilder_ = CustomStatBuilder;
    class ParticleGroup {
        constructor(arg0: number)
        getLimit(): number;
        get limit(): number
        readonly static "SPORE_BLOSSOM": Internal.ParticleGroup;
    }
    type ParticleGroup_ = ParticleGroup;
    class BlockEntityType <T> extends Internal.ForgeRegistryEntry<Internal.BlockEntityType<any>> {
        constructor(arg0: any_<any>, arg1: Internal.Set_<Internal.Block_>, arg2: com.mojang.datafixers.types.Type_<any>)
        isValid(arg0: Internal.BlockState_): boolean;
        static getKey(arg0: Internal.BlockEntityType_<any>): ResourceLocation;
        getBlockEntity(arg0: Internal.BlockGetter_, arg1: BlockPos_): T;
        create(arg0: BlockPos_, arg1: Internal.BlockState_): T;
        readonly static "PISTON": Internal.BlockEntityType<any>;
        readonly static "CONDUIT": Internal.BlockEntityType<any>;
        readonly static "BEACON": Internal.BlockEntityType<any>;
        readonly static "END_GATEWAY": Internal.BlockEntityType<any>;
        readonly static "SHULKER_BOX": Internal.BlockEntityType<any>;
        readonly static "LECTERN": Internal.BlockEntityType<any>;
        readonly static "BREWING_STAND": Internal.BlockEntityType<any>;
        readonly static "BEEHIVE": Internal.BlockEntityType<any>;
        readonly static "COMMAND_BLOCK": Internal.BlockEntityType<any>;
        readonly static "TRAPPED_CHEST": Internal.BlockEntityType<any>;
        readonly static "BANNER": Internal.BlockEntityType<any>;
        readonly static "HOPPER": Internal.BlockEntityType<any>;
        readonly static "CHEST": Internal.BlockEntityType<any>;
        readonly static "ENDER_CHEST": Internal.BlockEntityType<any>;
        readonly static "END_PORTAL": Internal.BlockEntityType<any>;
        readonly static "COMPARATOR": Internal.BlockEntityType<any>;
        readonly static "FURNACE": Internal.BlockEntityType<any>;
        readonly static "BED": Internal.BlockEntityType<any>;
        readonly static "JUKEBOX": Internal.BlockEntityType<any>;
        readonly static "SCULK_SENSOR": Internal.BlockEntityType<any>;
        readonly static "MOB_SPAWNER": Internal.BlockEntityType<any>;
        readonly static "DAYLIGHT_DETECTOR": Internal.BlockEntityType<any>;
        readonly static "BLAST_FURNACE": Internal.BlockEntityType<any>;
        readonly static "DISPENSER": Internal.BlockEntityType<any>;
        readonly static "SIGN": Internal.BlockEntityType<any>;
        readonly static "BELL": Internal.BlockEntityType<any>;
        readonly static "JIGSAW": Internal.BlockEntityType<any>;
        readonly static "BARREL": Internal.BlockEntityType<any>;
        readonly static "SMOKER": Internal.BlockEntityType<any>;
        readonly static "SKULL": Internal.BlockEntityType<any>;
        readonly static "STRUCTURE_BLOCK": Internal.BlockEntityType<any>;
        readonly static "DROPPER": Internal.BlockEntityType<any>;
        readonly static "ENCHANTING_TABLE": Internal.BlockEntityType<any>;
        readonly static "CAMPFIRE": Internal.BlockEntityType<any>;
    }
    type BlockEntityType_<T> = Special.BlockEntityType | BlockEntityType<T>;
    class GraphicsStatus extends Internal.Enum<Internal.GraphicsStatus> {
        getKey(): string;
        toString(): string;
        static values(): Internal.GraphicsStatus[];
        static valueOf(arg0: string): Internal.GraphicsStatus;
        static byId(arg0: number): Internal.GraphicsStatus;
        getId(): number;
        get key(): string
        get id(): number
        readonly static "FANCY": Internal.GraphicsStatus;
        readonly static "FABULOUS": Internal.GraphicsStatus;
        readonly static "FAST": Internal.GraphicsStatus;
    }
    type GraphicsStatus_ = "fabulous" | "fancy" | GraphicsStatus | "fast";
    abstract class ItemBuilder extends Internal.BuilderBase<Internal.Item> {
        constructor(i: ResourceLocation_)
        static toToolTier(o: any): Internal.Tier;
        fireResistant(isFireResistant: boolean): this;
        color(index: number, c: Internal.Color_): this;
        barColor(barColor: Internal.Function_<Internal.ItemStackJS_, Internal.Color_>): this;
        subtypes(fn: Internal.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): this;
        texture(key: string, tex: string): this;
        maxDamage(v: number): this;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        name(name: Internal.ItemBuilder$NameCallback_): this;
        createItemProperties(): Internal.Item$Properties;
        clientRegistry(minecraft: Internal.Supplier_<Internal.Minecraft_>): void;
        unstackable(): this;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): this;
        modifyAttribute(attribute: ResourceLocation_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): this;
        glow(v: boolean): this;
        transformObject(arg0: any): any;
        parentModel(m: string): this;
        maxStackSize(v: number): this;
        modelJson(json: Internal.JsonObject_): this;
        tooltip(text: Internal.Component_): this;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): this;
        rarity(v: Rarity_): this;
        useAnimation(animation: Internal.UseAnim_): this;
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): this;
        use(use: Internal.ItemBuilder$UseCallback_): this;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): this;
        color(callback: Internal.ItemBuilder$ItemColorJS_): this;
        texture(tex: string): this;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): this;
        transformObject(obj: Internal.Item_): Internal.Item;
        containerItem(id: string): this;
        burnTime(v: number): this;
        textureJson(json: Internal.JsonObject_): this;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        static toArmorMaterial(o: any): Internal.ArmorMaterial;
        group(g: string): this;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>
        "parentModel": string;
        "texture": string;
        "textureJson": Internal.JsonObject;
        readonly static "ARMOR_TIERS": {"gold": any, "chain": any, "diamond": any, "turtle": any, "iron": any, "leather": any, "netherite": any};
        "modelJson": Internal.JsonObject;
        readonly static "TOOL_TIERS": {"gold": any, "diamond": any, "iron": any, "wood": any, "stone": any, "netherite": any};
    }
    type ItemBuilder_ = ItemBuilder;
    class IpBanListEntry extends Internal.BanListEntry<string> {
        constructor(arg0: string, arg1: Internal.Date_, arg2: string, arg3: Internal.Date_, arg4: string)
        constructor(arg0: Internal.JsonObject_)
        constructor(arg0: string)
        getDisplayName(): Internal.Component;
        get displayName(): Internal.Component
    }
    type IpBanListEntry_ = IpBanListEntry;
    interface ProfileLookupCallback {
        onProfileLookupSucceeded(arg0: Internal.GameProfile_): void;
        onProfileLookupFailed(arg0: Internal.GameProfile_, arg1: Internal.Exception_): void;
    }
    type ProfileLookupCallback_ = ProfileLookupCallback;
    class ImmutableMultimap$Builder <K, V> {
        constructor()
        put(arg0: K, arg1: V): this;
        putAll(arg0: K, ...arg1: V[]): this;
        putAll(arg0: Internal.Iterable_<any>): this;
        build(): Internal.ImmutableMultimap<K, V>;
        orderKeysBy(arg0: Internal.Comparator_<any>): this;
        putAll(arg0: K, arg1: Internal.Iterable_<any>): this;
        orderValuesBy(arg0: Internal.Comparator_<any>): this;
        put(arg0: Internal.Map$Entry_<any, any>): this;
        putAll(arg0: Internal.Multimap_<any, any>): this;
    }
    type ImmutableMultimap$Builder_<K, V> = ImmutableMultimap$Builder<K, V>;
    class ServerboundSetJigsawBlockPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: BlockPos_, arg1: ResourceLocation_, arg2: ResourceLocation_, arg3: ResourceLocation_, arg4: string, arg5: Internal.JigsawBlockEntity$JointType_)
        handle(arg0: Internal.PacketListener_): void;
        getPos(): BlockPos;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getTarget(): ResourceLocation;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getFinalState(): string;
        getJoint(): Internal.JigsawBlockEntity$JointType;
        getName(): ResourceLocation;
        getPool(): ResourceLocation;
        isSkippable(): boolean;
        get pos(): BlockPos
        get target(): ResourceLocation
        get finalState(): string
        get joint(): Internal.JigsawBlockEntity$JointType
        get name(): ResourceLocation
        get pool(): ResourceLocation
        get skippable(): boolean
    }
    type ServerboundSetJigsawBlockPacket_ = ServerboundSetJigsawBlockPacket;
    interface Double2BooleanFunction extends it.unimi.dsi.fastutil.Function<number, boolean>, Internal.DoublePredicate {
        or(arg0: Internal.DoublePredicate_): Internal.DoublePredicate;
        test(arg0: number): boolean;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2BooleanFunction;
        getOrDefault(arg0: number, arg1: boolean): boolean;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Double2ByteFunction;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2BooleanFunction;
        getOrDefault(arg0: any, arg1: any): any;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Double2LongFunction;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2BooleanFunction;
        composeReference(arg0: Internal.Reference2DoubleFunction_<any>): Internal.Reference2BooleanFunction<T>;
        apply(arg0: number): boolean;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2BooleanFunction;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2BooleanFunction;
        containsKey(arg0: any): boolean;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Double2DoubleFunction;
        get(arg0: any): boolean;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Double2CharFunction;
        andThenReference(arg0: Internal.Boolean2ReferenceFunction_<any>): Internal.Double2ReferenceFunction<T>;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2BooleanFunction;
        put(arg0: any, arg1: any): any;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Double2IntFunction;
        defaultReturnValue(): boolean;
        get(arg0: number): boolean;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Double2ShortFunction;
        and(arg0: Internal.DoublePredicate_): Internal.DoublePredicate;
        getOrDefault(arg0: any, arg1: boolean): boolean;
        put(arg0: number, arg1: boolean): boolean;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeObject(arg0: Internal.Object2DoubleFunction_<any>): Internal.Object2BooleanFunction<T>;
        composeDouble(arg0: Internal.Double2DoubleFunction_): this;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, boolean>;
        containsKey(arg0: number): boolean;
        put(arg0: number, arg1: boolean): boolean;
        size(): number;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Double2FloatFunction;
        clear(): void;
        remove(arg0: any): any;
        andThenObject(arg0: Internal.Boolean2ObjectFunction_<any>): Internal.Double2ObjectFunction<T>;
        negate(): Internal.DoublePredicate;
        remove(arg0: number): boolean;
        defaultReturnValue(arg0: boolean): void;
    }
    type Double2BooleanFunction_ = ((arg0: number)=>boolean) | Double2BooleanFunction;
    abstract class AbstractMultimap <K, V> implements Internal.Multimap<K, V> {
        putAll(arg0: Internal.Multimap_<any, any>): boolean;
        keySet(): Internal.Set<K>;
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>;
        toString(): string;
        putAll(arg0: K, arg1: Internal.Iterable_<any>): boolean;
        values(): Internal.Collection<V>;
        containsValue(arg0: any): boolean;
        remove(arg0: any, arg1: any): boolean;
        isEmpty(): boolean;
        containsEntry(arg0: any, arg1: any): boolean;
        hashCode(): number;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        replaceValues(arg0: K, arg1: Internal.Iterable_<any>): Internal.Collection<V>;
        put(arg0: K, arg1: V): boolean;
        keys(): Internal.Multiset<K>;
        equals(arg0: any): boolean;
        asMap(): Internal.Map<K, Internal.Collection<V>>;
        get empty(): boolean
    }
    type AbstractMultimap_<K, V> = AbstractMultimap<K, V>;
    interface VibrationListener$VibrationListenerConfig {
        shouldListen(arg0: Internal.Level_, arg1: Internal.GameEventListener_, arg2: BlockPos_, arg3: Internal.GameEvent_, arg4: Internal.Entity_): boolean;
        onSignalReceive(arg0: Internal.Level_, arg1: Internal.GameEventListener_, arg2: Internal.GameEvent_, arg3: number): void;
    }
    type VibrationListener$VibrationListenerConfig_ = VibrationListener$VibrationListenerConfig;
    class RandomBlockMatchTest extends Internal.RuleTest {
        constructor(arg0: Internal.Block_, arg1: number)
        test(arg0: Internal.BlockState_, arg1: Internal.Random_): boolean;
        readonly static "CODEC": any;
    }
    type RandomBlockMatchTest_ = RandomBlockMatchTest;
    interface IWeatherRenderHandler {
        render(arg0: number, arg1: number, arg2: Internal.ClientLevel_, arg3: Internal.Minecraft_, arg4: Internal.LightTexture_, arg5: number, arg6: number, arg7: number): void;
    }
    type IWeatherRenderHandler_ = IWeatherRenderHandler | ((arg0: number, arg1: number, arg2: Internal.ClientLevel, arg3: Internal.Minecraft, arg4: Internal.LightTexture, arg5: number, arg6: number, arg7: number)=>void);
    class ModelGenerator {
        constructor()
        parent(s: string): void;
        element(consumer: Internal.Consumer_<Internal.ModelGenerator$Element_>): void;
        texture(name: string, texture: string): void;
        toJson(): Internal.JsonObject;
        textures(json: Internal.JsonObject_): void;
    }
    type ModelGenerator_ = ModelGenerator;
    interface RandomSource {
        forkPositional(): Internal.PositionalRandomFactory;
        consumeCount(arg0: number): void;
        nextInt(arg0: number): number;
        nextFloat(): number;
        nextBoolean(): boolean;
        nextLong(): number;
        setSeed(arg0: number): void;
        fork(): this;
        nextDouble(): number;
        nextGaussian(): number;
        nextInt(): number;
        nextIntBetweenInclusive(arg0: number, arg1: number): number;
        set seed(arg0: number)
    }
    type RandomSource_ = RandomSource;
    interface LongStream$LongMapMultiConsumer {
        accept(arg0: number, arg1: Internal.LongConsumer_): void;
    }
    type LongStream$LongMapMultiConsumer_ = LongStream$LongMapMultiConsumer | ((arg0: number, arg1: Internal.LongConsumer)=>void);
    class StageCreationEvent {
        getPlayerStages(): Internal.Stages;
        getPlayer(): Internal.Player;
        setPlayerStages(s: Internal.Stages_): void;
        get playerStages(): Internal.Stages
        get player(): Internal.Player
        set playerStages(s: Internal.Stages_)
    }
    type StageCreationEvent_ = StageCreationEvent;
    class ThrownEgg extends Internal.ThrowableItemProjectile {
        constructor(arg0: Internal.Level_, arg1: Internal.LivingEntity_)
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        handleEntityEvent(arg0: number): void;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type ThrownEgg_ = ThrownEgg;
    class Arrow extends Internal.AbstractArrow {
        constructor(arg0: Internal.Level_, arg1: Internal.LivingEntity_)
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        setEffectsFromItem(arg0: Internal.ItemStack_): void;
        tick(): void;
        asKJS(): Internal.EntityJS;
        addEffect(arg0: Internal.MobEffectInstance_): void;
        getColor(): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        static getCustomColor(arg0: Internal.ItemStack_): number;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        handleEntityEvent(arg0: number): void;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        set effectsFromItem(arg0: Internal.ItemStack_)
        get color(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type Arrow_ = Arrow;
    class ClientboundUpdateAttributesPacket$AttributeSnapshot {
        constructor(arg0: Internal.Attribute_, arg1: number, arg2: Internal.Collection_<Internal.AttributeModifier_>)
        getModifiers(): Internal.Collection<Internal.AttributeModifier>;
        getBase(): number;
        getAttribute(): Internal.Attribute;
        get modifiers(): Internal.Collection<Internal.AttributeModifier>
        get base(): number
        get attribute(): Internal.Attribute
    }
    type ClientboundUpdateAttributesPacket$AttributeSnapshot_ = ClientboundUpdateAttributesPacket$AttributeSnapshot;
    class ChunkDataEvent$Save extends Internal.ChunkDataEvent {
        constructor()
        constructor(arg0: Internal.ChunkAccess_, arg1: Internal.LevelAccessor_, arg2: Internal.CompoundTag_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ChunkDataEvent$Save_ = ChunkDataEvent$Save;
    class SensorType <U> extends Internal.ForgeRegistryEntry<Internal.SensorType<any>> {
        constructor(arg0: Internal.Supplier_<U>)
        create(): U;
        readonly static "DUMMY": Internal.SensorType<any>;
        readonly static "HOGLIN_SPECIFIC_SENSOR": Internal.SensorType<any>;
        readonly static "NEAREST_LIVING_ENTITIES": Internal.SensorType<any>;
        readonly static "NEAREST_ADULT": Internal.SensorType<any>;
        readonly static "AXOLOTL_ATTACKABLES": Internal.SensorType<any>;
        readonly static "NEAREST_ITEMS": Internal.SensorType<any>;
        readonly static "SECONDARY_POIS": Internal.SensorType<any>;
        readonly static "NEAREST_BED": Internal.SensorType<any>;
        readonly static "PIGLIN_SPECIFIC_SENSOR": Internal.SensorType<any>;
        readonly static "AXOLOTL_TEMPTATIONS": Internal.SensorType<any>;
        readonly static "GOLEM_DETECTED": Internal.SensorType<any>;
        readonly static "PIGLIN_BRUTE_SPECIFIC_SENSOR": Internal.SensorType<any>;
        readonly static "NEAREST_PLAYERS": Internal.SensorType<any>;
        readonly static "HURT_BY": Internal.SensorType<any>;
        readonly static "VILLAGER_BABIES": Internal.SensorType<any>;
        readonly static "GOAT_TEMPTATIONS": Internal.SensorType<any>;
        readonly static "VILLAGER_HOSTILES": Internal.SensorType<any>;
    }
    type SensorType_<U> = SensorType<U> | Special.SensorType;
    class InventoryJS {
        constructor(h: Internal.ItemHandler_)
        constructor(h: Internal.Container_)
        countNonEmpty(): number;
        markDirty(): void;
        count(): number;
        toString(): string;
        getWidth(): number;
        extract(slot: number, amount: number, simulate: boolean): Internal.ItemStackJS;
        getSlotLimit(slot: number): number;
        count(ingredient: Internal.IngredientJS_): number;
        countNonEmpty(ingredient: Internal.IngredientJS_): number;
        getBlock(level: Internal.LevelJS_): Internal.BlockContainerJS;
        isEmpty(): boolean;
        find(): number;
        insert(slot: number, item: Internal.ItemStack_, simulate: boolean): Internal.ItemStackJS;
        set(slot: number, item: Internal.ItemStack_): void;
        find(ingredient: Internal.IngredientJS_): number;
        getSize(): number;
        get(slot: number): Internal.ItemStackJS;
        clear(ingredient: Internal.IngredientJS_): void;
        clear(): void;
        getHeight(): number;
        isItemValid(slot: number, item: Internal.ItemStack_): boolean;
        get width(): number
        get empty(): boolean
        get size(): number
        get height(): number
        readonly "minecraftInventory": Internal.ItemHandler;
    }
    type InventoryJS_ = InventoryJS;
    class Suggestion implements Internal.Comparable<Internal.Suggestion> {
        constructor(arg0: Internal.StringRange_, arg1: string, arg2: Internal.Message_)
        constructor(arg0: Internal.StringRange_, arg1: string)
        apply(arg0: string): string;
        hashCode(): number;
        compareToIgnoreCase(arg0: Internal.Suggestion_): number;
        toString(): string;
        compareTo(arg0: Internal.Suggestion_): number;
        getTooltip(): Internal.Message;
        getText(): string;
        expand(arg0: string, arg1: Internal.StringRange_): this;
        equals(arg0: any): boolean;
        getRange(): Internal.StringRange;
        compareTo(arg0: any): number;
        get tooltip(): Internal.Message
        get text(): string
        get range(): Internal.StringRange
    }
    type Suggestion_ = Suggestion;
    abstract class Monster extends Internal.PathfinderMob implements Internal.Enemy {
        getFallSounds(): Internal.LivingEntity$Fallsounds;
        getProjectile(arg0: Internal.ItemStack_): Internal.ItemStack;
        isPreventingPlayerRest(arg0: Internal.Player_): boolean;
        getStepHeight(): number;
        static checkAnyLightMonsterSpawnRules(arg0: Internal.EntityType_<any>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        asKJS(): Internal.EntityJS;
        static checkMonsterSpawnRules(arg0: Internal.EntityType_<any>, arg1: Internal.ServerLevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        canRiderInteract(): boolean;
        getSoundSource(): Internal.SoundSource;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        static createMonsterAttributes(): Internal.AttributeSupplier$Builder;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getWalkTargetValue(arg0: BlockPos_, arg1: Internal.LevelReader_): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        static isDarkEnoughToSpawn(arg0: Internal.ServerLevelAccessor_, arg1: BlockPos_, arg2: Internal.Random_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get fallSounds(): Internal.LivingEntity$Fallsounds
        get stepHeight(): number
        get soundSource(): Internal.SoundSource
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type Monster_ = Monster;
    interface EntityKJS extends Internal.AsKJS<Internal.EntityJS> {
        getPersistentDataKJS(): Internal.CompoundTag;
        asKJS(): Internal.EntityJS;
        get persistentDataKJS(): Internal.CompoundTag
    }
    type EntityKJS_ = EntityKJS;
    interface IdMap <T> extends Internal.Iterable<T> {
        byId(arg0: number): T;
        size(): number;
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<T>;
        byIdOrThrow(arg0: number): T;
        getId(arg0: T): number;
        readonly static "DEFAULT": -1;
    }
    type IdMap_<T> = IdMap<T>;
    interface ChannelInboundHandler extends Internal.ChannelHandler {
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext_): void;
        channelInactive(arg0: Internal.ChannelHandlerContext_): void;
        channelActive(arg0: Internal.ChannelHandlerContext_): void;
        channelUnregistered(arg0: Internal.ChannelHandlerContext_): void;
        userEventTriggered(arg0: Internal.ChannelHandlerContext_, arg1: any): void;
        exceptionCaught(arg0: Internal.ChannelHandlerContext_, arg1: Internal.Throwable_): void;
        channelReadComplete(arg0: Internal.ChannelHandlerContext_): void;
        channelRegistered(arg0: Internal.ChannelHandlerContext_): void;
        channelRead(arg0: Internal.ChannelHandlerContext_, arg1: any): void;
    }
    type ChannelInboundHandler_ = ChannelInboundHandler;
    interface TemporalQuery <R> {
        queryFrom(arg0: Internal.TemporalAccessor_): R;
    }
    type TemporalQuery_<R> = TemporalQuery<R> | ((arg0: Internal.TemporalAccessor)=>R);
    abstract class EntityModel <T> extends Internal.Model {
        copyPropertiesTo(arg0: Internal.EntityModel_<T>): void;
        setupAnim(arg0: T, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        prepareMobModel(arg0: T, arg1: number, arg2: number, arg3: number): void;
        "riding": boolean;
        "attackTime": number;
        "young": boolean;
    }
    type EntityModel_<T> = EntityModel<T>;
    interface PaletteResize <T> {
        onResize(arg0: number, arg1: T): number;
    }
    type PaletteResize_<T> = PaletteResize<T>;
    interface NumberProvider extends Internal.LootContextUser {
        getInt(arg0: Internal.LootContext_): number;
        getFloat(arg0: Internal.LootContext_): number;
        getReferencedContextParams(): Internal.Set<Internal.LootContextParam<any>>;
        getType(): Internal.LootNumberProviderType;
        validate(arg0: Internal.ValidationContext_): void;
        get referencedContextParams(): Internal.Set<Internal.LootContextParam<any>>
        get type(): Internal.LootNumberProviderType
    }
    type NumberProvider_ = NumberProvider;
    interface ModuleFinder {
        find(arg0: string): Internal.Optional<Internal.ModuleReference>;
        compose(...arg0: Internal.ModuleFinder_[]): this;
        findAll(): Internal.Set<Internal.ModuleReference>;
        ofSystem(): this;
        of(...arg0: Internal.Path_[]): this;
    }
    type ModuleFinder_ = ModuleFinder;
    class Enum$EnumDesc <E> extends Internal.DynamicConstantDesc<E> {
        toString(): string;
        static of(arg0: Internal.ClassDesc_, arg1: string): Internal.Enum$EnumDesc<E>;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup_): any;
    }
    type Enum$EnumDesc_<E> = Enum$EnumDesc<E>;
    class ClientboundMapItemDataPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: number, arg2: boolean, arg3: Internal.Collection_<Internal.MapDecoration_>, arg4: any_)
        handle(arg0: Internal.PacketListener_): void;
        isLocked(): boolean;
        applyToMap(arg0: Internal.MapItemSavedData_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getMapId(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getScale(): number;
        isSkippable(): boolean;
        get locked(): boolean
        get mapId(): number
        get scale(): number
        get skippable(): boolean
    }
    type ClientboundMapItemDataPacket_ = ClientboundMapItemDataPacket;
    class CapabilityDispatcher implements Internal.ICapabilityProvider, Internal.INBTSerializable<Internal.CompoundTag> {
        constructor(arg0: Internal.Map_<ResourceLocation_, Internal.ICapabilityProvider_>, arg1: Internal.List_<Internal.Runnable_>, arg2: Internal.ICapabilityProvider_)
        constructor(arg0: Internal.Map_<ResourceLocation_, Internal.ICapabilityProvider_>, arg1: Internal.List_<Internal.Runnable_>)
        getCapability(arg0: Internal.Capability_<T>, arg1: Internal.Direction_): Internal.LazyOptional<T>;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        areCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        serializeNBT(): Internal.Tag;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        invalidate(): void;
    }
    type CapabilityDispatcher_ = CapabilityDispatcher;
    interface StructurePlacementType <SP> {
        codec(): Internal.Codec<SP>;
        readonly static "CONCENTRIC_RINGS": any;
        readonly static "RANDOM_SPREAD": any;
    }
    type StructurePlacementType_<SP> = StructurePlacementType<SP> | Special.StructurePlacementType;
    class PlayerEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.Player_)
        getListenerList(): Internal.ListenerList;
        getPlayer(): Internal.Player;
        get listenerList(): Internal.ListenerList
        get player(): Internal.Player
    }
    type PlayerEvent_ = PlayerEvent;
    class LevelSummary$BackupStatus extends Internal.Enum<Internal.LevelSummary$BackupStatus> {
        static valueOf(arg0: string): Internal.LevelSummary$BackupStatus;
        isSevere(): boolean;
        static values(): Internal.LevelSummary$BackupStatus[];
        getTranslationKey(): string;
        shouldBackup(): boolean;
        get severe(): boolean
        get translationKey(): string
        readonly static "DOWNGRADE": Internal.LevelSummary$BackupStatus;
        readonly static "UPGRADE_TO_SNAPSHOT": Internal.LevelSummary$BackupStatus;
        readonly static "NONE": Internal.LevelSummary$BackupStatus;
    }
    type LevelSummary$BackupStatus_ = "upgrade_to_snapshot" | "downgrade" | LevelSummary$BackupStatus | "none";
    class FoliagePlacer$FoliageAttachment {
        constructor(arg0: BlockPos_, arg1: number, arg2: boolean)
        pos(): BlockPos;
        radiusOffset(): number;
        doubleTrunk(): boolean;
    }
    type FoliagePlacer$FoliageAttachment_ = FoliagePlacer$FoliageAttachment;
    class Drowned extends Internal.Zombie implements Internal.RangedAttackMob {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        okTarget(arg0: Internal.LivingEntity_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        static checkDrownedSpawnRules(arg0: Internal.EntityType_<Internal.Drowned_>, arg1: Internal.ServerLevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        travel(arg0: Vec3_): void;
        updateSwimming(): void;
        setSearchingForLand(arg0: boolean): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        performRangedAttack(arg0: Internal.LivingEntity_, arg1: number): void;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        isPushedByFluid(): boolean;
        serializeNBT(): Internal.Tag;
        checkSpawnObstruction(arg0: Internal.LevelReader_): boolean;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        set searchingForLand(arg0: boolean)
        get stepHeight(): number
        get multipartEntity(): boolean
        get pushedByFluid(): boolean
        get parts(): Internal.PartEntity<any>[]
        readonly static "NAUTILUS_SHELL_CHANCE": 0.03;
    }
    type Drowned_ = Drowned;
    interface Set <E> extends Internal.Collection<E> {
        copyOf(arg0: Internal.Collection_<any>): this;
        add(arg0: E): boolean;
        forEach(arg0: Internal.Consumer_<any>): void;
        parallelStream(): Internal.Stream<E>;
        isEmpty(): boolean;
        of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): this;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        of(arg0: E, arg1: E): this;
        of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): this;
        of(arg0: E, arg1: E, arg2: E): this;
        addAll(arg0: Internal.Collection_<any>): boolean;
        of(arg0: E, arg1: E, arg2: E, arg3: E): this;
        of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): this;
        contains(arg0: any): boolean;
        of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): this;
        of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): this;
        toArray(arg0: T[]): T[];
        remove(arg0: any): boolean;
        toArray(): any[];
        iterator(): Internal.Iterator<E>;
        hashCode(): number;
        size(): number;
        of(arg0: E): this;
        stream(): Internal.Stream<E>;
        of(...arg0: E[]): this;
        of(): this;
        of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): this;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        clear(): void;
        spliterator(): Internal.Spliterator<E>;
        equals(arg0: any): boolean;
        get empty(): boolean
    }
    type Set_<E> = Set<E>;
    class RenderStateShard$BooleanStateShard extends Internal.RenderStateShard {
        constructor(arg0: string, arg1: Internal.Runnable_, arg2: Internal.Runnable_, arg3: boolean)
        toString(): string;
    }
    type RenderStateShard$BooleanStateShard_ = RenderStateShard$BooleanStateShard;
    class ChunkWatchEvent$Watch extends Internal.ChunkWatchEvent {
        constructor()
        constructor(arg0: Internal.ServerPlayer_, arg1: Internal.ChunkPos_, arg2: Internal.ServerLevel_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ChunkWatchEvent$Watch_ = ChunkWatchEvent$Watch;
    class ClientboundSelectAdvancementsTabPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: ResourceLocation_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getTab(): ResourceLocation;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get tab(): ResourceLocation
        get skippable(): boolean
    }
    type ClientboundSelectAdvancementsTabPacket_ = ClientboundSelectAdvancementsTabPacket;
    abstract class Property <T> {
        generateHashCode(): number;
        getValueClass(): Internal.Class<T>;
        toString(): string;
        getPossibleValues(): Internal.Collection<T>;
        getName(arg0: T): string;
        valueCodec(): Internal.Codec<Internal.Property$Value<T>>;
        value(arg0: Internal.StateHolder_<any, any>): Internal.Property$Value<T>;
        parseValue(arg0: Internal.DynamicOps_<U>, arg1: S, arg2: U): Internal.DataResult<S>;
        hashCode(): number;
        codec(): Internal.Codec<T>;
        getName(): string;
        value(arg0: T): Internal.Property$Value<T>;
        getValue(arg0: string): Internal.Optional<T>;
        equals(arg0: any): boolean;
        getAllValues(): Internal.Stream<Internal.Property$Value<T>>;
        get valueClass(): Internal.Class<T>
        get possibleValues(): Internal.Collection<T>
        get name(): string
        get allValues(): Internal.Stream<Internal.Property$Value<T>>
    }
    type Property_<T> = Property<T>;
    class LongTag extends Internal.NumericTag {
        copy(): this;
        getAsDouble(): number;
        accept(arg0: Internal.TagVisitor_): void;
        getAsLong(): number;
        getAsFloat(): number;
        hashCode(): number;
        getAsString(): string;
        getAsInt(): number;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        getAsByte(): number;
        getAsNumber(): Internal.Number;
        getType(): Internal.TagType<Internal.LongTag>;
        write(arg0: Internal.DataOutput_): void;
        static valueOf(arg0: number): Internal.LongTag;
        getId(): number;
        getAsShort(): number;
        equals(arg0: any): boolean;
        accept(arg0: Internal.StreamTagVisitor_): Internal.StreamTagVisitor$ValueResult;
        get asDouble(): number
        get asLong(): number
        get asFloat(): number
        get asString(): string
        get asInt(): number
        get asByte(): number
        get asNumber(): Internal.Number
        get type(): Internal.TagType<Internal.LongTag>
        get id(): number
        get asShort(): number
        readonly static "TYPE": any;
    }
    type LongTag_ = LongTag;
    class RedstoneSide extends Internal.Enum<Internal.RedstoneSide> implements Internal.StringRepresentable {
        static valueOf(arg0: string): Internal.RedstoneSide;
        toString(): string;
        getSerializedName(): string;
        static values(): Internal.RedstoneSide[];
        isConnected(): boolean;
        get serializedName(): string
        get connected(): boolean
        readonly static "UP": Internal.RedstoneSide;
        readonly static "NONE": Internal.RedstoneSide;
        readonly static "SIDE": Internal.RedstoneSide;
    }
    type RedstoneSide_ = "side" | "up" | RedstoneSide | "none";
    class AttachFace extends Internal.Enum<Internal.AttachFace> implements Internal.StringRepresentable {
        static values(): Internal.AttachFace[];
        getSerializedName(): string;
        static valueOf(arg0: string): Internal.AttachFace;
        get serializedName(): string
        readonly static "FLOOR": Internal.AttachFace;
        readonly static "WALL": Internal.AttachFace;
        readonly static "CEILING": Internal.AttachFace;
    }
    type AttachFace_ = "floor" | AttachFace | "ceiling" | "wall";
    class Boat extends Internal.Entity {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        push(arg0: Internal.Entity_): void;
        static canVehicleCollide(arg0: Internal.Entity_, arg1: Internal.Entity_): boolean;
        getStepHeight(): number;
        setHurtTime(arg0: number): void;
        setDamage(arg0: number): void;
        getAddEntityPacket(): Internal.Packet<any>;
        getRowingTime(arg0: number, arg1: number): number;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        onAboveBubbleCol(arg0: boolean): void;
        canCollideWith(arg0: Internal.Entity_): boolean;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        canBeCollidedWith(): boolean;
        getMotionDirection(): Internal.Direction;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isPickable(): boolean;
        tick(): void;
        positionRider(arg0: Internal.Entity_): void;
        getBoatType(): Internal.Boat$Type;
        alwaysAccepts(): boolean;
        getHurtTime(): number;
        getPickResult(): Internal.ItemStack;
        setPaddleState(arg0: boolean, arg1: boolean): void;
        getPaddleState(arg0: number): boolean;
        getDropItem(): Internal.Item;
        interact(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        setHurtDir(arg0: number): void;
        getDismountLocationForPassenger(arg0: Internal.LivingEntity_): Vec3;
        getControllingPassenger(): Internal.Entity;
        asKJS(): Internal.EntityJS;
        isUnderWater(): boolean;
        animateHurt(): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        getBubbleAngle(arg0: number): number;
        serializeNBT(): Internal.Tag;
        setInput(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean): void;
        getHurtDir(): number;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        deserializeNBT(arg0: Internal.Tag_): void;
        lerpTo(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: boolean): void;
        onPassengerTurned(arg0: Internal.Entity_): void;
        getPassengersRidingOffset(): number;
        getWaterLevelAbove(): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getGroundFriction(): number;
        isPushable(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getDamage(): number;
        setType(arg0: Internal.Boat$Type_): void;
        get stepHeight(): number
        set hurtTime(arg0: number)
        set damage(arg0: number)
        get addEntityPacket(): Internal.Packet<any>
        get motionDirection(): Internal.Direction
        get pickable(): boolean
        get boatType(): Internal.Boat$Type
        get hurtTime(): number
        get pickResult(): Internal.ItemStack
        get dropItem(): Internal.Item
        set hurtDir(arg0: number)
        get controllingPassenger(): Internal.Entity
        get underWater(): boolean
        get multipartEntity(): boolean
        get hurtDir(): number
        get parts(): Internal.PartEntity<any>[]
        get passengersRidingOffset(): number
        get waterLevelAbove(): number
        get groundFriction(): number
        get pushable(): boolean
        get damage(): number
        set type(arg0: Internal.Boat$Type_)
        readonly static "BUBBLE_TIME": 60;
        readonly static "PADDLE_SOUND_TIME": 0.7853981852531433;
        readonly static "PADDLE_LEFT": 0;
        readonly static "PADDLE_RIGHT": 1;
    }
    type Boat_ = Boat;
    abstract class PathfinderMob extends Internal.Mob {
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        isPathFinding(): boolean;
        asKJS(): Internal.EntityJS;
        getWalkTargetValue(arg0: BlockPos_, arg1: Internal.LevelReader_): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getWalkTargetValue(arg0: BlockPos_): number;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        checkSpawnRules(arg0: Internal.LevelAccessor_, arg1: Internal.MobSpawnType_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get pathFinding(): boolean
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type PathfinderMob_ = PathfinderMob;
    abstract class RenderPlayerEvent extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.PlayerRenderer_, arg2: number, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number)
        getRenderer(): Internal.PlayerRenderer;
        getPartialTick(): number;
        getPoseStack(): Internal.PoseStack;
        getListenerList(): Internal.ListenerList;
        getPackedLight(): number;
        getMultiBufferSource(): Internal.MultiBufferSource;
        get renderer(): Internal.PlayerRenderer
        get partialTick(): number
        get poseStack(): Internal.PoseStack
        get listenerList(): Internal.ListenerList
        get packedLight(): number
        get multiBufferSource(): Internal.MultiBufferSource
    }
    type RenderPlayerEvent_ = RenderPlayerEvent;
    class Node {
        constructor(arg0: number, arg1: number, arg2: number)
        distanceToSqr(arg0: BlockPos_): number;
        toString(): string;
        distanceTo(arg0: BlockPos_): number;
        static createFromStream(arg0: Internal.FriendlyByteBuf_): Internal.Node;
        static createHash(arg0: number, arg1: number, arg2: number): number;
        distanceToSqr(arg0: Internal.Node_): number;
        distanceManhattan(arg0: BlockPos_): number;
        distanceTo(arg0: Internal.Node_): number;
        asVec3(): Vec3;
        writeToStream(arg0: Internal.FriendlyByteBuf_): void;
        hashCode(): number;
        asBlockPos(): BlockPos;
        distanceManhattan(arg0: Internal.Node_): number;
        equals(arg0: any): boolean;
        inOpenSet(): boolean;
        cloneAndMove(arg0: number, arg1: number, arg2: number): this;
        "cameFrom": Internal.Node;
        readonly "z": number;
        "h": number;
        "walkedDistance": number;
        "g": number;
        readonly "x": number;
        "f": number;
        readonly "y": number;
        "type": Internal.BlockPathTypes;
        "costMalus": number;
        "heapIdx": number;
        "closed": boolean;
    }
    type Node_ = Node;
    interface CollisionContext {
        empty(): this;
        isHoldingItem(arg0: Internal.Item_): boolean;
        isDescending(): boolean;
        isAbove(arg0: Internal.VoxelShape_, arg1: BlockPos_, arg2: boolean): boolean;
        canStandOnFluid(arg0: Internal.FluidState_, arg1: Internal.FluidState_): boolean;
        of(arg0: Internal.Entity_): this;
        get descending(): boolean
    }
    type CollisionContext_ = CollisionContext;
    interface EntityAccess {
        getPassengersAndSelf(): Internal.Stream<any>;
        shouldBeSaved(): boolean;
        getBoundingBox(): Internal.AABB;
        getUUID(): Internal.UUID;
        blockPosition(): BlockPos;
        setLevelCallback(arg0: Internal.EntityInLevelCallback_): void;
        getSelfAndPassengers(): Internal.Stream<any>;
        isAlwaysTicking(): boolean;
        getId(): number;
        setRemoved(arg0: Internal.Entity$RemovalReason_): void;
        get passengersAndSelf(): Internal.Stream<any>
        get boundingBox(): Internal.AABB
        get UUID(): Internal.UUID
        set levelCallback(arg0: Internal.EntityInLevelCallback_)
        get selfAndPassengers(): Internal.Stream<any>
        get alwaysTicking(): boolean
        get id(): number
        set removed(arg0: Internal.Entity$RemovalReason_)
    }
    type EntityAccess_ = EntityAccess;
    class HumanoidArm extends Internal.Enum<Internal.HumanoidArm> {
        getName(): Internal.Component;
        toString(): string;
        static valueOf(arg0: string): Internal.HumanoidArm;
        getOpposite(): this;
        static values(): Internal.HumanoidArm[];
        get name(): Internal.Component
        get opposite(): Internal.HumanoidArm
        readonly static "LEFT": Internal.HumanoidArm;
        readonly static "RIGHT": Internal.HumanoidArm;
    }
    type HumanoidArm_ = HumanoidArm | "right" | "left";
    interface IScheduledEventCallback {
        onCallback(arg0: Internal.ScheduledEvent_): void;
    }
    type IScheduledEventCallback_ = ((arg0: Internal.ScheduledEvent)=>void) | IScheduledEventCallback;
    class ServerAboutToStartEvent extends Internal.ServerLifecycleEvent {
        constructor()
        constructor(arg0: Internal.MinecraftServer_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ServerAboutToStartEvent_ = ServerAboutToStartEvent;
    class ZombifiedPiglin extends Internal.Zombie implements Internal.NeutralMob {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        playerDied(arg0: Internal.Player_): void;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        isAngry(): boolean;
        isPreventingPlayerRest(arg0: Internal.Player_): boolean;
        getStepHeight(): number;
        forgetCurrentTargetAndRefreshUniversalAnger(): void;
        asKJS(): Internal.EntityJS;
        startPersistentAngerTimer(): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        setTarget(arg0: Internal.LivingEntity_): void;
        addPersistentAngerSaveData(arg0: Internal.CompoundTag_): void;
        isMultipartEntity(): boolean;
        setRemainingPersistentAngerTime(arg0: number): void;
        serializeNBT(): Internal.Tag;
        checkSpawnObstruction(arg0: Internal.LevelReader_): boolean;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        isAngryAt(arg0: Internal.LivingEntity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getRemainingPersistentAngerTime(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getPersistentAngerTarget(): Internal.UUID;
        static checkZombifiedPiglinSpawnRules(arg0: Internal.EntityType_<Internal.ZombifiedPiglin_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMyRidingOffset(): number;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        readPersistentAngerSaveData(arg0: Internal.Level_, arg1: Internal.CompoundTag_): void;
        stopBeingAngry(): void;
        wantsToPickUp(arg0: Internal.ItemStack_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        setPersistentAngerTarget(arg0: Internal.UUID_): void;
        updatePersistentAnger(arg0: Internal.ServerLevel_, arg1: boolean): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        isAngryAtAllPlayers(arg0: Internal.Level_): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get angry(): boolean
        get stepHeight(): number
        set target(arg0: Internal.LivingEntity_)
        get multipartEntity(): boolean
        set remainingPersistentAngerTime(arg0: number)
        get parts(): Internal.PartEntity<any>[]
        get remainingPersistentAngerTime(): number
        get persistentAngerTarget(): Internal.UUID
        get myRidingOffset(): number
        set persistentAngerTarget(arg0: Internal.UUID_)
    }
    type ZombifiedPiglin_ = ZombifiedPiglin;
    class StartupEventJS extends Internal.EventJS {
        constructor()
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
    }
    type StartupEventJS_ = StartupEventJS;
    class TickEvent$Phase extends Internal.Enum<Internal.TickEvent$Phase> {
        static values(): Internal.TickEvent$Phase[];
        static valueOf(arg0: string): Internal.TickEvent$Phase;
        readonly static "START": Internal.TickEvent$Phase;
        readonly static "END": Internal.TickEvent$Phase;
    }
    type TickEvent$Phase_ = "start" | "end" | TickEvent$Phase;
    interface ITag <V> extends Internal.Iterable<V> {
        getRandomElement(arg0: Internal.Random_): Internal.Optional<V>;
        getKey(): Internal.TagKey<V>;
        size(): number;
        isBound(): boolean;
        stream(): Internal.Stream<V>;
        contains(arg0: V): boolean;
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<V>;
        isEmpty(): boolean;
        get key(): Internal.TagKey<V>
        get bound(): boolean
        get empty(): boolean
    }
    type ITag_<V> = ITag<V>;
    class SimpleWeightedRandomList <E> extends Internal.WeightedRandomList<Internal.WeightedEntry$Wrapper<E>> {
        getRandomValue(arg0: Internal.Random_): Internal.Optional<E>;
        static builder(): Internal.SimpleWeightedRandomList$Builder<E>;
        static wrappedCodecAllowingEmpty(arg0: Internal.Codec_<E>): Internal.Codec<Internal.SimpleWeightedRandomList<E>>;
        static wrappedCodec(arg0: Internal.Codec_<E>): Internal.Codec<Internal.SimpleWeightedRandomList<E>>;
        static empty(): Internal.SimpleWeightedRandomList<E>;
        static single(arg0: E): Internal.SimpleWeightedRandomList<E>;
    }
    type SimpleWeightedRandomList_<E> = SimpleWeightedRandomList<E>;
    class CropBlockBuilder$ShapeBuilder {
        constructor(age: number)
        shape(age: number, minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number): this;
        getShapes(): Internal.List<Internal.VoxelShape>;
        get shapes(): Internal.List<Internal.VoxelShape>
    }
    type CropBlockBuilder$ShapeBuilder_ = CropBlockBuilder$ShapeBuilder;
    interface FunctionUserBuilder <T> {
        apply(arg0: Internal.LootItemFunction$Builder_): T;
        unwrap(): T;
    }
    type FunctionUserBuilder_<T> = FunctionUserBuilder<T>;
    interface ICapabilitySerializable <T> extends Internal.ICapabilityProvider, Internal.INBTSerializable<T> {
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
    }
    type ICapabilitySerializable_<T> = ICapabilitySerializable<T>;
    class LevelChunkTicks <T> implements Internal.TickContainerAccess<T>, Internal.SerializableTickContainer<T> {
        constructor()
        constructor(arg0: Internal.List_<any_<T>>)
        static load(arg0: Internal.ListTag_, arg1: Internal.Function_<string, Internal.Optional_<T>>, arg2: Internal.ChunkPos_): Internal.LevelChunkTicks<T>;
        unpack(arg0: number): void;
        count(): number;
        schedule(arg0: Internal.ScheduledTick_<T>): void;
        removeIf(arg0: Internal.Predicate_<Internal.ScheduledTick_<T>>): void;
        save(arg0: number, arg1: Internal.Function_<any, any>): Internal.Tag;
        peek(): Internal.ScheduledTick<T>;
        getAll(): Internal.Stream<Internal.ScheduledTick<T>>;
        hasScheduledTick(arg0: BlockPos_, arg1: T): boolean;
        setOnTickAdded(arg0: Internal.BiConsumer_<Internal.LevelChunkTicks_<T>, Internal.ScheduledTick_<T>>): void;
        poll(): Internal.ScheduledTick<T>;
        get all(): Internal.Stream<Internal.ScheduledTick<T>>
        set onTickAdded(arg0: Internal.BiConsumer_<Internal.LevelChunkTicks_<T>, Internal.ScheduledTick_<T>>)
    }
    type LevelChunkTicks_<T> = LevelChunkTicks<T>;
    class WorldgenRemoveEventJS extends Internal.StartupEventJS {
        constructor()
        printFiltered(): void;
        removeSpawns(p: Internal.Consumer_<Internal.RemoveSpawnsProperties_>): void;
        removeAllFeatures(filter: Internal.BiomeFilter_): void;
        printSpawns(category: Internal.MobCategory_): void;
        removeOres(p: Internal.Consumer_<Internal.RemoveOresProperties_>): void;
        removeAllSpawns(): void;
        printFeatures(type: DecorationGenerationStep_): void;
        removeAllFeatures(): void;
        printSpawns(): void;
        printFeatures(type: DecorationGenerationStep_, filter: Internal.BiomeFilter_): void;
        removeFeatureById(filter: Internal.BiomeFilter_, decoration: DecorationGenerationStep_, ids: ResourceLocation_[]): void;
        printFiltered(type: DecorationGenerationStep_): void;
        printFeaturesForType(type: DecorationGenerationStep_, filter: Internal.BiomeFilter_, afterRemoval: boolean): void;
        removeAllFeatures(filter: Internal.BiomeFilter_, type: DecorationGenerationStep_): void;
        removeFeatureById(type: DecorationGenerationStep_, ids: ResourceLocation_[]): void;
        printFiltered(type: DecorationGenerationStep_, filter: Internal.BiomeFilter_): void;
        printFeatures(): void;
    }
    type WorldgenRemoveEventJS_ = WorldgenRemoveEventJS;
    interface TooltipFlag {
        isAdvanced(): boolean;
        get advanced(): boolean
    }
    type TooltipFlag_ = TooltipFlag;
    interface Comparable <T> {
        compareTo(arg0: T): number;
    }
    type Comparable_<T> = Comparable<T>;
    class CodeSource implements Internal.Serializable {
        constructor(arg0: Internal.URL_, arg1: Internal.Certificate_[])
        constructor(arg0: Internal.URL_, arg1: any_[])
        getLocation(): Internal.URL;
        hashCode(): number;
        implies(arg0: Internal.CodeSource_): boolean;
        getCodeSigners(): any[];
        toString(): string;
        getCertificates(): Internal.Certificate[];
        equals(arg0: any): boolean;
        get location(): Internal.URL
        get codeSigners(): any[]
        get certificates(): Internal.Certificate[]
    }
    type CodeSource_ = CodeSource;
    class Climate$Parameter extends Internal.Record {
        constructor(arg0: number, arg1: number)
        span(arg0: Internal.Climate$Parameter_): this;
        distance(arg0: number): number;
        hashCode(): number;
        toString(): string;
        distance(arg0: Internal.Climate$Parameter_): number;
        static point(arg0: number): Internal.Climate$Parameter;
        static span(arg0: Internal.Climate$Parameter_, arg1: Internal.Climate$Parameter_): Internal.Climate$Parameter;
        static span(arg0: number, arg1: number): Internal.Climate$Parameter;
        equals(arg0: any): boolean;
        max(): number;
        min(): number;
        readonly static "CODEC": any;
    }
    type Climate$Parameter_ = Climate$Parameter;
    interface ShortCollection extends Internal.ShortIterable, Internal.Collection<number> {
        add(arg0: number): boolean;
        removeAll(arg0: Internal.ShortCollection_): boolean;
        forEach(arg0: Internal.Consumer_<any>): void;
        forEach(arg0: Internal.ShortConsumer_): void;
        iterator(): Internal.ShortIterator;
        forEach(arg0: Internal.IntConsumer_): void;
        intStream(): Internal.IntStream;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        stream(): Internal.Stream<number>;
        add(arg0: number): boolean;
        intParallelStream(): Internal.IntStream;
        intIterator(): Internal.IntIterator;
        contains(arg0: any): boolean;
        removeIf(arg0: Internal.IntPredicate_): boolean;
        parallelStream(): Internal.Stream<number>;
        contains(arg0: number): boolean;
        removeIf(arg0: Internal.ShortPredicate_): boolean;
        remove(arg0: any): boolean;
        intSpliterator(): Internal.IntSpliterator;
        addAll(arg0: Internal.ShortCollection_): boolean;
        retainAll(arg0: Internal.ShortCollection_): boolean;
        add(arg0: any): boolean;
        toShortArray(): number[];
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        toShortArray(arg0: number[]): number[];
        spliterator(): Internal.Spliterator<any>;
        toArray(arg0: number[]): number[];
        rem(arg0: number): boolean;
        containsAll(arg0: Internal.ShortCollection_): boolean;
    }
    type ShortCollection_ = ShortCollection;
    class DimensionSpecialEffects$SkyType extends Internal.Enum<Internal.DimensionSpecialEffects$SkyType> {
        static values(): Internal.DimensionSpecialEffects$SkyType[];
        static valueOf(arg0: string): Internal.DimensionSpecialEffects$SkyType;
        readonly static "NORMAL": Internal.DimensionSpecialEffects$SkyType;
        readonly static "END": Internal.DimensionSpecialEffects$SkyType;
        readonly static "NONE": Internal.DimensionSpecialEffects$SkyType;
    }
    type DimensionSpecialEffects$SkyType_ = "normal" | DimensionSpecialEffects$SkyType | "end" | "none";
    class ShieldDecorationRecipe extends Internal.CustomRecipe {
        constructor(arg0: ResourceLocation_)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        getSerializer(): Internal.RecipeSerializer<any>;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        matches(arg0: Internal.CraftingContainer_, arg1: Internal.Level_): boolean;
        isIncomplete(): boolean;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        assemble(arg0: Internal.CraftingContainer_): Internal.ItemStack;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get serializer(): Internal.RecipeSerializer<any>
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get incomplete(): boolean
    }
    type ShieldDecorationRecipe_ = ShieldDecorationRecipe;
    class Matrix4f {
        constructor()
        constructor(arg0: Internal.Quaternion_)
        constructor(arg0: Internal.Matrix4f_)
        constructor(arg0: number[])
        subtract(arg0: Internal.Matrix4f_): void;
        storeTransposed(arg0: Internal.FloatBuffer_): void;
        store(arg0: Internal.FloatBuffer_, arg1: boolean): void;
        multiply(arg0: Internal.Matrix4f_): void;
        isInteger(): boolean;
        static perspective(arg0: number, arg1: number, arg2: number, arg3: number): Internal.Matrix4f;
        multiply(arg0: number): void;
        trace(): number;
        static orthographic(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): Internal.Matrix4f;
        adjugateAndDet(): number;
        load(arg0: Internal.FloatBuffer_): void;
        setIdentity(): void;
        invert(): boolean;
        copy(): this;
        multiplyBackward(arg0: Internal.Matrix4f_): void;
        add(arg0: Internal.Matrix4f_): void;
        loadTransposed(arg0: Internal.FloatBuffer_): void;
        toString(): string;
        multiply(arg0: Internal.Quaternion_): void;
        load(arg0: Internal.Matrix4f_): void;
        static createTranslateMatrix(arg0: number, arg1: number, arg2: number): Internal.Matrix4f;
        setTranslation(arg0: number, arg1: number, arg2: number): void;
        load(arg0: Internal.FloatBuffer_, arg1: boolean): void;
        multiplyWithTranslation(arg0: number, arg1: number, arg2: number): void;
        hashCode(): number;
        store(arg0: Internal.FloatBuffer_): void;
        transpose(): void;
        determinant(): number;
        static createScaleMatrix(arg0: number, arg1: number, arg2: number): Internal.Matrix4f;
        equals(arg0: any): boolean;
        translate(arg0: Internal.Vector3f_): void;
        static orthographic(arg0: number, arg1: number, arg2: number, arg3: number): Internal.Matrix4f;
        get integer(): boolean
    }
    type Matrix4f_ = Matrix4f;
    class Pack implements Internal.AutoCloseable {
        constructor(arg0: string, arg1: boolean, arg2: Internal.Supplier_<Internal.PackResources_>, arg3: Internal.Component_, arg4: Internal.Component_, arg5: Internal.PackCompatibility_, arg6: Internal.Pack$Position_, arg7: boolean, arg8: Internal.PackSource_, arg9: boolean)
        constructor(arg0: string, arg1: Internal.Component_, arg2: boolean, arg3: Internal.Supplier_<Internal.PackResources_>, arg4: Internal.PackMetadataSection_, arg5: Internal.PackType_, arg6: Internal.Pack$Position_, arg7: Internal.PackSource_, arg8: boolean)
        constructor(arg0: string, arg1: boolean, arg2: Internal.Supplier_<Internal.PackResources_>, arg3: Internal.Component_, arg4: Internal.Component_, arg5: Internal.PackCompatibility_, arg6: Internal.Pack$Position_, arg7: boolean, arg8: Internal.PackSource_)
        constructor(arg0: string, arg1: Internal.Component_, arg2: boolean, arg3: Internal.Supplier_<Internal.PackResources_>, arg4: Internal.PackMetadataSection_, arg5: Internal.PackType_, arg6: Internal.Pack$Position_, arg7: Internal.PackSource_)
        open(): Internal.PackResources;
        isFixedPosition(): boolean;
        getPackSource(): Internal.PackSource;
        isHidden(): boolean;
        getId(): string;
        getChatLink(arg0: boolean): Internal.Component;
        static create(arg0: string, arg1: boolean, arg2: Internal.Supplier_<Internal.PackResources_>, arg3: Internal.Pack$PackConstructor_, arg4: Internal.Pack$Position_, arg5: Internal.PackSource_): Internal.Pack;
        hashCode(): number;
        isRequired(): boolean;
        close(): void;
        getTitle(): Internal.Component;
        equals(arg0: any): boolean;
        getDefaultPosition(): Internal.Pack$Position;
        getDescription(): Internal.Component;
        getCompatibility(): Internal.PackCompatibility;
        get fixedPosition(): boolean
        get packSource(): Internal.PackSource
        get hidden(): boolean
        get id(): string
        get required(): boolean
        get title(): Internal.Component
        get defaultPosition(): Internal.Pack$Position
        get description(): Internal.Component
        get compatibility(): Internal.PackCompatibility
    }
    type Pack_ = Pack;
    class SpawnPlacements$Type extends Internal.Enum<Internal.SpawnPlacements$Type> implements Internal.IExtensibleEnum {
        static values(): Internal.SpawnPlacements$Type[];
        static create(arg0: string, arg1: Internal.TriPredicate_<Internal.LevelReader_, BlockPos_, Internal.EntityType_<any>>): Internal.SpawnPlacements$Type;
        init(): void;
        static valueOf(arg0: string): Internal.SpawnPlacements$Type;
        canSpawnAt(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.EntityType_<any>): boolean;
        readonly static "ON_GROUND": Internal.SpawnPlacements$Type;
        readonly static "NO_RESTRICTIONS": Internal.SpawnPlacements$Type;
        readonly static "IN_WATER": Internal.SpawnPlacements$Type;
        readonly static "IN_LAVA": Internal.SpawnPlacements$Type;
    }
    type SpawnPlacements$Type_ = "in_lava" | "on_ground" | "in_water" | "no_restrictions" | SpawnPlacements$Type;
    class RenderStateShard$LayeringStateShard extends Internal.RenderStateShard {
        constructor(arg0: string, arg1: Internal.Runnable_, arg2: Internal.Runnable_)
    }
    type RenderStateShard$LayeringStateShard_ = RenderStateShard$LayeringStateShard;
    interface IIngameOverlay {
        render(arg0: Internal.ForgeIngameGui_, arg1: Internal.PoseStack_, arg2: number, arg3: number, arg4: number): void;
    }
    type IIngameOverlay_ = IIngameOverlay;
    class TargetingConditions {
        range(arg0: number): this;
        static forCombat(): Internal.TargetingConditions;
        static forNonCombat(): Internal.TargetingConditions;
        copy(): this;
        test(arg0: Internal.LivingEntity_, arg1: Internal.LivingEntity_): boolean;
        selector(arg0: Internal.Predicate_<Internal.LivingEntity_>): this;
        ignoreLineOfSight(): this;
        ignoreInvisibilityTesting(): this;
        readonly static "DEFAULT": Internal.TargetingConditions;
    }
    type TargetingConditions_ = TargetingConditions;
    class SimpleLevelEventJS extends Internal.LevelEventJS {
        constructor(l: Internal.LevelJS_)
        getLevel(): Internal.LevelJS;
        get level(): Internal.LevelJS
    }
    type SimpleLevelEventJS_ = SimpleLevelEventJS;
    abstract class Unit {
        constructor()
        lerp(a: Internal.Unit_, b: Internal.Unit_): this;
        log10(): this;
        boolNot(): this;
        add(value: number): this;
        or(other: Internal.Unit_): this;
        deg(): this;
        modSet(unit: Internal.Unit_): this;
        lte(other: Internal.Unit_): this;
        tan(): this;
        clamp(a: Internal.Unit_, b: Internal.Unit_): this;
        add(other: Internal.Unit_): this;
        pow(other: Internal.Unit_): this;
        set(unit: Internal.Unit_): this;
        bitOr(other: Internal.Unit_): this;
        lt(other: Internal.Unit_): this;
        lsh(other: Internal.Unit_): this;
        getFloat(variables: Internal.UnitVariables_): number;
        mod(value: number): this;
        sin(): this;
        rsh(other: Internal.Unit_): this;
        floor(): this;
        bitNot(): this;
        mul(other: Internal.Unit_): this;
        abs(): this;
        smoothstep(): this;
        mulSet(unit: Internal.Unit_): this;
        and(other: Internal.Unit_): this;
        isFixed(): boolean;
        positive(): this;
        toString(builder: Internal.StringBuilder_): void;
        bool(): this;
        max(other: Internal.Unit_): this;
        log1p(): this;
        ceil(): this;
        negate(): this;
        log(): this;
        withAlpha(a: Internal.Unit_): this;
        subSet(unit: Internal.Unit_): this;
        bitAnd(other: Internal.Unit_): this;
        div(other: Internal.Unit_): this;
        min(other: Internal.Unit_): this;
        cos(): this;
        div(value: number): this;
        addSet(unit: Internal.Unit_): this;
        mul(value: number): this;
        sq(): this;
        gte(other: Internal.Unit_): this;
        sqrt(): this;
        mod(other: Internal.Unit_): this;
        getInt(variables: Internal.UnitVariables_): number;
        toString(): string;
        sub(value: number): this;
        xor(other: Internal.Unit_): this;
        get(arg0: Internal.UnitVariables_): number;
        neq(other: Internal.Unit_): this;
        gt(other: Internal.Unit_): this;
        rad(): this;
        getBoolean(variables: Internal.UnitVariables_): boolean;
        eq(other: Internal.Unit_): this;
        sub(other: Internal.Unit_): this;
        atan(): this;
        atan2(other: Internal.Unit_): this;
        divSet(unit: Internal.Unit_): this;
        get fixed(): boolean
        static "EMPTY_ARRAY": any;
    }
    type Unit_ = Unit;
    class ZombieVillager extends Internal.Zombie implements Internal.VillagerDataHolder {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        setVillagerData(arg0: Internal.VillagerData_): void;
        setGossips(arg0: Internal.Tag_): void;
        getVillagerData(): Internal.VillagerData;
        getStepSound(): Internal.SoundEvent;
        setVillagerXp(arg0: number): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getDeathSound(): Internal.SoundEvent;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        getVillagerXp(): number;
        getAmbientSound(): Internal.SoundEvent;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        isConverting(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setTradeOffers(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        getVoicePitch(): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getClassification(arg0: boolean): Internal.MobCategory;
        removeWhenFarAway(arg0: number): boolean;
        getHurtSound(arg0: Internal.DamageSource_): Internal.SoundEvent;
        foodEatenKJS(is: Internal.ItemStack_): void;
        set villagerData(arg0: Internal.VillagerData_)
        set gossips(arg0: Internal.Tag_)
        get villagerData(): Internal.VillagerData
        get stepSound(): Internal.SoundEvent
        set villagerXp(arg0: number)
        get stepHeight(): number
        get multipartEntity(): boolean
        get deathSound(): Internal.SoundEvent
        get parts(): Internal.PartEntity<any>[]
        get villagerXp(): number
        get ambientSound(): Internal.SoundEvent
        get converting(): boolean
        set tradeOffers(arg0: Internal.CompoundTag_)
        get voicePitch(): number
    }
    type ZombieVillager_ = ZombieVillager;
    interface AlgorithmParameterSpec {
    }
    type AlgorithmParameterSpec_ = AlgorithmParameterSpec;
    class SectionPos extends Vec3i {
        static aroundChunk(arg0: Internal.ChunkPos_, arg1: number, arg2: number, arg3: number): Internal.Stream<Internal.SectionPos>;
        static of(arg0: number): Internal.SectionPos;
        static x(arg0: number): number;
        z(): number;
        x(): number;
        static z(arg0: number): number;
        minBlockZ(): number;
        minBlockX(): number;
        static sectionRelative(arg0: number): number;
        static aroundAndAtBlockPos(arg0: BlockPos_, arg1: it.unimi.dsi.fastutil.longs.LongConsumer_): void;
        relativeToBlockY(arg0: number): number;
        asLong(): number;
        static offset(arg0: number, arg1: number, arg2: number, arg3: number): number;
        static getZeroNode(arg0: number): number;
        static sectionRelativeY(arg0: number): number;
        blocksInside(): Internal.Stream<BlockPos>;
        origin(): BlockPos;
        static of(arg0: Internal.ChunkPos_, arg1: number): Internal.SectionPos;
        static offset(arg0: number, arg1: Internal.Direction_): number;
        static bottomOf(arg0: Internal.ChunkAccess_): Internal.SectionPos;
        maxBlockZ(): number;
        maxBlockX(): number;
        static y(arg0: number): number;
        y(): number;
        static sectionToBlockCoord(arg0: number, arg1: number): number;
        minBlockY(): number;
        static of(arg0: Internal.Entity_): Internal.SectionPos;
        static posToSectionCoord(arg0: number): number;
        static cube(arg0: Internal.SectionPos_, arg1: number): Internal.Stream<Internal.SectionPos>;
        static sectionToBlockCoord(arg0: number): number;
        center(): BlockPos;
        relativeToBlockX(arg0: number): number;
        static sectionRelativePos(arg0: BlockPos_): number;
        static sectionRelativeZ(arg0: number): number;
        relativeToBlockZ(arg0: number): number;
        static sectionRelativeX(arg0: number): number;
        static betweenClosedStream(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): Internal.Stream<Internal.SectionPos>;
        relativeToBlockPos(arg0: number): BlockPos;
        static asLong(arg0: number, arg1: number, arg2: number): number;
        static of(arg0: BlockPos_): Internal.SectionPos;
        static aroundAndAtBlockPos(arg0: number, arg1: number, arg2: number, arg3: it.unimi.dsi.fastutil.longs.LongConsumer_): void;
        static blockToSection(arg0: number): number;
        static aroundAndAtBlockPos(arg0: number, arg1: it.unimi.dsi.fastutil.longs.LongConsumer_): void;
        static asLong(arg0: BlockPos_): number;
        static blockToSectionCoord(arg0: number): number;
        offset(arg0: number, arg1: number, arg2: number): this;
        static of(arg0: number, arg1: number, arg2: number): Internal.SectionPos;
        maxBlockY(): number;
        chunk(): Internal.ChunkPos;
        readonly static "SECTION_BITS": 4;
        readonly static "SECTION_MASK": 15;
        readonly static "SECTION_HALF_SIZE": 8;
        readonly static "SECTION_MAX_INDEX": 15;
        readonly static "SECTION_SIZE": 16;
    }
    type SectionPos_ = SectionPos;
    class EnderDragonPhase <T> {
        static getCount(): number;
        toString(): string;
        static getById(arg0: number): Internal.EnderDragonPhase<any>;
        createInstance(arg0: Internal.EnderDragon_): Internal.DragonPhaseInstance;
        getId(): number;
        get count(): number
        get id(): number
        readonly static "DYING": Internal.EnderDragonPhase<any>;
        readonly static "HOLDING_PATTERN": Internal.EnderDragonPhase<any>;
        readonly static "LANDING": Internal.EnderDragonPhase<any>;
        readonly static "TAKEOFF": Internal.EnderDragonPhase<any>;
        readonly static "HOVERING": Internal.EnderDragonPhase<any>;
        readonly static "SITTING_FLAMING": Internal.EnderDragonPhase<any>;
        readonly static "SITTING_ATTACKING": Internal.EnderDragonPhase<any>;
        readonly static "CHARGING_PLAYER": Internal.EnderDragonPhase<any>;
        readonly static "STRAFE_PLAYER": Internal.EnderDragonPhase<any>;
        readonly static "SITTING_SCANNING": Internal.EnderDragonPhase<any>;
        readonly static "LANDING_APPROACH": Internal.EnderDragonPhase<any>;
    }
    type EnderDragonPhase_<T> = EnderDragonPhase<T>;
    class Matrix3f {
        constructor()
        constructor(arg0: Internal.Matrix4f_)
        constructor(arg0: Internal.Quaternion_)
        constructor(arg0: Internal.Matrix3f_)
        storeTransposed(arg0: Internal.FloatBuffer_): void;
        store(arg0: Internal.FloatBuffer_, arg1: boolean): void;
        sub(arg0: Internal.Matrix3f_): void;
        trace(): number;
        mul(arg0: Internal.Quaternion_): void;
        adjugateAndDet(): number;
        static createScaleMatrix(arg0: number, arg1: number, arg2: number): Internal.Matrix3f;
        load(arg0: Internal.FloatBuffer_): void;
        setIdentity(): void;
        invert(): boolean;
        mul(arg0: number): void;
        add(arg0: Internal.Matrix3f_): void;
        loadTransposed(arg0: Internal.FloatBuffer_): void;
        toString(): string;
        multiplyBackward(arg0: Internal.Matrix3f_): void;
        load(arg0: Internal.Matrix3f_): void;
        load(arg0: Internal.FloatBuffer_, arg1: boolean): void;
        svdDecompose(): Internal.Triple<Internal.Quaternion, Internal.Vector3f, Internal.Quaternion>;
        hashCode(): number;
        store(arg0: Internal.FloatBuffer_): void;
        transpose(): void;
        mul(arg0: Internal.Matrix3f_): void;
        determinant(): number;
        equals(arg0: any): boolean;
        set(arg0: number, arg1: number, arg2: number): void;
        copy(): this;
    }
    type Matrix3f_ = Matrix3f;
    interface InjectedBlockExtension extends Internal.InjectedRegistryEntryExtension<Internal.Block> {
        arch$holder(): Internal.Holder<Internal.Block>;
        arch$registryName(): ResourceLocation;
    }
    type InjectedBlockExtension_ = InjectedBlockExtension;
    class PlayerEvent$Clone extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.Player_, arg2: boolean)
        getOriginal(): Internal.Player;
        isWasDeath(): boolean;
        getListenerList(): Internal.ListenerList;
        get original(): Internal.Player
        get wasDeath(): boolean
        get listenerList(): Internal.ListenerList
    }
    type PlayerEvent$Clone_ = PlayerEvent$Clone;
    class PlayerEvent$NameFormat extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.Component_)
        getDisplayname(): Internal.Component;
        setDisplayname(arg0: Internal.Component_): void;
        getListenerList(): Internal.ListenerList;
        getUsername(): Internal.Component;
        get displayname(): Internal.Component
        set displayname(arg0: Internal.Component_)
        get listenerList(): Internal.ListenerList
        get username(): Internal.Component
    }
    type PlayerEvent$NameFormat_ = PlayerEvent$NameFormat;
    class TickEvent$ClientTickEvent extends Internal.TickEvent {
        constructor()
        constructor(arg0: Internal.TickEvent$Phase_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type TickEvent$ClientTickEvent_ = TickEvent$ClientTickEvent;
    class ScreenPaintEventJS extends Internal.PaintEventJS implements Internal.UnitVariables {
        constructor(m: Internal.Minecraft_, s: Internal.Screen_, ps: Internal.PoseStack_, mx: number, my: number, d: number)
        constructor(m: Internal.Minecraft_, ps: Internal.PoseStack_, d: number)
        rectangle(x: number, y: number, z: number, w: number, h: number, color: number): void;
        rawText(text: Internal.FormattedCharSequence_, x: number, y: number, color: number, shadow: boolean): void;
        scale(scale: number): void;
        alignY(y: number, h: number, alignY: number): number;
        text(text: Internal.Component_, x: number, y: number, color: number, shadow: boolean): void;
        getVariables(): Internal.VariableSet;
        alignX(x: number, w: number, alignX: number): number;
        translate(x: number, y: number): void;
        rotateDeg(angle: number): void;
        rotateRad(angle: number): void;
        rectangle(x: number, y: number, z: number, w: number, h: number, color: number, u0: number, v0: number, u1: number, v1: number): void;
        scale(x: number, y: number): void;
        get variables(): Internal.VariableSet
        readonly "width": number;
        readonly "mouseY": number;
        readonly "inventory": boolean;
        readonly "height": number;
        readonly "mouseX": number;
    }
    type ScreenPaintEventJS_ = ScreenPaintEventJS;
    class RenderGameOverlayEvent$ElementType extends Internal.Enum<Internal.RenderGameOverlayEvent$ElementType> {
        static values(): Internal.RenderGameOverlayEvent$ElementType[];
        static valueOf(arg0: string): Internal.RenderGameOverlayEvent$ElementType;
        readonly static "CHAT": Internal.RenderGameOverlayEvent$ElementType;
        readonly static "DEBUG": Internal.RenderGameOverlayEvent$ElementType;
        readonly static "TEXT": Internal.RenderGameOverlayEvent$ElementType;
        readonly static "ALL": Internal.RenderGameOverlayEvent$ElementType;
        readonly static "LAYER": Internal.RenderGameOverlayEvent$ElementType;
        readonly static "PLAYER_LIST": Internal.RenderGameOverlayEvent$ElementType;
        readonly static "BOSSINFO": Internal.RenderGameOverlayEvent$ElementType;
    }
    type RenderGameOverlayEvent$ElementType_ = "chat" | "text" | RenderGameOverlayEvent$ElementType | "debug" | "player_list" | "layer" | "bossinfo" | "all";
    class RegistryAccess$RegistryEntry <T> extends Internal.Record {
        constructor(key: Internal.ResourceKey_<any>, value: Internal.Registry_<T>)
        hashCode(): number;
        toString(): string;
        key(): Internal.ResourceKey<any>;
        equals(arg0: any): boolean;
        value(): Internal.Registry<T>;
    }
    type RegistryAccess$RegistryEntry_<T> = RegistryAccess$RegistryEntry<T>;
    class LevelStorageSource {
        constructor(arg0: Internal.Path_, arg1: Internal.Path_, arg2: Internal.DataFixer_)
        getBaseDir(): Internal.Path;
        getBackupPath(): Internal.Path;
        getName(): string;
        static createDefault(arg0: Internal.Path_): Internal.LevelStorageSource;
        getLevelList(): Internal.List<Internal.LevelSummary>;
        createAccess(arg0: string): Internal.LevelStorageSource$LevelStorageAccess;
        isNewLevelIdAcceptable(arg0: string): boolean;
        levelExists(arg0: string): boolean;
        get baseDir(): Internal.Path
        get backupPath(): Internal.Path
        get name(): string
        get levelList(): Internal.List<Internal.LevelSummary>
    }
    type LevelStorageSource_ = LevelStorageSource;
    interface ConditionContainer {
        entityProperties(entity: Internal.LootContext$EntityTarget_, properties: Internal.JsonObject_): this;
        addCondition(arg0: Internal.JsonObject_): this;
        randomChance(chance: number): this;
        randomChanceWithLooting(chance: number, multiplier: number): this;
        killedByPlayer(): this;
        entityScores(entity: Internal.LootContext$EntityTarget_, scores: Internal.Map_<string, any>): this;
        survivesExplosion(): this;
    }
    type ConditionContainer_ = ConditionContainer;
    class SkeletonHorse extends Internal.AbstractHorse {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getMobType(): Internal.MobType;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        isTrap(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        setTrap(arg0: boolean): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getPassengersRidingOffset(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        rideableUnderWater(): boolean;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get mobType(): Internal.MobType
        get stepHeight(): number
        get trap(): boolean
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        set trap(arg0: boolean)
        get passengersRidingOffset(): number
    }
    type SkeletonHorse_ = SkeletonHorse;
    interface BlockBehaviour$StateArgumentPredicate <A> {
        test(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: A): boolean;
    }
    type BlockBehaviour$StateArgumentPredicate_<A> = BlockBehaviour$StateArgumentPredicate<A>;
    interface ChannelInboundInvoker {
        fireChannelWritabilityChanged(): this;
        fireExceptionCaught(arg0: Internal.Throwable_): this;
        fireChannelUnregistered(): this;
        fireChannelRead(arg0: any): this;
        fireChannelReadComplete(): this;
        fireChannelRegistered(): this;
        fireChannelActive(): this;
        fireChannelInactive(): this;
        fireUserEventTriggered(arg0: any): this;
    }
    type ChannelInboundInvoker_ = ChannelInboundInvoker;
    class RenderTooltipEvent$GatherComponents extends Internal.Event {
        constructor()
        constructor(arg0: Internal.ItemStack_, arg1: number, arg2: number, arg3: Internal.List_<Internal.Either_<Internal.FormattedText_, Internal.TooltipComponent_>>, arg4: number)
        getMaxWidth(): number;
        isCancelable(): boolean;
        getScreenHeight(): number;
        getScreenWidth(): number;
        getListenerList(): Internal.ListenerList;
        setMaxWidth(arg0: number): void;
        getTooltipElements(): Internal.List<Internal.Either<Internal.FormattedText, Internal.TooltipComponent>>;
        getItemStack(): Internal.ItemStack;
        get maxWidth(): number
        get cancelable(): boolean
        get screenHeight(): number
        get screenWidth(): number
        get listenerList(): Internal.ListenerList
        set maxWidth(arg0: number)
        get tooltipElements(): Internal.List<Internal.Either<Internal.FormattedText, Internal.TooltipComponent>>
        get itemStack(): Internal.ItemStack
    }
    type RenderTooltipEvent$GatherComponents_ = RenderTooltipEvent$GatherComponents;
    class Raids extends Internal.SavedData {
        constructor(arg0: Internal.ServerLevel_)
        static load(arg0: Internal.ServerLevel_, arg1: Internal.CompoundTag_): Internal.Raids;
        get(arg0: number): Internal.Raid;
        createOrExtendRaid(arg0: Internal.ServerPlayer_): Internal.Raid;
        getNearbyRaid(arg0: BlockPos_, arg1: number): Internal.Raid;
        static getFileId(arg0: Internal.Holder_<Internal.DimensionType_>): string;
        static canJoinRaid(arg0: Internal.Raider_, arg1: Internal.Raid_): boolean;
        save(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        tick(): void;
    }
    type Raids_ = Raids;
    class StructureSet extends Internal.Record {
        constructor(arg0: Internal.Holder_<Internal.ConfiguredStructureFeature_<any, any>>, arg1: Internal.StructurePlacement_)
        constructor(arg0: Internal.List_<Internal.StructureSet$StructureSelectionEntry_>, arg1: Internal.StructurePlacement_)
        hashCode(): number;
        toString(): string;
        static entry(arg0: Internal.Holder_<Internal.ConfiguredStructureFeature_<any, any>>, arg1: number): Internal.StructureSet$StructureSelectionEntry;
        equals(arg0: any): boolean;
        static entry(arg0: Internal.Holder_<Internal.ConfiguredStructureFeature_<any, any>>): Internal.StructureSet$StructureSelectionEntry;
        placement(): Internal.StructurePlacement;
        structures(): Internal.List<Internal.StructureSet$StructureSelectionEntry>;
        readonly static "CODEC": any;
        readonly static "DIRECT_CODEC": any;
    }
    type StructureSet_ = StructureSet | Special.StructureSet;
    class PrioritizeChunkUpdates extends Internal.Enum<Internal.PrioritizeChunkUpdates> {
        static valueOf(arg0: string): Internal.PrioritizeChunkUpdates;
        getKey(): string;
        static byId(arg0: number): Internal.PrioritizeChunkUpdates;
        static values(): Internal.PrioritizeChunkUpdates[];
        getId(): number;
        get key(): string
        get id(): number
        readonly static "NEARBY": Internal.PrioritizeChunkUpdates;
        readonly static "NONE": Internal.PrioritizeChunkUpdates;
        readonly static "PLAYER_AFFECTED": Internal.PrioritizeChunkUpdates;
    }
    type PrioritizeChunkUpdates_ = "nearby" | PrioritizeChunkUpdates | "player_affected" | "none";
    interface ChannelHandler {
        exceptionCaught(arg0: Internal.ChannelHandlerContext_, arg1: Internal.Throwable_): void;
        handlerAdded(arg0: Internal.ChannelHandlerContext_): void;
        handlerRemoved(arg0: Internal.ChannelHandlerContext_): void;
    }
    type ChannelHandler_ = ChannelHandler;
    interface StructurePieceType {
        load(arg0: Internal.StructurePieceSerializationContext_, arg1: Internal.CompoundTag_): Internal.StructurePiece;
        readonly static "STRONGHOLD_ROOM_CROSSING": any;
        readonly static "STRONGHOLD_FILLER_CORRIDOR": any;
        readonly static "STRONGHOLD_PORTAL_ROOM": any;
        readonly static "END_CITY_PIECE": any;
        readonly static "NETHER_FORTRESS_BRIDGE_END_FILLER": any;
        readonly static "NETHER_FORTRESS_CASTLE_CORRIDOR_STAIRS": any;
        readonly static "OCEAN_MONUMENT_SIMPLE_ROOM": any;
        readonly static "STRONGHOLD_LEFT_TURN": any;
        readonly static "OCEAN_MONUMENT_WING_ROOM": any;
        readonly static "NETHER_FORTRESS_CASTLE_STALK_ROOM": any;
        readonly static "MINE_SHAFT_ROOM": any;
        readonly static "NETHER_FORTRESS_CASTLE_CORRIDOR_T_BALCONY": any;
        readonly static "OCEAN_MONUMENT_SIMPLE_TOP_ROOM": any;
        readonly static "MINE_SHAFT_CORRIDOR": any;
        readonly static "OCEAN_MONUMENT_DOUBLE_Y_ROOM": any;
        readonly static "OCEAN_MONUMENT_BUILDING": any;
        readonly static "OCEAN_MONUMENT_PENTHOUSE": any;
        readonly static "JUNGLE_PYRAMID_PIECE": any;
        readonly static "NETHER_FORTRESS_BRIDGE_CROSSING": any;
        readonly static "NETHER_FORTRESS_MONSTER_THRONE": any;
        readonly static "JIGSAW": any;
        readonly static "NETHER_FORTRESS_CASTLE_SMALL_CORRIDOR_RIGHT_TURN": any;
        readonly static "STRONGHOLD_START": any;
        readonly static "STRONGHOLD_PRISON_HALL": any;
        readonly static "RUINED_PORTAL": any;
        readonly static "NETHER_FORTRESS_START": any;
        readonly static "OCEAN_MONUMENT_DOUBLE_YZ_ROOM": any;
        readonly static "SHIPWRECK_PIECE": any;
        readonly static "SWAMPLAND_HUT": any;
        readonly static "STRONGHOLD_STRAIGHT": any;
        readonly static "OCEAN_MONUMENT_DOUBLE_X_ROOM": any;
        readonly static "OCEAN_MONUMENT_ENTRY_ROOM": any;
        readonly static "OCEAN_MONUMENT_CORE_ROOM": any;
        readonly static "STRONGHOLD_CHEST_CORRIDOR": any;
        readonly static "STRONGHOLD_LIBRARY": any;
        readonly static "OCEAN_MONUMENT_DOUBLE_XY_ROOM": any;
        readonly static "OCEAN_MONUMENT_DOUBLE_Z_ROOM": any;
        readonly static "WOODLAND_MANSION_PIECE": any;
        readonly static "NETHER_FORTRESS_CASTLE_SMALL_CORRIDOR_CROSSING": any;
        readonly static "OCEAN_RUIN": any;
        readonly static "MINE_SHAFT_CROSSING": any;
        readonly static "NETHER_FORTRESS_STAIRS_ROOM": any;
        readonly static "STRONGHOLD_RIGHT_TURN": any;
        readonly static "STRONGHOLD_STAIRS_DOWN": any;
        readonly static "NETHER_FOSSIL": any;
        readonly static "STRONGHOLD_STRAIGHT_STAIRS_DOWN": any;
        readonly static "NETHER_FORTRESS_ROOM_CROSSING": any;
        readonly static "NETHER_FORTRESS_BRIDGE_STRAIGHT": any;
        readonly static "IGLOO": any;
        readonly static "STRONGHOLD_FIVE_CROSSING": any;
        readonly static "NETHER_FORTRESS_CASTLE_ENTRANCE": any;
        readonly static "DESERT_PYRAMID_PIECE": any;
        readonly static "NETHER_FORTRESS_CASTLE_SMALL_CORRIDOR": any;
        readonly static "MINE_SHAFT_STAIRS": any;
        readonly static "NETHER_FORTRESS_CASTLE_SMALL_CORRIDOR_LEFT_TURN": any;
        readonly static "BURIED_TREASURE_PIECE": any;
    }
    type StructurePieceType_ = StructurePieceType | Special.StructurePieceType;
    interface ShortConsumer extends Internal.Consumer<number>, Internal.IntConsumer {
        accept(arg0: number): void;
        andThen(arg0: Internal.ShortConsumer_): this;
        accept(arg0: any): void;
        accept(arg0: number): void;
        andThen(arg0: Internal.Consumer_<any>): Internal.Consumer<number>;
        andThen(arg0: Internal.IntConsumer_): Internal.IntConsumer;
        accept(arg0: number): void;
    }
    type ShortConsumer_ = ShortConsumer | ((arg0: number)=>void);
    class NetworkEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.Supplier_<Internal.NetworkEvent$Context_>)
        getLoginIndex(): number;
        getListenerList(): Internal.ListenerList;
        getPayload(): Internal.FriendlyByteBuf;
        getSource(): Internal.Supplier<Internal.NetworkEvent$Context>;
        get loginIndex(): number
        get listenerList(): Internal.ListenerList
        get payload(): Internal.FriendlyByteBuf
        get source(): Internal.Supplier<Internal.NetworkEvent$Context>
    }
    type NetworkEvent_ = NetworkEvent;
    class EnderChestBlockEntity extends Internal.BlockEntity implements Internal.LidBlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        stopOpen(arg0: Internal.Player_): void;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        triggerEvent(arg0: number, arg1: number): boolean;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getOpenNess(arg0: number): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        static lidAnimateTick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.EnderChestBlockEntity_): void;
        serializeNBT(): Internal.CompoundTag;
        startOpen(arg0: Internal.Player_): void;
        stillValid(arg0: Internal.Player_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        recheckOpen(): void;
        onLoad(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get modelData(): Internal.IModelData
        get renderBoundingBox(): Internal.AABB
    }
    type EnderChestBlockEntity_ = EnderChestBlockEntity;
    interface TypeRewriteRule {
        seq(arg0: Internal.List_<Internal.TypeRewriteRule_>): this;
        everywhere(arg0: Internal.TypeRewriteRule_, arg1: Internal.PointFreeRule_, arg2: boolean, arg3: boolean): this;
        nop(): this;
        seq(arg0: Internal.TypeRewriteRule_, arg1: Internal.TypeRewriteRule_): this;
        seq(arg0: Internal.TypeRewriteRule_, ...arg1: Internal.TypeRewriteRule_[]): this;
        rewrite(arg0: com.mojang.datafixers.types.Type_<A>): Internal.Optional<Internal.RewriteResult<A, any>>;
        checkOnce(arg0: Internal.TypeRewriteRule_, arg1: Internal.Consumer_<com.mojang.datafixers.types.Type_<any>>): this;
        all(arg0: Internal.TypeRewriteRule_, arg1: boolean, arg2: boolean): this;
        orElse(arg0: Internal.TypeRewriteRule_, arg1: Internal.Supplier_<Internal.TypeRewriteRule_>): this;
        once(arg0: Internal.TypeRewriteRule_): this;
        orElse(arg0: Internal.TypeRewriteRule_, arg1: Internal.TypeRewriteRule_): this;
        ifSame(arg0: com.mojang.datafixers.types.Type_<B>, arg1: Internal.RewriteResult_<B, any>): this;
        one(arg0: Internal.TypeRewriteRule_): this;
    }
    type TypeRewriteRule_ = TypeRewriteRule;
    interface InjectedLiquidBlockExtension {
        arch$getFluid(): Internal.FlowingFluid;
    }
    type InjectedLiquidBlockExtension_ = InjectedLiquidBlockExtension;
    class FluidBucketItemBuilder extends Internal.ItemBuilder {
        constructor(b: Internal.FluidBuilder_)
        clientRegistry(minecraft: Internal.Supplier_<Internal.Minecraft_>): void;
        createObject(): any;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        readonly "fluidBuilder": Internal.FluidBuilder;
    }
    type FluidBucketItemBuilder_ = FluidBucketItemBuilder;
    class ItemOverrides {
        constructor(arg0: any_, arg1: any_, arg2: Internal.Function_<ResourceLocation_, any_>, arg3: Internal.Function_<any_, Internal.TextureAtlasSprite_>, arg4: Internal.List_<any_>)
        constructor(arg0: any_, arg1: any_, arg2: Internal.Function_<ResourceLocation_, any_>, arg3: Internal.List_<any_>)
        getOverrides(): Internal.ImmutableList<Internal.ItemOverrides$BakedOverride>;
        resolve(arg0: Internal.BakedModel_, arg1: Internal.ItemStack_, arg2: Internal.ClientLevel_, arg3: Internal.LivingEntity_, arg4: number): Internal.BakedModel;
        get overrides(): Internal.ImmutableList<Internal.ItemOverrides$BakedOverride>
        readonly static "EMPTY": Internal.ItemOverrides;
    }
    type ItemOverrides_ = ItemOverrides;
    interface FunctionFactory$FuncSupplier {
        create(arg0: Internal.Unit_[]): Internal.Unit;
    }
    type FunctionFactory$FuncSupplier_ = FunctionFactory$FuncSupplier | ((arg0: Internal.Unit[])=>Internal.Unit_);
    class MobSpawnSettings {
        getCreatureProbability(): number;
        getMobs(arg0: Internal.MobCategory_): Internal.WeightedRandomList<Internal.MobSpawnSettings$SpawnerData>;
        getEntityTypes(): Internal.Set<Internal.EntityType<any>>;
        getSpawnerTypes(): Internal.Set<Internal.MobCategory>;
        getMobSpawnCost(arg0: Internal.EntityType_<any>): Internal.MobSpawnSettings$MobSpawnCost;
        get creatureProbability(): number
        get entityTypes(): Internal.Set<Internal.EntityType<any>>
        get spawnerTypes(): Internal.Set<Internal.MobCategory>
        readonly static "EMPTY_MOB_LIST": Internal.WeightedRandomList<any>;
        readonly static "EMPTY": Internal.MobSpawnSettings;
        readonly static "CODEC": any;
    }
    type MobSpawnSettings_ = MobSpawnSettings;
    interface LevelWriter {
        destroyBlock(arg0: BlockPos_, arg1: boolean, arg2: Internal.Entity_, arg3: number): boolean;
        setBlock(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: number): boolean;
        setBlock(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: number, arg3: number): boolean;
        addFreshEntity(arg0: Internal.Entity_): boolean;
        destroyBlock(arg0: BlockPos_, arg1: boolean, arg2: Internal.Entity_): boolean;
        removeBlock(arg0: BlockPos_, arg1: boolean): boolean;
        destroyBlock(arg0: BlockPos_, arg1: boolean): boolean;
    }
    type LevelWriter_ = LevelWriter;
    abstract class ScreenEvent$MouseClickedEvent extends Internal.ScreenEvent$MouseInputEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number, arg3: number)
        getButton(): number;
        getListenerList(): Internal.ListenerList;
        get button(): number
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$MouseClickedEvent_ = ScreenEvent$MouseClickedEvent;
    interface Channel extends Internal.Closeable {
        isOpen(): boolean;
        close(): void;
        get open(): boolean
    }
    type Channel_ = Channel;
    class Context {
        setMaximumInterpreterStackDepth(max: number): void;
        executeScriptWithContinuations(script: Internal.Script_, scope: Internal.Scriptable_): any;
        static getSourcePositionFromStack(linep: number[]): string;
        static throwAsScriptRuntimeEx(e: Internal.Throwable_): Internal.RuntimeException;
        getElements(object: Internal.Scriptable_): any[];
        initSafeStandardObjects(scope: Internal.ScriptableObject_): Internal.Scriptable;
        setApplicationClassLoader(loader: Internal.ClassLoader_): void;
        static reportRuntimeError0(messageId: string): Internal.EvaluatorException;
        putThreadLocal(key: any, value: any): void;
        setGenerateObserverCount(generateObserverCount: boolean): void;
        static enterWithNewFactory(): Internal.Context;
        static enter(): Internal.Context;
        static reportRuntimeError3(messageId: string, arg1: any, arg2: any, arg3: any): Internal.EvaluatorException;
        static reportRuntimeError1(messageId: string, arg1: any): Internal.EvaluatorException;
        setLanguageVersion(version: number): void;
        static toString(value: any): string;
        static reportRuntimeError(message: string): Internal.EvaluatorException;
        static exit(): void;
        createClassLoader(parent: Internal.ClassLoader_): Internal.GeneratedClassLoader;
        evaluateReader(scope: Internal.Scriptable_, in_: Internal.Reader_, sourceName: string, lineno: number, securityDomain: any): any;
        newObject(scope: Internal.Scriptable_): Internal.Scriptable;
        static call(factory: Internal.ContextFactory_, callable: dev.latvian.mods.rhino.Callable_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        static toNumber(value: any): number;
        newObject(scope: Internal.Scriptable_, constructorName: string, args: any[]): Internal.Scriptable;
        getInstructionObserverThreshold(): number;
        getFactory(): Internal.ContextFactory;
        compileFunction(scope: Internal.Scriptable_, source: string, sourceName: string, lineno: number, securityDomain: any): dev.latvian.mods.rhino.Function;
        static toBoolean(value: any): boolean;
        getThreadLocal(key: any): any;
        static reportWarning(message: string, t: Internal.Throwable_): void;
        callFunctionWithContinuations(function_: dev.latvian.mods.rhino.Callable_, scope: Internal.Scriptable_, args: any[]): any;
        static reportError(message: string, sourceName: string, lineno: number, lineSource: string, lineOffset: number): void;
        stringIsCompilableUnit(source: string): boolean;
        newArray(scope: Internal.Scriptable_, elements: any[]): Internal.Scriptable;
        getErrorReporter(): Internal.ErrorReporter;
        initSafeStandardObjects(): Internal.ScriptableObject;
        seal(sealKey: any): void;
        getImplementationVersion(): string;
        static reportRuntimeError4(messageId: string, arg1: any, arg2: any, arg3: any, arg4: any): Internal.EvaluatorException;
        static jsToJava(data: Internal.SharedContextData_, value: any, desiredType: Internal.Class_<any>): any;
        static reportRuntimeError(message: string, sourceName: string, lineno: number, lineSource: string, lineOffset: number): Internal.EvaluatorException;
        removePropertyChangeListener(l: Internal.PropertyChangeListener_): void;
        captureContinuation(): Internal.ContinuationPending;
        initStandardObjects(scope: Internal.ScriptableObject_, sealed: boolean): Internal.ScriptableObject;
        resumeContinuation(continuation: any, scope: Internal.Scriptable_, functionResult: any): any;
        initStandardObjects(): Internal.ScriptableObject;
        initStandardObjects(scope: Internal.ScriptableObject_): Internal.Scriptable;
        compileString(source: string, sourceName: string, lineno: number, securityDomain: any): Internal.Script;
        static getContext(): Internal.Context;
        initSafeStandardObjects(scope: Internal.ScriptableObject_, sealed: boolean): Internal.ScriptableObject;
        static reportRuntimeError2(messageId: string, arg1: any, arg2: any): Internal.EvaluatorException;
        getMaximumInterpreterStackDepth(): number;
        static getUndefinedValue(): any;
        newObject(scope: Internal.Scriptable_, constructorName: string): Internal.Scriptable;
        static javaToJS(contextData: Internal.SharedContextData_, value: any, scope: Internal.Scriptable_): any;
        static getCurrentContext(): Internal.Context;
        evaluateString(scope: Internal.Scriptable_, source: string, sourceName: string, lineno: number, securityDomain: any): any;
        setInstructionObserverThreshold(threshold: number): void;
        isSealed(): boolean;
        removeThreadLocal(key: any): void;
        isStrictMode(): boolean;
        static reportWarning(message: string, sourceName: string, lineno: number, lineSource: string, lineOffset: number): void;
        static reportWarning(message: string): void;
        setErrorReporter(reporter: Internal.ErrorReporter_): Internal.ErrorReporter;
        static toObject(value: any, scope: Internal.Scriptable_): Internal.Scriptable;
        compileReader(in_: Internal.Reader_, sourceName: string, lineno: number, securityDomain: any): Internal.Script;
        static reportError(message: string): void;
        unseal(sealKey: any): void;
        addPropertyChangeListener(l: Internal.PropertyChangeListener_): void;
        newArray(scope: Internal.Scriptable_, length: number): Internal.Scriptable;
        getApplicationClassLoader(): Internal.ClassLoader;
        set maximumInterpreterStackDepth(max: number)
        set applicationClassLoader(loader: Internal.ClassLoader_)
        set generateObserverCount(generateObserverCount: boolean)
        set languageVersion(version: number)
        get instructionObserverThreshold(): number
        get factory(): Internal.ContextFactory
        get errorReporter(): Internal.ErrorReporter
        get implementationVersion(): string
        get context(): Internal.Context
        get maximumInterpreterStackDepth(): number
        get undefinedValue(): any
        get currentContext(): Internal.Context
        set instructionObserverThreshold(threshold: number)
        get sealed(): boolean
        get strictMode(): boolean
        set errorReporter(reporter: Internal.ErrorReporter_)
        get applicationClassLoader(): Internal.ClassLoader
        readonly static "languageVersionProperty": "language version";
        "sharedContextData": Internal.SharedContextData;
        readonly static "errorReporterProperty": "error reporter";
        "generateObserverCount": boolean;
    }
    type Context_ = Context;
    abstract class LootEventJS extends Internal.EventJS {
        constructor(c: Internal.Map_<ResourceLocation_, Internal.JsonElement_>)
        removeAll(): void;
        modify(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        addJson(id: ResourceLocation_, json: Internal.JsonObject_): void;
        getType(): string;
        getDirectory(): string;
        get type(): string
        get directory(): string
    }
    type LootEventJS_ = LootEventJS;
    class UpgradeRecipe implements Internal.Recipe<Internal.Container> {
        constructor(arg0: ResourceLocation_, arg1: Internal.Ingredient_, arg2: Internal.Ingredient_, arg3: Internal.ItemStack_)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        isSpecial(): boolean;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        getSerializer(): Internal.RecipeSerializer<any>;
        getId(): ResourceLocation;
        isIncomplete(): boolean;
        isAdditionIngredient(arg0: Internal.ItemStack_): boolean;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getResultItem(): Internal.ItemStack;
        getRemainingItems(arg0: Internal.Container_): Internal.NonNullList<Internal.ItemStack>;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get special(): boolean
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get serializer(): Internal.RecipeSerializer<any>
        get id(): ResourceLocation
        get incomplete(): boolean
        get resultItem(): Internal.ItemStack
    }
    type UpgradeRecipe_ = UpgradeRecipe;
    class MultipartBlockStateGenerator$Part {
        constructor()
        model(s: string): Internal.VariantBlockStateGenerator$Model;
        toJson(): Internal.JsonObject;
    }
    type MultipartBlockStateGenerator$Part_ = MultipartBlockStateGenerator$Part;
    class NativeContinuation extends Internal.IdScriptableObject implements dev.latvian.mods.rhino.Function {
        constructor()
        getImplementation(): any;
        initImplementation(implementation: any): void;
        call(cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        static isContinuationConstructor(f: Internal.IdFunctionObject_): boolean;
        getClassName(): string;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getAllIds(): any[];
        static equalImplementations(c1: Internal.NativeContinuation_, c2: Internal.NativeContinuation_): boolean;
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        execIdCall(f: Internal.IdFunctionObject_, cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        getTypeOf(): Internal.MemberType;
        construct(cx: Internal.Context_, scope: Internal.Scriptable_, args: any[]): Internal.Scriptable;
        static init(cx: Internal.Context_, scope: Internal.Scriptable_, sealed: boolean): void;
        get implementation(): any
        get className(): string
        get allIds(): any[]
        get typeOf(): Internal.MemberType
    }
    type NativeContinuation_ = NativeContinuation;
    class ThreadedLevelLightEngine extends Internal.LevelLightEngine implements Internal.AutoCloseable {
        constructor(arg0: Internal.LightChunkGetter_, arg1: any_, arg2: boolean, arg3: any_<Internal.Runnable_>, arg4: Internal.ProcessorHandle_<any_<Internal.Runnable_>>)
        lightChunk(arg0: Internal.ChunkAccess_, arg1: boolean): Internal.CompletableFuture<Internal.ChunkAccess>;
        checkBlock(arg0: BlockPos_): void;
        setTaskPerBatch(arg0: number): void;
        runUpdates(arg0: number, arg1: boolean, arg2: boolean): number;
        queueSectionData(arg0: Internal.LightLayer_, arg1: Internal.SectionPos_, arg2: Internal.DataLayer_, arg3: boolean): void;
        close(): void;
        updateSectionStatus(arg0: BlockPos_, arg1: boolean): void;
        retainData(arg0: Internal.ChunkPos_, arg1: boolean): void;
        enableLightSources(arg0: Internal.ChunkPos_, arg1: boolean): void;
        tryScheduleUpdate(): void;
        onBlockEmissionIncrease(arg0: BlockPos_, arg1: number): void;
        updateSectionStatus(arg0: Internal.SectionPos_, arg1: boolean): void;
        set taskPerBatch(arg0: number)
    }
    type ThreadedLevelLightEngine_ = ThreadedLevelLightEngine;
    interface SecureRandomParameters {
    }
    type SecureRandomParameters_ = SecureRandomParameters;
    class PoiType extends Internal.ForgeRegistryEntry<Internal.PoiType> {
        constructor(arg0: string, arg1: Internal.Set_<Internal.BlockState_>, arg2: number, arg3: Internal.Predicate_<Internal.PoiType_>, arg4: number)
        constructor(arg0: string, arg1: Internal.Set_<Internal.BlockState_>, arg2: number, arg3: number)
        static forState(arg0: Internal.BlockState_): Internal.Optional<Internal.PoiType>;
        getPredicate(): Internal.Predicate<Internal.PoiType>;
        getBlockStates(): Internal.ImmutableSet<Internal.BlockState>;
        getMaxTickets(): number;
        toString(): string;
        is(arg0: Internal.BlockState_): boolean;
        getName(): string;
        getValidRange(): number;
        static getBlockStates(arg0: Internal.Block_): Internal.Set<Internal.BlockState>;
        get predicate(): Internal.Predicate<Internal.PoiType>
        get blockStates(): Internal.ImmutableSet<Internal.BlockState>
        get maxTickets(): number
        get name(): string
        get validRange(): number
        readonly static "WEAPONSMITH": Internal.PoiType;
        readonly static "LIGHTNING_ROD": Internal.PoiType;
        readonly static "TOOLSMITH": Internal.PoiType;
        readonly static "BUTCHER": Internal.PoiType;
        readonly static "CLERIC": Internal.PoiType;
        readonly static "ARMORER": Internal.PoiType;
        readonly static "MASON": Internal.PoiType;
        readonly static "CARTOGRAPHER": Internal.PoiType;
        readonly static "SHEPHERD": Internal.PoiType;
        readonly static "BEE_NEST": Internal.PoiType;
        readonly static "FLETCHER": Internal.PoiType;
        readonly static "HOME": Internal.PoiType;
        readonly static "ALL": any;
        readonly static "UNEMPLOYED": Internal.PoiType;
        readonly static "LIBRARIAN": Internal.PoiType;
        readonly static "NETHER_PORTAL": Internal.PoiType;
        readonly static "ALL_JOBS": any;
        readonly static "BEEHIVE": Internal.PoiType;
        readonly static "NITWIT": Internal.PoiType;
        readonly static "LEATHERWORKER": Internal.PoiType;
        readonly static "FARMER": Internal.PoiType;
        readonly static "LODESTONE": Internal.PoiType;
        readonly static "MEETING": Internal.PoiType;
        readonly static "FISHERMAN": Internal.PoiType;
    }
    type PoiType_ = PoiType | Special.PoiType;
    class Phantom extends Internal.FlyingMob implements Internal.Enemy {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getMobType(): Internal.MobType;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        setPhantomSize(arg0: number): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        getSoundSource(): Internal.SoundSource;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRenderAtSqrDistance(arg0: number): boolean;
        getDimensions(arg0: Internal.Pose_): Internal.EntityDimensions;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPhantomSize(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        isFlapping(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getUniqueFlapTickOffset(): number;
        foodEatenKJS(is: Internal.ItemStack_): void;
        canAttackType(arg0: Internal.EntityType_<any>): boolean;
        get mobType(): Internal.MobType
        get stepHeight(): number
        set phantomSize(arg0: number)
        get soundSource(): Internal.SoundSource
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get phantomSize(): number
        get flapping(): boolean
        get uniqueFlapTickOffset(): number
        readonly static "TICKS_PER_FLAP": 25;
        readonly static "FLAP_DEGREES_PER_TICK": 7.448451;
    }
    type Phantom_ = Phantom;
    class WalkTarget {
        constructor(arg0: Internal.Entity_, arg1: number, arg2: number)
        constructor(arg0: Internal.PositionTracker_, arg1: number, arg2: number)
        constructor(arg0: BlockPos_, arg1: number, arg2: number)
        constructor(arg0: Vec3_, arg1: number, arg2: number)
        getCloseEnoughDist(): number;
        getSpeedModifier(): number;
        getTarget(): Internal.PositionTracker;
        get closeEnoughDist(): number
        get speedModifier(): number
        get target(): Internal.PositionTracker
    }
    type WalkTarget_ = WalkTarget;
    interface IExtensibleEnum {
        init(): void;
        createCodecForExtensibleEnum(arg0: Internal.Supplier_<E[]>, arg1: Internal.Function_<any, any>): Internal.Codec<E>;
    }
    type IExtensibleEnum_ = IExtensibleEnum;
    interface CompletionStage <T> {
        runAfterEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletionStage<void>;
        whenCompleteAsync(arg0: Internal.BiConsumer_<any, any>, arg1: Internal.Executor_): this;
        thenAccept(arg0: Internal.Consumer_<any>): Internal.CompletionStage<void>;
        exceptionally(arg0: Internal.Function_<Internal.Throwable_, any>): this;
        thenCombineAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.BiFunction_<any, any, any>, arg2: Internal.Executor_): Internal.CompletionStage<V>;
        handleAsync(arg0: Internal.BiFunction_<any, Internal.Throwable_, any>, arg1: Internal.Executor_): Internal.CompletionStage<U>;
        thenAcceptBoth(arg0: Internal.CompletionStage_<any>, arg1: Internal.BiConsumer_<any, any>): Internal.CompletionStage<void>;
        thenApplyAsync(arg0: Internal.Function_<any, any>): Internal.CompletionStage<U>;
        thenRunAsync(arg0: Internal.Runnable_, arg1: Internal.Executor_): Internal.CompletionStage<void>;
        thenAcceptBothAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.BiConsumer_<any, any>, arg2: Internal.Executor_): Internal.CompletionStage<void>;
        acceptEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Consumer_<any>, arg2: Internal.Executor_): Internal.CompletionStage<void>;
        exceptionallyCompose(arg0: Internal.Function_<Internal.Throwable_, any>): this;
        thenComposeAsync(arg0: Internal.Function_<any, any>, arg1: Internal.Executor_): Internal.CompletionStage<U>;
        runAfterBoth(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletionStage<void>;
        whenComplete(arg0: Internal.BiConsumer_<any, any>): this;
        runAfterBothAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletionStage<void>;
        acceptEither(arg0: Internal.CompletionStage_<any>, arg1: Internal.Consumer_<any>): Internal.CompletionStage<void>;
        thenCompose(arg0: Internal.Function_<any, any>): Internal.CompletionStage<U>;
        applyToEither(arg0: Internal.CompletionStage_<any>, arg1: Internal.Function_<any, U>): Internal.CompletionStage<U>;
        handleAsync(arg0: Internal.BiFunction_<any, Internal.Throwable_, any>): Internal.CompletionStage<U>;
        thenCombineAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.BiFunction_<any, any, any>): Internal.CompletionStage<V>;
        whenCompleteAsync(arg0: Internal.BiConsumer_<any, any>): this;
        thenAcceptAsync(arg0: Internal.Consumer_<any>): Internal.CompletionStage<void>;
        thenRunAsync(arg0: Internal.Runnable_): Internal.CompletionStage<void>;
        thenCombine(arg0: Internal.CompletionStage_<any>, arg1: Internal.BiFunction_<any, any, any>): Internal.CompletionStage<V>;
        exceptionallyAsync(arg0: Internal.Function_<Internal.Throwable_, any>): this;
        applyToEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Function_<any, U>): Internal.CompletionStage<U>;
        thenComposeAsync(arg0: Internal.Function_<any, any>): Internal.CompletionStage<U>;
        thenAcceptAsync(arg0: Internal.Consumer_<any>, arg1: Internal.Executor_): Internal.CompletionStage<void>;
        runAfterEither(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletionStage<void>;
        handle(arg0: Internal.BiFunction_<any, Internal.Throwable_, any>): Internal.CompletionStage<U>;
        runAfterBothAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_, arg2: Internal.Executor_): Internal.CompletionStage<void>;
        runAfterEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_, arg2: Internal.Executor_): Internal.CompletionStage<void>;
        thenApplyAsync(arg0: Internal.Function_<any, any>, arg1: Internal.Executor_): Internal.CompletionStage<U>;
        toCompletableFuture(): Internal.CompletableFuture<T>;
        applyToEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Function_<any, U>, arg2: Internal.Executor_): Internal.CompletionStage<U>;
        acceptEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Consumer_<any>): Internal.CompletionStage<void>;
        thenRun(arg0: Internal.Runnable_): Internal.CompletionStage<void>;
        exceptionallyComposeAsync(arg0: Internal.Function_<Internal.Throwable_, any>): this;
        thenAcceptBothAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.BiConsumer_<any, any>): Internal.CompletionStage<void>;
        thenApply(arg0: Internal.Function_<any, any>): Internal.CompletionStage<U>;
        exceptionallyComposeAsync(arg0: Internal.Function_<Internal.Throwable_, any>, arg1: Internal.Executor_): this;
        exceptionallyAsync(arg0: Internal.Function_<Internal.Throwable_, any>, arg1: Internal.Executor_): this;
    }
    type CompletionStage_<T> = CompletionStage<T>;
    class ConnectionProtocol extends Internal.Enum<Internal.ConnectionProtocol> {
        static getProtocolForPacket(arg0: Internal.Packet_<any>): Internal.ConnectionProtocol;
        static values(): Internal.ConnectionProtocol[];
        getPacketsByIds(arg0: Internal.PacketFlow_): Internal.Int2ObjectMap<Internal.Class<any>>;
        createPacket(arg0: Internal.PacketFlow_, arg1: number, arg2: Internal.FriendlyByteBuf_): Internal.Packet<any>;
        static valueOf(arg0: string): Internal.ConnectionProtocol;
        getPacketId(arg0: Internal.PacketFlow_, arg1: Internal.Packet_<any>): number;
        getId(): number;
        static getById(arg0: number): Internal.ConnectionProtocol;
        get id(): number
        readonly static "STATUS": Internal.ConnectionProtocol;
        readonly static "HANDSHAKING": Internal.ConnectionProtocol;
        readonly static "LOGIN": Internal.ConnectionProtocol;
        readonly static "PLAY": Internal.ConnectionProtocol;
    }
    type ConnectionProtocol_ = "login" | ConnectionProtocol | "status" | "play" | "handshaking";
    class SolidPredicate extends Internal.StateTestingPredicate {
        constructor(arg0: Vec3i_)
        type(): Internal.BlockPredicateType<any>;
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        negate(): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        readonly static "CODEC": any;
    }
    type SolidPredicate_ = SolidPredicate;
    class BlockIDPredicate$PropertyObject extends Internal.Record {
        constructor(property: Internal.Property_<any>, value: any)
        hashCode(): number;
        toString(): string;
        value(): any;
        property(): Internal.Property<any>;
        equals(o: any): boolean;
    }
    type BlockIDPredicate$PropertyObject_ = BlockIDPredicate$PropertyObject;
    class OverlayTexture implements Internal.AutoCloseable {
        constructor()
        static pack(arg0: number, arg1: number): number;
        static pack(arg0: number, arg1: boolean): number;
        close(): void;
        teardownOverlayColor(): void;
        static v(arg0: boolean): number;
        static u(arg0: number): number;
        setupOverlayColor(): void;
        readonly static "NO_OVERLAY": 655360;
        readonly static "WHITE_OVERLAY_V": 10;
        readonly static "NO_WHITE_U": 0;
        readonly static "RED_OVERLAY_V": 3;
    }
    type OverlayTexture_ = OverlayTexture;
    class FunctionFactory extends Internal.Record {
        constructor(name: string, minArgs: number, maxArgs: number, supplier: Internal.FunctionFactory$FuncSupplier_)
        static of0(name: string, supplier: Internal.Supplier_<Internal.Unit_>): Internal.FunctionFactory;
        toString(): string;
        maxArgs(): number;
        static of(name: string, minArgs: number, maxArgs: number, supplier: Internal.FunctionFactory$FuncSupplier_): Internal.FunctionFactory;
        minArgs(): number;
        name(): string;
        hashCode(): number;
        create(args: Internal.Unit_[]): Internal.Unit;
        static of(name: string, args: number, supplier: Internal.FunctionFactory$FuncSupplier_): Internal.FunctionFactory;
        supplier(): Internal.FunctionFactory$FuncSupplier;
        equals(o: any): boolean;
        static of2(name: string, supplier: Internal.FunctionFactory$Arg2_): Internal.FunctionFactory;
        static of1(name: string, supplier: Internal.FunctionFactory$Arg1_): Internal.FunctionFactory;
        static of3(name: string, supplier: Internal.FunctionFactory$Arg3_): Internal.FunctionFactory;
    }
    type FunctionFactory_ = FunctionFactory;
    interface NBTSerializable {
        toNBT(): Internal.Tag;
    }
    type NBTSerializable_ = NBTSerializable;
    class Constructor <T> extends Internal.Executable {
        setAccessible(arg0: boolean): void;
        isVarArgs(): boolean;
        getGenericExceptionTypes(): Internal.Type[];
        getGenericParameterTypes(): Internal.Type[];
        toString(): string;
        getModifiers(): number;
        getDeclaringClass(): Internal.Class<T>;
        isSynthetic(): boolean;
        getAnnotation(arg0: Internal.Class_<T>): T;
        getAnnotatedReturnType(): Internal.AnnotatedType;
        getExceptionTypes(): Internal.Class<any>[];
        hashCode(): number;
        getParameterTypes(): Internal.Class<any>[];
        getParameterAnnotations(): Internal.Annotation[][];
        toGenericString(): string;
        getTypeParameters(): any[];
        newInstance(...arg0: any[]): T;
        getName(): string;
        getParameterCount(): number;
        equals(arg0: any): boolean;
        getAnnotatedReceiverType(): Internal.AnnotatedType;
        getDeclaredAnnotations(): Internal.Annotation[];
        set accessible(arg0: boolean)
        get varArgs(): boolean
        get genericExceptionTypes(): Internal.Type[]
        get genericParameterTypes(): Internal.Type[]
        get modifiers(): number
        get declaringClass(): Internal.Class<T>
        get synthetic(): boolean
        get annotatedReturnType(): Internal.AnnotatedType
        get exceptionTypes(): Internal.Class<any>[]
        get parameterTypes(): Internal.Class<any>[]
        get parameterAnnotations(): Internal.Annotation[][]
        get typeParameters(): any[]
        get name(): string
        get parameterCount(): number
        get annotatedReceiverType(): Internal.AnnotatedType
        get declaredAnnotations(): Internal.Annotation[]
    }
    type Constructor_<T> = Constructor<T>;
    abstract class AbstractPiglin extends Internal.Monster {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getTarget(): Internal.LivingEntity;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        isAdult(): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMyRidingOffset(): number;
        getArmPose(): Internal.PiglinArmPose;
        isConverting(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        playAmbientSound(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        setImmuneToZombification(arg0: boolean): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get target(): Internal.LivingEntity
        get adult(): boolean
        get myRidingOffset(): number
        get armPose(): Internal.PiglinArmPose
        get converting(): boolean
        get stepHeight(): number
        set immuneToZombification(arg0: boolean)
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type AbstractPiglin_ = AbstractPiglin;
    class OptionalLong {
        ifPresentOrElse(arg0: Internal.LongConsumer_, arg1: Internal.Runnable_): void;
        static empty(): Internal.OptionalLong;
        orElseGet(arg0: Internal.LongSupplier_): number;
        toString(): string;
        isEmpty(): boolean;
        ifPresent(arg0: Internal.LongConsumer_): void;
        stream(): Internal.LongStream;
        static of(arg0: number): Internal.OptionalLong;
        getAsLong(): number;
        orElseThrow(): number;
        hashCode(): number;
        isPresent(): boolean;
        orElse(arg0: number): number;
        equals(arg0: any): boolean;
        orElseThrow(arg0: Internal.Supplier_<any>): number;
        get empty(): boolean
        get asLong(): number
        get present(): boolean
    }
    type OptionalLong_ = OptionalLong;
    class ToolAction {
        static get(arg0: string): Internal.ToolAction;
        name(): string;
        toString(): string;
        static getActions(): Internal.Collection<Internal.ToolAction>;
        get actions(): Internal.Collection<Internal.ToolAction>
    }
    type ToolAction_ = ToolAction;
    abstract class Buffer {
        capacity(): number;
        reset(): this;
        remaining(): number;
        isDirect(): boolean;
        limit(): number;
        rewind(): this;
        position(): number;
        array(): any;
        arrayOffset(): number;
        mark(): this;
        limit(arg0: number): this;
        flip(): this;
        clear(): this;
        slice(): this;
        position(arg0: number): this;
        hasRemaining(): boolean;
        isReadOnly(): boolean;
        slice(arg0: number, arg1: number): this;
        hasArray(): boolean;
        duplicate(): this;
        get direct(): boolean
        get readOnly(): boolean
    }
    type Buffer_ = Buffer;
    class GravityProcessor extends Internal.StructureProcessor {
        constructor(arg0: Internal.Heightmap$Types_, arg1: number)
        processBlock(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.StructureTemplate$StructureBlockInfo_, arg4: Internal.StructureTemplate$StructureBlockInfo_, arg5: Internal.StructurePlaceSettings_): Internal.StructureTemplate$StructureBlockInfo;
        readonly static "CODEC": any;
    }
    type GravityProcessor_ = GravityProcessor;
    class LazyLoadedValue <T> {
        constructor(arg0: Internal.Supplier_<T>)
        get(): T;
    }
    type LazyLoadedValue_<T> = LazyLoadedValue<T>;
    interface NonNullPredicate <T> {
        test(arg0: T): boolean;
    }
    type NonNullPredicate_<T> = NonNullPredicate<T> | ((arg0: T)=>boolean);
    class ClientboundSetEntityLinkPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.Entity_, arg1: Internal.Entity_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getSourceId(): number;
        getDestId(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get sourceId(): number
        get destId(): number
        get skippable(): boolean
    }
    type ClientboundSetEntityLinkPacket_ = ClientboundSetEntityLinkPacket;
    interface NarrationElementOutput {
        add(arg0: Internal.NarratedElementType_, ...arg1: Internal.Component_[]): void;
        add(arg0: Internal.NarratedElementType_, arg1: Internal.Component_): void;
        add(arg0: Internal.NarratedElementType_, arg1: string): void;
        nest(): this;
        add(arg0: Internal.NarratedElementType_, arg1: Internal.NarrationThunk_<any>): void;
    }
    type NarrationElementOutput_ = NarrationElementOutput;
    class Goal$Flag extends Internal.Enum<Internal.Goal$Flag> {
        static values(): Internal.Goal$Flag[];
        static valueOf(arg0: string): Internal.Goal$Flag;
        readonly static "TARGET": Internal.Goal$Flag;
        readonly static "JUMP": Internal.Goal$Flag;
        readonly static "MOVE": Internal.Goal$Flag;
        readonly static "LOOK": Internal.Goal$Flag;
    }
    type Goal$Flag_ = "jump" | "move" | "target" | "look" | Goal$Flag;
    interface PlayerRideableJumping extends Internal.PlayerRideable {
        handleStopJump(): void;
        onPlayerJump(arg0: number): void;
        handleStartJump(arg0: number): void;
        canJump(): boolean;
    }
    type PlayerRideableJumping_ = PlayerRideableJumping;
    class ClientboundGameEventPacket$Type {
        constructor(arg0: number)
    }
    type ClientboundGameEventPacket$Type_ = ClientboundGameEventPacket$Type;
    class LivingEntityDropsEventJS extends Internal.LivingEntityEventJS {
        constructor(e: Internal.LivingDropsEvent_)
        getEntity(): Internal.EntityJS;
        canCancel(): boolean;
        addDrop(item: any, chance: number): Internal.ItemEntityJS;
        addDrop(item: any): Internal.ItemEntityJS;
        getSource(): Internal.DamageSource;
        getDrops(): Internal.List<Internal.ItemEntityJS>;
        isRecentlyHit(): boolean;
        getLootingLevel(): number;
        get entity(): Internal.EntityJS
        get source(): Internal.DamageSource
        get drops(): Internal.List<Internal.ItemEntityJS>
        get recentlyHit(): boolean
        get lootingLevel(): number
        "eventDrops": Internal.List<Internal.ItemEntityJS>;
    }
    type LivingEntityDropsEventJS_ = LivingEntityDropsEventJS;
    class LargeDripstoneConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: number, arg1: Internal.IntProvider_, arg2: Internal.FloatProvider_, arg3: number, arg4: Internal.FloatProvider_, arg5: Internal.FloatProvider_, arg6: Internal.FloatProvider_, arg7: number, arg8: number)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "floorToCeilingSearchRange": number;
        readonly "columnRadius": Internal.IntProvider;
        readonly "stalactiteBluntness": Internal.FloatProvider;
        readonly "minBluntnessForWind": number;
        readonly static "CODEC": any;
        readonly "minRadiusForWind": number;
        readonly "heightScale": Internal.FloatProvider;
        readonly "windSpeed": Internal.FloatProvider;
        readonly "maxColumnRadiusToCaveHeightRatio": number;
        readonly "stalagmiteBluntness": Internal.FloatProvider;
    }
    type LargeDripstoneConfiguration_ = LargeDripstoneConfiguration;
    class BossEvent$BossBarOverlay extends Internal.Enum<Internal.BossEvent$BossBarOverlay> {
        static valueOf(arg0: string): Internal.BossEvent$BossBarOverlay;
        getName(): string;
        static values(): Internal.BossEvent$BossBarOverlay[];
        static byName(arg0: string): Internal.BossEvent$BossBarOverlay;
        get name(): string
        readonly static "NOTCHED_12": Internal.BossEvent$BossBarOverlay;
        readonly static "NOTCHED_10": Internal.BossEvent$BossBarOverlay;
        readonly static "PROGRESS": Internal.BossEvent$BossBarOverlay;
        readonly static "NOTCHED_6": Internal.BossEvent$BossBarOverlay;
        readonly static "NOTCHED_20": Internal.BossEvent$BossBarOverlay;
    }
    type BossEvent$BossBarOverlay_ = "notched_20" | "notched_10" | "progress" | "notched_6" | "notched_12" | BossEvent$BossBarOverlay;
    class KeyCompressor <T> {
        constructor(arg0: Internal.DynamicOps_<T>, arg1: Internal.Stream_<T>)
        compress(arg0: T): number;
        size(): number;
        decompress(arg0: number): T;
        compress(arg0: string): number;
    }
    type KeyCompressor_<T> = KeyCompressor<T>;
    class WorldGenerationContext {
        constructor(arg0: Internal.ChunkGenerator_, arg1: Internal.LevelHeightAccessor_)
        getMinGenY(): number;
        getGenDepth(): number;
        get minGenY(): number
        get genDepth(): number
    }
    type WorldGenerationContext_ = WorldGenerationContext;
    class WallBlockBuilder extends Internal.ShapedBlockBuilder {
        constructor(i: ResourceLocation_)
        createObject(): any;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
    }
    type WallBlockBuilder_ = WallBlockBuilder;
    class TutorialSteps extends Internal.Enum<Internal.TutorialSteps> {
        static getByName(arg0: string): Internal.TutorialSteps;
        create(arg0: Internal.Tutorial_): Internal.TutorialStepInstance;
        getName(): string;
        static valueOf(arg0: string): Internal.TutorialSteps;
        static values(): Internal.TutorialSteps[];
        get name(): string
        readonly static "OPEN_INVENTORY": Internal.TutorialSteps;
        readonly static "CRAFT_PLANKS": Internal.TutorialSteps;
        readonly static "NONE": Internal.TutorialSteps;
        readonly static "FIND_TREE": Internal.TutorialSteps;
        readonly static "MOVEMENT": Internal.TutorialSteps;
        readonly static "PUNCH_TREE": Internal.TutorialSteps;
    }
    type TutorialSteps_ = TutorialSteps | "craft_planks" | "find_tree" | "open_inventory" | "punch_tree" | "none" | "movement";
    class ExplosionJS {
        constructor(l: Internal.LevelAccessor_, _x: number, _y: number, _z: number)
        damagesTerrain(b: boolean): this;
        destroysTerrain(b: boolean): this;
        explode(): void;
        causesFire(b: boolean): this;
        exploder(entity: Internal.EntityJS_): this;
        strength(f: number): this;
        readonly "z": number;
        "causesFire": boolean;
        "explosionMode": Internal.Explosion$BlockInteraction;
        readonly "x": number;
        readonly "y": number;
        "exploder": Internal.EntityJS;
        "strength": number;
    }
    type ExplosionJS_ = ExplosionJS;
    class ClientboundGameEventPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.ClientboundGameEventPacket$Type_, arg1: number)
        handle(arg0: Internal.PacketListener_): void;
        getParam(): number;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        getEvent(): Internal.ClientboundGameEventPacket$Type;
        get param(): number
        get skippable(): boolean
        get event(): Internal.ClientboundGameEventPacket$Type
        readonly static "DEMO_EVENT": Internal.ClientboundGameEventPacket$Type;
        readonly static "START_RAINING": Internal.ClientboundGameEventPacket$Type;
        readonly static "THUNDER_LEVEL_CHANGE": Internal.ClientboundGameEventPacket$Type;
        readonly static "PUFFER_FISH_STING": Internal.ClientboundGameEventPacket$Type;
        readonly static "IMMEDIATE_RESPAWN": Internal.ClientboundGameEventPacket$Type;
        readonly static "DEMO_PARAM_HINT_1": 101;
        readonly static "DEMO_PARAM_HINT_4": 104;
        readonly static "DEMO_PARAM_HINT_3": 103;
        readonly static "DEMO_PARAM_HINT_2": 102;
        readonly static "CHANGE_GAME_MODE": Internal.ClientboundGameEventPacket$Type;
        readonly static "RAIN_LEVEL_CHANGE": Internal.ClientboundGameEventPacket$Type;
        readonly static "STOP_RAINING": Internal.ClientboundGameEventPacket$Type;
        readonly static "WIN_GAME": Internal.ClientboundGameEventPacket$Type;
        readonly static "NO_RESPAWN_BLOCK_AVAILABLE": Internal.ClientboundGameEventPacket$Type;
        readonly static "ARROW_HIT_PLAYER": Internal.ClientboundGameEventPacket$Type;
        readonly static "GUARDIAN_ELDER_EFFECT": Internal.ClientboundGameEventPacket$Type;
        readonly static "DEMO_PARAM_INTRO": 0;
    }
    type ClientboundGameEventPacket_ = ClientboundGameEventPacket;
    interface SortedSet <E> extends Internal.Set<E> {
        tailSet(arg0: E): this;
        last(): E;
        comparator(): Internal.Comparator<any>;
        subSet(arg0: E, arg1: E): this;
        stream(): Internal.Stream<E>;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        forEach(arg0: Internal.Consumer_<any>): void;
        first(): E;
        headSet(arg0: E): this;
        spliterator(): Internal.Spliterator<E>;
        parallelStream(): Internal.Stream<E>;
    }
    type SortedSet_<E> = SortedSet<E>;
    class RecordCodecBuilder$Instance <O> implements Internal.Applicative<Internal.RecordCodecBuilder$Mu<O>, any> {
        constructor()
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13>, arg13: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T14>): Internal.Products$P14<Internal.RecordCodecBuilder$Mu<O>, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>;
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10>): Internal.Products$P10<Internal.RecordCodecBuilder$Mu<O>, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>;
        apply2(arg0: Internal.BiFunction_<A, B, R>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, A>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, B>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>): Internal.Products$P2<Internal.RecordCodecBuilder$Mu<O>, T1, T2>;
        lift8(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function8_<T1, T2, T3, T4, T5, T6, T7, T8, R>>): Internal.Function8<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>>;
        lift9(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>): Internal.Function9<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>>;
        ap4(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function4_<T1, T2, T3, T4, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        ap3(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function3_<T1, T2, T3, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        lift2(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.BiFunction_<A, B, R>>): Internal.BiFunction<Internal.App<Internal.RecordCodecBuilder$Mu<O>, A>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, B>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>>;
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13>, arg13: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T14>, arg14: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T15>): Internal.Products$P15<Internal.RecordCodecBuilder$Mu<O>, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>;
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11>): Internal.Products$P11<Internal.RecordCodecBuilder$Mu<O>, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>;
        apply4(arg0: Internal.Function4_<T1, T2, T3, T4, R>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        apply8(arg0: Internal.Function8_<T1, T2, T3, T4, T5, T6, T7, T8, R>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        ap5(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function5_<T1, T2, T3, T4, T5, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        apply9(arg0: Internal.Function9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        lift6(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function6_<T1, T2, T3, T4, T5, T6, R>>): Internal.Function6<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>>;
        ap6(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function6_<T1, T2, T3, T4, T5, T6, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        ap16(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function16_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12>, arg13: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13>, arg14: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T14>, arg15: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T15>, arg16: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T16>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>): Internal.Products$P3<Internal.RecordCodecBuilder$Mu<O>, T1, T2, T3>;
        ap11(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function11_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>): Internal.Products$P9<Internal.RecordCodecBuilder$Mu<O>, T1, T2, T3, T4, T5, T6, T7, T8, T9>;
        ap9(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>): Internal.Products$P7<Internal.RecordCodecBuilder$Mu<O>, T1, T2, T3, T4, T5, T6, T7>;
        apply5(arg0: Internal.Function5_<T1, T2, T3, T4, T5, R>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        ap13(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function13_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12>, arg13: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        ap14(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function14_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12>, arg13: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13>, arg14: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T14>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        ap12(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function12_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        point(arg0: A): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A>;
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13>): Internal.Products$P13<Internal.RecordCodecBuilder$Mu<O>, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>;
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>): Internal.Products$P5<Internal.RecordCodecBuilder$Mu<O>, T1, T2, T3, T4, T5>;
        lift1(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function_<A, R>>): Internal.Function<Internal.App<Internal.RecordCodecBuilder$Mu<O>, A>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>>;
        apply3(arg0: Internal.Function3_<T1, T2, T3, R>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>): Internal.Products$P4<Internal.RecordCodecBuilder$Mu<O>, T1, T2, T3, T4>;
        deprecated(arg0: A, arg1: number): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A>;
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13>, arg13: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T14>, arg14: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T15>, arg15: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T16>): Internal.Products$P16<Internal.RecordCodecBuilder$Mu<O>, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>;
        ap7(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function7_<T1, T2, T3, T4, T5, T6, T7, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        stable(arg0: A): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A>;
        ap8(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function8_<T1, T2, T3, T4, T5, T6, T7, T8, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        lift4(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function4_<T1, T2, T3, T4, R>>): Internal.Function4<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>>;
        ap(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function_<A, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, A>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        point(arg0: A, arg1: Internal.Lifecycle_): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A>;
        map(arg0: Internal.Function_<any, any>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12>): Internal.Products$P12<Internal.RecordCodecBuilder$Mu<O>, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>;
        ap15(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function15_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12>, arg13: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13>, arg14: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T14>, arg15: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T15>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        ap(arg0: Internal.Function_<A, R>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, A>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>): Internal.Products$P8<Internal.RecordCodecBuilder$Mu<O>, T1, T2, T3, T4, T5, T6, T7, T8>;
        lift5(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function5_<T1, T2, T3, T4, T5, R>>): Internal.Function5<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>>;
        lift7(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function7_<T1, T2, T3, T4, T5, T6, T7, R>>): Internal.Function7<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>>;
        ap10(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function10_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        apply7(arg0: Internal.Function7_<T1, T2, T3, T4, T5, T6, T7, R>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>): Internal.Products$P6<Internal.RecordCodecBuilder$Mu<O>, T1, T2, T3, T4, T5, T6>;
        lift3(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function3_<T1, T2, T3, R>>): Internal.Function3<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>>;
        apply6(arg0: Internal.Function6_<T1, T2, T3, T4, T5, T6, R>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        ap2(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.BiFunction_<A, B, R>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, A>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, B>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>;
        group(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1>): Internal.Products$P1<Internal.RecordCodecBuilder$Mu<O>, T1>;
    }
    type RecordCodecBuilder$Instance_<O> = RecordCodecBuilder$Instance<O>;
    class MetricSampler$SamplerResult {
        constructor(arg0: number, arg1: number, arg2: any_)
        valueAtTick(arg0: number): number;
        getFirstTick(): number;
        getLastTick(): number;
        get firstTick(): number
        get lastTick(): number
    }
    type MetricSampler$SamplerResult_ = MetricSampler$SamplerResult;
    interface CommandExceptionType {
    }
    type CommandExceptionType_ = CommandExceptionType;
    interface PreparableReloadListener$PreparationBarrier {
        wait(arg0: T): Internal.CompletableFuture<T>;
    }
    type PreparableReloadListener$PreparationBarrier_ = PreparableReloadListener$PreparationBarrier;
    class LootBuilderPool implements Internal.FunctionContainer, Internal.ConditionContainer {
        constructor()
        setUniformRolls(min: number, max: number): void;
        addFunction(arg0: Internal.JsonObject_): Internal.FunctionContainer;
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer;
        name(name: Internal.Component_, entity: Internal.LootContext$EntityTarget_): Internal.FunctionContainer;
        damage(damage: Internal.NumberProvider_): Internal.FunctionContainer;
        toJson(): Internal.JsonObject;
        survivesExplosion(): Internal.ConditionContainer;
        count(count: Internal.NumberProvider_): Internal.FunctionContainer;
        addTag(tag: string, expand: boolean): Internal.LootTableEntry;
        addItem(item: Internal.ItemStack_, weight: number, count: Internal.NumberProvider_): Internal.LootTableEntry;
        copyName(source: Internal.CopyNameFunction$NameSource_): Internal.FunctionContainer;
        addCondition(arg0: Internal.JsonObject_): Internal.ConditionContainer;
        lootTable(table: ResourceLocation_, seed: number): Internal.FunctionContainer;
        addItem(item: Internal.ItemStack_): Internal.LootTableEntry;
        enchantWithLevels(levels: Internal.NumberProvider_, treasure: boolean): Internal.FunctionContainer;
        enchantRandomly(enchantments: ResourceLocation_[]): Internal.FunctionContainer;
        addEntry(json: Internal.JsonObject_): Internal.LootTableEntry;
        furnaceSmelt(): Internal.FunctionContainer;
        entityProperties(entity: Internal.LootContext$EntityTarget_, properties: Internal.JsonObject_): Internal.ConditionContainer;
        lootingEnchant(count: Internal.NumberProvider_, limit: number): Internal.FunctionContainer;
        addEmpty(weight: number): Internal.LootTableEntry;
        addConditionalFunction(func: Internal.Consumer_<Internal.ConditionalFunction_>): Internal.FunctionContainer;
        randomChance(chance: number): Internal.ConditionContainer;
        addLootTable(table: ResourceLocation_): Internal.LootTableEntry;
        setBinomialRolls(n: number, p: number): void;
        killedByPlayer(): Internal.ConditionContainer;
        nbt(tag: Internal.CompoundTag_): Internal.FunctionContainer;
        entityScores(entity: Internal.LootContext$EntityTarget_, scores: Internal.Map_<string, any>): Internal.ConditionContainer;
        addItem(item: Internal.ItemStack_, weight: number): Internal.LootTableEntry;
        name(name: Internal.Component_): Internal.FunctionContainer;
        "rolls": Internal.NumberProvider;
        readonly "entries": Internal.JsonArray;
        readonly "conditions": Internal.JsonArray;
        "bonusRolls": Internal.NumberProvider;
        readonly "functions": Internal.JsonArray;
    }
    type LootBuilderPool_ = LootBuilderPool;
    class PiecesContainer extends Internal.Record {
        constructor(arg0: Internal.List_<Internal.StructurePiece_>)
        pieces(): Internal.List<Internal.StructurePiece>;
        isInsidePiece(arg0: BlockPos_): boolean;
        hashCode(): number;
        static load(arg0: Internal.ListTag_, arg1: Internal.StructurePieceSerializationContext_): Internal.PiecesContainer;
        toString(): string;
        save(arg0: Internal.StructurePieceSerializationContext_): Internal.Tag;
        calculateBoundingBox(): Internal.BoundingBox;
        isEmpty(): boolean;
        equals(arg0: any): boolean;
        get empty(): boolean
    }
    type PiecesContainer_ = PiecesContainer;
    interface ITagManager <V> extends Internal.Iterable<Internal.ITag<V>> {
        getTagNames(): Internal.Stream<Internal.TagKey<V>>;
        getReverseTag(arg0: V): Internal.Optional<Internal.IReverseTag<V>>;
        spliterator(): Internal.Spliterator<Internal.ITag<V>>;
        forEach(arg0: Internal.Consumer_<any>): void;
        getTag(arg0: Internal.TagKey_<V>): Internal.ITag<V>;
        isKnownTagName(arg0: Internal.TagKey_<V>): boolean;
        createOptionalTagKey(arg0: ResourceLocation_, arg1: Internal.Set_<any>): Internal.TagKey<V>;
        createTagKey(arg0: ResourceLocation_): Internal.TagKey<V>;
        stream(): Internal.Stream<Internal.ITag<V>>;
        addOptionalTagDefaults(arg0: Internal.TagKey_<V>, arg1: Internal.Set_<any>): void;
        get tagNames(): Internal.Stream<Internal.TagKey<V>>
    }
    type ITagManager_<V> = ITagManager<V>;
    class MapJS extends Internal.LinkedHashMap<string, any> implements Internal.ChangeListener<any>, Internal.NBTSerializable, Internal.Copyable, Internal.JsonSerializable, Internal.StringBuilderAppendable {
        constructor()
        constructor(s: number)
        replace(arg0: string, arg1: any): any;
        computeIfPresent(arg0: string, arg1: Internal.BiFunction_<any, any, any>): any;
        putAll(m: Internal.Map_<any, any>): void;
        merge(arg0: string, arg1: any, arg2: Internal.BiFunction_<any, any, any>): any;
        static of(o: any): Internal.MapJS;
        static json(map: any): Internal.JsonObject;
        toJson(): Internal.JsonElement;
        appendString(builder: Internal.StringBuilder_): void;
        onChanged(o: any): void;
        computeIfAbsent(arg0: string, arg1: Internal.Function_<any, any>): any;
        put(arg0: any, arg1: any): any;
        static nbt(map: any): Internal.CompoundTag;
        containsAll(other: Internal.MapJS_): boolean;
        putIfAbsent(arg0: string, arg1: any): any;
        toString(): string;
        compute(arg0: string, arg1: Internal.BiFunction_<any, any, any>): any;
        getOrNewList(id: string): Internal.ListJS;
        remove(arg0: any, arg1: any): boolean;
        replace(arg0: string, arg1: any, arg2: any): boolean;
        put(key: string, value: any): any;
        getLength(): number;
        getOrNewMap(id: string): this;
        containsAny(other: Internal.MapJS_): boolean;
        clear(): void;
        copy(): this;
        remove(key: any): any;
        toNBT(): Internal.Tag;
        get length(): number
        "changeListener": Internal.ChangeListener<Internal.MapJS>;
    }
    type MapJS_ = MapJS;
    class CallbackInfoReturnable <R> extends Internal.CallbackInfo {
        constructor(arg0: string, arg1: boolean, arg2: string)
        constructor(arg0: string, arg1: boolean, arg2: number)
        constructor(arg0: string, arg1: boolean, arg2: number)
        constructor(arg0: string, arg1: boolean, arg2: R)
        constructor(arg0: string, arg1: boolean, arg2: number)
        constructor(arg0: string, arg1: boolean)
        constructor(arg0: string, arg1: boolean, arg2: number)
        constructor(arg0: string, arg1: boolean, arg2: boolean)
        constructor(arg0: string, arg1: boolean, arg2: number)
        constructor(arg0: string, arg1: boolean, arg2: number)
        getReturnValueS(): number;
        setReturnValue(arg0: R): void;
        getReturnValueC(): string;
        getReturnValueZ(): boolean;
        getReturnValueB(): number;
        getReturnValueJ(): number;
        getReturnValueD(): number;
        getReturnValueI(): number;
        getReturnValue(): R;
        getReturnValueF(): number;
        get returnValueS(): number
        set returnValue(arg0: R)
        get returnValueC(): string
        get returnValueZ(): boolean
        get returnValueB(): number
        get returnValueJ(): number
        get returnValueD(): number
        get returnValueI(): number
        get returnValue(): R
        get returnValueF(): number
    }
    type CallbackInfoReturnable_<R> = CallbackInfoReturnable<R>;
    class DragonChargePlayerPhase extends Internal.AbstractDragonPhaseInstance {
        constructor(arg0: Internal.EnderDragon_)
        getPhase(): Internal.EnderDragonPhase<Internal.DragonChargePlayerPhase>;
        getFlyTargetLocation(): Vec3;
        setTarget(arg0: Vec3_): void;
        getFlySpeed(): number;
        begin(): void;
        doServerTick(): void;
        get phase(): Internal.EnderDragonPhase<Internal.DragonChargePlayerPhase>
        get flyTargetLocation(): Vec3
        set target(arg0: Vec3_)
        get flySpeed(): number
    }
    type DragonChargePlayerPhase_ = DragonChargePlayerPhase;
    class MinecartSpawner extends Internal.AbstractMinecart {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        isPoweredCart(): boolean;
        getCurrentRailPosition(): BlockPos;
        getMaxCartSpeedOnRail(): number;
        getStepHeight(): number;
        getSpawner(): Internal.BaseSpawner;
        asKJS(): Internal.EntityJS;
        getSlopeAdjustment(): number;
        shouldDoRailFunctions(): boolean;
        onlyOpCanSetNbt(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        canBeRidden(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        getDefaultDisplayBlockState(): Internal.BlockState;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getCartItem(): Internal.ItemStack;
        tick(): void;
        getMinecartType(): Internal.AbstractMinecart$Type;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getComparatorLevel(): number;
        get poweredCart(): boolean
        get currentRailPosition(): BlockPos
        get maxCartSpeedOnRail(): number
        get stepHeight(): number
        get spawner(): Internal.BaseSpawner
        get slopeAdjustment(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get defaultDisplayBlockState(): Internal.BlockState
        get cartItem(): Internal.ItemStack
        get minecartType(): Internal.AbstractMinecart$Type
        get comparatorLevel(): number
    }
    type MinecartSpawner_ = MinecartSpawner;
    class AxeItemBuilder extends Internal.HandheldItemBuilder {
        constructor(i: ResourceLocation_)
        createObject(): Internal.Item;
    }
    type AxeItemBuilder_ = AxeItemBuilder;
    interface ToLongFunction <T> {
        applyAsLong(arg0: T): number;
    }
    type ToLongFunction_<T> = ToLongFunction<T> | ((arg0: T)=>number);
    class ImmutableSetMultimap <K, V> extends Internal.ImmutableMultimap<K, V> implements Internal.SetMultimap<K, V> {
        static of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): Internal.ImmutableSetMultimap<K, V>;
        static of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): Internal.ImmutableSetMultimap<K, V>;
        static copyOf(arg0: Internal.Iterable_<any>): Internal.ImmutableSetMultimap<K, V>;
        static builder(): Internal.ImmutableSetMultimap$Builder<K, V>;
        entries(): Internal.Collection<any>;
        static of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): Internal.ImmutableSetMultimap<K, V>;
        static of(arg0: K, arg1: V, arg2: K, arg3: V): Internal.ImmutableSetMultimap<K, V>;
        replaceValues(arg0: any, arg1: Internal.Iterable_<any>): Internal.Set<any>;
        removeAll(arg0: any): Internal.ImmutableSet<V>;
        get(arg0: any): Internal.Collection<any>;
        inverse(): Internal.ImmutableSetMultimap<V, K>;
        static toImmutableSetMultimap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Collector<T, any, Internal.ImmutableSetMultimap<K, V>>;
        static flatteningToImmutableSetMultimap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Collector<T, any, Internal.ImmutableSetMultimap<K, V>>;
        static of(arg0: K, arg1: V): Internal.ImmutableSetMultimap<K, V>;
        static of(): Internal.ImmutableSetMultimap<K, V>;
        static copyOf(arg0: Internal.Multimap_<any, any>): Internal.ImmutableSetMultimap<K, V>;
    }
    type ImmutableSetMultimap_<K, V> = ImmutableSetMultimap<K, V>;
    class DefaultedRegistry <T> extends Internal.MappedRegistry<T> {
        constructor(arg0: string, arg1: Internal.ResourceKey_<any>, arg2: Internal.Lifecycle_, arg3: Internal.Function_<T, Internal.Holder$Reference_<T>>)
        byId(arg0: number): T;
        getDefaultKey(): ResourceLocation;
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<T>;
        getRandom(arg0: Internal.Random_): Internal.Optional<Internal.Holder<T>>;
        getKey(arg0: T): ResourceLocation;
        get(arg0: ResourceLocation_): T;
        byIdOrThrow(arg0: number): T;
        getOptional(arg0: ResourceLocation_): Internal.Optional<T>;
        registerMapping(arg0: number, arg1: Internal.ResourceKey_<T>, arg2: T, arg3: Internal.Lifecycle_): Internal.Holder<T>;
        getId(arg0: T): number;
        get defaultKey(): ResourceLocation
    }
    type DefaultedRegistry_<T> = DefaultedRegistry<T>;
    interface GameRules$GameRuleTypeVisitor {
        visit(arg0: Internal.GameRules$Key_<T>, arg1: Internal.GameRules$Type_<T>): void;
        visitInteger(arg0: Internal.GameRules$Key_<Internal.GameRules$IntegerValue_>, arg1: Internal.GameRules$Type_<Internal.GameRules$IntegerValue_>): void;
        visitBoolean(arg0: Internal.GameRules$Key_<Internal.GameRules$BooleanValue_>, arg1: Internal.GameRules$Type_<Internal.GameRules$BooleanValue_>): void;
    }
    type GameRules$GameRuleTypeVisitor_ = GameRules$GameRuleTypeVisitor;
    class Entity$RemovalReason extends Internal.Enum<Internal.Entity$RemovalReason> {
        static values(): Internal.Entity$RemovalReason[];
        shouldSave(): boolean;
        shouldDestroy(): boolean;
        static valueOf(arg0: string): Internal.Entity$RemovalReason;
        readonly static "CHANGED_DIMENSION": Internal.Entity$RemovalReason;
        readonly static "UNLOADED_TO_CHUNK": Internal.Entity$RemovalReason;
        readonly static "UNLOADED_WITH_PLAYER": Internal.Entity$RemovalReason;
        readonly static "KILLED": Internal.Entity$RemovalReason;
        readonly static "DISCARDED": Internal.Entity$RemovalReason;
    }
    type Entity$RemovalReason_ = "changed_dimension" | Entity$RemovalReason | "killed" | "discarded" | "unloaded_with_player" | "unloaded_to_chunk";
    class CommandEventJS extends Internal.ServerEventJS {
        constructor(e: any_)
        getException(): Internal.Throwable;
        canCancel(): boolean;
        setException(exception: Internal.Throwable_): void;
        setParseResults(parse: Internal.ParseResults_<Internal.CommandSourceStack_>): void;
        getParseResults(): Internal.ParseResults<Internal.CommandSourceStack>;
        get exception(): Internal.Throwable
        set exception(exception: Internal.Throwable_)
        set parseResults(parse: Internal.ParseResults_<Internal.CommandSourceStack_>)
        get parseResults(): Internal.ParseResults<Internal.CommandSourceStack>
    }
    type CommandEventJS_ = CommandEventJS;
    class ServerboundSelectTradePacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getItem(): number;
        isSkippable(): boolean;
        get item(): number
        get skippable(): boolean
    }
    type ServerboundSelectTradePacket_ = ServerboundSelectTradePacket;
    abstract class Provider extends Internal.Properties {
        getOrDefault(arg0: any, arg1: any): any;
        putAll(arg0: Internal.Map_<any, any>): void;
        isConfigured(): boolean;
        keys(): Internal.Enumeration<any>;
        keySet(): Internal.Set<any>;
        replaceAll(arg0: Internal.BiFunction_<any, any, any>): void;
        getServices(): Internal.Set<Internal.Provider$Service>;
        getVersion(): number;
        getName(): string;
        replace(arg0: any, arg1: any, arg2: any): boolean;
        put(arg0: any, arg1: any): any;
        getVersionStr(): string;
        values(): Internal.Collection<any>;
        getService(arg0: string, arg1: string): Internal.Provider$Service;
        load(arg0: Internal.InputStream_): void;
        toString(): string;
        getInfo(): string;
        computeIfAbsent(arg0: any, arg1: Internal.Function_<any, any>): any;
        remove(arg0: any, arg1: any): boolean;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        configure(arg0: string): this;
        entrySet(): Internal.Set<Internal.Map$Entry<any, any>>;
        elements(): Internal.Enumeration<any>;
        clear(): void;
        replace(arg0: any, arg1: any): any;
        getProperty(arg0: string): string;
        merge(arg0: any, arg1: any, arg2: Internal.BiFunction_<any, any, any>): any;
        remove(arg0: any): any;
        compute(arg0: any, arg1: Internal.BiFunction_<any, any, any>): any;
        get(arg0: any): any;
        computeIfPresent(arg0: any, arg1: Internal.BiFunction_<any, any, any>): any;
        putIfAbsent(arg0: any, arg1: any): any;
        get configured(): boolean
        get services(): Internal.Set<Internal.Provider$Service>
        get version(): number
        get name(): string
        get versionStr(): string
        get info(): string
    }
    type Provider_ = Provider;
    class Hoglin extends Internal.Animal implements Internal.Enemy, Internal.HoglinBase {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        canFallInLove(): boolean;
        isFood(arg0: Internal.ItemStack_): boolean;
        setImmuneToZombification(arg0: boolean): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        canBeHunted(): boolean;
        getSoundSource(): Internal.SoundSource;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        getAttackAnimationRemainingTicks(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        static checkHoglinSpawnRules(arg0: Internal.EntityType_<Internal.Hoglin_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        isAdult(): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        isConverting(): boolean;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canBeLeashed(arg0: Internal.Player_): boolean;
        aiStep(): void;
        getPassengersRidingOffset(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        getWalkTargetValue(arg0: BlockPos_, arg1: Internal.LevelReader_): number;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getClassification(arg0: boolean): Internal.MobCategory;
        removeWhenFarAway(arg0: number): boolean;
        getBrain(): Internal.Brain<Internal.Hoglin>;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        set immuneToZombification(arg0: boolean)
        get soundSource(): Internal.SoundSource
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get attackAnimationRemainingTicks(): number
        get adult(): boolean
        get converting(): boolean
        get passengersRidingOffset(): number
        get brain(): Internal.Brain<Internal.Hoglin>
    }
    type Hoglin_ = Hoglin;
    class MutableNumberUnit extends Internal.Unit {
        constructor(value: number)
        toString(builder: Internal.StringBuilder_): void;
        set(value: number): void;
        get(variables: Internal.UnitVariables_): number;
        "value": number;
    }
    type MutableNumberUnit_ = MutableNumberUnit;
    class SplashManager extends Internal.SimplePreparableReloadListener<Internal.List<string>> {
        constructor(arg0: Internal.User_)
        getName(): string;
        getSplash(): string;
        get name(): string
        get splash(): string
    }
    type SplashManager_ = SplashManager;
    class PartPose {
        static rotation(arg0: number, arg1: number, arg2: number): Internal.PartPose;
        static offsetAndRotation(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): Internal.PartPose;
        static offset(arg0: number, arg1: number, arg2: number): Internal.PartPose;
        readonly "zRot": number;
        readonly static "ZERO": Internal.PartPose;
        readonly "z": number;
        readonly "y": number;
        readonly "x": number;
        readonly "yRot": number;
        readonly "xRot": number;
    }
    type PartPose_ = PartPose;
    class ParsedArgument <S, T> {
        constructor(arg0: number, arg1: number, arg2: T)
        hashCode(): number;
        getResult(): T;
        equals(arg0: any): boolean;
        getRange(): Internal.StringRange;
        get result(): T
        get range(): Internal.StringRange
    }
    type ParsedArgument_<S, T> = ParsedArgument<S, T>;
    interface CrashReportDetail <V> extends Internal.Callable<V> {
    }
    type CrashReportDetail_<V> = CrashReportDetail<V>;
    class SculkSensorBlockEntity extends Internal.BlockEntity implements Internal.VibrationListener$VibrationListenerConfig {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        getLastVibrationFrequency(): number;
        getModelData(): Internal.IModelData;
        static getRedstoneStrengthForDistance(arg0: number, arg1: number): number;
        deserializeNBT(arg0: Internal.Tag_): void;
        shouldListen(arg0: Internal.Level_, arg1: Internal.GameEventListener_, arg2: BlockPos_, arg3: Internal.GameEvent_, arg4: Internal.Entity_): boolean;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        onSignalReceive(arg0: Internal.Level_, arg1: Internal.GameEventListener_, arg2: Internal.GameEvent_, arg3: number): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        serializeNBT(): Internal.CompoundTag;
        getListener(): Internal.VibrationListener;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        load(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get lastVibrationFrequency(): number
        get modelData(): Internal.IModelData
        get listener(): Internal.VibrationListener
        get renderBoundingBox(): Internal.AABB
    }
    type SculkSensorBlockEntity_ = SculkSensorBlockEntity;
    class NoneFeatureConfiguration implements Internal.FeatureConfiguration {
        constructor()
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
        readonly static "INSTANCE": Internal.NoneFeatureConfiguration;
    }
    type NoneFeatureConfiguration_ = NoneFeatureConfiguration;
    class RenderBuffers {
        constructor()
        bufferSource(): Internal.MultiBufferSource$BufferSource;
        crumblingBufferSource(): Internal.MultiBufferSource$BufferSource;
        fixedBufferPack(): Internal.ChunkBufferBuilderPack;
        outlineBufferSource(): Internal.OutlineBufferSource;
    }
    type RenderBuffers_ = RenderBuffers;
    interface WorldlyContainer extends Internal.Container {
        stopOpen(arg0: Internal.Player_): void;
        canPlaceItemThroughFace(arg0: number, arg1: Internal.ItemStack_, arg2: Internal.Direction_): boolean;
        getMaxStackSize(): number;
        countItem(arg0: Internal.Item_): number;
        getSlotsForFace(arg0: Internal.Direction_): number[];
        startOpen(arg0: Internal.Player_): void;
        canPlaceItem(arg0: number, arg1: Internal.ItemStack_): boolean;
        canTakeItemThroughFace(arg0: number, arg1: Internal.ItemStack_, arg2: Internal.Direction_): boolean;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        get maxStackSize(): number
    }
    type WorldlyContainer_ = WorldlyContainer;
    class PistonType extends Internal.Enum<Internal.PistonType> implements Internal.StringRepresentable {
        static valueOf(arg0: string): Internal.PistonType;
        toString(): string;
        getSerializedName(): string;
        static values(): Internal.PistonType[];
        get serializedName(): string
        readonly static "STICKY": Internal.PistonType;
        readonly static "DEFAULT": Internal.PistonType;
    }
    type PistonType_ = "sticky" | PistonType | "default";
    class ListJS extends Internal.ArrayList<any> implements Internal.ChangeListener<any>, Internal.NBTSerializable, Internal.Copyable, Internal.JsonSerializable, Internal.StringBuilderAppendable {
        constructor()
        constructor(s: number)
        static of(array: number[]): Internal.ListJS;
        remove(index: number): any;
        static orSelf(o: any): Internal.ListJS;
        static of(array: number[]): Internal.ListJS;
        static nbt(list: any): Internal.CollectionTag<any>;
        pop(): any;
        filter(predicate: Internal.Predicate_<any>): this;
        toJson(): Internal.JsonElement;
        add(index: number, value: any): void;
        appendString(builder: Internal.StringBuilder_): void;
        static ofArray(array: any): Internal.ListJS;
        onChanged(o: any): void;
        map(transformer: Internal.Function_<any, any>): this;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        reverse(): this;
        toNBT(): Internal.CollectionTag<any>;
        unshift(...o: any[]): this;
        static json(array: any): Internal.JsonArray;
        addAll(c: Internal.Collection_<any>): boolean;
        push(...o: any[]): this;
        static of(array: number[]): Internal.ListJS;
        addAll(index: number, c: Internal.Collection_<any>): boolean;
        static of(array: number[]): Internal.ListJS;
        parallelStream(): Internal.Stream<any>;
        toString(): string;
        splice(pos: number, deleteCount: number, ...items: any[]): this;
        remove(o: any): boolean;
        getLength(): number;
        add(value: any): boolean;
        static of(array: number[]): Internal.ListJS;
        shift(): any;
        copy(): this;
        clear(): void;
        stream(): Internal.Stream<any>;
        static of(array: number[]): Internal.ListJS;
        static of(o: any): Internal.ListJS;
        static of(array: string[]): Internal.ListJS;
        get length(): number
        "changeListener": Internal.ChangeListener<Internal.ListJS>;
    }
    type ListJS_ = ListJS;
    class ModuleLayer {
        defineModulesWithManyLoaders(arg0: Internal.Configuration_, arg1: Internal.ClassLoader_): this;
        toString(): string;
        static boot(): Internal.ModuleLayer;
        findLoader(arg0: string): Internal.ClassLoader;
        static defineModulesWithManyLoaders(arg0: Internal.Configuration_, arg1: Internal.List_<Internal.ModuleLayer_>, arg2: Internal.ClassLoader_): Internal.ModuleLayer$Controller;
        static defineModules(arg0: Internal.Configuration_, arg1: Internal.List_<Internal.ModuleLayer_>, arg2: Internal.Function_<string, Internal.ClassLoader_>): Internal.ModuleLayer$Controller;
        defineModulesWithOneLoader(arg0: Internal.Configuration_, arg1: Internal.ClassLoader_): this;
        modules(): Internal.Set<Internal.Module>;
        static defineModulesWithOneLoader(arg0: Internal.Configuration_, arg1: Internal.List_<Internal.ModuleLayer_>, arg2: Internal.ClassLoader_): Internal.ModuleLayer$Controller;
        defineModules(arg0: Internal.Configuration_, arg1: Internal.Function_<string, Internal.ClassLoader_>): this;
        parents(): Internal.List<Internal.ModuleLayer>;
        static empty(): Internal.ModuleLayer;
        configuration(): Internal.Configuration;
        findModule(arg0: string): Internal.Optional<Internal.Module>;
    }
    type ModuleLayer_ = ModuleLayer;
    class ServerLevel extends Internal.Level implements Internal.WorldGenLevel {
        constructor(arg0: Internal.MinecraftServer_, arg1: Internal.Executor_, arg2: Internal.LevelStorageSource$LevelStorageAccess_, arg3: Internal.ServerLevelData_, arg4: Internal.ResourceKey_<Internal.Level_>, arg5: Internal.Holder_<Internal.DimensionType_>, arg6: Internal.ChunkProgressListener_, arg7: Internal.ChunkGenerator_, arg8: boolean, arg9: number, arg10: Internal.List_<any_>, arg11: boolean)
        dragonFight(): Internal.EndDragonFight;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_): Internal.Player;
        getShade(arg0: Internal.Direction_, arg1: boolean): number;
        dayTime(): number;
        playSound(arg0: Internal.Player_, arg1: Internal.Entity_, arg2: Internal.SoundEvent_, arg3: Internal.SoundSource_, arg4: number, arg5: number): void;
        isUnobstructed(arg0: Internal.Entity_, arg1: Internal.VoxelShape_): boolean;
        resetEmptyTime(): void;
        getMaxSection(): number;
        gameEvent(arg0: Internal.GameEvent_, arg1: Internal.Entity_): void;
        setDefaultSpawnPos(arg0: BlockPos_, arg1: number): void;
        getSectionYFromSectionIndex(arg0: number): number;
        tick(arg0: Internal.BooleanSupplier_): void;
        gatherChunkSourceStats(): string;
        isEmptyBlock(arg0: BlockPos_): boolean;
        getTimeOfDay(arg0: number): number;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        addRespawnedPlayer(arg0: Internal.ServerPlayer_): void;
        getEntities(arg0: Internal.EntityTypeTest_<Internal.Entity_, T>, arg1: Internal.Predicate_<any>): Internal.List<any>;
        addWorldGenChunkEntities(arg0: Internal.Stream_<Internal.Entity_>): void;
        sendParticles(arg0: Internal.ServerPlayer_, arg1: T, arg2: boolean, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number): boolean;
        findNearestBiome(arg0: Internal.Predicate_<Internal.Holder_<Internal.Biome_>>, arg1: BlockPos_, arg2: number, arg3: number): com.mojang.datafixers.util.Pair<BlockPos, Internal.Holder<Internal.Biome>>;
        getRaidAt(arg0: BlockPos_): Internal.Raid;
        getDataStorage(): Internal.DimensionDataStorage;
        getSectionIndex(arg0: number): number;
        ensureCanWrite(arg0: BlockPos_): boolean;
        hasChunksAt(arg0: BlockPos_, arg1: BlockPos_): boolean;
        removeEntity(arg0: Internal.Entity_): void;
        destroyBlock(arg0: BlockPos_, arg1: boolean, arg2: Internal.Entity_): boolean;
        getHeight(): number;
        getDragons(): Internal.List<any>;
        addDuringTeleport(arg0: Internal.Entity_): void;
        hasChunkAt(arg0: BlockPos_): boolean;
        isNaturalSpawningAllowed(arg0: Internal.ChunkPos_): boolean;
        getBiome(arg0: BlockPos_): Internal.Holder<Internal.Biome>;
        isPositionEntityTicking(arg0: BlockPos_): boolean;
        shouldTickBlocksAt(arg0: number): boolean;
        getSharedSpawnAngle(): number;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Block_, arg2: number, arg3: Internal.TickPriority_): void;
        structureFeatureManager(): Internal.StructureFeatureManager;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: number, arg3: number, arg4: number): Internal.Player;
        isNaturalSpawningAllowed(arg0: BlockPos_): boolean;
        setWeatherParameters(arg0: number, arg1: number, arg2: boolean, arg3: boolean): void;
        findFreePosition(arg0: Internal.Entity_, arg1: Internal.VoxelShape_, arg2: Vec3_, arg3: number, arg4: number, arg5: number): Internal.Optional<Vec3>;
        getPortalForcer(): Internal.PortalForcer;
        removeEntityComplete(arg0: Internal.Entity_, arg1: boolean): void;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        players(): Internal.List<Internal.ServerPlayer>;
        isVillage(arg0: Internal.SectionPos_): boolean;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        getRawBrightness(arg0: BlockPos_, arg1: number): number;
        getDifficulty(): Internal.Difficulty;
        getForcedChunks(): Internal.LongSet;
        getUncachedNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        mayInteract(arg0: Internal.Player_, arg1: BlockPos_): boolean;
        canSeeSkyFromBelowWater(arg0: BlockPos_): boolean;
        getSectionsCount(): number;
        getFreeMapId(): number;
        getFluidTicks(): Internal.LevelTicks<Internal.Fluid>;
        levelEvent(arg0: Internal.Player_, arg1: number, arg2: BlockPos_, arg3: number): void;
        getChunk(arg0: number, arg1: number, arg2: Internal.ChunkStatus_): Internal.ChunkAccess;
        hasChunk(arg0: number, arg1: number): boolean;
        destroyBlockProgress(arg0: number, arg1: BlockPos_, arg2: number): void;
        getMoonBrightness(): number;
        isWaterAt(arg0: BlockPos_): boolean;
        explode(arg0: Internal.Entity_, arg1: Internal.DamageSource_, arg2: Internal.ExplosionDamageCalculator_, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean, arg8: Internal.Explosion$BlockInteraction_): Internal.Explosion;
        saveDebugReport(arg0: Internal.Path_): void;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        getEntityCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.VoxelShape>;
        getNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getChunkSource(): Internal.ChunkSource;
        registryAccess(): Internal.RegistryAccess;
        removePlayerImmediately(arg0: Internal.ServerPlayer_, arg1: Internal.Entity$RemovalReason_): void;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        getPoiManager(): Internal.PoiManager;
        getRecipeManager(): Internal.RecipeManager;
        static makeObsidianPlatform(arg0: Internal.ServerLevel_): void;
        gameEvent(arg0: Internal.Entity_, arg1: Internal.GameEvent_, arg2: BlockPos_): void;
        containsAnyLiquid(arg0: Internal.AABB_): boolean;
        getMaxLightLevel(): number;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
        tickNonPassenger(arg0: Internal.Entity_): void;
        getPlayers(arg0: Internal.Predicate_<any>): Internal.List<Internal.ServerPlayer>;
        getSeed(): number;
        save(arg0: Internal.ProgressListener_, arg1: boolean, arg2: boolean): void;
        broadcastEntityEvent(arg0: Internal.Entity_, arg1: number): void;
        getBrightness(arg0: Internal.LightLayer_, arg1: BlockPos_): number;
        addWithUUID(arg0: Internal.Entity_): boolean;
        getAllEntities(): Internal.Iterable<Internal.Entity>;
        unload(arg0: Internal.LevelChunk_): void;
        getMaxLocalRawBrightness(arg0: BlockPos_, arg1: number): number;
        getBlockCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        canSleepThroughNights(): boolean;
        getHeightmapPos(arg0: Internal.Heightmap$Types_, arg1: BlockPos_): BlockPos;
        blockUpdated(arg0: BlockPos_, arg1: Internal.Block_): void;
        getEntities(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.Entity>;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_): Internal.List<T>;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        onReputationEvent(arg0: Internal.ReputationEventType_, arg1: Internal.Entity_, arg2: Internal.ReputationEventHandler_): void;
        getBrightness(arg0: BlockPos_): number;
        getNearestEntity(arg0: Internal.List_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number): T;
        setDayTime(arg0: number): void;
        onBlockStateChange(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: Internal.BlockState_): void;
        getMinBuildHeight(): number;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Fluid_, arg2: number): void;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): Internal.Player;
        playSound(arg0: Internal.Player_, arg1: number, arg2: number, arg3: number, arg4: Internal.SoundEvent_, arg5: Internal.SoundSource_, arg6: number, arg7: number): void;
        getStructureManager(): Internal.StructureManager;
        getEntities(): Internal.LevelEntityGetter<Internal.Entity>;
        hasChunkAt(arg0: number, arg1: number): boolean;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: number, arg2: number, arg3: number): Internal.Player;
        getMaxBuildHeight(): number;
        setMapData(arg0: string, arg1: Internal.MapItemSavedData_): void;
        destroyBlock(arg0: BlockPos_, arg1: boolean): boolean;
        areEntitiesLoaded(arg0: number): boolean;
        tryAddFreshEntityWithPassengers(arg0: Internal.Entity_): boolean;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Block_, arg2: number): void;
        addFreshEntity(arg0: Internal.Entity_): boolean;
        setChunkForced(arg0: number, arg1: number, arg2: boolean): boolean;
        getCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        addDuringCommandTeleport(arg0: Internal.ServerPlayer_): void;
        startTickingChunk(arg0: Internal.LevelChunk_): void;
        getBlockTicks(): Internal.LevelTickAccess<any>;
        getChunk(arg0: BlockPos_): Internal.ChunkAccess;
        getWatchdogStats(): string;
        gameEvent(arg0: Internal.GameEvent_, arg1: BlockPos_): void;
        toString(): string;
        getMaxLocalRawBrightness(arg0: BlockPos_): number;
        isUnobstructed(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.CollisionContext_): boolean;
        removeEntity(arg0: Internal.Entity_, arg1: boolean): void;
        asKJS(): Internal.LevelJS;
        isCloseToVillage(arg0: BlockPos_, arg1: number): boolean;
        hasNearbyAlivePlayer(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        tickCustomSpawners(arg0: boolean, arg1: boolean): void;
        noSave(): boolean;
        getBlockTint(arg0: BlockPos_, arg1: Internal.ColorResolver_): number;
        getScoreboard(): Internal.ServerScoreboard;
        addNewPlayer(arg0: Internal.ServerPlayer_): void;
        removePlayer(arg0: Internal.ServerPlayer_, arg1: boolean): void;
        getMinSection(): number;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        getNearestPlayer(arg0: Internal.Entity_, arg1: number): Internal.Player;
        getBlockStatesIfLoaded(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getPartEntities(): Internal.Collection<Internal.PartEntity<any>>;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        sendParticles(arg0: T, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number): number;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        getSharedSpawnPos(): BlockPos;
        isHandlingTick(): boolean;
        canSeeSky(arg0: BlockPos_): boolean;
        getMoonPhase(): number;
        isUnobstructed(arg0: Internal.Entity_): boolean;
        getEntityOrPart(arg0: number): Internal.Entity;
        addFreshEntityWithPassengers(arg0: Internal.Entity_): void;
        blockEvent(arg0: BlockPos_, arg1: Internal.Block_, arg2: number, arg3: number): void;
        getPlayerByUUID(arg0: Internal.UUID_): Internal.Player;
        getSectionIndexFromSectionY(arg0: number): number;
        getNearbyPlayers(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: Internal.AABB_): Internal.List<Internal.Player>;
        getServer(): Internal.MinecraftServer;
        updateSleepingPlayerList(): void;
        getRandomPlayer(): Internal.ServerPlayer;
        noCollision(arg0: Internal.Entity_): boolean;
        getLevel(): this;
        tickChunk(arg0: Internal.LevelChunk_, arg1: number): void;
        getEntity(arg0: Internal.UUID_): Internal.Entity;
        sectionsToVillage(arg0: Internal.SectionPos_): number;
        getNearbyEntities(arg0: Internal.Class_<T>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: Internal.AABB_): Internal.List<T>;
        getMapData(arg0: string): Internal.MapItemSavedData;
        sendVibrationParticle(arg0: Internal.VibrationPath_): void;
        noCollision(arg0: Internal.AABB_): boolean;
        findNearestMapFeature(arg0: Internal.TagKey_<Internal.ConfiguredStructureFeature_<any, any>>, arg1: BlockPos_, arg2: number, arg3: boolean): BlockPos;
        getDirectSignal(arg0: BlockPos_, arg1: Internal.Direction_): number;
        collidesWithSuffocatingBlock(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        clearBlockEvents(arg0: Internal.BoundingBox_): void;
        setCurrentlyGenerating(arg0: Internal.Supplier_<string>): void;
        noCollision(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        isOutsideBuildHeight(arg0: number): boolean;
        gameEvent(arg0: Internal.Entity_, arg1: Internal.GameEvent_, arg2: Internal.Entity_): void;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Fluid_, arg2: number, arg3: Internal.TickPriority_): void;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Predicate_<Internal.Entity_>): Internal.Player;
        getNearestEntity(arg0: Internal.Class_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number, arg6: Internal.AABB_): T;
        globalLevelEvent(arg0: number, arg1: BlockPos_, arg2: number): void;
        addDuringPortalTeleport(arg0: Internal.ServerPlayer_): void;
        getLogicalHeight(): number;
        onStructureStartsAvailable(arg0: Internal.ChunkAccess_): void;
        addLegacyChunkEntities(arg0: Internal.Stream_<Internal.Entity_>): void;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_, arg2: Internal.Predicate_<any>): Internal.List<T>;
        isRaided(arg0: BlockPos_): boolean;
        sendBlockUpdated(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: Internal.BlockState_, arg3: number): void;
        levelEvent(arg0: number, arg1: BlockPos_, arg2: number): void;
        getRaids(): Internal.Raids;
        isVillage(arg0: BlockPos_): boolean;
        close(): void;
        getEntity(arg0: number): Internal.Entity;
        isFlat(): boolean;
        get maxSection(): number
        get dataStorage(): Internal.DimensionDataStorage
        get height(): number
        get dragons(): Internal.List<any>
        get sharedSpawnAngle(): number
        get portalForcer(): Internal.PortalForcer
        get difficulty(): Internal.Difficulty
        get forcedChunks(): Internal.LongSet
        get sectionsCount(): number
        get freeMapId(): number
        get fluidTicks(): Internal.LevelTicks<Internal.Fluid>
        get moonBrightness(): number
        get chunkSource(): Internal.ChunkSource
        get poiManager(): Internal.PoiManager
        get recipeManager(): Internal.RecipeManager
        get maxLightLevel(): number
        get seed(): number
        get allEntities(): Internal.Iterable<Internal.Entity>
        set dayTime(arg0: number)
        get minBuildHeight(): number
        get structureManager(): Internal.StructureManager
        get entities(): Internal.LevelEntityGetter<Internal.Entity>
        get maxBuildHeight(): number
        get blockTicks(): Internal.LevelTickAccess<any>
        get watchdogStats(): string
        get scoreboard(): Internal.ServerScoreboard
        get minSection(): number
        get partEntities(): Internal.Collection<Internal.PartEntity<any>>
        get sharedSpawnPos(): BlockPos
        get handlingTick(): boolean
        get moonPhase(): number
        get server(): Internal.MinecraftServer
        get randomPlayer(): Internal.ServerPlayer
        get level(): Internal.ServerLevel
        set currentlyGenerating(arg0: Internal.Supplier_<string>)
        get logicalHeight(): number
        get raids(): Internal.Raids
        get flat(): boolean
        readonly static "END_SPAWN_POINT": BlockPos;
        "noSave": boolean;
    }
    type ServerLevel_ = ServerLevel;
    abstract class SavedData {
        constructor()
        isDirty(): boolean;
        setDirty(arg0: boolean): void;
        save(arg0: Internal.File_): void;
        save(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        setDirty(): void;
        get dirty(): boolean
        set dirty(arg0: boolean)
    }
    type SavedData_ = SavedData;
    interface NonNullConsumer <T> {
        accept(arg0: T): void;
    }
    type NonNullConsumer_<T> = NonNullConsumer<T> | ((arg0: T)=>void);
    interface EnchantmentBuilder$DamageProtectionFunction {
        getDamageProtection(arg0: number, arg1: Internal.DamageSource_): number;
    }
    type EnchantmentBuilder$DamageProtectionFunction_ = EnchantmentBuilder$DamageProtectionFunction | ((arg0: number, arg1: Internal.DamageSource)=>number);
    class LevelStorageSource$LevelStorageAccess implements Internal.AutoCloseable {
        constructor(arg0: Internal.LevelStorageSource_, arg1: string)
        deleteLevel(): void;
        getLevelPath(arg0: Internal.LevelResource_): Internal.Path;
        getLevelId(): string;
        getWorldDir(): Internal.Path;
        saveDataTag(arg0: Internal.RegistryAccess_, arg1: Internal.WorldData_, arg2: Internal.CompoundTag_): void;
        getSummary(): Internal.LevelSummary;
        makeWorldBackup(): number;
        getDimensionPath(arg0: Internal.ResourceKey_<Internal.Level_>): Internal.Path;
        readAdditionalLevelSaveData(): void;
        renameLevel(arg0: string): void;
        saveDataTag(arg0: Internal.RegistryAccess_, arg1: Internal.WorldData_): void;
        close(): void;
        getDataTag(arg0: Internal.DynamicOps_<Internal.Tag_>, arg1: Internal.DataPackConfig_, arg2: Internal.Lifecycle_): Internal.WorldData;
        createPlayerStorage(): Internal.PlayerDataStorage;
        getDataPacks(): Internal.DataPackConfig;
        getIconFile(): Internal.Optional<Internal.Path>;
        get levelId(): string
        get worldDir(): Internal.Path
        get summary(): Internal.LevelSummary
        get dataPacks(): Internal.DataPackConfig
        get iconFile(): Internal.Optional<Internal.Path>
    }
    type LevelStorageSource$LevelStorageAccess_ = LevelStorageSource$LevelStorageAccess;
    interface Applicative <F, Mu> extends Internal.Functor<F, Mu> {
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        apply7(arg0: Internal.Function7_<T1, T2, T3, T4, T5, T6, T7, R>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>, arg6: Internal.App_<F, T6>, arg7: Internal.App_<F, T7>): Internal.App<F, R>;
        lift2(arg0: Internal.App_<F, Internal.BiFunction_<A, B, R>>): Internal.BiFunction<Internal.App<F, A>, Internal.App<F, B>, Internal.App<F, R>>;
        apply3(arg0: Internal.Function3_<T1, T2, T3, R>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>): Internal.App<F, R>;
        ap4(arg0: Internal.App_<F, Internal.Function4_<T1, T2, T3, T4, R>>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>): Internal.App<F, R>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>): Internal.Products$P13<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>;
        lift6(arg0: Internal.App_<F, Internal.Function6_<T1, T2, T3, T4, T5, T6, R>>): Internal.Function6<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, R>>;
        ap6(arg0: Internal.App_<F, Internal.Function6_<T1, T2, T3, T4, T5, T6, R>>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>, arg6: Internal.App_<F, T6>): Internal.App<F, R>;
        apply9(arg0: Internal.Function9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>, arg6: Internal.App_<F, T6>, arg7: Internal.App_<F, T7>, arg8: Internal.App_<F, T8>, arg9: Internal.App_<F, T9>): Internal.App<F, R>;
        lift3(arg0: Internal.App_<F, Internal.Function3_<T1, T2, T3, R>>): Internal.Function3<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, R>>;
        ap13(arg0: Internal.App_<F, Internal.Function13_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>, arg6: Internal.App_<F, T6>, arg7: Internal.App_<F, T7>, arg8: Internal.App_<F, T8>, arg9: Internal.App_<F, T9>, arg10: Internal.App_<F, T10>, arg11: Internal.App_<F, T11>, arg12: Internal.App_<F, T12>, arg13: Internal.App_<F, T13>): Internal.App<F, R>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>): Internal.Products$P3<F, T1, T2, T3>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>): Internal.Products$P10<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>;
        ap11(arg0: Internal.App_<F, Internal.Function11_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>, arg6: Internal.App_<F, T6>, arg7: Internal.App_<F, T7>, arg8: Internal.App_<F, T8>, arg9: Internal.App_<F, T9>, arg10: Internal.App_<F, T10>, arg11: Internal.App_<F, T11>): Internal.App<F, R>;
        lift5(arg0: Internal.App_<F, Internal.Function5_<T1, T2, T3, T4, T5, R>>): Internal.Function5<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, R>>;
        unbox(arg0: Internal.App_<Mu, F>): this;
        lift4(arg0: Internal.App_<F, Internal.Function4_<T1, T2, T3, T4, R>>): Internal.Function4<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, R>>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>, arg13: Internal.App_<F, T14>): Internal.Products$P14<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>;
        lift1(arg0: Internal.App_<F, Internal.Function_<A, R>>): Internal.Function<Internal.App<F, A>, Internal.App<F, R>>;
        ap(arg0: Internal.App_<F, Internal.Function_<A, R>>, arg1: Internal.App_<F, A>): Internal.App<F, R>;
        ap(arg0: Internal.Function_<A, R>, arg1: Internal.App_<F, A>): Internal.App<F, R>;
        lift9(arg0: Internal.App_<F, Internal.Function9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>): Internal.Function9<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, T7>, Internal.App<F, T8>, Internal.App<F, T9>, Internal.App<F, R>>;
        ap9(arg0: Internal.App_<F, Internal.Function9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>, arg6: Internal.App_<F, T6>, arg7: Internal.App_<F, T7>, arg8: Internal.App_<F, T8>, arg9: Internal.App_<F, T9>): Internal.App<F, R>;
        ap2(arg0: Internal.App_<F, Internal.BiFunction_<A, B, R>>, arg1: Internal.App_<F, A>, arg2: Internal.App_<F, B>): Internal.App<F, R>;
        apply5(arg0: Internal.Function5_<T1, T2, T3, T4, T5, R>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>): Internal.App<F, R>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>): Internal.Products$P11<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>;
        ap10(arg0: Internal.App_<F, Internal.Function10_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>, arg6: Internal.App_<F, T6>, arg7: Internal.App_<F, T7>, arg8: Internal.App_<F, T8>, arg9: Internal.App_<F, T9>, arg10: Internal.App_<F, T10>): Internal.App<F, R>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>, arg13: Internal.App_<F, T14>, arg14: Internal.App_<F, T15>): Internal.Products$P15<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>): Internal.Products$P2<F, T1, T2>;
        lift7(arg0: Internal.App_<F, Internal.Function7_<T1, T2, T3, T4, T5, T6, T7, R>>): Internal.Function7<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, T7>, Internal.App<F, R>>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        ap14(arg0: Internal.App_<F, Internal.Function14_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>, arg6: Internal.App_<F, T6>, arg7: Internal.App_<F, T7>, arg8: Internal.App_<F, T8>, arg9: Internal.App_<F, T9>, arg10: Internal.App_<F, T10>, arg11: Internal.App_<F, T11>, arg12: Internal.App_<F, T12>, arg13: Internal.App_<F, T13>, arg14: Internal.App_<F, T14>): Internal.App<F, R>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>): Internal.Products$P9<F, T1, T2, T3, T4, T5, T6, T7, T8, T9>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>): Internal.Products$P4<F, T1, T2, T3, T4>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>;
        group(arg0: Internal.App_<F, T1>): Internal.Products$P1<F, T1>;
        ap5(arg0: Internal.App_<F, Internal.Function5_<T1, T2, T3, T4, T5, R>>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>): Internal.App<F, R>;
        ap7(arg0: Internal.App_<F, Internal.Function7_<T1, T2, T3, T4, T5, T6, T7, R>>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>, arg6: Internal.App_<F, T6>, arg7: Internal.App_<F, T7>): Internal.App<F, R>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>): Internal.Products$P12<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>;
        ap15(arg0: Internal.App_<F, Internal.Function15_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>, arg6: Internal.App_<F, T6>, arg7: Internal.App_<F, T7>, arg8: Internal.App_<F, T8>, arg9: Internal.App_<F, T9>, arg10: Internal.App_<F, T10>, arg11: Internal.App_<F, T11>, arg12: Internal.App_<F, T12>, arg13: Internal.App_<F, T13>, arg14: Internal.App_<F, T14>, arg15: Internal.App_<F, T15>): Internal.App<F, R>;
        ap3(arg0: Internal.App_<F, Internal.Function3_<T1, T2, T3, R>>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>): Internal.App<F, R>;
        ap8(arg0: Internal.App_<F, Internal.Function8_<T1, T2, T3, T4, T5, T6, T7, T8, R>>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>, arg6: Internal.App_<F, T6>, arg7: Internal.App_<F, T7>, arg8: Internal.App_<F, T8>): Internal.App<F, R>;
        apply8(arg0: Internal.Function8_<T1, T2, T3, T4, T5, T6, T7, T8, R>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>, arg6: Internal.App_<F, T6>, arg7: Internal.App_<F, T7>, arg8: Internal.App_<F, T8>): Internal.App<F, R>;
        point(arg0: A): Internal.App<F, A>;
        lift8(arg0: Internal.App_<F, Internal.Function8_<T1, T2, T3, T4, T5, T6, T7, T8, R>>): Internal.Function8<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, T7>, Internal.App<F, T8>, Internal.App<F, R>>;
        apply2(arg0: Internal.BiFunction_<A, B, R>, arg1: Internal.App_<F, A>, arg2: Internal.App_<F, B>): Internal.App<F, R>;
        apply6(arg0: Internal.Function6_<T1, T2, T3, T4, T5, T6, R>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>, arg6: Internal.App_<F, T6>): Internal.App<F, R>;
        apply4(arg0: Internal.Function4_<T1, T2, T3, T4, R>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>): Internal.App<F, R>;
        ap12(arg0: Internal.App_<F, Internal.Function12_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>, arg6: Internal.App_<F, T6>, arg7: Internal.App_<F, T7>, arg8: Internal.App_<F, T8>, arg9: Internal.App_<F, T9>, arg10: Internal.App_<F, T10>, arg11: Internal.App_<F, T11>, arg12: Internal.App_<F, T12>): Internal.App<F, R>;
        ap16(arg0: Internal.App_<F, Internal.Function16_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>, arg1: Internal.App_<F, T1>, arg2: Internal.App_<F, T2>, arg3: Internal.App_<F, T3>, arg4: Internal.App_<F, T4>, arg5: Internal.App_<F, T5>, arg6: Internal.App_<F, T6>, arg7: Internal.App_<F, T7>, arg8: Internal.App_<F, T8>, arg9: Internal.App_<F, T9>, arg10: Internal.App_<F, T10>, arg11: Internal.App_<F, T11>, arg12: Internal.App_<F, T12>, arg13: Internal.App_<F, T13>, arg14: Internal.App_<F, T14>, arg15: Internal.App_<F, T15>, arg16: Internal.App_<F, T16>): Internal.App<F, R>;
        group(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>, arg13: Internal.App_<F, T14>, arg14: Internal.App_<F, T15>, arg15: Internal.App_<F, T16>): Internal.Products$P16<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>;
    }
    type Applicative_<F, Mu> = Applicative<F, Mu>;
    interface GenericDeclaration extends Internal.AnnotatedElement {
        getAnnotationsByType(arg0: Internal.Class_<T>): T[];
        getDeclaredAnnotation(arg0: Internal.Class_<T>): T;
        getDeclaredAnnotationsByType(arg0: Internal.Class_<T>): T[];
        isAnnotationPresent(arg0: Internal.Class_<any>): boolean;
        getTypeParameters(): any[];
        get typeParameters(): any[]
    }
    type GenericDeclaration_ = GenericDeclaration;
    class LocalPlayer extends Internal.AbstractClientPlayer {
        constructor(arg0: Internal.Minecraft_, arg1: Internal.ClientLevel_, arg2: Internal.ClientPacketListener_, arg3: Internal.StatsCounter_, arg4: Internal.ClientRecipeBook_, arg5: boolean, arg6: boolean)
        resetPos(): void;
        openCommandBlock(arg0: Internal.CommandBlockEntity_): void;
        updateSyncFields(arg0: Internal.LocalPlayer_): void;
        isRidingJumpable(): boolean;
        playSound(arg0: Internal.SoundEvent_, arg1: number, arg2: number): void;
        getStepHeight(): number;
        isLocalPlayer(): boolean;
        isEffectiveAi(): boolean;
        isSuppressingSlidingDownLadder(): boolean;
        startRiding(arg0: Internal.Entity_, arg1: boolean): boolean;
        isMovingSlowly(): boolean;
        stopUsingItem(): void;
        startUsingItem(arg0: Hand_): void;
        sendMessage(arg0: Internal.Component_, arg1: Internal.UUID_): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        canInteractWith(arg0: BlockPos_, arg1: number): boolean;
        onUpdateAbilities(): void;
        setServerBrand(arg0: string): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getRopeHoldPosition(arg0: number): Vec3;
        clientSideCloseContainer(): void;
        removeRecipeHighlight(arg0: Internal.Recipe_<any>): void;
        canInteractWith(arg0: Internal.Entity_, arg1: number): boolean;
        isCloseEnough(arg0: Internal.Entity_, arg1: number): boolean;
        isCrouching(): boolean;
        getServerBrand(): string;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        playNotifySound(arg0: Internal.SoundEvent_, arg1: Internal.SoundSource_, arg2: number, arg3: number): void;
        move(arg0: Internal.MoverType_, arg1: Vec3_): void;
        getWaterVision(): number;
        magicCrit(arg0: Internal.Entity_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        getCurrentMood(): number;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        rideTick(): void;
        alwaysAccepts(): boolean;
        canSpawnSprintParticle(): boolean;
        isShiftKeyDown(): boolean;
        openItemGui(arg0: Internal.ItemStack_, arg1: Hand_): void;
        isAutoJumpEnabled(): boolean;
        getUsedItemHand(): Hand;
        setShowDeathScreen(arg0: boolean): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        crit(arg0: Internal.Entity_): void;
        heal(arg0: number): void;
        setExperienceValues(arg0: number, arg1: number, arg2: number): void;
        displayClientMessage(arg0: Internal.Component_, arg1: boolean): void;
        getRecipeBook(): Internal.ClientRecipeBook;
        getAttackRange(): number;
        canHit(arg0: Internal.Entity_, arg1: number): boolean;
        openMinecartCommandBlock(arg0: Internal.BaseCommandBlock_): void;
        openStructureBlock(arg0: Internal.StructureBlockEntity_): void;
        closeContainer(): void;
        asKJS(): Internal.EntityJS;
        updateTutorialInventoryAction(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.ClickAction_): void;
        hurtTo(arg0: number): void;
        openTextEdit(arg0: Internal.SignBlockEntity_): void;
        setPermissionLevel(arg0: number): void;
        isUnderWater(): boolean;
        canRiderInteract(): boolean;
        getViewXRot(arg0: number): number;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        openJigsawBlock(arg0: Internal.JigsawBlockEntity_): void;
        sendOpenInventory(): void;
        removeEffectNoUpdate(arg0: Internal.MobEffect_): Internal.MobEffectInstance;
        isUsingItem(): boolean;
        canSpawnSoulSpeedParticle(): boolean;
        getReachDistance(): number;
        setSprinting(arg0: boolean): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        isHandsBusy(): boolean;
        getPermissionLevel(): number;
        aiStep(): void;
        removeVehicle(): void;
        getJumpRidingScale(): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        shouldShowDeathScreen(): boolean;
        respawn(): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        serverAiStep(): void;
        drop(arg0: boolean): boolean;
        swing(arg0: Hand_): void;
        getViewYRot(arg0: number): number;
        chat(arg0: string): void;
        getStats(): Internal.StatsCounter;
        get ridingJumpable(): boolean
        get stepHeight(): number
        get localPlayer(): boolean
        get effectiveAi(): boolean
        get suppressingSlidingDownLadder(): boolean
        get movingSlowly(): boolean
        set serverBrand(arg0: string)
        get crouching(): boolean
        get serverBrand(): string
        get waterVision(): number
        get currentMood(): number
        get shiftKeyDown(): boolean
        get autoJumpEnabled(): boolean
        get usedItemHand(): Hand
        set showDeathScreen(arg0: boolean)
        get recipeBook(): Internal.ClientRecipeBook
        get attackRange(): number
        set permissionLevel(arg0: number)
        get underWater(): boolean
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get usingItem(): boolean
        get reachDistance(): number
        set sprinting(arg0: boolean)
        get handsBusy(): boolean
        get permissionLevel(): number
        get jumpRidingScale(): number
        get stats(): Internal.StatsCounter
        "input": Internal.Input;
        "xBobO": number;
        "portalTime": number;
        readonly "connection": Internal.ClientPacketListener;
        "xBob": number;
        "oPortalTime": number;
        "yBob": number;
        "yBobO": number;
        "sprintTime": number;
    }
    type LocalPlayer_ = LocalPlayer;
    class Explosion {
        constructor(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: boolean, arg7: Internal.Explosion$BlockInteraction_)
        constructor(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: boolean, arg7: Internal.Explosion$BlockInteraction_, arg8: Internal.List_<BlockPos_>)
        constructor(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: number, arg3: number, arg4: number, arg5: number)
        constructor(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.List_<BlockPos_>)
        constructor(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.DamageSource_, arg3: Internal.ExplosionDamageCalculator_, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean, arg9: Internal.Explosion$BlockInteraction_)
        getSourceMob(): Internal.LivingEntity;
        getToBlow(): Internal.List<BlockPos>;
        static getSeenPercent(arg0: Vec3_, arg1: Internal.Entity_): number;
        clearToBlow(): void;
        getDamageSource(): Internal.DamageSource;
        getPosition(): Vec3;
        getExploder(): Internal.Entity;
        finalizeExplosion(arg0: boolean): void;
        explode(): void;
        getHitPlayers(): Internal.Map<Internal.Player, Vec3>;
        get sourceMob(): Internal.LivingEntity
        get toBlow(): Internal.List<BlockPos>
        get damageSource(): Internal.DamageSource
        get position(): Vec3
        get exploder(): Internal.Entity
        get hitPlayers(): Internal.Map<Internal.Player, Vec3>
        "radius": number;
        "source": Internal.Entity;
    }
    type Explosion_ = Explosion;
    interface LongConsumer {
        andThen(arg0: Internal.LongConsumer_): this;
        accept(arg0: number): void;
    }
    type LongConsumer_ = LongConsumer | ((arg0: number)=>void);
    class Holder$Reference <T> implements Internal.Holder<T> {
        isValidInRegistry(arg0: Internal.Registry_<T>): boolean;
        bindTags(arg0: Internal.Collection_<Internal.TagKey_<T>>): void;
        containsTag(arg0: Internal.TagKey_<T>): boolean;
        isBound(): boolean;
        toString(): string;
        static createIntrusive(arg0: Internal.Registry_<T>, arg1: T): Internal.Holder$Reference<T>;
        is(arg0: ResourceLocation_): boolean;
        static createStandAlone(arg0: Internal.Registry_<T>, arg1: Internal.ResourceKey_<T>): Internal.Holder$Reference<T>;
        getType(): Internal.Holder$Reference$Type;
        value(): T;
        bind(arg0: Internal.ResourceKey_<T>, arg1: T): void;
        key(): Internal.ResourceKey<T>;
        is(arg0: Internal.Predicate_<Internal.ResourceKey_<T>>): boolean;
        unwrap(): Internal.Either<Internal.ResourceKey<T>, T>;
        unwrapKey(): Internal.Optional<Internal.ResourceKey<T>>;
        getTagKeys(): Internal.Stream<Internal.TagKey<T>>;
        kind(): Internal.Holder$Kind;
        is(arg0: Internal.ResourceKey_<T>): boolean;
        tags(): Internal.Stream<Internal.TagKey<T>>;
        containsTag(arg0: Internal.ITag_<T>): boolean;
        is(arg0: Internal.TagKey_<T>): boolean;
        get bound(): boolean
        get type(): Internal.Holder$Reference$Type
        get tagKeys(): Internal.Stream<Internal.TagKey<T>>
    }
    type Holder$Reference_<T> = Holder$Reference<T>;
    class GlobalPos {
        hashCode(): number;
        dimension(): Internal.ResourceKey<Internal.Level>;
        toString(): string;
        pos(): BlockPos;
        static of(arg0: Internal.ResourceKey_<Internal.Level_>, arg1: BlockPos_): Internal.GlobalPos;
        equals(arg0: any): boolean;
        readonly static "CODEC": any;
    }
    type GlobalPos_ = GlobalPos;
    abstract class Model {
        constructor(arg0: Internal.Function_<ResourceLocation_, Internal.RenderType_>)
        renderType(arg0: ResourceLocation_): Internal.RenderType;
        renderToBuffer(arg0: Internal.PoseStack_, arg1: Internal.VertexConsumer_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
    }
    type Model_ = Model;
    class ClientboundContainerSetContentPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: number, arg2: Internal.NonNullList_<Internal.ItemStack_>, arg3: Internal.ItemStack_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getStateId(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getCarriedItem(): Internal.ItemStack;
        getContainerId(): number;
        isSkippable(): boolean;
        getItems(): Internal.List<Internal.ItemStack>;
        get stateId(): number
        get carriedItem(): Internal.ItemStack
        get containerId(): number
        get skippable(): boolean
        get items(): Internal.List<Internal.ItemStack>
    }
    type ClientboundContainerSetContentPacket_ = ClientboundContainerSetContentPacket;
    class IntSummaryStatistics implements Internal.IntConsumer {
        constructor()
        constructor(arg0: number, arg1: number, arg2: number, arg3: number)
        getSum(): number;
        toString(): string;
        getCount(): number;
        getAverage(): number;
        getMax(): number;
        accept(arg0: number): void;
        getMin(): number;
        combine(arg0: Internal.IntSummaryStatistics_): void;
        andThen(arg0: Internal.IntConsumer_): Internal.IntConsumer;
        get sum(): number
        get count(): number
        get average(): number
        get max(): number
        get min(): number
    }
    type IntSummaryStatistics_ = IntSummaryStatistics;
    class Class <T> implements Internal.Constable, Internal.Type, Internal.TypeDescriptor$OfField<Internal.Class<any>>, Internal.Serializable, Internal.AnnotatedElement, Internal.GenericDeclaration {
        isPrimitive(): boolean;
        getTypeName(): string;
        isAnnotation(): boolean;
        getConstructors(): Internal.Constructor<any>[];
        isInstance(arg0: any): boolean;
        getModifiers(): number;
        static forName(arg0: Internal.Module_, arg1: string): Internal.Class<any>;
        getDeclaredMethod(arg0: string, ...arg1: Internal.Class_<any>[]): Internal.Method;
        getEnumConstants(): T[];
        getAnnotation(arg0: Internal.Class_<A>): A;
        getAnnotatedSuperclass(): Internal.AnnotatedType;
        getRecordComponents(): any[];
        getDeclaredField(arg0: string): Internal.Field;
        getClassLoader(): Internal.ClassLoader;
        getPackageName(): string;
        getAnnotatedInterfaces(): Internal.AnnotatedType[];
        static forName(arg0: string): Internal.Class<any>;
        getDeclaredFields(): Internal.Field[];
        getResourceAsStream(arg0: string): Internal.InputStream;
        isLocalClass(): boolean;
        arrayType(): Internal.TypeDescriptor$OfField<any>;
        getDeclaredAnnotationsByType(arg0: Internal.Class_<A>): A[];
        cast(arg0: any): T;
        getProtectionDomain(): Internal.ProtectionDomain;
        getDeclaredConstructor(...arg0: Internal.Class_<any>[]): Internal.Constructor<T>;
        isAnonymousClass(): boolean;
        getGenericSuperclass(): Internal.Type;
        getMethods(): Internal.Method[];
        isNestmateOf(arg0: Internal.Class_<any>): boolean;
        isInterface(): boolean;
        getField(arg0: string): Internal.Field;
        getTypeParameters(): any[];
        getModule(): Internal.Module;
        getFields(): Internal.Field[];
        toGenericString(): string;
        isAssignableFrom(arg0: Internal.Class_<any>): boolean;
        getComponentType(): Internal.Class<any>;
        componentType(): Internal.TypeDescriptor$OfField<any>;
        getGenericInterfaces(): Internal.Type[];
        getEnclosingMethod(): Internal.Method;
        getNestMembers(): Internal.Class<any>[];
        getEnclosingConstructor(): Internal.Constructor<any>;
        descriptorString(): string;
        newInstance(): T;
        isRecord(): boolean;
        isArray(): boolean;
        getSuperclass(): Internal.Class<any>;
        getName(): string;
        describeConstable(): Internal.Optional<Internal.ClassDesc>;
        asSubclass(arg0: Internal.Class_<U>): Internal.Class<any>;
        isSealed(): boolean;
        getDeclaredAnnotations(): Internal.Annotation[];
        isMemberClass(): boolean;
        getDeclaredConstructors(): Internal.Constructor<any>[];
        getCanonicalName(): string;
        toString(): string;
        getClasses(): Internal.Class<any>[];
        isSynthetic(): boolean;
        isHidden(): boolean;
        getEnclosingClass(): Internal.Class<any>;
        getInterfaces(): Internal.Class<any>[];
        getSimpleName(): string;
        getMethod(arg0: string, ...arg1: Internal.Class_<any>[]): Internal.Method;
        getDeclaringClass(): Internal.Class<any>;
        getSigners(): any[];
        desiredAssertionStatus(): boolean;
        static forName(arg0: string, arg1: boolean, arg2: Internal.ClassLoader_): Internal.Class<any>;
        getPackage(): Internal.Package;
        getDeclaredMethods(): Internal.Method[];
        getConstructor(...arg0: Internal.Class_<any>[]): Internal.Constructor<T>;
        isEnum(): boolean;
        getPermittedSubclasses(): Internal.Class<any>[];
        getAnnotations(): Internal.Annotation[];
        getNestHost(): Internal.Class<any>;
        getDeclaredAnnotation(arg0: Internal.Class_<A>): A;
        isAnnotationPresent(arg0: Internal.Class_<any>): boolean;
        getResource(arg0: string): Internal.URL;
        getAnnotationsByType(arg0: Internal.Class_<A>): A[];
        getDeclaredClasses(): Internal.Class<any>[];
        get primitive(): boolean
        get typeName(): string
        get annotation(): boolean
        get constructors(): Internal.Constructor<any>[]
        get modifiers(): number
        get enumConstants(): T[]
        get annotatedSuperclass(): Internal.AnnotatedType
        get recordComponents(): any[]
        get classLoader(): Internal.ClassLoader
        get packageName(): string
        get annotatedInterfaces(): Internal.AnnotatedType[]
        get declaredFields(): Internal.Field[]
        get localClass(): boolean
        get protectionDomain(): Internal.ProtectionDomain
        get anonymousClass(): boolean
        get genericSuperclass(): Internal.Type
        get methods(): Internal.Method[]
        get interface(): boolean
        get typeParameters(): any[]
        get module(): Internal.Module
        get fields(): Internal.Field[]
        get componentType(): Internal.Class<any>
        get genericInterfaces(): Internal.Type[]
        get enclosingMethod(): Internal.Method
        get nestMembers(): Internal.Class<any>[]
        get enclosingConstructor(): Internal.Constructor<any>
        get record(): boolean
        get array(): boolean
        get superclass(): Internal.Class<any>
        get name(): string
        get sealed(): boolean
        get declaredAnnotations(): Internal.Annotation[]
        get memberClass(): boolean
        get declaredConstructors(): Internal.Constructor<any>[]
        get canonicalName(): string
        get classes(): Internal.Class<any>[]
        get synthetic(): boolean
        get hidden(): boolean
        get enclosingClass(): Internal.Class<any>
        get interfaces(): Internal.Class<any>[]
        get simpleName(): string
        get declaringClass(): Internal.Class<any>
        get signers(): any[]
        get package(): Internal.Package
        get declaredMethods(): Internal.Method[]
        get enum(): boolean
        get permittedSubclasses(): Internal.Class<any>[]
        get annotations(): Internal.Annotation[]
        get nestHost(): Internal.Class<any>
        get declaredClasses(): Internal.Class<any>[]
    }
    type Class_<T> = Class<T>;
    class HeightRangePlacement extends Internal.PlacementModifier {
        static uniform(arg0: Internal.VerticalAnchor_, arg1: Internal.VerticalAnchor_): Internal.HeightRangePlacement;
        type(): Internal.PlacementModifierType<any>;
        getPositions(arg0: Internal.PlacementContext_, arg1: Internal.Random_, arg2: BlockPos_): Internal.Stream<BlockPos>;
        static triangle(arg0: Internal.VerticalAnchor_, arg1: Internal.VerticalAnchor_): Internal.HeightRangePlacement;
        static of(arg0: Internal.HeightProvider_): Internal.HeightRangePlacement;
        readonly static "CODEC": any;
    }
    type HeightRangePlacement_ = HeightRangePlacement;
    class TerrainShaper$PointCustom extends Internal.Record {
        constructor(arg0: Internal.DensityFunction$FunctionContext_)
        hashCode(): number;
        toString(): string;
        context(): Internal.DensityFunction$FunctionContext;
        equals(arg0: any): boolean;
    }
    type TerrainShaper$PointCustom_ = TerrainShaper$PointCustom;
    class CommandDispatcher <S> {
        constructor()
        constructor(arg0: Internal.RootCommandNode_<S>)
        execute(arg0: Internal.ParseResults_<S>): number;
        getPath(arg0: Internal.CommandNode_<S>): Internal.Collection<string>;
        register(arg0: Internal.LiteralArgumentBuilder_<S>): Internal.LiteralCommandNode<S>;
        parse(arg0: string, arg1: S): Internal.ParseResults<S>;
        getRoot(): Internal.RootCommandNode<S>;
        getCompletionSuggestions(arg0: Internal.ParseResults_<S>, arg1: number): Internal.CompletableFuture<Internal.Suggestions>;
        getAllUsage(arg0: Internal.CommandNode_<S>, arg1: S, arg2: boolean): string[];
        execute(arg0: Internal.StringReader_, arg1: S): number;
        findNode(arg0: Internal.Collection_<string>): Internal.CommandNode<S>;
        parse(arg0: Internal.StringReader_, arg1: S): Internal.ParseResults<S>;
        getCompletionSuggestions(arg0: Internal.ParseResults_<S>): Internal.CompletableFuture<Internal.Suggestions>;
        getSmartUsage(arg0: Internal.CommandNode_<S>, arg1: S): Internal.Map<Internal.CommandNode<S>, string>;
        execute(arg0: string, arg1: S): number;
        setConsumer(arg0: Internal.ResultConsumer_<S>): void;
        findAmbiguities(arg0: Internal.AmbiguityConsumer_<S>): void;
        get root(): Internal.RootCommandNode<S>
        set consumer(arg0: Internal.ResultConsumer_<S>)
        readonly static "ARGUMENT_SEPARATOR_CHAR": " ";
        readonly static "ARGUMENT_SEPARATOR": " ";
    }
    type CommandDispatcher_<S> = CommandDispatcher<S>;
    class ServerboundCommandSuggestionPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: string)
        handle(arg0: Internal.PacketListener_): void;
        getCommand(): string;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        isSkippable(): boolean;
        getId(): number;
        get command(): string
        get skippable(): boolean
        get id(): number
    }
    type ServerboundCommandSuggestionPacket_ = ServerboundCommandSuggestionPacket;
    interface Shapes$DoubleLineConsumer {
        consume(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
    }
    type Shapes$DoubleLineConsumer_ = Shapes$DoubleLineConsumer;
    abstract class Team {
        constructor()
        getDeathMessageVisibility(): Internal.Team$Visibility;
        isAllowFriendlyFire(): boolean;
        getFormattedName(arg0: Internal.Component_): Internal.MutableComponent;
        getName(): string;
        isAlliedTo(arg0: Internal.Team_): boolean;
        getColor(): Internal.ChatFormatting;
        getNameTagVisibility(): Internal.Team$Visibility;
        getCollisionRule(): Internal.Team$CollisionRule;
        getPlayers(): Internal.Collection<string>;
        canSeeFriendlyInvisibles(): boolean;
        get deathMessageVisibility(): Internal.Team$Visibility
        get allowFriendlyFire(): boolean
        get name(): string
        get color(): Internal.ChatFormatting
        get nameTagVisibility(): Internal.Team$Visibility
        get collisionRule(): Internal.Team$CollisionRule
        get players(): Internal.Collection<string>
    }
    type Team_ = Team;
    interface FormattedText$ContentConsumer <T> {
        accept(arg0: string): Internal.Optional<T>;
    }
    type FormattedText$ContentConsumer_<T> = FormattedText$ContentConsumer<T>;
    abstract class AbstractClientPlayer extends Internal.Player {
        constructor(arg0: Internal.ClientLevel_, arg1: Internal.GameProfile_)
        getCloakTextureLocation(): ResourceLocation;
        getModelName(): string;
        getAttackRange(): number;
        canHit(arg0: Internal.Entity_, arg1: number): boolean;
        isElytraLoaded(): boolean;
        getStepHeight(): number;
        static registerSkinTexture(arg0: ResourceLocation_, arg1: string): void;
        asKJS(): Internal.EntityJS;
        canRiderInteract(): boolean;
        isCreative(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        isSpectator(): boolean;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        canInteractWith(arg0: BlockPos_, arg1: number): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        static getSkinLocation(arg0: string): ResourceLocation;
        isCapeLoaded(): boolean;
        getFieldOfViewModifier(): number;
        getReachDistance(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        canInteractWith(arg0: Internal.Entity_, arg1: number): boolean;
        isCloseEnough(arg0: Internal.Entity_, arg1: number): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getElytraTextureLocation(): ResourceLocation;
        getSkinTextureLocation(): ResourceLocation;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        isSkinLoaded(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get cloakTextureLocation(): ResourceLocation
        get modelName(): string
        get attackRange(): number
        get elytraLoaded(): boolean
        get stepHeight(): number
        get creative(): boolean
        get multipartEntity(): boolean
        get spectator(): boolean
        get parts(): Internal.PartEntity<any>[]
        get capeLoaded(): boolean
        get fieldOfViewModifier(): number
        get reachDistance(): number
        get elytraTextureLocation(): ResourceLocation
        get skinTextureLocation(): ResourceLocation
        get skinLoaded(): boolean
        readonly static "SKIN_HAT_WIDTH": 8;
        "elytraRotX": number;
        "elytraRotY": number;
        "elytraRotZ": number;
        readonly static "SKIN_HEAD_WIDTH": 8;
        readonly static "SKIN_HAT_V": 8;
        readonly "clientLevel": Internal.ClientLevel;
        readonly static "SKIN_HAT_HEIGHT": 8;
        readonly static "SKIN_TEX_HEIGHT": 64;
        readonly static "SKIN_HAT_U": 40;
        readonly static "SKIN_TEX_WIDTH": 64;
        readonly static "SKIN_HEAD_HEIGHT": 8;
        readonly static "SKIN_HEAD_V": 8;
        readonly static "SKIN_HEAD_U": 8;
    }
    type AbstractClientPlayer_ = AbstractClientPlayer;
    interface MetricSampler$ThresholdTest {
        test(arg0: number): boolean;
    }
    type MetricSampler$ThresholdTest_ = MetricSampler$ThresholdTest;
    class ZoneOffsetTransition implements Internal.Comparable<Internal.ZoneOffsetTransition>, Internal.Serializable {
        toString(): string;
        getOffsetAfter(): Internal.ZoneOffset;
        isValidOffset(arg0: Internal.ZoneOffset_): boolean;
        compareTo(arg0: Internal.ZoneOffsetTransition_): number;
        isGap(): boolean;
        compareTo(arg0: any): number;
        static of(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneOffset_, arg2: Internal.ZoneOffset_): Internal.ZoneOffsetTransition;
        isOverlap(): boolean;
        getDateTimeAfter(): Internal.LocalDateTime;
        hashCode(): number;
        getOffsetBefore(): Internal.ZoneOffset;
        getDuration(): Internal.Duration;
        equals(arg0: any): boolean;
        toEpochSecond(): number;
        getDateTimeBefore(): Internal.LocalDateTime;
        getInstant(): Internal.Instant;
        get offsetAfter(): Internal.ZoneOffset
        get gap(): boolean
        get overlap(): boolean
        get dateTimeAfter(): Internal.LocalDateTime
        get offsetBefore(): Internal.ZoneOffset
        get duration(): Internal.Duration
        get dateTimeBefore(): Internal.LocalDateTime
        get instant(): Internal.Instant
    }
    type ZoneOffsetTransition_ = ZoneOffsetTransition;
    class Giant extends Internal.Monster {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        getWalkTargetValue(arg0: BlockPos_, arg1: Internal.LevelReader_): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type Giant_ = Giant;
    class PoseStack$Pose {
        normal(): Internal.Matrix3f;
        pose(): Internal.Matrix4f;
    }
    type PoseStack$Pose_ = PoseStack$Pose;
    interface ObjLongConsumer <T> {
        accept(arg0: T, arg1: number): void;
    }
    type ObjLongConsumer_<T> = ObjLongConsumer<T> | ((arg0: T, arg1: number)=>void);
    interface Float2DoubleFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleUnaryOperator {
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Float2FloatFunction;
        compose(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        getOrDefault(arg0: any, arg1: any): any;
        get(arg0: any): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Float2LongFunction;
        put(arg0: number, arg1: number): number;
        get(arg0: number): number;
        containsKey(arg0: any): boolean;
        andThenReference(arg0: Internal.Double2ReferenceFunction_<any>): Internal.Float2ReferenceFunction<T>;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2DoubleFunction;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2DoubleFunction;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2DoubleFunction;
        put(arg0: any, arg1: any): any;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Float2ByteFunction;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Float2IntFunction;
        defaultReturnValue(arg0: number): void;
        getOrDefault(arg0: number, arg1: number): number;
        containsKey(arg0: number): boolean;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2DoubleFunction;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): this;
        remove(arg0: number): number;
        andThenObject(arg0: Internal.Double2ObjectFunction_<any>): Internal.Float2ObjectFunction<T>;
        getOrDefault(arg0: any, arg1: number): number;
        put(arg0: number, arg1: number): number;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Float2CharFunction;
        composeObject(arg0: Internal.Object2FloatFunction_<any>): Internal.Object2DoubleFunction<T>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        applyAsDouble(arg0: number): number;
        composeFloat(arg0: Internal.Float2FloatFunction_): this;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Float2ShortFunction;
        defaultReturnValue(): number;
        size(): number;
        composeReference(arg0: Internal.Reference2FloatFunction_<any>): Internal.Reference2DoubleFunction<T>;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2DoubleFunction;
        andThen(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2DoubleFunction;
        clear(): void;
        apply(arg0: number): number;
        remove(arg0: any): any;
    }
    type Float2DoubleFunction_ = Float2DoubleFunction | ((arg0: number)=>number);
    class CharStream {
        constructor(c: string[])
        nextIf(match: string): boolean;
        peek(): string;
        next(): string;
        peek(ahead: number): string;
        "position": number;
        "skipWhitespace": boolean;
        readonly "chars": string[];
    }
    type CharStream_ = CharStream;
    class ItemStack extends Internal.CapabilityProvider<Internal.ItemStack> implements Internal.ItemStackKJS, Internal.IForgeItemStack {
        constructor(arg0: Internal.Holder_<Internal.Item_>)
        constructor(arg0: Internal.ItemLike_)
        constructor(arg0: Internal.ItemLike_, arg1: number, arg2: Internal.CompoundTag_)
        constructor(arg0: Internal.ItemLike_, arg1: number)
        getDrinkingSound(): Internal.SoundEvent;
        getHoverName(): Internal.Component;
        static isSame(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_): boolean;
        getBaseRepairCost(): number;
        elytraFlightTick(arg0: Internal.LivingEntity_, arg1: number): boolean;
        getFrame(): Internal.ItemFrame;
        static isSameIgnoreDurability(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        onDestroyed(arg0: Internal.ItemEntity_): void;
        static appendEnchantmentNames(arg0: Internal.List_<Internal.Component_>, arg1: Internal.ListTag_): void;
        static matches(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        hasAdventureModeBreakTagForBlock(arg0: Internal.Registry_<Internal.Block_>, arg1: Internal.BlockInWorld_): boolean;
        getPopTime(): number;
        makesPiglinsNeutral(arg0: Internal.LivingEntity_): boolean;
        areShareTagsEqual(arg0: Internal.ItemStack_): boolean;
        getRarity(): Rarity;
        hurtEnemy(arg0: Internal.LivingEntity_, arg1: Internal.Player_): void;
        getDescriptionId(): string;
        finishUsingItem(arg0: Internal.Level_, arg1: Internal.LivingEntity_): this;
        canWalkOnPowderedSnow(arg0: Internal.LivingEntity_): boolean;
        getHighlightTip(arg0: Internal.Component_): Internal.Component;
        canPerformAction(arg0: Internal.ToolAction_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        addAttributeModifier(arg0: Internal.Attribute_, arg1: Internal.AttributeModifier_, arg2: EquipmentSlot_): void;
        hasAdventureModePlaceTagForBlock(arg0: Internal.Registry_<Internal.Block_>, arg1: Internal.BlockInWorld_): boolean;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: Internal.LivingEntity_): boolean;
        removeTagKJS(): void;
        canEquip(arg0: EquipmentSlot_, arg1: Internal.Entity_): boolean;
        getContainerItem(): this;
        getItemEnchantability(): number;
        getItem(): Internal.Item;
        inventoryTick(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: number, arg3: boolean): void;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        is(arg0: Internal.TagKey_<Internal.Item_>): boolean;
        getOrCreateTagElement(arg0: string): Internal.CompoundTag;
        hideTooltipPart(arg0: Internal.ItemStack$TooltipPart_): void;
        getAttributeModifiers(arg0: EquipmentSlot_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        getMaxDamage(): number;
        grow(arg0: number): void;
        getDisplayName(): Internal.Component;
        getCount(): number;
        enchant(arg0: Internal.Enchantment_, arg1: number): void;
        onItemUseFirst(arg0: Internal.UseOnContext_): Internal.InteractionResult;
        asKJS(): Internal.ItemStackJS;
        hasCustomHoverName(): boolean;
        onArmorTick(arg0: Internal.Level_, arg1: Internal.Player_): void;
        useOn(arg0: Internal.UseOnContext_): Internal.InteractionResult;
        isBarVisible(): boolean;
        doesSneakBypassUse(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        removeTagKey(arg0: string): void;
        hurt(arg0: number, arg1: Internal.Random_, arg2: Internal.ServerPlayer_): boolean;
        getShareTag(): Internal.CompoundTag;
        onCraftedBy(arg0: Internal.Level_, arg1: Internal.Player_, arg2: number): void;
        isEdible(): boolean;
        isFramed(): boolean;
        use(arg0: Internal.Level_, arg1: Internal.Player_, arg2: Hand_): Internal.InteractionResultHolder<Internal.ItemStack>;
        getEquipmentSlot(): EquipmentSlot;
        getBurnTime(arg0: Internal.RecipeType_<any>): number;
        onEntityItemUpdate(arg0: Internal.ItemEntity_): boolean;
        toString(): string;
        sameItem(arg0: Internal.ItemStack_): boolean;
        isRepairable(): boolean;
        setCount(arg0: number): void;
        getSweepHitBox(arg0: Internal.Player_, arg1: Internal.Entity_): Internal.AABB;
        is(arg0: Internal.Item_): boolean;
        setDamageValue(arg0: number): void;
        getOrCreateTag(): Internal.CompoundTag;
        getTagElement(arg0: string): Internal.CompoundTag;
        onBlockStartBreak(arg0: BlockPos_, arg1: Internal.Player_): boolean;
        getTag(): Internal.CompoundTag;
        setHoverName(arg0: Internal.Component_): this;
        getTags(): Internal.Stream<Internal.TagKey<Internal.Item>>;
        hasFoil(): boolean;
        setEntityRepresentation(arg0: Internal.Entity_): void;
        getBarWidth(): number;
        split(arg0: number): this;
        setPopTime(arg0: number): void;
        save(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        getTooltipImage(): Internal.Optional<Internal.TooltipComponent>;
        isEnderMask(arg0: Internal.Player_, arg1: Internal.EnderMan_): boolean;
        shrink(arg0: number): void;
        isPiglinCurrency(): boolean;
        getFoodProperties(arg0: Internal.LivingEntity_): Internal.FoodProperties;
        overrideOtherStackedOnMe(arg0: Internal.ItemStack_, arg1: Internal.Slot_, arg2: Internal.ClickAction_, arg3: Internal.Player_, arg4: Internal.SlotAccess_): boolean;
        getXpRepairRatio(): number;
        onUsingTick(arg0: Internal.LivingEntity_, arg1: number): void;
        getEquipSound(): Internal.SoundEvent;
        isDamageableItem(): boolean;
        isEnchantable(): boolean;
        getTooltipLines(arg0: Internal.Player_, arg1: Internal.TooltipFlag_): Internal.List<Internal.Component>;
        getMaxStackSize(): number;
        sameItemStackIgnoreDurability(arg0: Internal.ItemStack_): boolean;
        getDestroySpeed(arg0: Internal.BlockState_): number;
        hurtAndBreak(arg0: number, arg1: T, arg2: Internal.Consumer_<T>): void;
        copy(): this;
        isStackable(): boolean;
        equals(arg0: Internal.ItemStack_, arg1: boolean): boolean;
        isCorrectToolForDrops(arg0: Internal.BlockState_): boolean;
        setTag(arg0: Internal.CompoundTag_): void;
        static of(arg0: Internal.CompoundTag_): Internal.ItemStack;
        getEatingSound(): Internal.SoundEvent;
        overrideStackedOnOther(arg0: Internal.Slot_, arg1: Internal.ClickAction_, arg2: Internal.Player_): boolean;
        isBookEnchantable(arg0: Internal.ItemStack_): boolean;
        getEntityLifespan(arg0: Internal.Level_): number;
        getEntityRepresentation(): Internal.Entity;
        static isSameItemSameTags(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        isEmpty(): boolean;
        resetHoverName(): void;
        setRepairCost(arg0: number): void;
        onUseTick(arg0: Internal.Level_, arg1: Internal.LivingEntity_, arg2: number): void;
        getUseDuration(): number;
        serializeNBT(): Internal.Tag;
        isDamaged(): boolean;
        mineBlock(arg0: Internal.Level_, arg1: Internal.BlockState_, arg2: BlockPos_, arg3: Internal.Player_): void;
        getDamageValue(): number;
        getUseAnimation(): Internal.UseAnim;
        getEnchantmentTags(): Internal.ListTag;
        deserializeNBT(arg0: Internal.Tag_): void;
        hasContainerItem(): boolean;
        interactLivingEntity(arg0: Internal.Player_, arg1: Internal.LivingEntity_, arg2: Hand_): Internal.InteractionResult;
        readShareTag(arg0: Internal.CompoundTag_): void;
        addTagElement(arg0: string, arg1: Internal.Tag_): void;
        useOnRelease(): boolean;
        static tagMatches(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onDroppedByPlayer(arg0: Internal.Player_): boolean;
        canApplyAtEnchantingTable(arg0: Internal.Enchantment_): boolean;
        releaseUsing(arg0: Internal.Level_, arg1: Internal.LivingEntity_, arg2: number): void;
        onEntitySwing(arg0: Internal.LivingEntity_): boolean;
        getBarColor(): number;
        hasTag(): boolean;
        onHorseArmorTick(arg0: Internal.Level_, arg1: Internal.Mob_): void;
        canElytraFly(arg0: Internal.LivingEntity_): boolean;
        isEnchanted(): boolean;
        get drinkingSound(): Internal.SoundEvent
        get hoverName(): Internal.Component
        get baseRepairCost(): number
        get frame(): Internal.ItemFrame
        get popTime(): number
        get rarity(): Rarity
        get descriptionId(): string
        get containerItem(): Internal.ItemStack
        get itemEnchantability(): number
        get item(): Internal.Item
        get maxDamage(): number
        get displayName(): Internal.Component
        get count(): number
        get barVisible(): boolean
        get shareTag(): Internal.CompoundTag
        get edible(): boolean
        get framed(): boolean
        get equipmentSlot(): EquipmentSlot
        get repairable(): boolean
        set count(arg0: number)
        set damageValue(arg0: number)
        get orCreateTag(): Internal.CompoundTag
        get tag(): Internal.CompoundTag
        set hoverName(arg0: Internal.Component_)
        get tags(): Internal.Stream<Internal.TagKey<Internal.Item>>
        set entityRepresentation(arg0: Internal.Entity_)
        get barWidth(): number
        set popTime(arg0: number)
        get tooltipImage(): Internal.Optional<Internal.TooltipComponent>
        get piglinCurrency(): boolean
        get xpRepairRatio(): number
        get equipSound(): Internal.SoundEvent
        get damageableItem(): boolean
        get enchantable(): boolean
        get maxStackSize(): number
        get stackable(): boolean
        set tag(arg0: Internal.CompoundTag_)
        get eatingSound(): Internal.SoundEvent
        get entityRepresentation(): Internal.Entity
        get empty(): boolean
        set repairCost(arg0: number)
        get useDuration(): number
        get damaged(): boolean
        get damageValue(): number
        get useAnimation(): Internal.UseAnim
        get enchantmentTags(): Internal.ListTag
        get barColor(): number
        get enchanted(): boolean
        readonly static "TAG_DISPLAY_NAME": "Name";
        readonly static "TAG_LORE": "Lore";
        readonly static "TAG_ENCH": "Enchantments";
        readonly static "ATTRIBUTE_MODIFIER_FORMAT": Internal.DecimalFormat;
        readonly static "TAG_DAMAGE": "Damage";
        readonly static "CODEC": any;
        readonly static "TAG_DISPLAY": "display";
        readonly static "TAG_COLOR": "color";
        readonly static "EMPTY": Internal.ItemStack;
    }
    type ItemStack_ = ItemStack;
    interface Byte2ByteFunction extends Internal.IntUnaryOperator, it.unimi.dsi.fastutil.Function<number, number> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: number, arg1: number): number;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2ByteFunction;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2DoubleFunction;
        containsKey(arg0: any): boolean;
        defaultReturnValue(arg0: number): void;
        identity(): this;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2ByteFunction;
        applyAsInt(arg0: number): number;
        composeObject(arg0: Internal.Object2ByteFunction_<any>): Internal.Object2ByteFunction<T>;
        remove(arg0: any): number;
        andThenByte(arg0: Internal.Byte2ByteFunction_): this;
        put(arg0: any, arg1: any): any;
        defaultReturnValue(): number;
        containsKey(arg0: number): boolean;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Byte2ShortFunction;
        composeReference(arg0: Internal.Reference2ByteFunction_<any>): Internal.Reference2ByteFunction<T>;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Byte2FloatFunction;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2ByteFunction;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Byte2IntFunction;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Byte2CharFunction;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Byte2LongFunction;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2ByteFunction;
        getOrDefault(arg0: any, arg1: number): number;
        get(arg0: number): number;
        andThenObject(arg0: Internal.Byte2ObjectFunction_<any>): Internal.Byte2ObjectFunction<T>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        size(): number;
        composeByte(arg0: Internal.Byte2ByteFunction_): this;
        andThenReference(arg0: Internal.Byte2ReferenceFunction_<any>): Internal.Byte2ReferenceFunction<T>;
        put(arg0: number, arg1: number): number;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2ByteFunction;
        clear(): void;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2ByteFunction;
        put(arg0: number, arg1: number): number;
        get(arg0: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        remove(arg0: number): number;
        apply(arg0: number): number;
    }
    type Byte2ByteFunction_ = ((arg0: number)=>number) | Byte2ByteFunction;
    abstract class CreativeModeTab {
        constructor(arg0: number, arg1: string)
        constructor(arg0: string)
        getDisplayName(): Internal.Component;
        static getGroupCountSafe(): number;
        setBackgroundSuffix(arg0: string): this;
        getSlotColor(): number;
        hideTitle(): this;
        getEnchantmentCategories(): Internal.EnchantmentCategory[];
        isTopRow(): boolean;
        getRecipeFolderName(): string;
        getBackgroundImage(): ResourceLocation;
        hasSearchBar(): boolean;
        getId(): number;
        isAlignedRight(): boolean;
        fillItemList(arg0: Internal.NonNullList_<Internal.ItemStack_>): void;
        getBackgroundSuffix(): string;
        setRecipeFolderName(arg0: string): this;
        canScroll(): boolean;
        getLabelColor(): number;
        getColumn(): number;
        getTabPage(): number;
        hasEnchantmentCategory(arg0: Internal.EnchantmentCategory_): boolean;
        getTabsImage(): ResourceLocation;
        showTitle(): boolean;
        setBackgroundImage(arg0: ResourceLocation_): this;
        hideScroll(): this;
        getIconItem(): Internal.ItemStack;
        makeIcon(): Internal.ItemStack;
        getSearchbarWidth(): number;
        setEnchantmentCategories(...arg0: Internal.EnchantmentCategory_[]): this;
        get displayName(): Internal.Component
        get groupCountSafe(): number
        set backgroundSuffix(arg0: string)
        get slotColor(): number
        get enchantmentCategories(): Internal.EnchantmentCategory[]
        get topRow(): boolean
        get recipeFolderName(): string
        get backgroundImage(): ResourceLocation
        get id(): number
        get alignedRight(): boolean
        get backgroundSuffix(): string
        set recipeFolderName(arg0: string)
        get labelColor(): number
        get column(): number
        get tabPage(): number
        get tabsImage(): ResourceLocation
        set backgroundImage(arg0: ResourceLocation_)
        get iconItem(): Internal.ItemStack
        get searchbarWidth(): number
        set enchantmentCategories(...arg0: Internal.EnchantmentCategory_[])
        readonly static "TAB_HOTBAR": any;
        readonly static "TAB_FOOD": any;
        readonly static "TAB_INVENTORY": any;
        readonly static "TAB_MISC": any;
        readonly static "TAB_MATERIALS": any;
        readonly static "TAB_BUILDING_BLOCKS": any;
        readonly static "TAB_TRANSPORTATION": any;
        readonly static "TAB_DECORATIONS": any;
        readonly static "TAB_REDSTONE": any;
        readonly static "TAB_SEARCH": any;
        static "TABS": any;
        readonly static "TAB_TOOLS": any;
        readonly static "TAB_BREWING": any;
        readonly static "TAB_COMBAT": any;
    }
    type CreativeModeTab_ = CreativeModeTab;
    abstract class SingleItemRecipe implements Internal.Recipe<Internal.Container> {
        constructor(arg0: Internal.RecipeType_<any>, arg1: Internal.RecipeSerializer_<any>, arg2: ResourceLocation_, arg3: string, arg4: Internal.Ingredient_, arg5: Internal.ItemStack_)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        isSpecial(): boolean;
        getSerializer(): Internal.RecipeSerializer<any>;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        getId(): ResourceLocation;
        isIncomplete(): boolean;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        getResultItem(): Internal.ItemStack;
        getRemainingItems(arg0: Internal.Container_): Internal.NonNullList<Internal.ItemStack>;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get special(): boolean
        get serializer(): Internal.RecipeSerializer<any>
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get id(): ResourceLocation
        get incomplete(): boolean
        get resultItem(): Internal.ItemStack
    }
    type SingleItemRecipe_ = SingleItemRecipe;
    abstract class NumberFormat extends Internal.Format {
        clone(): any;
        format(arg0: any, arg1: Internal.StringBuffer_, arg2: Internal.FieldPosition_): Internal.StringBuffer;
        parse(arg0: string, arg1: Internal.ParsePosition_): Internal.Number;
        static getCompactNumberInstance(): Internal.NumberFormat;
        format(arg0: number): string;
        setMaximumIntegerDigits(arg0: number): void;
        parse(arg0: string): Internal.Number;
        parseObject(arg0: string, arg1: Internal.ParsePosition_): any;
        static getAvailableLocales(): Internal.Locale[];
        setParseIntegerOnly(arg0: boolean): void;
        setGroupingUsed(arg0: boolean): void;
        static getPercentInstance(): Internal.NumberFormat;
        format(arg0: number): string;
        getMinimumIntegerDigits(): number;
        setMaximumFractionDigits(arg0: number): void;
        getCurrency(): Internal.Currency;
        getMaximumFractionDigits(): number;
        static getInstance(arg0: Internal.Locale_): Internal.NumberFormat;
        setRoundingMode(arg0: Internal.RoundingMode_): void;
        static getInstance(): Internal.NumberFormat;
        setCurrency(arg0: Internal.Currency_): void;
        getMaximumIntegerDigits(): number;
        isGroupingUsed(): boolean;
        static getNumberInstance(): Internal.NumberFormat;
        static getPercentInstance(arg0: Internal.Locale_): Internal.NumberFormat;
        static getCurrencyInstance(arg0: Internal.Locale_): Internal.NumberFormat;
        isParseIntegerOnly(): boolean;
        setMinimumIntegerDigits(arg0: number): void;
        format(arg0: number, arg1: Internal.StringBuffer_, arg2: Internal.FieldPosition_): Internal.StringBuffer;
        static getCompactNumberInstance(arg0: Internal.Locale_, arg1: Internal.NumberFormat$Style_): Internal.NumberFormat;
        static getCurrencyInstance(): Internal.NumberFormat;
        static getNumberInstance(arg0: Internal.Locale_): Internal.NumberFormat;
        hashCode(): number;
        getMinimumFractionDigits(): number;
        setMinimumFractionDigits(arg0: number): void;
        static getIntegerInstance(arg0: Internal.Locale_): Internal.NumberFormat;
        format(arg0: number, arg1: Internal.StringBuffer_, arg2: Internal.FieldPosition_): Internal.StringBuffer;
        equals(arg0: any): boolean;
        static getIntegerInstance(): Internal.NumberFormat;
        getRoundingMode(): Internal.RoundingMode;
        get compactNumberInstance(): Internal.NumberFormat
        set maximumIntegerDigits(arg0: number)
        get availableLocales(): Internal.Locale[]
        set parseIntegerOnly(arg0: boolean)
        set groupingUsed(arg0: boolean)
        get percentInstance(): Internal.NumberFormat
        get minimumIntegerDigits(): number
        set maximumFractionDigits(arg0: number)
        get currency(): Internal.Currency
        get maximumFractionDigits(): number
        set roundingMode(arg0: Internal.RoundingMode_)
        get instance(): Internal.NumberFormat
        set currency(arg0: Internal.Currency_)
        get maximumIntegerDigits(): number
        get groupingUsed(): boolean
        get numberInstance(): Internal.NumberFormat
        get parseIntegerOnly(): boolean
        set minimumIntegerDigits(arg0: number)
        get currencyInstance(): Internal.NumberFormat
        get minimumFractionDigits(): number
        set minimumFractionDigits(arg0: number)
        get integerInstance(): Internal.NumberFormat
        get roundingMode(): Internal.RoundingMode
        readonly static "INTEGER_FIELD": 0;
        readonly static "FRACTION_FIELD": 1;
    }
    type NumberFormat_ = NumberFormat;
    class Endermite extends Internal.Monster {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        deserializeNBT(arg0: Internal.Tag_): void;
        getMyRidingOffset(): number;
        getMobType(): Internal.MobType;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        tick(): void;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setYBodyRot(arg0: number): void;
        static checkEndermiteSpawnRules(arg0: Internal.EntityType_<Internal.Endermite_>, arg1: Internal.LevelAccessor_, arg2: Internal.MobSpawnType_, arg3: BlockPos_, arg4: Internal.Random_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get myRidingOffset(): number
        get mobType(): Internal.MobType
        get stepHeight(): number
        get multipartEntity(): boolean
        set YBodyRot(arg0: number)
        get parts(): Internal.PartEntity<any>[]
    }
    type Endermite_ = Endermite;
    class ClientboundAddExperienceOrbPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.ExperienceOrb_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getX(): number;
        getY(): number;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getZ(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getValue(): number;
        isSkippable(): boolean;
        getId(): number;
        get x(): number
        get y(): number
        get z(): number
        get value(): number
        get skippable(): boolean
        get id(): number
    }
    type ClientboundAddExperienceOrbPacket_ = ClientboundAddExperienceOrbPacket;
    abstract class PointFree <T> {
        constructor()
        eval(): Internal.Function<Internal.DynamicOps<any>, T>;
        static indent(arg0: number): string;
        toString(): string;
        evalCached(): Internal.Function<Internal.DynamicOps<any>, T>;
        toString(arg0: number): string;
    }
    type PointFree_<T> = PointFree<T>;
    interface FileNameMap {
        getContentTypeFor(arg0: string): string;
    }
    type FileNameMap_ = FileNameMap;
    class StructureTemplatePool {
        constructor(arg0: ResourceLocation_, arg1: ResourceLocation_, arg2: Internal.List_<com.mojang.datafixers.util.Pair_<Internal.Function_<Internal.StructureTemplatePool$Projection_, any>, number>>, arg3: Internal.StructureTemplatePool$Projection_)
        constructor(arg0: ResourceLocation_, arg1: ResourceLocation_, arg2: Internal.List_<com.mojang.datafixers.util.Pair_<Internal.StructurePoolElement_, number>>)
        size(): number;
        getFallback(): ResourceLocation;
        getShuffledTemplates(arg0: Internal.Random_): Internal.List<Internal.StructurePoolElement>;
        getName(): ResourceLocation;
        getMaxSize(arg0: Internal.StructureManager_): number;
        getRandomTemplate(arg0: Internal.Random_): Internal.StructurePoolElement;
        get fallback(): ResourceLocation
        get name(): ResourceLocation
        readonly static "DIRECT_CODEC": any;
        readonly static "CODEC": any;
    }
    type StructureTemplatePool_ = StructureTemplatePool | Special.StructureTemplatePool;
    class DripstoneThickness extends Internal.Enum<Internal.DripstoneThickness> implements Internal.StringRepresentable {
        static valueOf(arg0: string): Internal.DripstoneThickness;
        toString(): string;
        getSerializedName(): string;
        static values(): Internal.DripstoneThickness[];
        get serializedName(): string
        readonly static "BASE": Internal.DripstoneThickness;
        readonly static "FRUSTUM": Internal.DripstoneThickness;
        readonly static "TIP_MERGE": Internal.DripstoneThickness;
        readonly static "MIDDLE": Internal.DripstoneThickness;
        readonly static "TIP": Internal.DripstoneThickness;
    }
    type DripstoneThickness_ = "tip_merge" | DripstoneThickness | "frustum" | "middle" | "base" | "tip";
    class SurfaceWaterDepthFilter extends Internal.PlacementFilter {
        type(): Internal.PlacementModifierType<any>;
        static forMaxDepth(arg0: number): Internal.SurfaceWaterDepthFilter;
        readonly static "CODEC": any;
    }
    type SurfaceWaterDepthFilter_ = SurfaceWaterDepthFilter;
    interface LevelTickAccess <T> extends Internal.TickAccess<T> {
        willTickThisTick(arg0: BlockPos_, arg1: T): boolean;
    }
    type LevelTickAccess_<T> = LevelTickAccess<T>;
    class RenderStateShard$LightmapStateShard extends Internal.RenderStateShard$BooleanStateShard {
        constructor(arg0: boolean)
    }
    type RenderStateShard$LightmapStateShard_ = RenderStateShard$LightmapStateShard;
    class PointerBuffer extends Internal.CustomBuffer<Internal.PointerBuffer> implements Internal.Comparable<Internal.PointerBuffer> {
        put(arg0: number, arg1: number): this;
        put(arg0: Internal.DoubleBuffer_): this;
        put(arg0: Internal.LongBuffer_): this;
        getPointerBuffer(arg0: number): this;
        put(arg0: number[], arg1: number, arg2: number): this;
        getPointerBuffer(arg0: number, arg1: number): this;
        put(arg0: number, arg1: Internal.DoubleBuffer_): this;
        getByteBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        compareTo(arg0: any): number;
        getStringUTF8(): string;
        getShortBuffer(arg0: number, arg1: number): Internal.ShortBuffer;
        getShortBuffer(arg0: number): Internal.ShortBuffer;
        putAddressOf(arg0: number, arg1: Internal.CustomBuffer_<any>): this;
        static put(arg0: Internal.ByteBuffer_, arg1: number): void;
        put(arg0: number, arg1: Internal.FloatBuffer_): this;
        static get(arg0: Internal.ByteBuffer_, arg1: number): number;
        static get(arg0: Internal.ByteBuffer_): number;
        get(arg0: number[], arg1: number, arg2: number): this;
        put(arg0: number, arg1: Internal.LongBuffer_): this;
        getStringUTF16(): string;
        getStringASCII(arg0: number): string;
        sizeof(): number;
        compareTo(arg0: Internal.PointerBuffer_): number;
        put(arg0: Internal.FloatBuffer_): this;
        put(arg0: number[]): this;
        static allocateDirect(arg0: number): Internal.PointerBuffer;
        static create(arg0: number, arg1: number): Internal.PointerBuffer;
        get(arg0: number): number;
        put(arg0: number, arg1: Internal.ByteBuffer_): this;
        getStringUTF16(arg0: number): string;
        static create(arg0: Internal.ByteBuffer_): Internal.PointerBuffer;
        put(arg0: number, arg1: Internal.ShortBuffer_): this;
        put(arg0: Internal.IntBuffer_): this;
        put(arg0: number, arg1: Internal.Pointer_): this;
        get(arg0: number[]): this;
        put(arg0: Internal.ByteBuffer_): this;
        put(arg0: Internal.ShortBuffer_): this;
        put(arg0: Internal.Pointer_): this;
        put(arg0: number, arg1: Internal.IntBuffer_): this;
        getStringASCII(): string;
        putAddressOf(arg0: Internal.CustomBuffer_<any>): this;
        get(): number;
        getFloatBuffer(arg0: number): Internal.FloatBuffer;
        getStringUTF8(arg0: number): string;
        getIntBuffer(arg0: number): Internal.IntBuffer;
        put(arg0: number): this;
        static put(arg0: Internal.ByteBuffer_, arg1: number, arg2: number): void;
        hashCode(): number;
        getFloatBuffer(arg0: number, arg1: number): Internal.FloatBuffer;
        getDoubleBuffer(arg0: number): Internal.DoubleBuffer;
        getLongBuffer(arg0: number): Internal.LongBuffer;
        getDoubleBuffer(arg0: number, arg1: number): Internal.DoubleBuffer;
        getByteBuffer(arg0: number): Internal.ByteBuffer;
        getLongBuffer(arg0: number, arg1: number): Internal.LongBuffer;
        equals(arg0: any): boolean;
        getIntBuffer(arg0: number, arg1: number): Internal.IntBuffer;
        get stringUTF8(): string
        get stringUTF16(): string
        get stringASCII(): string
    }
    type PointerBuffer_ = PointerBuffer;
    class NoiseSlider extends Internal.Record {
        constructor(arg0: number, arg1: number, arg2: number)
        size(): number;
        hashCode(): number;
        toString(): string;
        equals(arg0: any): boolean;
        applySlide(arg0: number, arg1: number): number;
        offset(): number;
        target(): number;
        readonly static "CODEC": any;
    }
    type NoiseSlider_ = NoiseSlider;
    class GameEventListenerRenderer implements Internal.DebugRenderer$SimpleDebugRenderer {
        constructor(arg0: Internal.Minecraft_)
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource_, arg2: number, arg3: number, arg4: number): void;
        clear(): void;
        trackListener(arg0: Internal.PositionSource_, arg1: number): void;
        trackGameEvent(arg0: Internal.GameEvent_, arg1: BlockPos_): void;
    }
    type GameEventListenerRenderer_ = GameEventListenerRenderer;
    interface RecvByteBufAllocator$Handle {
        reset(arg0: Internal.ChannelConfig_): void;
        incMessagesRead(arg0: number): void;
        attemptedBytesRead(arg0: number): void;
        readComplete(): void;
        attemptedBytesRead(): number;
        allocate(arg0: Internal.ByteBufAllocator_): Internal.ByteBuf;
        guess(): number;
        lastBytesRead(): number;
        continueReading(): boolean;
        lastBytesRead(arg0: number): void;
    }
    type RecvByteBufAllocator$Handle_ = RecvByteBufAllocator$Handle;
    class PistonMovingBlockEntity extends Internal.BlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: Internal.BlockState_, arg3: Internal.Direction_, arg4: boolean, arg5: boolean)
        getMovementDirection(): Internal.Direction;
        isSourcePiston(): boolean;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getUpdateTag(): Internal.CompoundTag;
        getMovedState(): Internal.BlockState;
        getLastTicked(): number;
        load(arg0: Internal.CompoundTag_): void;
        getProgress(arg0: number): number;
        onLoad(): void;
        getZOff(arg0: number): number;
        isExtending(): boolean;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        static tick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.PistonMovingBlockEntity_): void;
        getXOff(arg0: number): number;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        serializeNBT(): Internal.CompoundTag;
        getCollisionShape(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.VoxelShape;
        getYOff(arg0: number): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        finalTick(): void;
        getRenderBoundingBox(): Internal.AABB;
        getDirection(): Internal.Direction;
        get movementDirection(): Internal.Direction
        get sourcePiston(): boolean
        get updateTag(): Internal.CompoundTag
        get movedState(): Internal.BlockState
        get lastTicked(): number
        get extending(): boolean
        get modelData(): Internal.IModelData
        get renderBoundingBox(): Internal.AABB
        get direction(): Internal.Direction
        readonly static "TICK_MOVEMENT": 0.51;
    }
    type PistonMovingBlockEntity_ = PistonMovingBlockEntity;
    class DragonSittingAttackingPhase extends Internal.AbstractDragonSittingPhase {
        constructor(arg0: Internal.EnderDragon_)
        doClientTick(): void;
        getPhase(): Internal.EnderDragonPhase<Internal.DragonSittingAttackingPhase>;
        begin(): void;
        doServerTick(): void;
        get phase(): Internal.EnderDragonPhase<Internal.DragonSittingAttackingPhase>
    }
    type DragonSittingAttackingPhase_ = DragonSittingAttackingPhase;
    interface Object2IntMap$Entry <K> extends Internal.Map$Entry<K, number> {
        setValue(arg0: number): number;
        getValue(): number;
        setValue(arg0: number): number;
        getIntValue(): number;
        setValue(arg0: any): any;
        set value(arg0: number)
        get value(): number
        set value(arg0: number)
        get intValue(): number
        set value(arg0: any)
    }
    type Object2IntMap$Entry_<K> = Object2IntMap$Entry<K>;
    interface ItemHandler extends Internal.Iterable<Internal.ItemStack> {
        insertItem(arg0: number, arg1: Internal.ItemStack_, arg2: boolean): Internal.ItemStack;
        getSlots(): number;
        extractItem(arg0: number, arg1: number, arg2: boolean): Internal.ItemStack;
        getWidth(): number;
        getSlotLimit(arg0: number): number;
        forEach(arg0: Internal.Consumer_<any>): void;
        getStackInSlot(arg0: number): Internal.ItemStack;
        iterator(): Internal.Iterator<Internal.ItemStack>;
        getHeight(): number;
        spliterator(): Internal.Spliterator<Internal.ItemStack>;
        isItemValid(arg0: number, arg1: Internal.ItemStack_): boolean;
        get slots(): number
        get width(): number
        get height(): number
    }
    type ItemHandler_ = ItemHandler;
    interface NeutralMob {
        getTarget(): Internal.LivingEntity;
        playerDied(arg0: Internal.Player_): void;
        getPersistentAngerTarget(): Internal.UUID;
        isAngry(): boolean;
        setLastHurtByMob(arg0: Internal.LivingEntity_): void;
        forgetCurrentTargetAndRefreshUniversalAnger(): void;
        readPersistentAngerSaveData(arg0: Internal.Level_, arg1: Internal.CompoundTag_): void;
        startPersistentAngerTimer(): void;
        stopBeingAngry(): void;
        canAttack(arg0: Internal.LivingEntity_): boolean;
        setLastHurtByPlayer(arg0: Internal.Player_): void;
        setTarget(arg0: Internal.LivingEntity_): void;
        setPersistentAngerTarget(arg0: Internal.UUID_): void;
        addPersistentAngerSaveData(arg0: Internal.CompoundTag_): void;
        setRemainingPersistentAngerTime(arg0: number): void;
        isAngryAtAllPlayers(arg0: Internal.Level_): boolean;
        updatePersistentAnger(arg0: Internal.ServerLevel_, arg1: boolean): void;
        getLastHurtByMob(): Internal.LivingEntity;
        isAngryAt(arg0: Internal.LivingEntity_): boolean;
        getRemainingPersistentAngerTime(): number;
        get target(): Internal.LivingEntity
        get persistentAngerTarget(): Internal.UUID
        get angry(): boolean
        set lastHurtByMob(arg0: Internal.LivingEntity_)
        set lastHurtByPlayer(arg0: Internal.Player_)
        set target(arg0: Internal.LivingEntity_)
        set persistentAngerTarget(arg0: Internal.UUID_)
        set remainingPersistentAngerTime(arg0: number)
        get lastHurtByMob(): Internal.LivingEntity
        get remainingPersistentAngerTime(): number
        readonly static "TAG_ANGER_TIME": "AngerTime";
        readonly static "TAG_ANGRY_AT": "AngryAt";
    }
    type NeutralMob_ = NeutralMob;
    interface IntPredicate {
        and(arg0: Internal.IntPredicate_): this;
        or(arg0: Internal.IntPredicate_): this;
        negate(): this;
        test(arg0: number): boolean;
    }
    type IntPredicate_ = IntPredicate | ((arg0: number)=>boolean);
    interface TriPredicate <T, U, V> {
        test(arg0: T, arg1: U, arg2: V): boolean;
        and(arg0: Internal.TriPredicate_<any, any, any>): this;
        negate(): this;
        or(arg0: Internal.TriPredicate_<any, any, any>): this;
    }
    type TriPredicate_<T, U, V> = TriPredicate<T, U, V> | ((arg0: T, arg1: U, arg2: V)=>boolean);
    class DragonLandingApproachPhase extends Internal.AbstractDragonPhaseInstance {
        constructor(arg0: Internal.EnderDragon_)
        getFlyTargetLocation(): Vec3;
        begin(): void;
        doServerTick(): void;
        getPhase(): Internal.EnderDragonPhase<Internal.DragonLandingApproachPhase>;
        get flyTargetLocation(): Vec3
        get phase(): Internal.EnderDragonPhase<Internal.DragonLandingApproachPhase>
    }
    type DragonLandingApproachPhase_ = DragonLandingApproachPhase;
    class PropertyMap extends Internal.ForwardingMultimap<string, com.mojang.authlib.properties.Property> {
        constructor()
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
    }
    type PropertyMap_ = PropertyMap;
    interface IShapedRecipe <T> extends Internal.Recipe<T> {
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        isSpecial(): boolean;
        getGroup(): string;
        getToastSymbol(): Internal.ItemStack;
        getRecipeHeight(): number;
        getRecipeWidth(): number;
        isIncomplete(): boolean;
        getRemainingItems(arg0: T): Internal.NonNullList<Internal.ItemStack>;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get special(): boolean
        get group(): string
        get toastSymbol(): Internal.ItemStack
        get recipeHeight(): number
        get recipeWidth(): number
        get incomplete(): boolean
    }
    type IShapedRecipe_<T> = IShapedRecipe<T>;
    class DataResult$Instance extends Internal.Enum<Internal.DataResult$Instance> implements Internal.Applicative<Internal.DataResult$Mu, any> {
        apply8(arg0: Internal.Function8_<T1, T2, T3, T4, T5, T6, T7, T8, R>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>, arg6: Internal.App_<Internal.DataResult$Mu_, T6>, arg7: Internal.App_<Internal.DataResult$Mu_, T7>, arg8: Internal.App_<Internal.DataResult$Mu_, T8>): Internal.App<Internal.DataResult$Mu, R>;
        apply2(arg0: Internal.BiFunction_<A, B, R>, arg1: Internal.App_<Internal.DataResult$Mu_, A>, arg2: Internal.App_<Internal.DataResult$Mu_, B>): Internal.App<Internal.DataResult$Mu, R>;
        lift4(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function4_<T1, T2, T3, T4, R>>): Internal.Function4<Internal.App<Internal.DataResult$Mu, T1>, Internal.App<Internal.DataResult$Mu, T2>, Internal.App<Internal.DataResult$Mu, T3>, Internal.App<Internal.DataResult$Mu, T4>, Internal.App<Internal.DataResult$Mu, R>>;
        ap14(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function14_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>, arg6: Internal.App_<Internal.DataResult$Mu_, T6>, arg7: Internal.App_<Internal.DataResult$Mu_, T7>, arg8: Internal.App_<Internal.DataResult$Mu_, T8>, arg9: Internal.App_<Internal.DataResult$Mu_, T9>, arg10: Internal.App_<Internal.DataResult$Mu_, T10>, arg11: Internal.App_<Internal.DataResult$Mu_, T11>, arg12: Internal.App_<Internal.DataResult$Mu_, T12>, arg13: Internal.App_<Internal.DataResult$Mu_, T13>, arg14: Internal.App_<Internal.DataResult$Mu_, T14>): Internal.App<Internal.DataResult$Mu, R>;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>, arg1: Internal.App_<Internal.DataResult$Mu_, T2>, arg2: Internal.App_<Internal.DataResult$Mu_, T3>, arg3: Internal.App_<Internal.DataResult$Mu_, T4>, arg4: Internal.App_<Internal.DataResult$Mu_, T5>, arg5: Internal.App_<Internal.DataResult$Mu_, T6>, arg6: Internal.App_<Internal.DataResult$Mu_, T7>, arg7: Internal.App_<Internal.DataResult$Mu_, T8>, arg8: Internal.App_<Internal.DataResult$Mu_, T9>, arg9: Internal.App_<Internal.DataResult$Mu_, T10>, arg10: Internal.App_<Internal.DataResult$Mu_, T11>, arg11: Internal.App_<Internal.DataResult$Mu_, T12>, arg12: Internal.App_<Internal.DataResult$Mu_, T13>, arg13: Internal.App_<Internal.DataResult$Mu_, T14>, arg14: Internal.App_<Internal.DataResult$Mu_, T15>): Internal.Products$P15<Internal.DataResult$Mu, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>, arg1: Internal.App_<Internal.DataResult$Mu_, T2>, arg2: Internal.App_<Internal.DataResult$Mu_, T3>, arg3: Internal.App_<Internal.DataResult$Mu_, T4>, arg4: Internal.App_<Internal.DataResult$Mu_, T5>, arg5: Internal.App_<Internal.DataResult$Mu_, T6>, arg6: Internal.App_<Internal.DataResult$Mu_, T7>, arg7: Internal.App_<Internal.DataResult$Mu_, T8>, arg8: Internal.App_<Internal.DataResult$Mu_, T9>): Internal.Products$P9<Internal.DataResult$Mu, T1, T2, T3, T4, T5, T6, T7, T8, T9>;
        ap4(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function4_<T1, T2, T3, T4, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>): Internal.App<Internal.DataResult$Mu, R>;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>, arg1: Internal.App_<Internal.DataResult$Mu_, T2>, arg2: Internal.App_<Internal.DataResult$Mu_, T3>, arg3: Internal.App_<Internal.DataResult$Mu_, T4>, arg4: Internal.App_<Internal.DataResult$Mu_, T5>, arg5: Internal.App_<Internal.DataResult$Mu_, T6>, arg6: Internal.App_<Internal.DataResult$Mu_, T7>, arg7: Internal.App_<Internal.DataResult$Mu_, T8>, arg8: Internal.App_<Internal.DataResult$Mu_, T9>, arg9: Internal.App_<Internal.DataResult$Mu_, T10>, arg10: Internal.App_<Internal.DataResult$Mu_, T11>, arg11: Internal.App_<Internal.DataResult$Mu_, T12>, arg12: Internal.App_<Internal.DataResult$Mu_, T13>, arg13: Internal.App_<Internal.DataResult$Mu_, T14>): Internal.Products$P14<Internal.DataResult$Mu, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>): Internal.Products$P1<Internal.DataResult$Mu, T1>;
        ap16(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function16_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>, arg6: Internal.App_<Internal.DataResult$Mu_, T6>, arg7: Internal.App_<Internal.DataResult$Mu_, T7>, arg8: Internal.App_<Internal.DataResult$Mu_, T8>, arg9: Internal.App_<Internal.DataResult$Mu_, T9>, arg10: Internal.App_<Internal.DataResult$Mu_, T10>, arg11: Internal.App_<Internal.DataResult$Mu_, T11>, arg12: Internal.App_<Internal.DataResult$Mu_, T12>, arg13: Internal.App_<Internal.DataResult$Mu_, T13>, arg14: Internal.App_<Internal.DataResult$Mu_, T14>, arg15: Internal.App_<Internal.DataResult$Mu_, T15>, arg16: Internal.App_<Internal.DataResult$Mu_, T16>): Internal.App<Internal.DataResult$Mu, R>;
        lift1(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function_<A, R>>): Internal.Function<Internal.App<Internal.DataResult$Mu, A>, Internal.App<Internal.DataResult$Mu, R>>;
        ap7(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function7_<T1, T2, T3, T4, T5, T6, T7, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>, arg6: Internal.App_<Internal.DataResult$Mu_, T6>, arg7: Internal.App_<Internal.DataResult$Mu_, T7>): Internal.App<Internal.DataResult$Mu, R>;
        lift5(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function5_<T1, T2, T3, T4, T5, R>>): Internal.Function5<Internal.App<Internal.DataResult$Mu, T1>, Internal.App<Internal.DataResult$Mu, T2>, Internal.App<Internal.DataResult$Mu, T3>, Internal.App<Internal.DataResult$Mu, T4>, Internal.App<Internal.DataResult$Mu, T5>, Internal.App<Internal.DataResult$Mu, R>>;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>, arg1: Internal.App_<Internal.DataResult$Mu_, T2>, arg2: Internal.App_<Internal.DataResult$Mu_, T3>, arg3: Internal.App_<Internal.DataResult$Mu_, T4>, arg4: Internal.App_<Internal.DataResult$Mu_, T5>, arg5: Internal.App_<Internal.DataResult$Mu_, T6>): Internal.Products$P6<Internal.DataResult$Mu, T1, T2, T3, T4, T5, T6>;
        ap12(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function12_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>, arg6: Internal.App_<Internal.DataResult$Mu_, T6>, arg7: Internal.App_<Internal.DataResult$Mu_, T7>, arg8: Internal.App_<Internal.DataResult$Mu_, T8>, arg9: Internal.App_<Internal.DataResult$Mu_, T9>, arg10: Internal.App_<Internal.DataResult$Mu_, T10>, arg11: Internal.App_<Internal.DataResult$Mu_, T11>, arg12: Internal.App_<Internal.DataResult$Mu_, T12>): Internal.App<Internal.DataResult$Mu, R>;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>, arg1: Internal.App_<Internal.DataResult$Mu_, T2>, arg2: Internal.App_<Internal.DataResult$Mu_, T3>, arg3: Internal.App_<Internal.DataResult$Mu_, T4>, arg4: Internal.App_<Internal.DataResult$Mu_, T5>, arg5: Internal.App_<Internal.DataResult$Mu_, T6>, arg6: Internal.App_<Internal.DataResult$Mu_, T7>, arg7: Internal.App_<Internal.DataResult$Mu_, T8>, arg8: Internal.App_<Internal.DataResult$Mu_, T9>, arg9: Internal.App_<Internal.DataResult$Mu_, T10>, arg10: Internal.App_<Internal.DataResult$Mu_, T11>, arg11: Internal.App_<Internal.DataResult$Mu_, T12>): Internal.Products$P12<Internal.DataResult$Mu, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>;
        apply9(arg0: Internal.Function9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>, arg6: Internal.App_<Internal.DataResult$Mu_, T6>, arg7: Internal.App_<Internal.DataResult$Mu_, T7>, arg8: Internal.App_<Internal.DataResult$Mu_, T8>, arg9: Internal.App_<Internal.DataResult$Mu_, T9>): Internal.App<Internal.DataResult$Mu, R>;
        apply6(arg0: Internal.Function6_<T1, T2, T3, T4, T5, T6, R>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>, arg6: Internal.App_<Internal.DataResult$Mu_, T6>): Internal.App<Internal.DataResult$Mu, R>;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>, arg1: Internal.App_<Internal.DataResult$Mu_, T2>, arg2: Internal.App_<Internal.DataResult$Mu_, T3>): Internal.Products$P3<Internal.DataResult$Mu, T1, T2, T3>;
        static values(): Internal.DataResult$Instance[];
        lift3(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function3_<T1, T2, T3, R>>): Internal.Function3<Internal.App<Internal.DataResult$Mu, T1>, Internal.App<Internal.DataResult$Mu, T2>, Internal.App<Internal.DataResult$Mu, T3>, Internal.App<Internal.DataResult$Mu, R>>;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>, arg1: Internal.App_<Internal.DataResult$Mu_, T2>, arg2: Internal.App_<Internal.DataResult$Mu_, T3>, arg3: Internal.App_<Internal.DataResult$Mu_, T4>, arg4: Internal.App_<Internal.DataResult$Mu_, T5>, arg5: Internal.App_<Internal.DataResult$Mu_, T6>, arg6: Internal.App_<Internal.DataResult$Mu_, T7>, arg7: Internal.App_<Internal.DataResult$Mu_, T8>, arg8: Internal.App_<Internal.DataResult$Mu_, T9>, arg9: Internal.App_<Internal.DataResult$Mu_, T10>): Internal.Products$P10<Internal.DataResult$Mu, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>;
        ap(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function_<A, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, A>): Internal.App<Internal.DataResult$Mu, R>;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>, arg1: Internal.App_<Internal.DataResult$Mu_, T2>, arg2: Internal.App_<Internal.DataResult$Mu_, T3>, arg3: Internal.App_<Internal.DataResult$Mu_, T4>, arg4: Internal.App_<Internal.DataResult$Mu_, T5>, arg5: Internal.App_<Internal.DataResult$Mu_, T6>, arg6: Internal.App_<Internal.DataResult$Mu_, T7>, arg7: Internal.App_<Internal.DataResult$Mu_, T8>, arg8: Internal.App_<Internal.DataResult$Mu_, T9>, arg9: Internal.App_<Internal.DataResult$Mu_, T10>, arg10: Internal.App_<Internal.DataResult$Mu_, T11>, arg11: Internal.App_<Internal.DataResult$Mu_, T12>, arg12: Internal.App_<Internal.DataResult$Mu_, T13>): Internal.Products$P13<Internal.DataResult$Mu, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>;
        apply5(arg0: Internal.Function5_<T1, T2, T3, T4, T5, R>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>): Internal.App<Internal.DataResult$Mu, R>;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>, arg1: Internal.App_<Internal.DataResult$Mu_, T2>, arg2: Internal.App_<Internal.DataResult$Mu_, T3>, arg3: Internal.App_<Internal.DataResult$Mu_, T4>, arg4: Internal.App_<Internal.DataResult$Mu_, T5>): Internal.Products$P5<Internal.DataResult$Mu, T1, T2, T3, T4, T5>;
        lift6(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function6_<T1, T2, T3, T4, T5, T6, R>>): Internal.Function6<Internal.App<Internal.DataResult$Mu, T1>, Internal.App<Internal.DataResult$Mu, T2>, Internal.App<Internal.DataResult$Mu, T3>, Internal.App<Internal.DataResult$Mu, T4>, Internal.App<Internal.DataResult$Mu, T5>, Internal.App<Internal.DataResult$Mu, T6>, Internal.App<Internal.DataResult$Mu, R>>;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>, arg1: Internal.App_<Internal.DataResult$Mu_, T2>, arg2: Internal.App_<Internal.DataResult$Mu_, T3>, arg3: Internal.App_<Internal.DataResult$Mu_, T4>, arg4: Internal.App_<Internal.DataResult$Mu_, T5>, arg5: Internal.App_<Internal.DataResult$Mu_, T6>, arg6: Internal.App_<Internal.DataResult$Mu_, T7>): Internal.Products$P7<Internal.DataResult$Mu, T1, T2, T3, T4, T5, T6, T7>;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>, arg1: Internal.App_<Internal.DataResult$Mu_, T2>): Internal.Products$P2<Internal.DataResult$Mu, T1, T2>;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>, arg1: Internal.App_<Internal.DataResult$Mu_, T2>, arg2: Internal.App_<Internal.DataResult$Mu_, T3>, arg3: Internal.App_<Internal.DataResult$Mu_, T4>, arg4: Internal.App_<Internal.DataResult$Mu_, T5>, arg5: Internal.App_<Internal.DataResult$Mu_, T6>, arg6: Internal.App_<Internal.DataResult$Mu_, T7>, arg7: Internal.App_<Internal.DataResult$Mu_, T8>): Internal.Products$P8<Internal.DataResult$Mu, T1, T2, T3, T4, T5, T6, T7, T8>;
        ap3(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function3_<T1, T2, T3, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>): Internal.App<Internal.DataResult$Mu, R>;
        lift2(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.BiFunction_<A, B, R>>): Internal.BiFunction<Internal.App<Internal.DataResult$Mu, A>, Internal.App<Internal.DataResult$Mu, B>, Internal.App<Internal.DataResult$Mu, R>>;
        apply3(arg0: Internal.Function3_<T1, T2, T3, R>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>): Internal.App<Internal.DataResult$Mu, R>;
        ap5(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function5_<T1, T2, T3, T4, T5, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>): Internal.App<Internal.DataResult$Mu, R>;
        ap10(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function10_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>, arg6: Internal.App_<Internal.DataResult$Mu_, T6>, arg7: Internal.App_<Internal.DataResult$Mu_, T7>, arg8: Internal.App_<Internal.DataResult$Mu_, T8>, arg9: Internal.App_<Internal.DataResult$Mu_, T9>, arg10: Internal.App_<Internal.DataResult$Mu_, T10>): Internal.App<Internal.DataResult$Mu, R>;
        map(arg0: Internal.Function_<any, any>, arg1: Internal.App_<Internal.DataResult$Mu_, T>): Internal.App<Internal.DataResult$Mu, R>;
        lift7(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function7_<T1, T2, T3, T4, T5, T6, T7, R>>): Internal.Function7<Internal.App<Internal.DataResult$Mu, T1>, Internal.App<Internal.DataResult$Mu, T2>, Internal.App<Internal.DataResult$Mu, T3>, Internal.App<Internal.DataResult$Mu, T4>, Internal.App<Internal.DataResult$Mu, T5>, Internal.App<Internal.DataResult$Mu, T6>, Internal.App<Internal.DataResult$Mu, T7>, Internal.App<Internal.DataResult$Mu, R>>;
        ap9(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>, arg6: Internal.App_<Internal.DataResult$Mu_, T6>, arg7: Internal.App_<Internal.DataResult$Mu_, T7>, arg8: Internal.App_<Internal.DataResult$Mu_, T8>, arg9: Internal.App_<Internal.DataResult$Mu_, T9>): Internal.App<Internal.DataResult$Mu, R>;
        lift8(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function8_<T1, T2, T3, T4, T5, T6, T7, T8, R>>): Internal.Function8<Internal.App<Internal.DataResult$Mu, T1>, Internal.App<Internal.DataResult$Mu, T2>, Internal.App<Internal.DataResult$Mu, T3>, Internal.App<Internal.DataResult$Mu, T4>, Internal.App<Internal.DataResult$Mu, T5>, Internal.App<Internal.DataResult$Mu, T6>, Internal.App<Internal.DataResult$Mu, T7>, Internal.App<Internal.DataResult$Mu, T8>, Internal.App<Internal.DataResult$Mu, R>>;
        ap11(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function11_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>, arg6: Internal.App_<Internal.DataResult$Mu_, T6>, arg7: Internal.App_<Internal.DataResult$Mu_, T7>, arg8: Internal.App_<Internal.DataResult$Mu_, T8>, arg9: Internal.App_<Internal.DataResult$Mu_, T9>, arg10: Internal.App_<Internal.DataResult$Mu_, T10>, arg11: Internal.App_<Internal.DataResult$Mu_, T11>): Internal.App<Internal.DataResult$Mu, R>;
        ap6(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function6_<T1, T2, T3, T4, T5, T6, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>, arg6: Internal.App_<Internal.DataResult$Mu_, T6>): Internal.App<Internal.DataResult$Mu, R>;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>, arg1: Internal.App_<Internal.DataResult$Mu_, T2>, arg2: Internal.App_<Internal.DataResult$Mu_, T3>, arg3: Internal.App_<Internal.DataResult$Mu_, T4>): Internal.Products$P4<Internal.DataResult$Mu, T1, T2, T3, T4>;
        ap15(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function15_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>, arg6: Internal.App_<Internal.DataResult$Mu_, T6>, arg7: Internal.App_<Internal.DataResult$Mu_, T7>, arg8: Internal.App_<Internal.DataResult$Mu_, T8>, arg9: Internal.App_<Internal.DataResult$Mu_, T9>, arg10: Internal.App_<Internal.DataResult$Mu_, T10>, arg11: Internal.App_<Internal.DataResult$Mu_, T11>, arg12: Internal.App_<Internal.DataResult$Mu_, T12>, arg13: Internal.App_<Internal.DataResult$Mu_, T13>, arg14: Internal.App_<Internal.DataResult$Mu_, T14>, arg15: Internal.App_<Internal.DataResult$Mu_, T15>): Internal.App<Internal.DataResult$Mu, R>;
        static valueOf(arg0: string): Internal.DataResult$Instance;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>, arg1: Internal.App_<Internal.DataResult$Mu_, T2>, arg2: Internal.App_<Internal.DataResult$Mu_, T3>, arg3: Internal.App_<Internal.DataResult$Mu_, T4>, arg4: Internal.App_<Internal.DataResult$Mu_, T5>, arg5: Internal.App_<Internal.DataResult$Mu_, T6>, arg6: Internal.App_<Internal.DataResult$Mu_, T7>, arg7: Internal.App_<Internal.DataResult$Mu_, T8>, arg8: Internal.App_<Internal.DataResult$Mu_, T9>, arg9: Internal.App_<Internal.DataResult$Mu_, T10>, arg10: Internal.App_<Internal.DataResult$Mu_, T11>, arg11: Internal.App_<Internal.DataResult$Mu_, T12>, arg12: Internal.App_<Internal.DataResult$Mu_, T13>, arg13: Internal.App_<Internal.DataResult$Mu_, T14>, arg14: Internal.App_<Internal.DataResult$Mu_, T15>, arg15: Internal.App_<Internal.DataResult$Mu_, T16>): Internal.Products$P16<Internal.DataResult$Mu, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>;
        ap2(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.BiFunction_<A, B, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, A>, arg2: Internal.App_<Internal.DataResult$Mu_, B>): Internal.App<Internal.DataResult$Mu, R>;
        lift9(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>): Internal.Function9<Internal.App<Internal.DataResult$Mu, T1>, Internal.App<Internal.DataResult$Mu, T2>, Internal.App<Internal.DataResult$Mu, T3>, Internal.App<Internal.DataResult$Mu, T4>, Internal.App<Internal.DataResult$Mu, T5>, Internal.App<Internal.DataResult$Mu, T6>, Internal.App<Internal.DataResult$Mu, T7>, Internal.App<Internal.DataResult$Mu, T8>, Internal.App<Internal.DataResult$Mu, T9>, Internal.App<Internal.DataResult$Mu, R>>;
        ap8(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function8_<T1, T2, T3, T4, T5, T6, T7, T8, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>, arg6: Internal.App_<Internal.DataResult$Mu_, T6>, arg7: Internal.App_<Internal.DataResult$Mu_, T7>, arg8: Internal.App_<Internal.DataResult$Mu_, T8>): Internal.App<Internal.DataResult$Mu, R>;
        group(arg0: Internal.App_<Internal.DataResult$Mu_, T1>, arg1: Internal.App_<Internal.DataResult$Mu_, T2>, arg2: Internal.App_<Internal.DataResult$Mu_, T3>, arg3: Internal.App_<Internal.DataResult$Mu_, T4>, arg4: Internal.App_<Internal.DataResult$Mu_, T5>, arg5: Internal.App_<Internal.DataResult$Mu_, T6>, arg6: Internal.App_<Internal.DataResult$Mu_, T7>, arg7: Internal.App_<Internal.DataResult$Mu_, T8>, arg8: Internal.App_<Internal.DataResult$Mu_, T9>, arg9: Internal.App_<Internal.DataResult$Mu_, T10>, arg10: Internal.App_<Internal.DataResult$Mu_, T11>): Internal.Products$P11<Internal.DataResult$Mu, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>;
        apply7(arg0: Internal.Function7_<T1, T2, T3, T4, T5, T6, T7, R>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>, arg6: Internal.App_<Internal.DataResult$Mu_, T6>, arg7: Internal.App_<Internal.DataResult$Mu_, T7>): Internal.App<Internal.DataResult$Mu, R>;
        ap(arg0: Internal.Function_<A, R>, arg1: Internal.App_<Internal.DataResult$Mu_, A>): Internal.App<Internal.DataResult$Mu, R>;
        point(arg0: A): Internal.App<Internal.DataResult$Mu, A>;
        ap13(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function13_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>, arg5: Internal.App_<Internal.DataResult$Mu_, T5>, arg6: Internal.App_<Internal.DataResult$Mu_, T6>, arg7: Internal.App_<Internal.DataResult$Mu_, T7>, arg8: Internal.App_<Internal.DataResult$Mu_, T8>, arg9: Internal.App_<Internal.DataResult$Mu_, T9>, arg10: Internal.App_<Internal.DataResult$Mu_, T10>, arg11: Internal.App_<Internal.DataResult$Mu_, T11>, arg12: Internal.App_<Internal.DataResult$Mu_, T12>, arg13: Internal.App_<Internal.DataResult$Mu_, T13>): Internal.App<Internal.DataResult$Mu, R>;
        apply4(arg0: Internal.Function4_<T1, T2, T3, T4, R>, arg1: Internal.App_<Internal.DataResult$Mu_, T1>, arg2: Internal.App_<Internal.DataResult$Mu_, T2>, arg3: Internal.App_<Internal.DataResult$Mu_, T3>, arg4: Internal.App_<Internal.DataResult$Mu_, T4>): Internal.App<Internal.DataResult$Mu, R>;
        readonly static "INSTANCE": Internal.DataResult$Instance;
    }
    type DataResult$Instance_ = "instance" | DataResult$Instance;
    class WeightedListHeight extends Internal.HeightProvider {
        constructor(arg0: Internal.SimpleWeightedRandomList_<Internal.HeightProvider_>)
        sample(arg0: Internal.Random_, arg1: Internal.WorldGenerationContext_): number;
        getType(): Internal.HeightProviderType<any>;
        get type(): Internal.HeightProviderType<any>
        readonly static "CODEC": any;
    }
    type WeightedListHeight_ = WeightedListHeight;
    class Thread$State extends Internal.Enum<Internal.Thread$State> {
        static values(): Internal.Thread$State[];
        static valueOf(arg0: string): Internal.Thread$State;
        readonly static "WAITING": Internal.Thread$State;
        readonly static "BLOCKED": Internal.Thread$State;
        readonly static "NEW": Internal.Thread$State;
        readonly static "TIMED_WAITING": Internal.Thread$State;
        readonly static "RUNNABLE": Internal.Thread$State;
        readonly static "TERMINATED": Internal.Thread$State;
    }
    type Thread$State_ = "terminated" | "blocked" | "timed_waiting" | "new" | "runnable" | "waiting" | Thread$State;
    interface AsKJS <T> {
        wrapSafe(as: Internal.AsKJS_<T>): T;
        asKJS(): T;
    }
    type AsKJS_<T> = AsKJS<T>;
    class RewriteResult <A, B> {
        constructor(arg0: Internal.View_<A, B>, arg1: Internal.BitSet_)
        recData(): Internal.BitSet;
        hashCode(): number;
        static nop(arg0: com.mojang.datafixers.types.Type_<A>): Internal.RewriteResult<A, A>;
        toString(): string;
        static create(arg0: Internal.View_<A, B>, arg1: Internal.BitSet_): Internal.RewriteResult<A, B>;
        view(): Internal.View<A, B>;
        compose(arg0: Internal.RewriteResult_<C, A>): Internal.RewriteResult<C, B>;
        equals(arg0: any): boolean;
    }
    type RewriteResult_<A, B> = RewriteResult<A, B>;
    interface Multiset$Entry <E> {
        hashCode(): number;
        getCount(): number;
        toString(): string;
        equals(arg0: any): boolean;
        getElement(): E;
        get count(): number
        get element(): E
    }
    type Multiset$Entry_<E> = Multiset$Entry<E>;
    class ClientboundUpdateAttributesPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: Internal.Collection_<Internal.AttributeInstance_>)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getEntityId(): number;
        getValues(): Internal.List<Internal.ClientboundUpdateAttributesPacket$AttributeSnapshot>;
        isSkippable(): boolean;
        get entityId(): number
        get values(): Internal.List<Internal.ClientboundUpdateAttributesPacket$AttributeSnapshot>
        get skippable(): boolean
    }
    type ClientboundUpdateAttributesPacket_ = ClientboundUpdateAttributesPacket;
    class Format$Field extends Internal.AttributedCharacterIterator$Attribute {
    }
    type Format$Field_ = Format$Field;
    interface List <E> extends Internal.Collection<E> {
        of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): this;
        get(arg0: number): E;
        add(arg0: E): boolean;
        of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): this;
        forEach(arg0: Internal.Consumer_<any>): void;
        listIterator(): Internal.ListIterator<E>;
        of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): this;
        parallelStream(): Internal.Stream<E>;
        isEmpty(): boolean;
        of(arg0: E): this;
        set(arg0: number, arg1: E): E;
        of(...arg0: E[]): this;
        of(): this;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        addAll(arg0: Internal.Collection_<any>): boolean;
        addAll(arg0: number, arg1: Internal.Collection_<any>): boolean;
        remove(arg0: number): E;
        contains(arg0: any): boolean;
        of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): this;
        of(arg0: E, arg1: E, arg2: E): this;
        replaceAll(arg0: Internal.UnaryOperator_<E>): void;
        subList(arg0: number, arg1: number): this;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: E): void;
        copyOf(arg0: Internal.Collection_<any>): this;
        toArray(arg0: T[]): T[];
        remove(arg0: any): boolean;
        of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): this;
        of(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): this;
        toArray(): any[];
        sort(arg0: Internal.Comparator_<any>): void;
        listIterator(arg0: number): Internal.ListIterator<E>;
        iterator(): Internal.Iterator<E>;
        hashCode(): number;
        size(): number;
        of(arg0: E, arg1: E): this;
        stream(): Internal.Stream<E>;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        clear(): void;
        of(arg0: E, arg1: E, arg2: E, arg3: E): this;
        spliterator(): Internal.Spliterator<E>;
        equals(arg0: any): boolean;
        lastIndexOf(arg0: any): number;
        get empty(): boolean
    }
    type List_<E> = List<E>;
    class CommandStorage {
        constructor(arg0: Internal.DimensionDataStorage_)
        get(arg0: ResourceLocation_): Internal.CompoundTag;
        keys(): Internal.Stream<ResourceLocation>;
        set(arg0: ResourceLocation_, arg1: Internal.CompoundTag_): void;
    }
    type CommandStorage_ = CommandStorage;
    class DragonHoldingPatternPhase extends Internal.AbstractDragonPhaseInstance {
        constructor(arg0: Internal.EnderDragon_)
        getFlyTargetLocation(): Vec3;
        begin(): void;
        onCrystalDestroyed(arg0: Internal.EndCrystal_, arg1: BlockPos_, arg2: Internal.DamageSource_, arg3: Internal.Player_): void;
        doServerTick(): void;
        getPhase(): Internal.EnderDragonPhase<Internal.DragonHoldingPatternPhase>;
        get flyTargetLocation(): Vec3
        get phase(): Internal.EnderDragonPhase<Internal.DragonHoldingPatternPhase>
    }
    type DragonHoldingPatternPhase_ = DragonHoldingPatternPhase;
    class ClientboundSetPlayerTeamPacket$Parameters {
        constructor(arg0: Internal.PlayerTeam_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        getDisplayName(): Internal.Component;
        getCollisionRule(): string;
        getNametagVisibility(): string;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getPlayerPrefix(): Internal.Component;
        getPlayerSuffix(): Internal.Component;
        getColor(): Internal.ChatFormatting;
        getOptions(): number;
        get displayName(): Internal.Component
        get collisionRule(): string
        get nametagVisibility(): string
        get playerPrefix(): Internal.Component
        get playerSuffix(): Internal.Component
        get color(): Internal.ChatFormatting
        get options(): number
    }
    type ClientboundSetPlayerTeamPacket$Parameters_ = ClientboundSetPlayerTeamPacket$Parameters;
    class LookControl implements Internal.Control {
        constructor(arg0: Internal.Mob_)
        setLookAt(arg0: Internal.Entity_): void;
        setLookAt(arg0: Internal.Entity_, arg1: number, arg2: number): void;
        getWantedX(): number;
        getWantedY(): number;
        setLookAt(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        getWantedZ(): number;
        setLookAt(arg0: Vec3_): void;
        isLookingAtTarget(): boolean;
        tick(): void;
        setLookAt(arg0: number, arg1: number, arg2: number): void;
        set lookAt(arg0: Internal.Entity_)
        get wantedX(): number
        get wantedY(): number
        get wantedZ(): number
        set lookAt(arg0: Vec3_)
        get lookingAtTarget(): boolean
    }
    type LookControl_ = LookControl;
    class EntitySpawnedEventJS extends Internal.EntityEventJS {
        constructor(entity: Internal.Entity_, level: Internal.Level_)
        getEntity(): Internal.EntityJS;
        canCancel(): boolean;
        getLevel(): Internal.LevelJS;
        get entity(): Internal.EntityJS
        get level(): Internal.LevelJS
    }
    type EntitySpawnedEventJS_ = EntitySpawnedEventJS;
    class ClientboundAwardStatsPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.Object2IntMap_<Internal.Stat_<any>>)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getStats(): Internal.Map<Internal.Stat<any>, number>;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get stats(): Internal.Map<Internal.Stat<any>, number>
        get skippable(): boolean
    }
    type ClientboundAwardStatsPacket_ = ClientboundAwardStatsPacket;
    interface Control {
    }
    type Control_ = Control;
    class EntityViewRenderEvent$FogEvent extends Internal.EntityViewRenderEvent {
        constructor()
        getMode(): Internal.FogRenderer$FogMode;
        getListenerList(): Internal.ListenerList;
        get mode(): Internal.FogRenderer$FogMode
        get listenerList(): Internal.ListenerList
    }
    type EntityViewRenderEvent$FogEvent_ = EntityViewRenderEvent$FogEvent;
    class DispenserMenu extends Internal.AbstractContainerMenu {
        constructor(arg0: number, arg1: Internal.Inventory_)
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Container_)
        stillValid(arg0: Internal.Player_): boolean;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        removed(arg0: Internal.Player_): void;
    }
    type DispenserMenu_ = DispenserMenu;
    class GameEvent implements Internal.InjectedGameEventExtension {
        constructor(arg0: string, arg1: number)
        is(arg0: Internal.TagKey_<Internal.GameEvent_>): boolean;
        toString(): string;
        builtInRegistryHolder(): Internal.Holder$Reference<Internal.GameEvent>;
        getName(): string;
        arch$registryName(): ResourceLocation;
        getNotificationRadius(): number;
        arch$holder(): Internal.Holder<Internal.GameEvent>;
        get name(): string
        get notificationRadius(): number
        readonly static "EQUIP": Internal.GameEvent;
        readonly static "BLOCK_ATTACH": Internal.GameEvent;
        readonly static "ENTITY_DAMAGED": Internal.GameEvent;
        readonly static "PISTON_CONTRACT": Internal.GameEvent;
        readonly static "LIGHTNING_STRIKE": Internal.GameEvent;
        readonly static "BLOCK_PLACE": Internal.GameEvent;
        readonly static "DISPENSE_FAIL": Internal.GameEvent;
        readonly static "MINECART_MOVING": Internal.GameEvent;
        readonly static "ENTITY_KILLED": Internal.GameEvent;
        readonly static "DEFAULT_NOTIFICATION_RADIUS": 16;
        readonly static "DRINKING_FINISH": Internal.GameEvent;
        readonly static "PROJECTILE_LAND": Internal.GameEvent;
        readonly static "BLOCK_OPEN": Internal.GameEvent;
        readonly static "PISTON_EXTEND": Internal.GameEvent;
        readonly static "BLOCK_DESTROY": Internal.GameEvent;
        readonly static "EAT": Internal.GameEvent;
        readonly static "ENTITY_PLACE": Internal.GameEvent;
        readonly static "SPLASH": Internal.GameEvent;
        readonly static "BLOCK_SWITCH": Internal.GameEvent;
        readonly static "BLOCK_UNSWITCH": Internal.GameEvent;
        readonly static "SWIM": Internal.GameEvent;
        readonly static "WOLF_SHAKING": Internal.GameEvent;
        readonly static "FLUID_PICKUP": Internal.GameEvent;
        readonly static "PRIME_FUSE": Internal.GameEvent;
        readonly static "ELYTRA_FREE_FALL": Internal.GameEvent;
        readonly static "CONTAINER_CLOSE": Internal.GameEvent;
        readonly static "EXPLODE": Internal.GameEvent;
        readonly static "HIT_GROUND": Internal.GameEvent;
        readonly static "RING_BELL": Internal.GameEvent;
        readonly static "STEP": Internal.GameEvent;
        readonly static "FISHING_ROD_CAST": Internal.GameEvent;
        readonly static "MOB_INTERACT": Internal.GameEvent;
        readonly static "FISHING_ROD_REEL_IN": Internal.GameEvent;
        readonly static "BLOCK_CHANGE": Internal.GameEvent;
        readonly static "FLAP": Internal.GameEvent;
        readonly static "RAVAGER_ROAR": Internal.GameEvent;
        readonly static "SHULKER_OPEN": Internal.GameEvent;
        readonly static "BLOCK_PRESS": Internal.GameEvent;
        readonly static "BLOCK_UNPRESS": Internal.GameEvent;
        readonly static "SHEAR": Internal.GameEvent;
        readonly static "BLOCK_CLOSE": Internal.GameEvent;
        readonly static "BLOCK_DETACH": Internal.GameEvent;
        readonly static "FLUID_PLACE": Internal.GameEvent;
        readonly static "SHULKER_CLOSE": Internal.GameEvent;
        readonly static "PROJECTILE_SHOOT": Internal.GameEvent;
        readonly static "CONTAINER_OPEN": Internal.GameEvent;
    }
    type GameEvent_ = Special.GameEvent | GameEvent;
    class RenderStateShard$ShaderStateShard extends Internal.RenderStateShard {
        constructor()
        constructor(arg0: Internal.Supplier_<Internal.ShaderInstance_>)
        toString(): string;
    }
    type RenderStateShard$ShaderStateShard_ = RenderStateShard$ShaderStateShard;
    interface Iterable <T> {
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<T>;
        iterator(): Internal.Iterator<T>;
    }
    type Iterable_<T> = Iterable<T>;
    interface ParticleRenderType {
        begin(arg0: Internal.BufferBuilder_, arg1: Internal.TextureManager_): void;
        end(arg0: Internal.Tesselator_): void;
        readonly static "TERRAIN_SHEET": any;
        readonly static "CUSTOM": any;
        readonly static "PARTICLE_SHEET_OPAQUE": any;
        readonly static "PARTICLE_SHEET_LIT": any;
        readonly static "NO_RENDER": any;
        readonly static "PARTICLE_SHEET_TRANSLUCENT": any;
    }
    type ParticleRenderType_ = ParticleRenderType;
    class StructureTemplate$StructureBlockInfo {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: Internal.CompoundTag_)
        toString(): string;
        readonly "nbt": Internal.CompoundTag;
        readonly "pos": BlockPos;
        readonly "state": Internal.BlockState;
    }
    type StructureTemplate$StructureBlockInfo_ = StructureTemplate$StructureBlockInfo;
    class ServerData$ServerPackStatus extends Internal.Enum<Internal.ServerData$ServerPackStatus> {
        getName(): Internal.Component;
        static values(): Internal.ServerData$ServerPackStatus[];
        static valueOf(arg0: string): Internal.ServerData$ServerPackStatus;
        get name(): Internal.Component
        readonly static "ENABLED": Internal.ServerData$ServerPackStatus;
        readonly static "DISABLED": Internal.ServerData$ServerPackStatus;
        readonly static "PROMPT": Internal.ServerData$ServerPackStatus;
    }
    type ServerData$ServerPackStatus_ = ServerData$ServerPackStatus | "prompt" | "disabled" | "enabled";
    class EquipmentSlot$Type extends Internal.Enum<Internal.EquipmentSlot$Type> {
        static values(): Internal.EquipmentSlot$Type[];
        static valueOf(arg0: string): Internal.EquipmentSlot$Type;
        readonly static "ARMOR": Internal.EquipmentSlot$Type;
        readonly static "HAND": Internal.EquipmentSlot$Type;
    }
    type EquipmentSlot$Type_ = EquipmentSlot$Type | "armor" | "hand";
    class Brain$Provider <E> {
        makeBrain(arg0: Internal.Dynamic_<any>): Internal.Brain<E>;
    }
    type Brain$Provider_<E> = Brain$Provider<E>;
    class ClientPlayerDataJS extends Internal.PlayerDataJS<Internal.Player, Internal.ClientPlayerJS> {
        constructor(l: Internal.ClientLevelJS_, p: Internal.Player_, s: boolean)
        getMinecraftPlayer(): Internal.Player;
        getProfile(): Internal.GameProfile;
        getOverworld(): Internal.LevelJS;
        getName(): string;
        getId(): Internal.UUID;
        getLevel(): Internal.ClientLevelJS;
        getPlayer(): Internal.ClientPlayerJS;
        get minecraftPlayer(): Internal.Player
        get profile(): Internal.GameProfile
        get overworld(): Internal.LevelJS
        get name(): string
        get id(): Internal.UUID
        get level(): Internal.ClientLevelJS
        get player(): Internal.ClientPlayerJS
    }
    type ClientPlayerDataJS_ = ClientPlayerDataJS;
    class JigsawBlockEntity$JointType extends Internal.Enum<Internal.JigsawBlockEntity$JointType> implements Internal.StringRepresentable {
        static valueOf(arg0: string): Internal.JigsawBlockEntity$JointType;
        static byName(arg0: string): Internal.Optional<Internal.JigsawBlockEntity$JointType>;
        getSerializedName(): string;
        static values(): Internal.JigsawBlockEntity$JointType[];
        getTranslatedName(): Internal.Component;
        get serializedName(): string
        get translatedName(): Internal.Component
        readonly static "ROLLABLE": Internal.JigsawBlockEntity$JointType;
        readonly static "ALIGNED": Internal.JigsawBlockEntity$JointType;
    }
    type JigsawBlockEntity$JointType_ = "aligned" | "rollable" | JigsawBlockEntity$JointType;
    class ClientboundInitializeBorderPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.WorldBorder_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getOldSize(): number;
        getLerpTime(): number;
        getWarningBlocks(): number;
        getNewSize(): number;
        getNewCenterX(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getNewCenterZ(): number;
        getWarningTime(): number;
        getNewAbsoluteMaxSize(): number;
        isSkippable(): boolean;
        get oldSize(): number
        get lerpTime(): number
        get warningBlocks(): number
        get newSize(): number
        get newCenterX(): number
        get newCenterZ(): number
        get warningTime(): number
        get newAbsoluteMaxSize(): number
        get skippable(): boolean
    }
    type ClientboundInitializeBorderPacket_ = ClientboundInitializeBorderPacket;
    class OreConfiguration$TargetBlockState {
        readonly static "CODEC": any;
        readonly "state": Internal.BlockState;
        readonly "target": Internal.RuleTest;
    }
    type OreConfiguration$TargetBlockState_ = OreConfiguration$TargetBlockState;
    interface OpenOption {
    }
    type OpenOption_ = OpenOption;
    class VertexFormatElement$Usage extends Internal.Enum<Internal.VertexFormatElement$Usage> {
        static values(): Internal.VertexFormatElement$Usage[];
        getName(): string;
        clearBufferState(arg0: number, arg1: number): void;
        static valueOf(arg0: string): Internal.VertexFormatElement$Usage;
        get name(): string
        readonly static "GENERIC": Internal.VertexFormatElement$Usage;
        readonly static "COLOR": Internal.VertexFormatElement$Usage;
        readonly static "NORMAL": Internal.VertexFormatElement$Usage;
        readonly static "UV": Internal.VertexFormatElement$Usage;
        readonly static "POSITION": Internal.VertexFormatElement$Usage;
        readonly static "PADDING": Internal.VertexFormatElement$Usage;
    }
    type VertexFormatElement$Usage_ = VertexFormatElement$Usage | "normal" | "color" | "generic" | "position" | "padding" | "uv";
    class ItemAttributeModifierEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.ItemStack_, arg1: EquipmentSlot_, arg2: Internal.Multimap_<Internal.Attribute_, Internal.AttributeModifier_>)
        getOriginalModifiers(): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        removeAttribute(arg0: Internal.Attribute_): Internal.Collection<Internal.AttributeModifier>;
        removeModifier(arg0: Internal.Attribute_, arg1: Internal.AttributeModifier_): boolean;
        getListenerList(): Internal.ListenerList;
        clearModifiers(): void;
        getSlotType(): EquipmentSlot;
        getModifiers(): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        addModifier(arg0: Internal.Attribute_, arg1: Internal.AttributeModifier_): boolean;
        getItemStack(): Internal.ItemStack;
        get originalModifiers(): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>
        get listenerList(): Internal.ListenerList
        get slotType(): EquipmentSlot
        get modifiers(): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>
        get itemStack(): Internal.ItemStack
    }
    type ItemAttributeModifierEvent_ = ItemAttributeModifierEvent;
    class GameRulesJS {
        constructor(r: Internal.GameRules_)
        getBoolean(rule: string): boolean;
        getString(rule: string): string;
        getInt(rule: string): number;
        set(rule: string, value: any): void;
        getKey(rule: string): Internal.GameRules$Key<any>;
        get(rule: string): Internal.GameRules$Value<any>;
    }
    type GameRulesJS_ = GameRulesJS;
    class IntegerProperty extends Internal.Property<number> {
        getPossibleValues(): Internal.Collection<number>;
        getName(arg0: number): string;
        generateHashCode(): number;
        static create(arg0: string, arg1: number, arg2: number): Internal.IntegerProperty;
        getValue(arg0: string): Internal.Optional<number>;
        equals(arg0: any): boolean;
        getName(arg0: Internal.Comparable_<any>): string;
        get possibleValues(): Internal.Collection<number>
    }
    type IntegerProperty_ = IntegerProperty;
    class AnvilMenu extends Internal.ItemCombinerMenu {
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: any_)
        constructor(arg0: number, arg1: Internal.Inventory_)
        static calculateIncreasedRepairCost(arg0: number): number;
        getCost(): number;
        setMaximumCost(arg0: number): void;
        setItemName(arg0: string): void;
        createResult(): void;
        get cost(): number
        set maximumCost(arg0: number)
        set itemName(arg0: string)
        readonly static "MAX_NAME_LENGTH": 50;
        "repairItemCountCost": number;
    }
    type AnvilMenu_ = AnvilMenu;
    interface Closeable extends Internal.AutoCloseable {
        close(): void;
    }
    type Closeable_ = Closeable;
    class Event$Result extends Internal.Enum<Internal.Event$Result> {
        static values(): Internal.Event$Result[];
        static valueOf(arg0: string): Internal.Event$Result;
        readonly static "ALLOW": Internal.Event$Result;
        readonly static "DEFAULT": Internal.Event$Result;
        readonly static "DENY": Internal.Event$Result;
    }
    type Event$Result_ = "deny" | "allow" | "default" | Event$Result;
    interface MobEffectBuilder$EffectTickCallback {
        applyEffectTick(arg0: Internal.LivingEntityJS_, arg1: number): void;
    }
    type MobEffectBuilder$EffectTickCallback_ = MobEffectBuilder$EffectTickCallback | ((arg0: Internal.LivingEntityJS, arg1: number)=>void);
    class Mule extends Internal.AbstractChestedHorse {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type Mule_ = Mule;
    interface CollisionGetter extends Internal.BlockGetter {
        noCollision(arg0: Internal.Entity_): boolean;
        getMinSection(): number;
        findFreePosition(arg0: Internal.Entity_, arg1: Internal.VoxelShape_, arg2: Vec3_, arg3: number, arg4: number, arg5: number): Internal.Optional<Vec3>;
        getSectionIndex(arg0: number): number;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        isUnobstructed(arg0: Internal.Entity_, arg1: Internal.VoxelShape_): boolean;
        getMaxSection(): number;
        getMaxBuildHeight(): number;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getSectionYFromSectionIndex(arg0: number): number;
        noCollision(arg0: Internal.AABB_): boolean;
        getCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        getEntityCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.VoxelShape>;
        collidesWithSuffocatingBlock(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getBlockCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        noCollision(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getWorldBorder(): Internal.WorldBorder;
        isOutsideBuildHeight(arg0: number): boolean;
        isUnobstructed(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.CollisionContext_): boolean;
        isUnobstructed(arg0: Internal.Entity_): boolean;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        getSectionsCount(): number;
        getChunkForCollisions(arg0: number, arg1: number): Internal.BlockGetter;
        getSectionIndexFromSectionY(arg0: number): number;
        getMaxLightLevel(): number;
        get minSection(): number
        get maxSection(): number
        get maxBuildHeight(): number
        get worldBorder(): Internal.WorldBorder
        get sectionsCount(): number
        get maxLightLevel(): number
    }
    type CollisionGetter_ = CollisionGetter;
    abstract class AbstractVillager extends Internal.AgeableMob implements Internal.InventoryCarrier, Internal.Npc, Internal.Merchant {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        notifyTradeUpdated(arg0: Internal.ItemStack_): void;
        getUnhappyCounter(): number;
        setTradingPlayer(arg0: Internal.Player_): void;
        getTradingPlayer(): Internal.Player;
        getSlot(arg0: number): Internal.SlotAccess;
        getInventory(): Internal.SimpleContainer;
        getStepHeight(): number;
        getNotifyTradeSound(): Internal.SoundEvent;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        showProgressBar(): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getVillagerXp(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        isTrading(): boolean;
        getRopeHoldPosition(arg0: number): Vec3;
        notifyTrade(arg0: Internal.MerchantOffer_): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        isClientSide(): boolean;
        setUnhappyCounter(arg0: number): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canBeLeashed(arg0: Internal.Player_): boolean;
        canRestock(): boolean;
        getOffers(): Internal.MerchantOffers;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        openTradingScreen(arg0: Internal.Player_, arg1: Internal.Component_, arg2: number): void;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        die(arg0: Internal.DamageSource_): void;
        overrideOffers(arg0: Internal.MerchantOffers_): void;
        overrideXp(arg0: number): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        playCelebrateSound(): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get unhappyCounter(): number
        set tradingPlayer(arg0: Internal.Player_)
        get tradingPlayer(): Internal.Player
        get inventory(): Internal.SimpleContainer
        get stepHeight(): number
        get notifyTradeSound(): Internal.SoundEvent
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get villagerXp(): number
        get trading(): boolean
        get clientSide(): boolean
        set unhappyCounter(arg0: number)
        get offers(): Internal.MerchantOffers
        readonly static "VILLAGER_SLOT_OFFSET": 300;
    }
    type AbstractVillager_ = AbstractVillager;
    interface WatchEvent$Kind <T> {
        name(): string;
        type(): Internal.Class<T>;
    }
    type WatchEvent$Kind_<T> = WatchEvent$Kind<T>;
    class ClientboundUpdateRecipesPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.Collection_<Internal.Recipe_<any>>)
        handle(arg0: Internal.PacketListener_): void;
        static fromNetwork(arg0: Internal.FriendlyByteBuf_): Internal.Recipe<any>;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        static toNetwork(arg0: Internal.FriendlyByteBuf_, arg1: T): void;
        isSkippable(): boolean;
        getRecipes(): Internal.List<Internal.Recipe<any>>;
        get skippable(): boolean
        get recipes(): Internal.List<Internal.Recipe<any>>
    }
    type ClientboundUpdateRecipesPacket_ = ClientboundUpdateRecipesPacket;
    abstract class ScriptableObject implements Internal.SymbolScriptable, Internal.Scriptable, Internal.ConstProperties {
        constructor()
        constructor(scope: Internal.Scriptable_, prototype: Internal.Scriptable_)
        preventExtensions(): void;
        static defineClass(scope: Internal.Scriptable_, clazz: Internal.Class_<T>, sealed: boolean, mapInheritance: boolean): string;
        getClassName(): string;
        setParentScope(m: Internal.Scriptable_): void;
        static getTopScopeValue(scope: Internal.Scriptable_, key: any): any;
        has(key: Internal.Symbol_, start: Internal.Scriptable_): boolean;
        getTypeOf(): Internal.MemberType;
        defineOwnProperties(cx: Internal.Context_, props: Internal.ScriptableObject_): void;
        static getProperty(obj: Internal.Scriptable_, key: Internal.Symbol_): any;
        put(name: string, start: Internal.Scriptable_, value: any): void;
        getAttributes(name: string): number;
        static putProperty(obj: Internal.Scriptable_, key: Internal.Symbol_, value: any): void;
        associateValue(key: any, value: any): any;
        getAttributes(index: number): number;
        getParentScope(): Internal.Scriptable;
        put(key: Internal.Symbol_, start: Internal.Scriptable_, value: any): void;
        hasInstance(instance: Internal.Scriptable_): boolean;
        getAttributes(sym: Internal.Symbol_): number;
        static defineClass(scope: Internal.Scriptable_, clazz: Internal.Class_<T>): void;
        has(name: string, start: Internal.Scriptable_): boolean;
        static putConstProperty(obj: Internal.Scriptable_, name: string, value: any): void;
        static getClassPrototype(scope: Internal.Scriptable_, className: string): Internal.Scriptable;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        static putProperty(obj: Internal.Scriptable_, name: string, value: any): void;
        getIds(): any[];
        has(index: number, start: Internal.Scriptable_): boolean;
        isConst(name: string): boolean;
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method_, setter: Internal.Method_, attributes: number): void;
        getPrototype(): Internal.Scriptable;
        isExtensible(): boolean;
        avoidObjectDetection(): boolean;
        setPrototype(m: Internal.Scriptable_): void;
        defineProperty(propertyName: string, clazz: Internal.Class_<any>, attributes: number): void;
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any;
        defineFunctionProperties(names: string[], clazz: Internal.Class_<any>, attributes: number): void;
        get(key: Internal.Symbol_, start: Internal.Scriptable_): any;
        static getDefaultValue(object: Internal.Scriptable_, typeHint: Internal.Class_<any>): any;
        static callMethod(obj: Internal.Scriptable_, methodName: string, args: any[]): any;
        getAssociatedValue(key: any): any;
        static hasProperty(obj: Internal.Scriptable_, name: string): boolean;
        static getArrayPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        setAttributes(key: Internal.Symbol_, attributes: number): void;
        static getProperty(obj: Internal.Scriptable_, index: number): any;
        getExternalArrayData(): Internal.ExternalArrayData;
        setExternalArrayData(array: Internal.ExternalArrayData_): void;
        static getFunctionPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        static putProperty(obj: Internal.Scriptable_, index: number, value: any): void;
        isEmpty(): boolean;
        get(name: string, start: Internal.Scriptable_): any;
        static deleteProperty(obj: Internal.Scriptable_, name: string): boolean;
        static getProperty(obj: Internal.Scriptable_, name: string): any;
        defineOwnProperty(cx: Internal.Context_, id: any, desc: Internal.ScriptableObject_): void;
        static redefineProperty(obj: Internal.Scriptable_, name: string, isConst: boolean): void;
        static hasProperty(obj: Internal.Scriptable_, index: number): boolean;
        defineConst(name: string, start: Internal.Scriptable_): void;
        static defineProperty(destination: Internal.Scriptable_, propertyName: string, value: any, attributes: number): void;
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        static callMethod(cx: Internal.Context_, obj: Internal.Scriptable_, methodName: string, args: any[]): any;
        putConst(name: string, start: Internal.Scriptable_, value: any): void;
        static getPropertyIds(obj: Internal.Scriptable_): any[];
        defineProperty(key: Internal.Symbol_, value: any, attributes: number): void;
        isSealed(): boolean;
        defineProperty(propertyName: string, value: any, attributes: number): void;
        setAttributes(index: number, attributes: number): void;
        setGetterOrSetter(name: string, index: number, getterOrSetter: dev.latvian.mods.rhino.Callable_, isSetter: boolean): void;
        put(index: number, start: Internal.Scriptable_, value: any): void;
        delete(name: string): void;
        static deleteProperty(obj: Internal.Scriptable_, index: number): boolean;
        getDefaultValue(typeHint: Internal.Class_<any>): any;
        getAllIds(): any[];
        static getObjectPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        delete(key: Internal.Symbol_): void;
        get(index: number, start: Internal.Scriptable_): any;
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        size(): number;
        getExternalArrayLength(): any;
        delete(index: number): void;
        setAttributes(name: string, attributes: number): void;
        static hasProperty(obj: Internal.Scriptable_, key: Internal.Symbol_): boolean;
        static defineConstProperty(destination: Internal.Scriptable_, propertyName: string): void;
        static getTopLevelScope(obj: Internal.Scriptable_): Internal.Scriptable;
        sealObject(): void;
        get(key: any): any;
        static defineClass(scope: Internal.Scriptable_, clazz: Internal.Class_<T>, sealed: boolean): void;
        get className(): string
        set parentScope(m: Internal.Scriptable_)
        get typeOf(): Internal.MemberType
        get parentScope(): Internal.Scriptable
        get ids(): any[]
        get prototype(): Internal.Scriptable
        get extensible(): boolean
        set prototype(m: Internal.Scriptable_)
        get externalArrayData(): Internal.ExternalArrayData
        set externalArrayData(array: Internal.ExternalArrayData_)
        get empty(): boolean
        get sealed(): boolean
        get allIds(): any[]
        get externalArrayLength(): any
        readonly static "EMPTY": 0;
        readonly static "READONLY": 1;
        readonly static "DONTENUM": 2;
        readonly static "UNINITIALIZED_CONST": 8;
        readonly static "CONST": 13;
        readonly static "PERMANENT": 4;
    }
    type ScriptableObject_ = ScriptableObject;
    class ClientEventJS extends Internal.EventJS {
        constructor()
        post(id: string): boolean;
        getEntity(): Internal.EntityJS;
        post(id: string, sub: string): boolean;
        getLevel(): Internal.ClientLevelJS;
        getPlayer(): Internal.ClientPlayerJS;
        get entity(): Internal.EntityJS
        get level(): Internal.ClientLevelJS
        get player(): Internal.ClientPlayerJS
    }
    type ClientEventJS_ = ClientEventJS;
    class RegistryLoader {
        overrideRegistryFromResources(arg0: Internal.WritableRegistry_<E>, arg1: Internal.ResourceKey_<any>, arg2: Internal.Codec_<E>, arg3: Internal.DynamicOps_<Internal.JsonElement_>): Internal.DataResult<any>;
        bind(arg0: Internal.RegistryAccess$Writable_): Internal.RegistryLoader$Bound;
    }
    type RegistryLoader_ = RegistryLoader;
    class BigInteger extends Internal.Number implements Internal.Comparable<Internal.BigInteger> {
        constructor(arg0: number, arg1: number[], arg2: number, arg3: number)
        constructor(arg0: string, arg1: number)
        constructor(arg0: number, arg1: number[])
        constructor(arg0: number, arg1: number, arg2: Internal.Random_)
        constructor(arg0: number[], arg1: number, arg2: number)
        constructor(arg0: number[])
        constructor(arg0: number, arg1: Internal.Random_)
        constructor(arg0: string)
        modInverse(arg0: Internal.BigInteger_): this;
        doubleValue(): number;
        andNot(arg0: Internal.BigInteger_): this;
        static valueOf(arg0: number): Internal.BigInteger;
        bitCount(): number;
        not(): this;
        compareTo(arg0: any): number;
        shiftRight(arg0: number): this;
        min(arg0: Internal.BigInteger_): this;
        compareTo(arg0: Internal.BigInteger_): number;
        longValue(): number;
        clearBit(arg0: number): this;
        setBit(arg0: number): this;
        max(arg0: Internal.BigInteger_): this;
        multiply(arg0: Internal.BigInteger_): this;
        divideAndRemainder(arg0: Internal.BigInteger_): Internal.BigInteger[];
        testBit(arg0: number): boolean;
        abs(): this;
        pow(arg0: number): this;
        toByteArray(): number[];
        isProbablePrime(arg0: number): boolean;
        modPow(arg0: Internal.BigInteger_, arg1: Internal.BigInteger_): this;
        toString(arg0: number): string;
        getLowestSetBit(): number;
        and(arg0: Internal.BigInteger_): this;
        nextProbablePrime(): this;
        floatValue(): number;
        mod(arg0: Internal.BigInteger_): this;
        sqrtAndRemainder(): Internal.BigInteger[];
        static probablePrime(arg0: number, arg1: Internal.Random_): Internal.BigInteger;
        remainder(arg0: Internal.BigInteger_): this;
        intValue(): number;
        intValueExact(): number;
        negate(): this;
        shiftLeft(arg0: number): this;
        subtract(arg0: Internal.BigInteger_): this;
        toString(): string;
        shortValueExact(): number;
        byteValueExact(): number;
        longValueExact(): number;
        or(arg0: Internal.BigInteger_): this;
        bitLength(): number;
        hashCode(): number;
        flipBit(arg0: number): this;
        divide(arg0: Internal.BigInteger_): this;
        gcd(arg0: Internal.BigInteger_): this;
        sqrt(): this;
        xor(arg0: Internal.BigInteger_): this;
        add(arg0: Internal.BigInteger_): this;
        equals(arg0: any): boolean;
        signum(): number;
        set bit(arg0: number)
        get lowestSetBit(): number
        readonly static "TEN": 10;
        readonly static "ONE": 1;
        readonly static "TWO": 2;
        readonly static "ZERO": 0;
    }
    type BigInteger_ = BigInteger;
    class TranslatableComponent extends Internal.BaseComponent implements Internal.ContextAwareComponent {
        constructor(arg0: string)
        constructor(arg0: string, ...arg1: any[])
        getKey(): string;
        hasStyle(): boolean;
        darkRed(): Internal.MutableComponent;
        visitSelf(arg0: Internal.FormattedText$StyledContentConsumer_<T>, arg1: Internal.Style_): Internal.Optional<T>;
        visit(arg0: Internal.FormattedText$ContentConsumer_<T>): Internal.Optional<T>;
        toJson(): Internal.JsonElement;
        visit(arg0: Internal.FormattedText$StyledContentConsumer_<T>, arg1: Internal.Style_): Internal.Optional<T>;
        visitSelf(arg0: Internal.FormattedText$ContentConsumer_<T>): Internal.Optional<T>;
        darkBlue(): Internal.MutableComponent;
        obfuscated(value: boolean): Internal.MutableComponent;
        getString(arg0: number): string;
        darkGreen(): Internal.MutableComponent;
        getArgs(): any[];
        bold(): Internal.MutableComponent;
        color(c: Internal.Color_): Internal.MutableComponent;
        underlined(): Internal.MutableComponent;
        yellow(): Internal.MutableComponent;
        withStyle(arg0: Internal.UnaryOperator_<Internal.Style_>): Internal.MutableComponent;
        darkPurple(): Internal.MutableComponent;
        blue(): Internal.MutableComponent;
        hover(s: Internal.Component_): Internal.MutableComponent;
        bold(value: boolean): Internal.MutableComponent;
        withStyle(arg0: Internal.ChatFormatting_): Internal.MutableComponent;
        aqua(): Internal.MutableComponent;
        plainCopy(): this;
        green(): Internal.MutableComponent;
        black(): Internal.MutableComponent;
        obfuscated(): Internal.MutableComponent;
        strikethrough(value: boolean): Internal.MutableComponent;
        insertion(s: string): Internal.MutableComponent;
        red(): Internal.MutableComponent;
        italic(): Internal.MutableComponent;
        forEach(arg0: Internal.Consumer_<any>): void;
        component(): Internal.Component;
        click(s: Internal.ClickEvent_): Internal.MutableComponent;
        underlined(value: boolean): Internal.MutableComponent;
        resolve(arg0: Internal.CommandSourceStack_, arg1: Internal.Entity_, arg2: number): Internal.MutableComponent;
        self(): Internal.MutableComponent;
        rawComponent(): Internal.MutableComponent;
        gray(): Internal.MutableComponent;
        font(s: ResourceLocation_): Internal.MutableComponent;
        darkAqua(): Internal.MutableComponent;
        getString(): string;
        darkGray(): Internal.MutableComponent;
        spliterator(): Internal.Spliterator<Internal.Component>;
        toString(): string;
        iterator(): Internal.Iterator<any>;
        noColor(): Internal.MutableComponent;
        withStyle(arg0: Internal.Style_): Internal.MutableComponent;
        strikethrough(): Internal.MutableComponent;
        gold(): Internal.MutableComponent;
        hashCode(): number;
        white(): Internal.MutableComponent;
        hasSiblings(): boolean;
        italic(value: boolean): Internal.MutableComponent;
        withStyle(...arg0: Internal.ChatFormatting_[]): Internal.MutableComponent;
        rawCopy(): Internal.MutableComponent;
        toFlatList(arg0: Internal.Style_): Internal.List<Internal.Component>;
        lightPurple(): Internal.MutableComponent;
        equals(arg0: any): boolean;
        get key(): string
        get args(): any[]
        get string(): string
    }
    type TranslatableComponent_ = TranslatableComponent;
    interface Type$TypeMatcher <FT, FR> {
        match(arg0: com.mojang.datafixers.types.Type_<S>): Internal.Either<Internal.TypedOptic<S, any, FT, FR>, Internal.Type$FieldNotFoundException>;
    }
    type Type$TypeMatcher_<FT, FR> = Type$TypeMatcher<FT, FR>;
    class ModelProperty <T> implements Internal.Predicate<T> {
        constructor()
        constructor(arg0: Internal.Predicate_<T>)
        negate(): Internal.Predicate<T>;
        or(arg0: Internal.Predicate_<any>): Internal.Predicate<T>;
        test(arg0: T): boolean;
        and(arg0: Internal.Predicate_<any>): Internal.Predicate<T>;
    }
    type ModelProperty_<T> = ModelProperty<T>;
    class RecipeTypeJS {
        constructor(s: Internal.RecipeSerializer_<any>, f: Internal.Supplier_<Internal.RecipeJS_>)
        hashCode(): number;
        getId(): ResourceLocation;
        isCustom(): boolean;
        toString(): string;
        equals(obj: any): boolean;
        getMod(): string;
        get id(): ResourceLocation
        get custom(): boolean
        get mod(): string
        readonly "factory": Internal.Supplier<Internal.RecipeJS>;
        readonly "serializer": Internal.RecipeSerializer<any>;
    }
    type RecipeTypeJS_ = RecipeTypeJS;
    class BlockEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: Internal.BlockState_)
        getPos(): BlockPos;
        getListenerList(): Internal.ListenerList;
        getWorld(): Internal.LevelAccessor;
        getState(): Internal.BlockState;
        get pos(): BlockPos
        get listenerList(): Internal.ListenerList
        get world(): Internal.LevelAccessor
        get state(): Internal.BlockState
    }
    type BlockEvent_ = BlockEvent;
    class BedPart extends Internal.Enum<Internal.BedPart> implements Internal.StringRepresentable {
        static valueOf(arg0: string): Internal.BedPart;
        toString(): string;
        getSerializedName(): string;
        static values(): Internal.BedPart[];
        get serializedName(): string
        readonly static "HEAD": Internal.BedPart;
        readonly static "FOOT": Internal.BedPart;
    }
    type BedPart_ = "foot" | "head" | BedPart;
    class ServerRecipeBook extends Internal.RecipeBook {
        constructor()
        sendInitialRecipeBook(arg0: Internal.ServerPlayer_): void;
        toNbt(): Internal.CompoundTag;
        fromNbt(arg0: Internal.CompoundTag_, arg1: Internal.RecipeManager_): void;
        removeRecipes(arg0: Internal.Collection_<Internal.Recipe_<any>>, arg1: Internal.ServerPlayer_): number;
        addRecipes(arg0: Internal.Collection_<Internal.Recipe_<any>>, arg1: Internal.ServerPlayer_): number;
        readonly static "RECIPE_BOOK_TAG": "recipeBook";
    }
    type ServerRecipeBook_ = ServerRecipeBook;
    class Witch extends Internal.Raider implements Internal.RangedAttackMob {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        setUsingItem(arg0: boolean): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        performRangedAttack(arg0: Internal.LivingEntity_, arg1: number): void;
        canBeLeader(): boolean;
        isDrinkingPotion(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getCelebrateSound(): Internal.SoundEvent;
        shouldRiderSit(): boolean;
        applyRaidBuffs(arg0: number, arg1: boolean): void;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        set usingItem(arg0: boolean)
        get stepHeight(): number
        get drinkingPotion(): boolean
        get multipartEntity(): boolean
        get celebrateSound(): Internal.SoundEvent
        get parts(): Internal.PartEntity<any>[]
    }
    type Witch_ = Witch;
    class DoorHingeSide extends Internal.Enum<Internal.DoorHingeSide> implements Internal.StringRepresentable {
        static values(): Internal.DoorHingeSide[];
        toString(): string;
        getSerializedName(): string;
        static valueOf(arg0: string): Internal.DoorHingeSide;
        get serializedName(): string
        readonly static "LEFT": Internal.DoorHingeSide;
        readonly static "RIGHT": Internal.DoorHingeSide;
    }
    type DoorHingeSide_ = DoorHingeSide | "right" | "left";
    interface IPermissionHandlerFactory {
        create(arg0: Internal.Collection_<Internal.PermissionNode_<any>>): Internal.IPermissionHandler;
    }
    type IPermissionHandlerFactory_ = ((arg0: Internal.Collection<Internal.PermissionNode<any>>)=>Internal.IPermissionHandler_) | IPermissionHandlerFactory;
    class EntityLeaveWorldEvent extends Internal.EntityEvent {
        constructor()
        constructor(arg0: Internal.Entity_, arg1: Internal.Level_)
        getWorld(): Internal.Level;
        getListenerList(): Internal.ListenerList;
        get world(): Internal.Level
        get listenerList(): Internal.ListenerList
    }
    type EntityLeaveWorldEvent_ = EntityLeaveWorldEvent;
    interface Long2ShortFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.LongToIntFunction {
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Long2IntFunction;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2ShortFunction;
        put(arg0: number, arg1: number): number;
        put(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: any): any;
        composeLong(arg0: Internal.Long2LongFunction_): this;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Long2FloatFunction;
        get(arg0: number): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): this;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        get(arg0: any): number;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2ShortFunction;
        defaultReturnValue(): number;
        andThenReference(arg0: Internal.Short2ReferenceFunction_<any>): Internal.Long2ReferenceFunction<T>;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Long2LongFunction;
        put(arg0: any, arg1: any): any;
        applyAsInt(arg0: number): number;
        composeObject(arg0: Internal.Object2LongFunction_<any>): Internal.Object2ShortFunction<T>;
        andThenObject(arg0: Internal.Short2ObjectFunction_<any>): Internal.Long2ObjectFunction<T>;
        remove(arg0: number): number;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2ShortFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2ShortFunction;
        containsKey(arg0: number): boolean;
        getOrDefault(arg0: number, arg1: number): number;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Long2ByteFunction;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2ShortFunction;
        size(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Long2DoubleFunction;
        clear(): void;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2ShortFunction;
        getOrDefault(arg0: any, arg1: number): number;
        remove(arg0: any): any;
        composeReference(arg0: Internal.Reference2LongFunction_<any>): Internal.Reference2ShortFunction<T>;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Long2CharFunction;
    }
    type Long2ShortFunction_ = Long2ShortFunction | ((arg0: number)=>number);
    class DyeColor extends Internal.Enum<Internal.DyeColor> implements Internal.StringRepresentable, Internal.Color {
        static valueOf(arg0: string): Internal.DyeColor;
        toString(): string;
        getSerializedName(): string;
        getArgbJS(): number;
        specialEquals(o: any, shallow: boolean): boolean;
        static values(): Internal.DyeColor[];
        getTextColor(): number;
        getRgbJS(): number;
        static byName(arg0: string, arg1: Internal.DyeColor_): Internal.DyeColor;
        getSerializeJS(): string;
        getFireworkColor(): number;
        static byFireworkColor(arg0: number): Internal.DyeColor;
        getMaterialColor(): Internal.MaterialColor;
        getName(): string;
        createTextColorJS(): Internal.TextColor;
        getTag(): Internal.TagKey<Internal.Item>;
        getHexJS(): string;
        getTextureDiffuseColors(): number[];
        getFireworkColorJS(): number;
        static byId(arg0: number): Internal.DyeColor;
        getId(): number;
        static getColor(arg0: Internal.ItemStack_): Internal.DyeColor;
        get serializedName(): string
        get argbJS(): number
        get textColor(): number
        get rgbJS(): number
        get serializeJS(): string
        get fireworkColor(): number
        get materialColor(): Internal.MaterialColor
        get name(): string
        get tag(): Internal.TagKey<Internal.Item>
        get hexJS(): string
        get textureDiffuseColors(): number[]
        get fireworkColorJS(): number
        get id(): number
        readonly static "BROWN": Internal.DyeColor;
        readonly static "PINK": Internal.DyeColor;
        readonly static "BLUE": Internal.DyeColor;
        readonly static "ORANGE": Internal.DyeColor;
        readonly static "CYAN": Internal.DyeColor;
        readonly static "WHITE": Internal.DyeColor;
        readonly static "RED": Internal.DyeColor;
        readonly static "LIGHT_BLUE": Internal.DyeColor;
        readonly static "LIGHT_GRAY": Internal.DyeColor;
        readonly static "GRAY": Internal.DyeColor;
        readonly static "PURPLE": Internal.DyeColor;
        readonly static "BLACK": Internal.DyeColor;
        readonly static "YELLOW": Internal.DyeColor;
        readonly static "GREEN": Internal.DyeColor;
        readonly static "LIME": Internal.DyeColor;
        readonly static "MAGENTA": Internal.DyeColor;
    }
    type DyeColor_ = "light_blue" | "magenta" | "lime" | "brown" | "red" | "purple" | "pink" | "black" | DyeColor | "green" | "cyan" | "light_gray" | "yellow" | "white" | "gray" | "blue" | "orange";
    class IdFunctionObject extends Internal.BaseFunction {
        constructor(idcall: Internal.IdFunctionCall_, tag: any, id: number, name: string, arity: number, scope: Internal.Scriptable_)
        constructor(idcall: Internal.IdFunctionCall_, tag: any, id: number, arity: number)
        getArity(): number;
        getTag(): any;
        call(cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        addAsProperty(target: Internal.Scriptable_): void;
        exportAsScopeProperty(): void;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getAllIds(): any[];
        methodId(): number;
        initFunction(name: string, scope: Internal.Scriptable_): void;
        getLength(): number;
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getFunctionName(): string;
        getPrototype(): Internal.Scriptable;
        hasTag(tag: any): boolean;
        createObject(cx: Internal.Context_, scope: Internal.Scriptable_): Internal.Scriptable;
        markAsConstructor(prototypeProperty: Internal.Scriptable_): void;
        unknown(): Internal.RuntimeException;
        get arity(): number
        get tag(): any
        get allIds(): any[]
        get length(): number
        get functionName(): string
        get prototype(): Internal.Scriptable
    }
    type IdFunctionObject_ = IdFunctionObject;
    class FoodData {
        constructor()
        setExhaustion(arg0: number): void;
        addExhaustion(arg0: number): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getSaturationLevel(): number;
        getFoodLevel(): number;
        eat(arg0: Internal.Item_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        tick(arg0: Internal.Player_): void;
        setFoodLevel(arg0: number): void;
        setSaturation(arg0: number): void;
        eat(arg0: Internal.Item_, arg1: Internal.ItemStack_): void;
        eat(arg0: number, arg1: number): void;
        getLastFoodLevel(): number;
        getExhaustionLevel(): number;
        needsFood(): boolean;
        set exhaustion(arg0: number)
        get saturationLevel(): number
        get foodLevel(): number
        set foodLevel(arg0: number)
        set saturation(arg0: number)
        get lastFoodLevel(): number
        get exhaustionLevel(): number
    }
    type FoodData_ = FoodData;
    interface IForgeBakedModel {
        isLayered(): boolean;
        getModelData(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.IModelData_): Internal.IModelData;
        getLayerModels(arg0: Internal.ItemStack_, arg1: boolean): Internal.List<com.mojang.datafixers.util.Pair<Internal.BakedModel, Internal.RenderType>>;
        handlePerspective(arg0: Internal.ItemTransforms$TransformType_, arg1: Internal.PoseStack_): Internal.BakedModel;
        useAmbientOcclusion(arg0: Internal.BlockState_): boolean;
        doesHandlePerspectives(): boolean;
        getQuads(arg0: Internal.BlockState_, arg1: Internal.Direction_, arg2: Internal.Random_, arg3: Internal.IModelData_): Internal.List<Internal.BakedQuad>;
        getParticleIcon(arg0: Internal.IModelData_): Internal.TextureAtlasSprite;
        get layered(): boolean
    }
    type IForgeBakedModel_ = IForgeBakedModel;
    class ServerboundUseItemOnPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Hand_, arg1: Internal.BlockHitResult_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getHand(): Hand;
        getHitResult(): Internal.BlockHitResult;
        isSkippable(): boolean;
        get hand(): Hand
        get hitResult(): Internal.BlockHitResult
        get skippable(): boolean
    }
    type ServerboundUseItemOnPacket_ = ServerboundUseItemOnPacket;
    interface Char2ReferenceFunction <V> extends Internal.IntFunction<V>, it.unimi.dsi.fastutil.Function<string, V> {
        andThenReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Char2ReferenceFunction<T>;
        composeObject(arg0: Internal.Object2CharFunction_<any>): Internal.Object2ReferenceFunction<T, V>;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2ReferenceFunction<V>;
        getOrDefault(arg0: any, arg1: V): V;
        containsKey(arg0: string): boolean;
        containsKey(arg0: any): boolean;
        composeChar(arg0: Internal.Char2CharFunction_): this;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2ReferenceFunction<V>;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2ReferenceFunction<V>;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2ReferenceFunction<V>;
        andThenObject(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Char2ObjectFunction<T>;
        remove(arg0: string): V;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2ReferenceFunction<V>;
        get(arg0: any): V;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2ReferenceFunction<V>;
        put(arg0: any, arg1: any): any;
        apply(arg0: number): V;
        remove(arg0: any): V;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Char2CharFunction;
        put(arg0: string, arg1: V): V;
        get(arg0: string): V;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Char2ShortFunction;
        getOrDefault(arg0: string, arg1: V): V;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Char2ByteFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        apply(arg0: string): V;
        size(): number;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Char2LongFunction;
        clear(): void;
        put(arg0: string, arg1: V): V;
        defaultReturnValue(): V;
        composeReference(arg0: Internal.Reference2CharFunction_<any>): Internal.Reference2ReferenceFunction<T, V>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<string, V>;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Char2IntFunction;
        defaultReturnValue(arg0: V): void;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Char2DoubleFunction;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Char2FloatFunction;
    }
    type Char2ReferenceFunction_<V> = Char2ReferenceFunction<V> | ((arg0: string)=>V);
    class UseOnContext {
        constructor(arg0: Internal.Player_, arg1: Hand_, arg2: Internal.BlockHitResult_)
        constructor(arg0: Internal.Level_, arg1: Internal.Player_, arg2: Hand_, arg3: Internal.ItemStack_, arg4: Internal.BlockHitResult_)
        getLevel(): Internal.Level;
        getClickedFace(): Internal.Direction;
        getClickLocation(): Vec3;
        isSecondaryUseActive(): boolean;
        getHand(): Hand;
        getClickedPos(): BlockPos;
        getHorizontalDirection(): Internal.Direction;
        getPlayer(): Internal.Player;
        getItemInHand(): Internal.ItemStack;
        getRotation(): number;
        isInside(): boolean;
        get level(): Internal.Level
        get clickedFace(): Internal.Direction
        get clickLocation(): Vec3
        get secondaryUseActive(): boolean
        get hand(): Hand
        get clickedPos(): BlockPos
        get horizontalDirection(): Internal.Direction
        get player(): Internal.Player
        get itemInHand(): Internal.ItemStack
        get rotation(): number
        get inside(): boolean
    }
    type UseOnContext_ = UseOnContext;
    class Music {
        constructor(arg0: Internal.SoundEvent_, arg1: number, arg2: number, arg3: boolean)
        getEvent(): Internal.SoundEvent;
        replaceCurrentMusic(): boolean;
        getMaxDelay(): number;
        getMinDelay(): number;
        get event(): Internal.SoundEvent
        get maxDelay(): number
        get minDelay(): number
        readonly static "CODEC": any;
    }
    type Music_ = Music;
    interface Long2FloatFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.LongToDoubleFunction {
        remove(arg0: number): number;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2FloatFunction;
        get(arg0: any): number;
        apply(arg0: number): number;
        getOrDefault(arg0: any, arg1: any): any;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Long2ShortFunction;
        defaultReturnValue(arg0: number): void;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2FloatFunction;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Long2ByteFunction;
        containsKey(arg0: any): boolean;
        andThenObject(arg0: Internal.Float2ObjectFunction_<any>): Internal.Long2ObjectFunction<T>;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2FloatFunction;
        composeReference(arg0: Internal.Reference2LongFunction_<any>): Internal.Reference2FloatFunction<T>;
        put(arg0: any, arg1: any): any;
        andThenReference(arg0: Internal.Float2ReferenceFunction_<any>): Internal.Long2ReferenceFunction<T>;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Long2CharFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeObject(arg0: Internal.Object2LongFunction_<any>): Internal.Object2FloatFunction<T>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Long2IntFunction;
        defaultReturnValue(): number;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2FloatFunction;
        get(arg0: number): number;
        containsKey(arg0: number): boolean;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Long2DoubleFunction;
        put(arg0: number, arg1: number): number;
        composeLong(arg0: Internal.Long2LongFunction_): this;
        applyAsDouble(arg0: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        put(arg0: number, arg1: number): number;
        size(): number;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2FloatFunction;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Long2LongFunction;
        clear(): void;
        andThenFloat(arg0: Internal.Float2FloatFunction_): this;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2FloatFunction;
        remove(arg0: any): any;
        getOrDefault(arg0: number, arg1: number): number;
    }
    type Long2FloatFunction_ = Long2FloatFunction | ((arg0: number)=>number);
    class AlwaysTrueTest extends Internal.RuleTest {
        test(arg0: Internal.BlockState_, arg1: Internal.Random_): boolean;
        readonly static "CODEC": any;
        readonly static "INSTANCE": Internal.AlwaysTrueTest;
    }
    type AlwaysTrueTest_ = AlwaysTrueTest;
    interface Ingredient$Value {
        serialize(): Internal.JsonObject;
        getItems(): Internal.Collection<Internal.ItemStack>;
        get items(): Internal.Collection<Internal.ItemStack>
    }
    type Ingredient$Value_ = Ingredient$Value;
    class BonusChestFeature extends Internal.Feature<Internal.NoneFeatureConfiguration> {
        constructor(arg0: Internal.Codec_<Internal.NoneFeatureConfiguration_>)
        place(arg0: Internal.FeaturePlaceContext_<Internal.NoneFeatureConfiguration_>): boolean;
    }
    type BonusChestFeature_ = BonusChestFeature;
    interface Char2IntFunction extends Internal.IntUnaryOperator, it.unimi.dsi.fastutil.Function<string, number> {
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        defaultReturnValue(): number;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Char2CharFunction;
        composeReference(arg0: Internal.Reference2CharFunction_<any>): Internal.Reference2IntFunction<T>;
        remove(arg0: string): number;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2IntFunction;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2IntFunction;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: string, arg1: number): number;
        put(arg0: string, arg1: number): number;
        containsKey(arg0: string): boolean;
        getOrDefault(arg0: string, arg1: number): number;
        containsKey(arg0: any): boolean;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Char2LongFunction;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        applyAsInt(arg0: number): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        put(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        andThenObject(arg0: Internal.Int2ObjectFunction_<any>): Internal.Char2ObjectFunction<T>;
        composeObject(arg0: Internal.Object2CharFunction_<any>): Internal.Object2IntFunction<T>;
        composeChar(arg0: Internal.Char2CharFunction_): this;
        andThenInt(arg0: Internal.Int2IntFunction_): this;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Char2ShortFunction;
        apply(arg0: string): number;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2IntFunction;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2IntFunction;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Char2DoubleFunction;
        andThenReference(arg0: Internal.Int2ReferenceFunction_<any>): Internal.Char2ReferenceFunction<T>;
        get(arg0: string): number;
        size(): number;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Char2FloatFunction;
        defaultReturnValue(arg0: number): void;
        clear(): void;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Char2ByteFunction;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2IntFunction;
        remove(arg0: any): any;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2IntFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<string, T>;
    }
    type Char2IntFunction_ = Char2IntFunction | ((arg0: string)=>number);
    class SlabBlockBuilder extends Internal.ShapedBlockBuilder {
        constructor(i: ResourceLocation_)
        createObject(): any;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
    }
    type SlabBlockBuilder_ = SlabBlockBuilder;
    interface SpectatorMenuCategory {
        getPrompt(): Internal.Component;
        getItems(): Internal.List<Internal.SpectatorMenuItem>;
        get prompt(): Internal.Component
        get items(): Internal.List<Internal.SpectatorMenuItem>
    }
    type SpectatorMenuCategory_ = SpectatorMenuCategory;
    class TwistingVinesConfig extends Internal.Record implements Internal.FeatureConfiguration {
        constructor(arg0: number, arg1: number, arg2: number)
        spreadWidth(): number;
        hashCode(): number;
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        toString(): string;
        spreadHeight(): number;
        maxHeight(): number;
        equals(arg0: any): boolean;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
    }
    type TwistingVinesConfig_ = TwistingVinesConfig;
    abstract class FlowingFluid extends Internal.Fluid {
        constructor()
        getAmount(arg0: Internal.FluidState_): number;
        tick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.FluidState_): void;
        getSource(arg0: boolean): Internal.FluidState;
        getFlow(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.FluidState_): Vec3;
        getHeight(arg0: Internal.FluidState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): number;
        getExplosionResistance(arg0: Internal.FluidState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        getFlowing(): Internal.Fluid;
        isEntityInside(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_, arg4: number, arg5: Internal.HolderSet_<Internal.Fluid_>, arg6: boolean): boolean;
        getOwnHeight(arg0: Internal.FluidState_): number;
        isAABBInsideMaterial(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.AABB_, arg4: Internal.Material_): boolean;
        getShape(arg0: Internal.FluidState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): Internal.VoxelShape;
        isAABBInsideLiquid(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.AABB_): boolean;
        arch$holder(): Internal.Holder<Internal.Fluid>;
        getFlowing(arg0: number, arg1: boolean): Internal.FluidState;
        arch$registryName(): ResourceLocation;
        getSource(): Internal.Fluid;
        get flowing(): Internal.Fluid
        get source(): Internal.Fluid
        readonly static "FALLING": Internal.BooleanProperty;
        readonly static "LEVEL": Internal.IntegerProperty;
    }
    type FlowingFluid_ = FlowingFluid;
    interface Remapper {
        getMappedClass(from: Internal.Class_<any>): string;
        getUnmappedClass(from: string): string;
        getMappedField(from: Internal.Class_<any>, field: Internal.Field_): string;
        getTypeName(type: string): string;
        getMappedMethod(from: Internal.Class_<any>, method: Internal.Method_): string;
    }
    type Remapper_ = Remapper;
    class Climate$Sampler extends Internal.Record {
        constructor(arg0: Internal.DensityFunction_, arg1: Internal.DensityFunction_, arg2: Internal.DensityFunction_, arg3: Internal.DensityFunction_, arg4: Internal.DensityFunction_, arg5: Internal.DensityFunction_, arg6: Internal.List_<Internal.Climate$ParameterPoint_>)
        spawnTarget(): Internal.List<Internal.Climate$ParameterPoint>;
        hashCode(): number;
        findSpawnPosition(): BlockPos;
        temperature(): Internal.DensityFunction;
        toString(): string;
        sample(arg0: number, arg1: number, arg2: number): Internal.Climate$TargetPoint;
        humidity(): Internal.DensityFunction;
        equals(arg0: any): boolean;
        weirdness(): Internal.DensityFunction;
        continentalness(): Internal.DensityFunction;
        depth(): Internal.DensityFunction;
        erosion(): Internal.DensityFunction;
    }
    type Climate$Sampler_ = Climate$Sampler;
    class PackRepository implements Internal.AutoCloseable {
        constructor(arg0: Internal.PackType_, ...arg1: Internal.RepositorySource_[])
        constructor(arg0: Internal.Pack$PackConstructor_, ...arg1: Internal.RepositorySource_[])
        isAvailable(arg0: string): boolean;
        openAllSelected(): Internal.List<Internal.PackResources>;
        setSelected(arg0: Internal.Collection_<string>): void;
        addPackFinder(arg0: Internal.RepositorySource_): void;
        reload(): void;
        getSelectedPacks(): Internal.Collection<Internal.Pack>;
        getSelectedIds(): Internal.Collection<string>;
        close(): void;
        getPack(arg0: string): Internal.Pack;
        getAvailableIds(): Internal.Collection<string>;
        getAvailablePacks(): Internal.Collection<Internal.Pack>;
        set selected(arg0: Internal.Collection_<string>)
        get selectedPacks(): Internal.Collection<Internal.Pack>
        get selectedIds(): Internal.Collection<string>
        get availableIds(): Internal.Collection<string>
        get availablePacks(): Internal.Collection<Internal.Pack>
        "sources": Internal.Set<Internal.RepositorySource>;
    }
    type PackRepository_ = PackRepository;
    class IntOpenHashSet extends Internal.AbstractIntSet implements Internal.Cloneable, Internal.Hash, Internal.Serializable {
        constructor()
        constructor(arg0: Internal.IntCollection_)
        constructor(arg0: Internal.Collection_<any>, arg1: number)
        constructor(arg0: Internal.Iterator_<any>)
        constructor(arg0: number)
        constructor(arg0: number[])
        constructor(arg0: number[], arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.Iterator_<any>, arg1: number)
        constructor(arg0: number, arg1: number)
        constructor(arg0: number[], arg1: number)
        constructor(arg0: Internal.IntCollection_, arg1: number)
        constructor(arg0: Internal.Collection_<any>)
        constructor(arg0: number[], arg1: number, arg2: number)
        constructor(arg0: Internal.IntIterator_)
        constructor(arg0: Internal.IntIterator_, arg1: number)
        static of(arg0: number, arg1: number, arg2: number): Internal.IntOpenHashSet;
        stream(): Internal.Stream<number>;
        forEach(arg0: Internal.Consumer_<any>): void;
        add(arg0: number): boolean;
        trim(arg0: number): boolean;
        isEmpty(): boolean;
        contains(arg0: number): boolean;
        forEach(arg0: Internal.IntConsumer_): void;
        static toSetWithExpectedSize(arg0: Internal.IntStream_, arg1: number): Internal.IntOpenHashSet;
        static toSet(arg0: Internal.IntStream_): Internal.IntOpenHashSet;
        intStream(): Internal.IntStream;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        clone(): this;
        intParallelStream(): Internal.IntStream;
        addAll(arg0: Internal.Collection_<any>): boolean;
        intIterator(): Internal.IntIterator;
        contains(arg0: any): boolean;
        iterator(): Internal.IntIterator;
        removeIf(arg0: Internal.IntPredicate_): boolean;
        trim(): boolean;
        remove(arg0: number): boolean;
        addAll(arg0: Internal.IntCollection_): boolean;
        add(arg0: number): boolean;
        parallelStream(): Internal.Stream<number>;
        remove(arg0: any): boolean;
        static of(): Internal.IntOpenHashSet;
        intSpliterator(): Internal.IntSpliterator;
        add(arg0: any): boolean;
        size(): number;
        hashCode(): number;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        spliterator(): Internal.Spliterator<any>;
        static of(arg0: number): Internal.IntOpenHashSet;
        clear(): void;
        static of(...arg0: number[]): Internal.IntOpenHashSet;
        static of(arg0: number, arg1: number): Internal.IntOpenHashSet;
        get empty(): boolean
    }
    type IntOpenHashSet_ = IntOpenHashSet;
    class SnowGolem extends Internal.AbstractGolem implements Internal.Shearable, Internal.IForgeShearable, Internal.RangedAttackMob {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        hasPumpkin(): boolean;
        isShearable(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: BlockPos_): boolean;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        shear(arg0: Internal.SoundSource_): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        performRangedAttack(arg0: Internal.LivingEntity_, arg1: number): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readyForShearing(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isSensitiveToWater(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        setPumpkin(arg0: boolean): void;
        alwaysAccepts(): boolean;
        onSheared(arg0: Internal.Player_, arg1: Internal.ItemStack_, arg2: Internal.Level_, arg3: BlockPos_, arg4: number): Internal.List<Internal.ItemStack>;
        getLeashOffset(): Vec3;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get sensitiveToWater(): boolean
        set pumpkin(arg0: boolean)
        get leashOffset(): Vec3
    }
    type SnowGolem_ = SnowGolem;
    interface Npc {
    }
    type Npc_ = Npc;
    interface HoglinBase {
        getAttackAnimationRemainingTicks(): number;
        hurtAndThrowTarget(arg0: Internal.LivingEntity_, arg1: Internal.LivingEntity_): boolean;
        throwTarget(arg0: Internal.LivingEntity_, arg1: Internal.LivingEntity_): void;
        get attackAnimationRemainingTicks(): number
        readonly static "ATTACK_ANIMATION_DURATION": 10;
    }
    type HoglinBase_ = HoglinBase;
    interface Float2ReferenceFunction <V> extends Internal.DoubleFunction<V>, it.unimi.dsi.fastutil.Function<number, V> {
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2ReferenceFunction<V>;
        composeReference(arg0: Internal.Reference2FloatFunction_<any>): Internal.Reference2ReferenceFunction<T, V>;
        composeObject(arg0: Internal.Object2FloatFunction_<any>): Internal.Object2ReferenceFunction<T, V>;
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: number, arg1: V): V;
        put(arg0: number, arg1: V): V;
        containsKey(arg0: any): boolean;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2ReferenceFunction<V>;
        composeFloat(arg0: Internal.Float2FloatFunction_): this;
        get(arg0: any): V;
        put(arg0: any, arg1: any): any;
        remove(arg0: number): V;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2ReferenceFunction<V>;
        remove(arg0: any): V;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Float2FloatFunction;
        get(arg0: number): V;
        containsKey(arg0: number): boolean;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Float2LongFunction;
        apply(arg0: number): V;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Float2IntFunction;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Float2ByteFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
        apply(arg0: number): V;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2ReferenceFunction<V>;
        andThenReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Float2ReferenceFunction<T>;
        andThenObject(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Float2ObjectFunction<T>;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Float2ShortFunction;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2ReferenceFunction<V>;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2ReferenceFunction<V>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        size(): number;
        clear(): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Float2DoubleFunction;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Float2CharFunction;
        put(arg0: number, arg1: V): V;
        defaultReturnValue(arg0: V): void;
    }
    type Float2ReferenceFunction_<V> = ((arg0: number)=>V) | Float2ReferenceFunction<V>;
    class ClientboundSetTimePacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number, arg1: number, arg2: boolean)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getGameTime(): number;
        getDayTime(): number;
        isSkippable(): boolean;
        get gameTime(): number
        get dayTime(): number
        get skippable(): boolean
    }
    type ClientboundSetTimePacket_ = ClientboundSetTimePacket;
    class DetectorBlock$Builder extends Internal.BlockBuilder {
        constructor(i: ResourceLocation_)
        detectorId(id: string): this;
        createObject(): Internal.Block;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
    }
    type DetectorBlock$Builder_ = DetectorBlock$Builder;
    interface IForgePlayer {
        getReachDistance(): number;
        isCloseEnough(arg0: Internal.Entity_, arg1: number): boolean;
        canInteractWith(arg0: Internal.Entity_, arg1: number): boolean;
        getAttackRange(): number;
        canHit(arg0: Internal.Entity_, arg1: number): boolean;
        canInteractWith(arg0: BlockPos_, arg1: number): boolean;
        get reachDistance(): number
        get attackRange(): number
    }
    type IForgePlayer_ = IForgePlayer;
    class Date implements Internal.Cloneable, Internal.Comparable<Internal.Date>, Internal.Serializable {
        constructor()
        constructor(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number)
        constructor(arg0: number, arg1: number, arg2: number)
        constructor(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number)
        constructor(arg0: number)
        constructor(arg0: string)
        clone(): any;
        getHours(): number;
        toInstant(): Internal.Instant;
        compareTo(arg0: any): number;
        setDate(arg0: number): void;
        getMonth(): number;
        static parse(arg0: string): number;
        getTimezoneOffset(): number;
        before(arg0: Internal.Date_): boolean;
        setMonth(arg0: number): void;
        compareTo(arg0: Internal.Date_): number;
        getMinutes(): number;
        getSeconds(): number;
        toString(): string;
        setYear(arg0: number): void;
        getTime(): number;
        setHours(arg0: number): void;
        setSeconds(arg0: number): void;
        setMinutes(arg0: number): void;
        static from(arg0: Internal.Instant_): Internal.Date;
        getYear(): number;
        hashCode(): number;
        toGMTString(): string;
        after(arg0: Internal.Date_): boolean;
        toLocaleString(): string;
        getDate(): number;
        getDay(): number;
        equals(arg0: any): boolean;
        static UTC(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): number;
        setTime(arg0: number): void;
        get hours(): number
        set date(arg0: number)
        get month(): number
        get timezoneOffset(): number
        set month(arg0: number)
        get minutes(): number
        get seconds(): number
        set year(arg0: number)
        get time(): number
        set hours(arg0: number)
        set seconds(arg0: number)
        set minutes(arg0: number)
        get year(): number
        get date(): number
        get day(): number
        set time(arg0: number)
    }
    type Date_ = Date;
    class Random implements Internal.RandomGenerator, Internal.Serializable {
        constructor()
        constructor(arg0: number)
        nextFloat(arg0: number): number;
        ints(arg0: number, arg1: number): Internal.IntStream;
        nextLong(): number;
        nextDouble(): number;
        nextLong(arg0: number, arg1: number): number;
        nextGaussian(): number;
        doubles(arg0: number, arg1: number, arg2: number): Internal.DoubleStream;
        nextDouble(arg0: number): number;
        nextInt(arg0: number): number;
        nextFloat(): number;
        nextLong(arg0: number): number;
        ints(arg0: number, arg1: number, arg2: number): Internal.IntStream;
        nextFloat(arg0: number, arg1: number): number;
        doubles(): Internal.DoubleStream;
        nextBytes(arg0: number[]): void;
        nextInt(): number;
        longs(arg0: number): Internal.LongStream;
        longs(arg0: number, arg1: number, arg2: number): Internal.LongStream;
        nextBoolean(): boolean;
        nextDouble(arg0: number, arg1: number): number;
        nextExponential(): number;
        setSeed(arg0: number): void;
        longs(arg0: number, arg1: number): Internal.LongStream;
        nextInt(arg0: number, arg1: number): number;
        longs(): Internal.LongStream;
        isDeprecated(): boolean;
        nextGaussian(arg0: number, arg1: number): number;
        doubles(arg0: number): Internal.DoubleStream;
        ints(): Internal.IntStream;
        ints(arg0: number): Internal.IntStream;
        doubles(arg0: number, arg1: number): Internal.DoubleStream;
        set seed(arg0: number)
        get deprecated(): boolean
    }
    type Random_ = Random;
    class ClientboundLevelParticlesPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: T, arg1: boolean, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getCount(): number;
        getMaxSpeed(): number;
        getParticle(): Internal.ParticleOptions;
        isOverrideLimiter(): boolean;
        isSkippable(): boolean;
        getX(): number;
        getY(): number;
        getXDist(): number;
        getZ(): number;
        getYDist(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getZDist(): number;
        get count(): number
        get maxSpeed(): number
        get particle(): Internal.ParticleOptions
        get overrideLimiter(): boolean
        get skippable(): boolean
        get x(): number
        get y(): number
        get XDist(): number
        get z(): number
        get YDist(): number
        get ZDist(): number
    }
    type ClientboundLevelParticlesPacket_ = ClientboundLevelParticlesPacket;
    abstract class FileLock implements Internal.AutoCloseable {
        isValid(): boolean;
        toString(): string;
        overlaps(arg0: number, arg1: number): boolean;
        position(): number;
        release(): void;
        close(): void;
        isShared(): boolean;
        size(): number;
        channel(): Internal.FileChannel;
        acquiredBy(): Internal.Channel;
        get valid(): boolean
        get shared(): boolean
    }
    type FileLock_ = FileLock;
    class Locale$FilteringMode extends Internal.Enum<Internal.Locale$FilteringMode> {
        static valueOf(arg0: string): Internal.Locale$FilteringMode;
        static values(): Internal.Locale$FilteringMode[];
        readonly static "EXTENDED_FILTERING": Internal.Locale$FilteringMode;
        readonly static "IGNORE_EXTENDED_RANGES": Internal.Locale$FilteringMode;
        readonly static "AUTOSELECT_FILTERING": Internal.Locale$FilteringMode;
        readonly static "MAP_EXTENDED_RANGES": Internal.Locale$FilteringMode;
        readonly static "REJECT_EXTENDED_RANGES": Internal.Locale$FilteringMode;
    }
    type Locale$FilteringMode_ = "reject_extended_ranges" | Locale$FilteringMode | "extended_filtering" | "ignore_extended_ranges" | "autoselect_filtering" | "map_extended_ranges";
    class IsoChronology extends Internal.AbstractChronology implements Internal.Serializable {
        localDateTime(arg0: Internal.TemporalAccessor_): Internal.LocalDateTime;
        date(arg0: Internal.TemporalAccessor_): Internal.LocalDate;
        eras(): Internal.List<Internal.Era>;
        resolveDate(arg0: Internal.Map_<Internal.TemporalField_, number>, arg1: Internal.ResolverStyle_): Internal.LocalDate;
        period(arg0: number, arg1: number, arg2: number): Internal.ChronoPeriod;
        epochSecond(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.ZoneOffset_): number;
        zonedDateTime(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.ChronoZonedDateTime<any>;
        eraOf(arg0: number): Internal.IsoEra;
        date(arg0: Internal.Era_, arg1: number, arg2: number, arg3: number): Internal.LocalDate;
        getId(): string;
        isLeapYear(arg0: number): boolean;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        dateNow(arg0: Internal.ZoneId_): Internal.LocalDate;
        zonedDateTime(arg0: Internal.TemporalAccessor_): Internal.ChronoZonedDateTime<any>;
        dateYearDay(arg0: Internal.Era_, arg1: number, arg2: number): Internal.LocalDate;
        dateNow(arg0: Internal.Clock_): Internal.ChronoLocalDate;
        dateEpochDay(arg0: number): Internal.ChronoLocalDate;
        getCalendarType(): string;
        dateYearDay(arg0: number, arg1: number): Internal.ChronoLocalDate;
        date(arg0: number, arg1: number, arg2: number): Internal.ChronoLocalDate;
        range(arg0: Internal.ChronoField_): Internal.ValueRange;
        prolepticYear(arg0: Internal.Era_, arg1: number): number;
        epochSecond(arg0: Internal.Era_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneOffset_): number;
        dateNow(): Internal.ChronoLocalDate;
        get id(): string
        get calendarType(): string
        readonly static "INSTANCE": Internal.IsoChronology;
    }
    type IsoChronology_ = IsoChronology;
    class SoundEventBuilder extends Internal.BuilderBase<Internal.SoundEvent> {
        constructor(i: ResourceLocation_)
        createObject(): any;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.SoundEvent>;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.SoundEvent>
    }
    type SoundEventBuilder_ = SoundEventBuilder;
    interface ScriptSource {
        createStream(arg0: Internal.ScriptFileInfo_): Internal.InputStream;
    }
    type ScriptSource_ = ((arg0: Internal.ScriptFileInfo)=>Internal.InputStream_) | ScriptSource;
    class TagEventJS <T> extends Internal.EventJS {
        constructor(t: string, m: Internal.Map_<ResourceLocation_, any_>, r: Internal.Registry_<T>)
        removeAllTagsFrom(...ids: string[]): void;
        post(event: string): void;
        get(id: ResourceLocation_): Internal.TagEventJS$TagWrapper<>;
        add(tag: ResourceLocation_, ...ids: string[]): Internal.TagEventJS$TagWrapper<>;
        getType(): string;
        setGlobalPriorityList(o: any): void;
        remove(tag: ResourceLocation_, ...ids: string[]): Internal.TagEventJS$TagWrapper<>;
        removeAll(tag: ResourceLocation_): Internal.TagEventJS$TagWrapper<>;
        get type(): string
        set globalPriorityList(o: any)
    }
    type TagEventJS_<T> = TagEventJS<T>;
    class BlockPathTypes extends Internal.Enum<Internal.BlockPathTypes> {
        static valueOf(arg0: string): Internal.BlockPathTypes;
        static values(): Internal.BlockPathTypes[];
        getDanger(): this;
        getMalus(): number;
        get danger(): Internal.BlockPathTypes
        get malus(): number
        readonly static "STICKY_HONEY": Internal.BlockPathTypes;
        readonly static "WALKABLE": Internal.BlockPathTypes;
        readonly static "WATER_BORDER": Internal.BlockPathTypes;
        readonly static "LAVA": Internal.BlockPathTypes;
        readonly static "TRAPDOOR": Internal.BlockPathTypes;
        readonly static "DAMAGE_CACTUS": Internal.BlockPathTypes;
        readonly static "FENCE": Internal.BlockPathTypes;
        readonly static "OPEN": Internal.BlockPathTypes;
        readonly static "UNPASSABLE_RAIL": Internal.BlockPathTypes;
        readonly static "BLOCKED": Internal.BlockPathTypes;
        readonly static "LEAVES": Internal.BlockPathTypes;
        readonly static "DANGER_OTHER": Internal.BlockPathTypes;
        readonly static "DANGER_POWDER_SNOW": Internal.BlockPathTypes;
        readonly static "DOOR_WOOD_CLOSED": Internal.BlockPathTypes;
        readonly static "DOOR_IRON_CLOSED": Internal.BlockPathTypes;
        readonly static "BREACH": Internal.BlockPathTypes;
        readonly static "COCOA": Internal.BlockPathTypes;
        readonly static "DAMAGE_OTHER": Internal.BlockPathTypes;
        readonly static "DAMAGE_FIRE": Internal.BlockPathTypes;
        readonly static "WALKABLE_DOOR": Internal.BlockPathTypes;
        readonly static "DANGER_CACTUS": Internal.BlockPathTypes;
        readonly static "RAIL": Internal.BlockPathTypes;
        readonly static "POWDER_SNOW": Internal.BlockPathTypes;
        readonly static "DANGER_FIRE": Internal.BlockPathTypes;
        readonly static "DOOR_OPEN": Internal.BlockPathTypes;
        readonly static "WATER": Internal.BlockPathTypes;
    }
    type BlockPathTypes_ = "breach" | "lava" | "danger_powder_snow" | BlockPathTypes | "unpassable_rail" | "leaves" | "cocoa" | "rail" | "fence" | "danger_cactus" | "trapdoor" | "danger_fire" | "blocked" | "walkable" | "open" | "door_iron_closed" | "damage_cactus" | "walkable_door" | "powder_snow" | "damage_other" | "door_wood_closed" | "door_open" | "danger_other" | "water" | "damage_fire" | "water_border" | "sticky_honey";
    class SimpleWeightedRandomList$Builder <E> {
        constructor()
        build(): Internal.SimpleWeightedRandomList<E>;
        add(arg0: E, arg1: number): this;
    }
    type SimpleWeightedRandomList$Builder_<E> = SimpleWeightedRandomList$Builder<E>;
    class Property$Value <T> extends Internal.Record {
        constructor(arg0: Internal.Property_<T>, arg1: T)
        hashCode(): number;
        toString(): string;
        property(): Internal.Property<T>;
        value(): T;
        equals(arg0: any): boolean;
    }
    type Property$Value_<T> = Property$Value<T>;
    interface LevelReader extends Internal.BlockAndTintGetter, Internal.BiomeManager$NoiseBiomeSource, Internal.CollisionGetter {
        getBlockTint(arg0: BlockPos_, arg1: Internal.ColorResolver_): number;
        getMinSection(): number;
        findFreePosition(arg0: Internal.Entity_, arg1: Internal.VoxelShape_, arg2: Vec3_, arg3: number, arg4: number, arg5: number): Internal.Optional<Vec3>;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        isUnobstructed(arg0: Internal.Entity_, arg1: Internal.VoxelShape_): boolean;
        getMaxSection(): number;
        getBrightness(arg0: Internal.LightLayer_, arg1: BlockPos_): number;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getBlockStatesIfLoaded(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getSectionYFromSectionIndex(arg0: number): number;
        getBiomeManager(): Internal.BiomeManager;
        isEmptyBlock(arg0: BlockPos_): boolean;
        getMaxLocalRawBrightness(arg0: BlockPos_, arg1: number): number;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        getBlockCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        getRawBrightness(arg0: BlockPos_, arg1: number): number;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getHeightmapPos(arg0: Internal.Heightmap$Types_, arg1: BlockPos_): BlockPos;
        canSeeSky(arg0: BlockPos_): boolean;
        isClientSide(): boolean;
        isUnobstructed(arg0: Internal.Entity_): boolean;
        getUncachedNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getBrightness(arg0: BlockPos_): number;
        dimensionType(): Internal.DimensionType;
        getSkyDarken(): number;
        canSeeSkyFromBelowWater(arg0: BlockPos_): boolean;
        getSectionsCount(): number;
        getHeight(arg0: Internal.Heightmap$Types_, arg1: number, arg2: number): number;
        getMinBuildHeight(): number;
        getSectionIndexFromSectionY(arg0: number): number;
        noCollision(arg0: Internal.Entity_): boolean;
        getChunk(arg0: number, arg1: number, arg2: Internal.ChunkStatus_): Internal.ChunkAccess;
        getSeaLevel(): number;
        hasChunkAt(arg0: number, arg1: number): boolean;
        getSectionIndex(arg0: number): number;
        hasChunk(arg0: number, arg1: number): boolean;
        getMaxBuildHeight(): number;
        hasChunksAt(arg0: BlockPos_, arg1: BlockPos_): boolean;
        noCollision(arg0: Internal.AABB_): boolean;
        getChunk(arg0: number, arg1: number): Internal.ChunkAccess;
        isWaterAt(arg0: BlockPos_): boolean;
        getDirectSignal(arg0: BlockPos_, arg1: Internal.Direction_): number;
        getCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        collidesWithSuffocatingBlock(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getHeight(): number;
        getNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        noCollision(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getChunk(arg0: BlockPos_): Internal.ChunkAccess;
        isOutsideBuildHeight(arg0: number): boolean;
        getMaxLocalRawBrightness(arg0: BlockPos_): number;
        isUnobstructed(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.CollisionContext_): boolean;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getChunk(arg0: number, arg1: number, arg2: Internal.ChunkStatus_, arg3: boolean): Internal.ChunkAccess;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        hasChunkAt(arg0: BlockPos_): boolean;
        getBiome(arg0: BlockPos_): Internal.Holder<Internal.Biome>;
        getChunkForCollisions(arg0: number, arg1: number): Internal.BlockGetter;
        containsAnyLiquid(arg0: Internal.AABB_): boolean;
        getMaxLightLevel(): number;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
        get minSection(): number
        get maxSection(): number
        get biomeManager(): Internal.BiomeManager
        get clientSide(): boolean
        get skyDarken(): number
        get sectionsCount(): number
        get minBuildHeight(): number
        get seaLevel(): number
        get maxBuildHeight(): number
        get height(): number
        get maxLightLevel(): number
    }
    type LevelReader_ = LevelReader;
    class IngredientWithCustomPredicateJS implements Internal.IngredientJS {
        constructor(id: Internal.UUID_, i: Internal.IngredientJS_, p: Internal.Predicate_<Internal.ItemStack_>)
        getVanillaItems(): Internal.Set<Internal.Item>;
        x(c: number): Internal.IngredientJS;
        getCount(): number;
        isInvalidRecipeIngredient(): boolean;
        toString(): string;
        getStacks(): Internal.Set<Internal.ItemStackJS>;
        asIngredientStack(): Internal.IngredientStackJS;
        getItemIds(): Internal.Set<string>;
        copy(): Internal.Copyable;
        test(stack: Internal.ItemStackJS_): boolean;
        isEmpty(): boolean;
        toJson(): Internal.JsonElement;
        testVanillaItem(i: Internal.Item_): boolean;
        filter(filter: Internal.IngredientJS_): Internal.IngredientJS;
        not(): Internal.IngredientJS;
        anyStackMatches(ingredient: Internal.IngredientJS_): boolean;
        createVanillaIngredient(): Internal.Ingredient;
        getVanillaPredicate(): Internal.Predicate<Internal.ItemStack>;
        getFirst(): Internal.ItemStackJS;
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>;
        withCount(count: number): Internal.IngredientJS;
        testVanilla(stack: Internal.ItemStack_): boolean;
        get vanillaItems(): Internal.Set<Internal.Item>
        get count(): number
        get invalidRecipeIngredient(): boolean
        get stacks(): Internal.Set<Internal.ItemStackJS>
        get itemIds(): Internal.Set<string>
        get empty(): boolean
        get vanillaPredicate(): Internal.Predicate<Internal.ItemStack>
        get first(): Internal.ItemStackJS
        readonly "predicate": Internal.Predicate<Internal.ItemStack>;
        readonly "uuid": Internal.UUID;
        readonly "ingredient": Internal.IngredientJS;
    }
    type IngredientWithCustomPredicateJS_ = IngredientWithCustomPredicateJS;
    class ShortTag extends Internal.NumericTag {
        getAsDouble(): number;
        accept(arg0: Internal.TagVisitor_): void;
        getAsLong(): number;
        getAsFloat(): number;
        hashCode(): number;
        getAsString(): string;
        getAsInt(): number;
        getType(): Internal.TagType<Internal.ShortTag>;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        getAsByte(): number;
        getAsNumber(): Internal.Number;
        write(arg0: Internal.DataOutput_): void;
        static valueOf(arg0: number): Internal.ShortTag;
        getId(): number;
        getAsShort(): number;
        equals(arg0: any): boolean;
        accept(arg0: Internal.StreamTagVisitor_): Internal.StreamTagVisitor$ValueResult;
        copy(): this;
        get asDouble(): number
        get asLong(): number
        get asFloat(): number
        get asString(): string
        get asInt(): number
        get type(): Internal.TagType<Internal.ShortTag>
        get asByte(): number
        get asNumber(): Internal.Number
        get id(): number
        get asShort(): number
        readonly static "TYPE": any;
    }
    type ShortTag_ = ShortTag;
    interface ComposableEntryContainer {
        and(arg0: Internal.ComposableEntryContainer_): this;
        or(arg0: Internal.ComposableEntryContainer_): this;
        expand(arg0: Internal.LootContext_, arg1: Internal.Consumer_<Internal.LootPoolEntry_>): boolean;
        readonly static "ALWAYS_TRUE": Internal.ComposableEntryContainer;
        readonly static "ALWAYS_FALSE": Internal.ComposableEntryContainer;
    }
    type ComposableEntryContainer_ = ComposableEntryContainer | ((arg0: Internal.LootContext, arg1: Internal.Consumer<Internal.LootPoolEntry>)=>boolean);
    class MapExtendingRecipe extends Internal.ShapedRecipe {
        constructor(arg0: ResourceLocation_)
        isSpecial(): boolean;
        getSerializer(): Internal.RecipeSerializer<any>;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        matches(arg0: Internal.CraftingContainer_, arg1: Internal.Level_): boolean;
        assemble(arg0: Internal.CraftingContainer_): Internal.ItemStack;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        get special(): boolean
        get serializer(): Internal.RecipeSerializer<any>
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
    }
    type MapExtendingRecipe_ = MapExtendingRecipe;
    interface LevelAccessor extends Internal.CommonLevelAccessor, Internal.LevelTimeAccess {
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_): Internal.Player;
        dayTime(): number;
        isUnobstructed(arg0: Internal.Entity_, arg1: Internal.VoxelShape_): boolean;
        getMaxSection(): number;
        getLevelData(): Internal.LevelData;
        gameEvent(arg0: Internal.GameEvent_, arg1: Internal.Entity_): void;
        getBrightness(arg0: Internal.LightLayer_, arg1: BlockPos_): number;
        getSectionYFromSectionIndex(arg0: number): number;
        isEmptyBlock(arg0: BlockPos_): boolean;
        getMaxLocalRawBrightness(arg0: BlockPos_, arg1: number): number;
        getBlockCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        getTimeOfDay(arg0: number): number;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getHeightmapPos(arg0: Internal.Heightmap$Types_, arg1: BlockPos_): BlockPos;
        blockUpdated(arg0: BlockPos_, arg1: Internal.Block_): void;
        getEntities(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.Entity>;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_): Internal.List<T>;
        getBlockTicks(): Internal.LevelTickAccess<Internal.Block>;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getBrightness(arg0: BlockPos_): number;
        getNearestEntity(arg0: Internal.List_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number): T;
        getMinBuildHeight(): number;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Fluid_, arg2: number): void;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): Internal.Player;
        hasChunkAt(arg0: number, arg1: number): boolean;
        getFluidTicks(): Internal.LevelTickAccess<Internal.Fluid>;
        getSectionIndex(arg0: number): number;
        getRandom(): Internal.Random;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: number, arg2: number, arg3: number): Internal.Player;
        getMaxBuildHeight(): number;
        hasChunksAt(arg0: BlockPos_, arg1: BlockPos_): boolean;
        destroyBlock(arg0: BlockPos_, arg1: boolean): boolean;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Block_, arg2: number): void;
        addFreshEntity(arg0: Internal.Entity_): boolean;
        getChunk(arg0: number, arg1: number): Internal.ChunkAccess;
        getCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.Iterable<Internal.VoxelShape>;
        destroyBlock(arg0: BlockPos_, arg1: boolean, arg2: Internal.Entity_): boolean;
        getHeight(): number;
        getChunk(arg0: BlockPos_): Internal.ChunkAccess;
        gameEvent(arg0: Internal.GameEvent_, arg1: BlockPos_): void;
        getMaxLocalRawBrightness(arg0: BlockPos_): number;
        isUnobstructed(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.CollisionContext_): boolean;
        hasChunkAt(arg0: BlockPos_): boolean;
        getBiome(arg0: BlockPos_): Internal.Holder<Internal.Biome>;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Block_, arg2: number, arg3: Internal.TickPriority_): void;
        hasNearbyAlivePlayer(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: number, arg3: number, arg4: number): Internal.Player;
        getBlockTint(arg0: BlockPos_, arg1: Internal.ColorResolver_): number;
        getMinSection(): number;
        findFreePosition(arg0: Internal.Entity_, arg1: Internal.VoxelShape_, arg2: Vec3_, arg3: number, arg4: number, arg5: number): Internal.Optional<Vec3>;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        playSound(arg0: Internal.Player_, arg1: BlockPos_, arg2: Internal.SoundEvent_, arg3: Internal.SoundSource_, arg4: number, arg5: number): void;
        getNearestPlayer(arg0: Internal.Entity_, arg1: number): Internal.Player;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getBlockStatesIfLoaded(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        hasChunksAt(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        getRawBrightness(arg0: BlockPos_, arg1: number): number;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        addParticle(arg0: Internal.ParticleOptions_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
        getCurrentDifficultyAt(arg0: BlockPos_): Internal.DifficultyInstance;
        getDifficulty(): Internal.Difficulty;
        canSeeSky(arg0: BlockPos_): boolean;
        getMoonPhase(): number;
        isUnobstructed(arg0: Internal.Entity_): boolean;
        getPlayerByUUID(arg0: Internal.UUID_): Internal.Player;
        canSeeSkyFromBelowWater(arg0: BlockPos_): boolean;
        getSectionsCount(): number;
        getSectionIndexFromSectionY(arg0: number): number;
        getNearbyPlayers(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: Internal.AABB_): Internal.List<Internal.Player>;
        getServer(): Internal.MinecraftServer;
        levelEvent(arg0: Internal.Player_, arg1: number, arg2: BlockPos_, arg3: number): void;
        setBlock(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: number): boolean;
        noCollision(arg0: Internal.Entity_): boolean;
        getChunk(arg0: number, arg1: number, arg2: Internal.ChunkStatus_): Internal.ChunkAccess;
        hasChunk(arg0: number, arg1: number): boolean;
        getNearbyEntities(arg0: Internal.Class_<T>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: Internal.AABB_): Internal.List<T>;
        getMoonBrightness(): number;
        noCollision(arg0: Internal.AABB_): boolean;
        isWaterAt(arg0: BlockPos_): boolean;
        getDirectSignal(arg0: BlockPos_, arg1: Internal.Direction_): number;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        getEntityCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.VoxelShape>;
        collidesWithSuffocatingBlock(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        getNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        noCollision(arg0: Internal.Entity_, arg1: Internal.AABB_): boolean;
        isOutsideBuildHeight(arg0: number): boolean;
        scheduleTick(arg0: BlockPos_, arg1: Internal.Fluid_, arg2: number, arg3: Internal.TickPriority_): void;
        gameEvent(arg0: Internal.Entity_, arg1: Internal.GameEvent_, arg2: Internal.Entity_): void;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Predicate_<Internal.Entity_>): Internal.Player;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        getNearestEntity(arg0: Internal.Class_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number, arg6: Internal.AABB_): T;
        getChunkSource(): Internal.ChunkSource;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_, arg2: Internal.Predicate_<any>): Internal.List<T>;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        levelEvent(arg0: number, arg1: BlockPos_, arg2: number): void;
        nextSubTickCount(): number;
        getChunkForCollisions(arg0: number, arg1: number): Internal.BlockGetter;
        gameEvent(arg0: Internal.Entity_, arg1: Internal.GameEvent_, arg2: BlockPos_): void;
        containsAnyLiquid(arg0: Internal.AABB_): boolean;
        getMaxLightLevel(): number;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
        get maxSection(): number
        get levelData(): Internal.LevelData
        get blockTicks(): Internal.LevelTickAccess<Internal.Block>
        get minBuildHeight(): number
        get fluidTicks(): Internal.LevelTickAccess<Internal.Fluid>
        get random(): Internal.Random
        get maxBuildHeight(): number
        get height(): number
        get minSection(): number
        get difficulty(): Internal.Difficulty
        get moonPhase(): number
        get sectionsCount(): number
        get server(): Internal.MinecraftServer
        get moonBrightness(): number
        get chunkSource(): Internal.ChunkSource
        get maxLightLevel(): number
    }
    type LevelAccessor_ = LevelAccessor;
    interface Char2DoubleFunction extends Internal.IntToDoubleFunction, it.unimi.dsi.fastutil.Function<string, number> {
        applyAsDouble(arg0: number): number;
        getOrDefault(arg0: any, arg1: any): any;
        get(arg0: any): number;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Char2ShortFunction;
        remove(arg0: string): number;
        put(arg0: string, arg1: number): number;
        put(arg0: string, arg1: number): number;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Char2ByteFunction;
        andThenReference(arg0: Internal.Double2ReferenceFunction_<any>): Internal.Char2ReferenceFunction<T>;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2DoubleFunction;
        containsKey(arg0: string): boolean;
        containsKey(arg0: any): boolean;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Char2LongFunction;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Char2IntFunction;
        put(arg0: any, arg1: any): any;
        composeReference(arg0: Internal.Reference2CharFunction_<any>): Internal.Reference2DoubleFunction<T>;
        defaultReturnValue(arg0: number): void;
        apply(arg0: string): number;
        getOrDefault(arg0: string, arg1: number): number;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): this;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2DoubleFunction;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2DoubleFunction;
        getOrDefault(arg0: any, arg1: number): number;
        get(arg0: string): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2DoubleFunction;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2DoubleFunction;
        andThenObject(arg0: Internal.Double2ObjectFunction_<any>): Internal.Char2ObjectFunction<T>;
        defaultReturnValue(): number;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2DoubleFunction;
        size(): number;
        composeObject(arg0: Internal.Object2CharFunction_<any>): Internal.Object2DoubleFunction<T>;
        clear(): void;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Char2FloatFunction;
        remove(arg0: any): any;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Char2CharFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<string, T>;
        composeChar(arg0: Internal.Char2CharFunction_): this;
    }
    type Char2DoubleFunction_ = Char2DoubleFunction | ((arg0: string)=>number);
    class ClientChatReceivedEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.ChatType_, arg1: Internal.Component_, arg2: Internal.UUID_)
        getMessage(): Internal.Component;
        getSenderUUID(): Internal.UUID;
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        getType(): Internal.ChatType;
        setMessage(arg0: Internal.Component_): void;
        get message(): Internal.Component
        get senderUUID(): Internal.UUID
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
        get type(): Internal.ChatType
        set message(arg0: Internal.Component_)
    }
    type ClientChatReceivedEvent_ = ClientChatReceivedEvent;
    abstract class PlacementModifier {
        constructor()
        type(): Internal.PlacementModifierType<any>;
        getPositions(arg0: Internal.PlacementContext_, arg1: Internal.Random_, arg2: BlockPos_): Internal.Stream<BlockPos>;
        readonly static "CODEC": any;
    }
    type PlacementModifier_ = PlacementModifier;
    interface CommandSource {
        shouldInformAdmins(): boolean;
        alwaysAccepts(): boolean;
        acceptsFailure(): boolean;
        sendMessage(arg0: Internal.Component_, arg1: Internal.UUID_): void;
        acceptsSuccess(): boolean;
        readonly static "NULL": any;
    }
    type CommandSource_ = CommandSource;
    class EnchantmentMenu extends Internal.AbstractContainerMenu {
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: any_)
        constructor(arg0: number, arg1: Internal.Inventory_)
        stillValid(arg0: Internal.Player_): boolean;
        slotsChanged(arg0: Internal.Container_): void;
        clickMenuButton(arg0: Internal.Player_, arg1: number): boolean;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        getGoldCount(): number;
        removed(arg0: Internal.Player_): void;
        getEnchantmentSeed(): number;
        get goldCount(): number
        get enchantmentSeed(): number
        readonly "enchantClue": number[];
        readonly "levelClue": number[];
        readonly "costs": number[];
    }
    type EnchantmentMenu_ = EnchantmentMenu;
    class GameRules$BooleanValue extends Internal.GameRules$Value<Internal.GameRules$BooleanValue> {
        constructor(arg0: Internal.GameRules$Type_<Internal.GameRules$BooleanValue_>, arg1: boolean)
        setFrom(arg0: Internal.GameRules$BooleanValue_, arg1: Internal.MinecraftServer_): void;
        setFrom(arg0: Internal.GameRules$Value_<any>, arg1: Internal.MinecraftServer_): void;
        serialize(): string;
        getCommandResult(): number;
        set(arg0: boolean, arg1: Internal.MinecraftServer_): void;
        static create(arg0: boolean): Internal.GameRules$Type<Internal.GameRules$BooleanValue>;
        static create(arg0: boolean, arg1: Internal.BiConsumer_<Internal.MinecraftServer_, Internal.GameRules$BooleanValue_>): Internal.GameRules$Type<Internal.GameRules$BooleanValue>;
        get(): boolean;
        get commandResult(): number
    }
    type GameRules$BooleanValue_ = GameRules$BooleanValue;
    abstract class EntityEventJS extends Internal.LevelEventJS {
        constructor()
        getEntity(): Internal.EntityJS;
        getLevel(): Internal.LevelJS;
        get entity(): Internal.EntityJS
        get level(): Internal.LevelJS
    }
    type EntityEventJS_ = EntityEventJS;
    interface Cancellable {
        isCancellable(): boolean;
        cancel(): void;
        isCancelled(): boolean;
        get cancellable(): boolean
        get cancelled(): boolean
    }
    type Cancellable_ = Cancellable;
    class StringSplitter {
        constructor(arg0: any_)
        plainIndexAtWidth(arg0: string, arg1: number, arg2: Internal.Style_): number;
        findLineBreak(arg0: string, arg1: number, arg2: Internal.Style_): number;
        stringWidth(arg0: Internal.FormattedText_): number;
        splitLines(arg0: Internal.FormattedText_, arg1: number, arg2: Internal.Style_): Internal.List<Internal.FormattedText>;
        stringWidth(arg0: string): number;
        static getWordPosition(arg0: string, arg1: number, arg2: number, arg3: boolean): number;
        plainTailByWidth(arg0: string, arg1: number, arg2: Internal.Style_): string;
        plainHeadByWidth(arg0: string, arg1: number, arg2: Internal.Style_): string;
        splitLines(arg0: string, arg1: number, arg2: Internal.Style_): Internal.List<Internal.FormattedText>;
        splitLines(arg0: string, arg1: number, arg2: Internal.Style_, arg3: boolean, arg4: Internal.StringSplitter$LinePosConsumer_): void;
        formattedHeadByWidth(arg0: string, arg1: number, arg2: Internal.Style_): string;
        componentStyleAtWidth(arg0: Internal.FormattedText_, arg1: number): Internal.Style;
        headByWidth(arg0: Internal.FormattedText_, arg1: number, arg2: Internal.Style_): Internal.FormattedText;
        splitLines(arg0: Internal.FormattedText_, arg1: number, arg2: Internal.Style_, arg3: Internal.FormattedText_): Internal.List<Internal.FormattedText>;
        componentStyleAtWidth(arg0: Internal.FormattedCharSequence_, arg1: number): Internal.Style;
        stringWidth(arg0: Internal.FormattedCharSequence_): number;
        formattedIndexByWidth(arg0: string, arg1: number, arg2: Internal.Style_): number;
        splitLines(arg0: Internal.FormattedText_, arg1: number, arg2: Internal.Style_, arg3: Internal.BiConsumer_<Internal.FormattedText_, boolean>): void;
    }
    type StringSplitter_ = StringSplitter;
    class STBTTFontinfo$Buffer extends Internal.StructBuffer<Internal.STBTTFontinfo, Internal.STBTTFontinfo$Buffer> implements Internal.NativeResource {
        constructor(arg0: number, arg1: number)
        constructor(arg0: Internal.ByteBuffer_)
        close(): void;
    }
    type STBTTFontinfo$Buffer_ = STBTTFontinfo$Buffer;
    class TrueBlockPredicate implements net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate {
        type(): Internal.BlockPredicateType<any>;
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: any, arg1: any): boolean;
        negate(): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: Internal.WorldGenLevel_, arg1: BlockPos_): boolean;
        static "INSTANCE": Internal.TrueBlockPredicate;
        readonly static "CODEC": Internal.Codec<Internal.TrueBlockPredicate>;
    }
    type TrueBlockPredicate_ = TrueBlockPredicate;
    interface CustomJavaToJsWrapperProvider <T> {
        create(arg0: T): Internal.CustomJavaToJsWrapper;
        readonly static "NONE": any;
    }
    type CustomJavaToJsWrapperProvider_<T> = ((arg0: T)=>Internal.CustomJavaToJsWrapper_) | CustomJavaToJsWrapperProvider<T>;
    class ModuleDescriptor implements Internal.Comparable<Internal.ModuleDescriptor> {
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Modifier>;
        uses(): Internal.Set<string>;
        static read(arg0: Internal.ByteBuffer_): Internal.ModuleDescriptor;
        static read(arg0: Internal.InputStream_, arg1: Internal.Supplier_<Internal.Set_<string>>): Internal.ModuleDescriptor;
        exports(): Internal.Set<Internal.ModuleDescriptor$Exports>;
        compareTo(arg0: any): number;
        toNameAndVersion(): string;
        static newModule(arg0: string, arg1: Internal.Set_<Internal.ModuleDescriptor$Modifier_>): Internal.ModuleDescriptor$Builder;
        static read(arg0: Internal.InputStream_): Internal.ModuleDescriptor;
        isOpen(): boolean;
        rawVersion(): Internal.Optional<string>;
        static read(arg0: Internal.ByteBuffer_, arg1: Internal.Supplier_<Internal.Set_<string>>): Internal.ModuleDescriptor;
        toString(): string;
        isAutomatic(): boolean;
        static newOpenModule(arg0: string): Internal.ModuleDescriptor$Builder;
        requires(): Internal.Set<Internal.ModuleDescriptor$Requires>;
        provides(): Internal.Set<Internal.ModuleDescriptor$Provides>;
        name(): string;
        hashCode(): number;
        opens(): Internal.Set<Internal.ModuleDescriptor$Opens>;
        compareTo(arg0: Internal.ModuleDescriptor_): number;
        version(): Internal.Optional<Internal.ModuleDescriptor$Version>;
        mainClass(): Internal.Optional<string>;
        static newAutomaticModule(arg0: string): Internal.ModuleDescriptor$Builder;
        equals(arg0: any): boolean;
        packages(): Internal.Set<string>;
        static newModule(arg0: string): Internal.ModuleDescriptor$Builder;
        get open(): boolean
        get automatic(): boolean
    }
    type ModuleDescriptor_ = ModuleDescriptor;
    abstract class AbstractIntCollection extends Internal.AbstractCollection<number> implements Internal.IntCollection {
        stream(): Internal.Stream<number>;
        forEach(arg0: Internal.Consumer_<any>): void;
        add(arg0: number): boolean;
        contains(arg0: number): boolean;
        toIntArray(): number[];
        forEach(arg0: Internal.IntConsumer_): void;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        intStream(): Internal.IntStream;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        toArray(arg0: number[]): number[];
        addAll(arg0: Internal.Collection_<any>): boolean;
        intParallelStream(): Internal.IntStream;
        removeAll(arg0: Internal.IntCollection_): boolean;
        intIterator(): Internal.IntIterator;
        contains(arg0: any): boolean;
        removeIf(arg0: Internal.IntPredicate_): boolean;
        addAll(arg0: Internal.IntCollection_): boolean;
        toString(): string;
        retainAll(arg0: Internal.IntCollection_): boolean;
        iterator(): Internal.Iterator<any>;
        forEach(arg0: it.unimi.dsi.fastutil.ints.IntConsumer_): void;
        add(arg0: number): boolean;
        toIntArray(arg0: number[]): number[];
        parallelStream(): Internal.Stream<number>;
        containsAll(arg0: Internal.IntCollection_): boolean;
        remove(arg0: any): boolean;
        removeIf(arg0: it.unimi.dsi.fastutil.ints.IntPredicate_): boolean;
        intSpliterator(): Internal.IntSpliterator;
        add(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        spliterator(): Internal.Spliterator<any>;
        rem(arg0: number): boolean;
    }
    type AbstractIntCollection_ = AbstractIntCollection;
    class ClientboundOpenBookPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Hand_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getHand(): Hand;
        isSkippable(): boolean;
        get hand(): Hand
        get skippable(): boolean
    }
    type ClientboundOpenBookPacket_ = ClientboundOpenBookPacket;
    interface LootPoolEntry {
        getWeight(arg0: number): number;
        createItemStack(arg0: Internal.Consumer_<Internal.ItemStack_>, arg1: Internal.LootContext_): void;
    }
    type LootPoolEntry_ = LootPoolEntry;
    class ClassWrapper <T> extends Internal.Record implements Internal.CustomJavaToJsWrapper {
        constructor(wrappedClass: Internal.Class_<T>)
        hashCode(): number;
        toString(): string;
        wrappedClass(): Internal.Class<T>;
        equals(o: any): boolean;
        convertJavaToJs(data: Internal.SharedContextData_, scope: Internal.Scriptable_, staticType: Internal.Class_<any>): Internal.Scriptable;
    }
    type ClassWrapper_<T> = ClassWrapper<T>;
    interface Object2IntFunction <K> extends Internal.ToIntFunction<K>, it.unimi.dsi.fastutil.Function<K, number> {
        put(arg0: K, arg1: number): number;
        andThenReference(arg0: Internal.Int2ReferenceFunction_<any>): Internal.Object2ReferenceFunction<K, T>;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Object2FloatFunction<K>;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Object2LongFunction<K>;
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        defaultReturnValue(): number;
        removeInt(arg0: any): number;
        apply(arg0: K): number;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2IntFunction;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Object2ShortFunction<K>;
        containsKey(arg0: any): boolean;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2IntFunction;
        getInt(arg0: any): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        put(arg0: any, arg1: any): any;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        composeReference(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Reference2IntFunction<T>;
        andThenInt(arg0: Internal.Int2IntFunction_): this;
        put(arg0: K, arg1: number): number;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2IntFunction;
        composeObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Object2IntFunction<T>;
        getOrDefault(arg0: any, arg1: number): number;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2IntFunction;
        applyAsInt(arg0: K): number;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2IntFunction;
        size(): number;
        defaultReturnValue(arg0: number): void;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2IntFunction;
        andThenObject(arg0: Internal.Int2ObjectFunction_<any>): Internal.Object2ObjectFunction<K, T>;
        clear(): void;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Object2ByteFunction<K>;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Object2CharFunction<K>;
        getOrDefault(arg0: any, arg1: number): number;
        remove(arg0: any): any;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2IntFunction;
    }
    type Object2IntFunction_<K> = ((arg0: any)=>number) | Object2IntFunction<K>;
    class PaintingTextureManager extends Internal.TextureAtlasHolder {
        constructor(arg0: Internal.TextureManager_)
        get(arg0: Internal.Motive_): Internal.TextureAtlasSprite;
        getName(): string;
        getBackSprite(): Internal.TextureAtlasSprite;
        get name(): string
        get backSprite(): Internal.TextureAtlasSprite
    }
    type PaintingTextureManager_ = PaintingTextureManager;
    class ShapedRecipeJS extends Internal.RecipeJS {
        constructor()
        create(args: Internal.ListJS_): void;
        noShrink(): this;
        serialize(): void;
        noMirror(): this;
        deserialize(): void;
    }
    type ShapedRecipeJS_ = ShapedRecipeJS;
    class ExistingFileHelper {
        constructor(arg0: Internal.Collection_<Internal.Path_>, arg1: Internal.Set_<string>, arg2: boolean, arg3: string, arg4: Internal.File_)
        getResource(arg0: ResourceLocation_, arg1: Internal.PackType_, arg2: string, arg3: string): Internal.Resource;
        trackGenerated(arg0: ResourceLocation_, arg1: Internal.ExistingFileHelper$IResourceType_): void;
        getResource(arg0: ResourceLocation_, arg1: Internal.PackType_): Internal.Resource;
        exists(arg0: ResourceLocation_, arg1: Internal.PackType_): boolean;
        exists(arg0: ResourceLocation_, arg1: Internal.ExistingFileHelper$IResourceType_): boolean;
        exists(arg0: ResourceLocation_, arg1: Internal.PackType_, arg2: string, arg3: string): boolean;
        trackGenerated(arg0: ResourceLocation_, arg1: Internal.PackType_, arg2: string, arg3: string): void;
        isEnabled(): boolean;
        get enabled(): boolean
    }
    type ExistingFileHelper_ = ExistingFileHelper;
    interface MenuAccess <T> {
        getMenu(): T;
        get menu(): T
    }
    type MenuAccess_<T> = MenuAccess<T>;
    interface PrimitiveIterator <T, T_CONS> extends Internal.Iterator<T> {
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        forEachRemaining(arg0: T_CONS): void;
    }
    type PrimitiveIterator_<T, T_CONS> = PrimitiveIterator<T, T_CONS>;
    abstract class ProjectileWeaponItem extends Internal.Item {
        constructor(arg0: Internal.Item$Properties_)
        getMaxDamage(arg0: Internal.ItemStack_): number;
        elytraFlightTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getShareTag(arg0: Internal.ItemStack_): Internal.CompoundTag;
        isDamageable(arg0: Internal.ItemStack_): boolean;
        isEnderMask(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.EnderMan_): boolean;
        getBurnTime(arg0: Internal.ItemStack_, arg1: Internal.RecipeType_<any>): number;
        onItemUseFirst(arg0: Internal.ItemStack_, arg1: Internal.UseOnContext_): Internal.InteractionResult;
        onUsingTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack_): boolean;
        isCorrectToolForDrops(arg0: Internal.ItemStack_, arg1: Internal.BlockState_): boolean;
        getItemStackLimit(arg0: Internal.ItemStack_): number;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_, arg3: Internal.LivingEntity_): boolean;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_, arg1: Internal.Enchantment_): boolean;
        canWalkOnPowderedSnow(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        hasContainerItem(arg0: Internal.ItemStack_): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        getXpRepairRatio(arg0: Internal.ItemStack_): number;
        getAllSupportedProjectiles(): Internal.Predicate<Internal.ItemStack>;
        isBookEnchantable(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        initCapabilities(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): Internal.ICapabilityProvider;
        onDroppedByPlayer(arg0: Internal.ItemStack_, arg1: Internal.Player_): boolean;
        isDamaged(arg0: Internal.ItemStack_): boolean;
        static getHeldProjectile(arg0: Internal.LivingEntity_, arg1: Internal.Predicate_<Internal.ItemStack_>): Internal.ItemStack;
        getSupportedHeldProjectiles(): Internal.Predicate<Internal.ItemStack>;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack_): number;
        getCreatorModId(arg0: Internal.ItemStack_): string;
        canContinueUsing(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getFoodProperties(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): Internal.FoodProperties;
        getHighlightTip(arg0: Internal.ItemStack_, arg1: Internal.Component_): Internal.Component;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        onLeftClickEntity(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): boolean;
        canEquip(arg0: Internal.ItemStack_, arg1: EquipmentSlot_, arg2: Internal.Entity_): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        canPerformAction(arg0: Internal.ItemStack_, arg1: Internal.ToolAction_): boolean;
        getItemEnchantability(arg0: Internal.ItemStack_): number;
        hasCustomEntity(arg0: Internal.ItemStack_): boolean;
        onEntityItemUpdate(arg0: Internal.ItemStack_, arg1: Internal.ItemEntity_): boolean;
        getDamage(arg0: Internal.ItemStack_): number;
        onArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Player_): void;
        readShareTag(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): void;
        getEquipmentSlot(arg0: Internal.ItemStack_): EquipmentSlot;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getDefaultProjectileRange(): number;
        damageItem(arg0: Internal.ItemStack_, arg1: number, arg2: T, arg3: Internal.Consumer_<T>): number;
        arch$registryName(): ResourceLocation;
        getAttributeModifiers(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        arch$holder(): Internal.Holder<Internal.Item>;
        canElytraFly(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getArmorTexture(arg0: Internal.ItemStack_, arg1: Internal.Entity_, arg2: EquipmentSlot_, arg3: string): string;
        createEntity(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.ItemStack_): Internal.Entity;
        onEntitySwing(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getEntityLifespan(arg0: Internal.ItemStack_, arg1: Internal.Level_): number;
        getEnchantmentValue(): number;
        setDamage(arg0: Internal.ItemStack_, arg1: number): void;
        getSweepHitBox(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): Internal.AABB;
        doesSneakBypassUse(arg0: Internal.ItemStack_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: boolean): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Mob_): void;
        getContainerItem(arg0: Internal.ItemStack_): Internal.ItemStack;
        onBlockStartBreak(arg0: Internal.ItemStack_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>
        get allSupportedProjectiles(): Internal.Predicate<Internal.ItemStack>
        get supportedHeldProjectiles(): Internal.Predicate<Internal.ItemStack>
        get defaultProjectileRange(): number
        get enchantmentValue(): number
        readonly static "ARROW_OR_FIREWORK": any;
        readonly static "ARROW_ONLY": any;
    }
    type ProjectileWeaponItem_ = ProjectileWeaponItem;
    interface PointFreeRule {
        seq(arg0: Internal.List_<Internal.Supplier_<Internal.PointFreeRule_>>): this;
        once(arg0: Internal.PointFreeRule_): this;
        seq(arg0: Internal.PointFreeRule_, arg1: Internal.Supplier_<Internal.PointFreeRule_>): this;
        one(arg0: Internal.PointFreeRule_): this;
        rewriteOrNop(arg0: com.mojang.datafixers.types.Type_<A>, arg1: Internal.PointFree_<A>): Internal.PointFree<A>;
        many(arg0: Internal.PointFreeRule_): this;
        all(arg0: Internal.PointFreeRule_): this;
        orElseStrict(arg0: Internal.PointFreeRule_, arg1: Internal.Supplier_<Internal.PointFreeRule_>): this;
        rewrite(arg0: Internal.View_<A, B>): Internal.Optional<Internal.View<A, B>>;
        everywhere(arg0: Internal.PointFreeRule_): this;
        rewrite(arg0: com.mojang.datafixers.types.Type_<A>, arg1: Internal.PointFree_<A>): Internal.Optional<any>;
        orElse(arg0: Internal.PointFreeRule_, arg1: Internal.PointFreeRule_): this;
        rewriteOrNop(arg0: Internal.View_<A, B>): Internal.View<A, B>;
        nop(): this;
    }
    type PointFreeRule_ = PointFreeRule;
    interface Reference2CharFunction <K> extends it.unimi.dsi.fastutil.Function<K, string>, Internal.ToIntFunction<K> {
        put(arg0: K, arg1: string): string;
        getOrDefault(arg0: any, arg1: string): string;
        removeChar(arg0: any): string;
        getOrDefault(arg0: any, arg1: any): any;
        defaultReturnValue(): string;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Reference2DoubleFunction<K>;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Reference2LongFunction<K>;
        composeReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Reference2CharFunction<T>;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2CharFunction;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Reference2ByteFunction<K>;
        containsKey(arg0: any): boolean;
        getChar(arg0: any): string;
        composeObject(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Object2CharFunction<T>;
        put(arg0: K, arg1: string): string;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2CharFunction;
        defaultReturnValue(arg0: string): void;
        get(arg0: any): string;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2CharFunction;
        put(arg0: any, arg1: any): any;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Reference2IntFunction<K>;
        andThenChar(arg0: Internal.Char2CharFunction_): this;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2CharFunction;
        apply(arg0: K): string;
        andThenObject(arg0: Internal.Char2ObjectFunction_<any>): Internal.Reference2ObjectFunction<K, T>;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Reference2FloatFunction<K>;
        applyAsInt(arg0: K): number;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2CharFunction;
        andThenReference(arg0: Internal.Char2ReferenceFunction_<any>): Internal.Reference2ReferenceFunction<K, T>;
        size(): number;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2CharFunction;
        clear(): void;
        getOrDefault(arg0: any, arg1: string): string;
        remove(arg0: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, string>;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Reference2ShortFunction<K>;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2CharFunction;
    }
    type Reference2CharFunction_<K> = ((arg0: any)=>string) | Reference2CharFunction<K>;
    interface DoubleSupplier {
        getAsDouble(): number;
        get asDouble(): number
    }
    type DoubleSupplier_ = DoubleSupplier | (()=>number);
    abstract class Particle {
        constructor(arg0: Internal.ClientLevel_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number)
        getLifetime(): number;
        toString(): string;
        setLifetime(arg0: number): void;
        getParticleGroup(): Internal.Optional<Internal.ParticleGroup>;
        setPos(arg0: number, arg1: number, arg2: number): void;
        render(arg0: Internal.VertexConsumer_, arg1: Internal.Camera_, arg2: number): void;
        setBoundingBox(arg0: Internal.AABB_): void;
        scale(arg0: number): this;
        tick(): void;
        move(arg0: number, arg1: number, arg2: number): void;
        getRenderType(): Internal.ParticleRenderType;
        remove(): void;
        getBoundingBox(): Internal.AABB;
        setColor(arg0: number, arg1: number, arg2: number): void;
        setParticleSpeed(arg0: number, arg1: number, arg2: number): void;
        isAlive(): boolean;
        shouldCull(): boolean;
        setPower(arg0: number): this;
        get lifetime(): number
        set lifetime(arg0: number)
        get particleGroup(): Internal.Optional<Internal.ParticleGroup>
        set boundingBox(arg0: Internal.AABB_)
        get renderType(): Internal.ParticleRenderType
        get boundingBox(): Internal.AABB
        get alive(): boolean
        set power(arg0: number)
    }
    type Particle_ = Particle;
    class FurnaceMenu extends Internal.AbstractFurnaceMenu {
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Container_, arg3: any_)
        constructor(arg0: number, arg1: Internal.Inventory_)
    }
    type FurnaceMenu_ = FurnaceMenu;
    abstract class FileChannel extends Internal.AbstractInterruptibleChannel implements Internal.SeekableByteChannel, Internal.ScatteringByteChannel, Internal.GatheringByteChannel {
        lock(): Internal.FileLock;
        write(arg0: Internal.ByteBuffer_): number;
        transferFrom(arg0: Internal.ReadableByteChannel_, arg1: number, arg2: number): number;
        read(arg0: Internal.ByteBuffer_): number;
        lock(arg0: number, arg1: number, arg2: boolean): Internal.FileLock;
        position(): number;
        truncate(arg0: number): Internal.SeekableByteChannel;
        tryLock(): Internal.FileLock;
        position(arg0: number): Internal.SeekableByteChannel;
        size(): number;
        read(arg0: Internal.ByteBuffer_[]): number;
        map(arg0: Internal.FileChannel$MapMode_, arg1: number, arg2: number): Internal.MappedByteBuffer;
        read(arg0: Internal.ByteBuffer_, arg1: number): number;
        read(arg0: Internal.ByteBuffer_[], arg1: number, arg2: number): number;
        write(arg0: Internal.ByteBuffer_[], arg1: number, arg2: number): number;
        static open(arg0: Internal.Path_, ...arg1: Internal.OpenOption_[]): Internal.FileChannel;
        static open(arg0: Internal.Path_, arg1: Internal.Set_<any>, ...arg2: any_<any>[]): Internal.FileChannel;
        transferTo(arg0: number, arg1: number, arg2: Internal.WritableByteChannel_): number;
        tryLock(arg0: number, arg1: number, arg2: boolean): Internal.FileLock;
        force(arg0: boolean): void;
        write(arg0: Internal.ByteBuffer_[]): number;
        write(arg0: Internal.ByteBuffer_, arg1: number): number;
    }
    type FileChannel_ = FileChannel;
    interface WorldStem$DataPackConfigSupplier extends Internal.Supplier<Internal.DataPackConfig> {
        loadFromWorld(arg0: Internal.LevelStorageSource$LevelStorageAccess_): this;
    }
    type WorldStem$DataPackConfigSupplier_ = WorldStem$DataPackConfigSupplier;
    interface MapLike <T> {
        get(arg0: string): T;
        forMap(arg0: Internal.Map_<T, T>, arg1: Internal.DynamicOps_<T>): this;
        entries(): Internal.Stream<com.mojang.datafixers.util.Pair<T, T>>;
        get(arg0: T): T;
    }
    type MapLike_<T> = MapLike<T>;
    interface IntBinaryOperator {
        applyAsInt(arg0: number, arg1: number): number;
    }
    type IntBinaryOperator_ = IntBinaryOperator | ((arg0: number, arg1: number)=>number);
    interface MenuConstructor {
        createMenu(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Player_): Internal.AbstractContainerMenu;
    }
    type MenuConstructor_ = MenuConstructor | ((arg0: number, arg1: Internal.Inventory, arg2: Internal.Player)=>Internal.AbstractContainerMenu_);
    interface ItemSteerable {
        travelWithInput(arg0: Vec3_): void;
        travel(arg0: Internal.Mob_, arg1: Internal.ItemBasedSteering_, arg2: Vec3_): boolean;
        boost(): boolean;
        getSteeringSpeed(): number;
        get steeringSpeed(): number
    }
    type ItemSteerable_ = ItemSteerable;
    class ItemFrame extends Internal.HangingEntity {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Direction_)
        constructor(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Direction_)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getRotateItemSound(): Internal.SoundEvent;
        push(arg0: number, arg1: number, arg2: number): void;
        interact(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        kill(): void;
        getSlot(arg0: number): Internal.SlotAccess;
        playPlacementSound(): void;
        getPickRadius(): number;
        getStepHeight(): number;
        getAddItemSound(): Internal.SoundEvent;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getAddEntityPacket(): Internal.Packet<any>;
        canRiderInteract(): boolean;
        getRotation(): number;
        isMultipartEntity(): boolean;
        setItem(arg0: Internal.ItemStack_): void;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRenderAtSqrDistance(arg0: number): boolean;
        shouldRiderSit(): boolean;
        getHeight(): number;
        getBreakSound(): Internal.SoundEvent;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        recreateFromPacket(arg0: Internal.ClientboundAddEntityPacket_): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        getWidth(): number;
        dropItem(arg0: Internal.Entity_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        setRotation(arg0: number): void;
        getItem(): Internal.ItemStack;
        survives(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        move(arg0: Internal.MoverType_, arg1: Vec3_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getPlaceSound(): Internal.SoundEvent;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        getAnalogOutput(): number;
        setItem(arg0: Internal.ItemStack_, arg1: boolean): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        getPickResult(): Internal.ItemStack;
        getRemoveItemSound(): Internal.SoundEvent;
        get rotateItemSound(): Internal.SoundEvent
        get pickRadius(): number
        get stepHeight(): number
        get addItemSound(): Internal.SoundEvent
        get addEntityPacket(): Internal.Packet<any>
        get rotation(): number
        get multipartEntity(): boolean
        set item(arg0: Internal.ItemStack_)
        get height(): number
        get breakSound(): Internal.SoundEvent
        get parts(): Internal.PartEntity<any>[]
        get width(): number
        set rotation(arg0: number)
        get item(): Internal.ItemStack
        get placeSound(): Internal.SoundEvent
        get analogOutput(): number
        get pickResult(): Internal.ItemStack
        get removeItemSound(): Internal.SoundEvent
        readonly static "NUM_ROTATIONS": 8;
    }
    type ItemFrame_ = ItemFrame;
    interface DirectoryStream <T> extends Internal.Closeable, Internal.Iterable<T> {
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<T>;
        iterator(): Internal.Iterator<T>;
    }
    type DirectoryStream_<T> = DirectoryStream<T>;
    class ServerboundPickItemPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getSlot(): number;
        isSkippable(): boolean;
        get slot(): number
        get skippable(): boolean
    }
    type ServerboundPickItemPacket_ = ServerboundPickItemPacket;
    class DataOutputStream extends Internal.FilterOutputStream implements Internal.DataOutput {
        constructor(arg0: Internal.OutputStream_)
        writeBoolean(arg0: boolean): void;
        writeUTF(arg0: string): void;
        writeLong(arg0: number): void;
        writeChars(arg0: string): void;
        writeChar(arg0: number): void;
        writeFloat(arg0: number): void;
        flush(): void;
        write(arg0: number): void;
        writeInt(arg0: number): void;
        writeBytes(arg0: string): void;
        size(): number;
        writeByte(arg0: number): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        writeDouble(arg0: number): void;
        writeShort(arg0: number): void;
    }
    type DataOutputStream_ = DataOutputStream;
    class MemberType extends Internal.Enum<Internal.MemberType> {
        static get(value: any): Internal.MemberType;
        toString(): string;
        static values(): Internal.MemberType[];
        static valueOf(name: string): Internal.MemberType;
        readonly static "OBJECT": Internal.MemberType;
        readonly static "BOOLEAN": Internal.MemberType;
        readonly static "FUNCTION": Internal.MemberType;
        readonly static "STRING": Internal.MemberType;
        readonly static "SYMBOL": Internal.MemberType;
        readonly static "NUMBER": Internal.MemberType;
        readonly static "UNDEFINED": Internal.MemberType;
    }
    type MemberType_ = "string" | "boolean" | MemberType | "symbol" | "function" | "undefined" | "object" | "number";
    class NetherForestVegetationConfig extends Internal.BlockPileConfiguration {
        constructor(arg0: Internal.BlockStateProvider_, arg1: number, arg2: number)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
        readonly "spreadWidth": number;
        readonly "spreadHeight": number;
    }
    type NetherForestVegetationConfig_ = NetherForestVegetationConfig;
    class ClientRecipeBook extends Internal.RecipeBook {
        constructor()
        getCollections(): Internal.List<Internal.RecipeCollection>;
        getCollection(arg0: Internal.RecipeBookCategories_): Internal.List<Internal.RecipeCollection>;
        setupCollections(arg0: Internal.Iterable_<Internal.Recipe_<any>>): void;
        get collections(): Internal.List<Internal.RecipeCollection>
        set upCollections(arg0: Internal.Iterable_<Internal.Recipe_<any>>)
    }
    type ClientRecipeBook_ = ClientRecipeBook;
    class BlockPileConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.BlockStateProvider_)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "stateProvider": Internal.BlockStateProvider;
        readonly static "CODEC": any;
    }
    type BlockPileConfiguration_ = BlockPileConfiguration;
    class RenderNameplateEvent extends Internal.EntityEvent {
        constructor()
        constructor(arg0: Internal.Entity_, arg1: Internal.Component_, arg2: Internal.EntityRenderer_<any>, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number, arg6: number)
        hasResult(): boolean;
        getPartialTick(): number;
        getPoseStack(): Internal.PoseStack;
        getOriginalContent(): Internal.Component;
        getEntityRenderer(): Internal.EntityRenderer<any>;
        getListenerList(): Internal.ListenerList;
        getPackedLight(): number;
        getMultiBufferSource(): Internal.MultiBufferSource;
        setContent(arg0: Internal.Component_): void;
        getContent(): Internal.Component;
        get partialTick(): number
        get poseStack(): Internal.PoseStack
        get originalContent(): Internal.Component
        get entityRenderer(): Internal.EntityRenderer<any>
        get listenerList(): Internal.ListenerList
        get packedLight(): number
        get multiBufferSource(): Internal.MultiBufferSource
        set content(arg0: Internal.Component_)
        get content(): Internal.Component
    }
    type RenderNameplateEvent_ = RenderNameplateEvent;
    class Screen$NarratableSearchResult {
        constructor(arg0: Internal.NarratableEntry_, arg1: number, arg2: Internal.NarratableEntry$NarrationPriority_)
        readonly "priority": Internal.NarratableEntry$NarrationPriority;
        readonly "entry": Internal.NarratableEntry;
        readonly "index": number;
    }
    type Screen$NarratableSearchResult_ = Screen$NarratableSearchResult;
    abstract class IngredientAction extends Internal.IngredientActionFilter {
        constructor()
        static getRemaining(container: Internal.CraftingContainer_, index: number, ingredientActions: Internal.List_<Internal.IngredientAction_>): Internal.ItemStack;
        getType(): string;
        transform(arg0: Internal.ItemStack_, arg1: number, arg2: Internal.CraftingContainer_): Internal.ItemStack;
        toJson(json: Internal.JsonObject_): void;
        static parseList(json: Internal.JsonElement_): Internal.List<Internal.IngredientAction>;
        toJson(): Internal.JsonObject;
        static writeList(buf: Internal.FriendlyByteBuf_, list: Internal.List_<Internal.IngredientAction_>): void;
        static readList(buf: Internal.FriendlyByteBuf_): Internal.List<Internal.IngredientAction>;
        get type(): string
        readonly static "FACTORY_MAP": {"damage": any, "custom": any, "keep": any, "replace": any};
    }
    type IngredientAction_ = IngredientAction;
    class WeightedRandomList <E> {
        static create(...arg0: E[]): Internal.WeightedRandomList<E>;
        static create(): Internal.WeightedRandomList<E>;
        unwrap(): Internal.List<E>;
        static create(arg0: Internal.List_<E>): Internal.WeightedRandomList<E>;
        isEmpty(): boolean;
        getRandom(arg0: Internal.Random_): Internal.Optional<E>;
        static codec(arg0: Internal.Codec_<E>): Internal.Codec<Internal.WeightedRandomList<E>>;
        get empty(): boolean
    }
    type WeightedRandomList_<E> = WeightedRandomList<E>;
    interface IntProviderType <P> {
        codec(): Internal.Codec<P>;
        register(arg0: string, arg1: Internal.Codec_<P>): this;
        readonly static "BIASED_TO_BOTTOM": any;
        readonly static "UNIFORM": any;
        readonly static "CLAMPED": any;
        readonly static "CLAMPED_NORMAL": any;
        readonly static "WEIGHTED_LIST": any;
        readonly static "CONSTANT": any;
    }
    type IntProviderType_<P> = IntProviderType<P> | Special.IntProviderType;
    class NoiseRouter extends Internal.Record {
        constructor(arg0: Internal.DensityFunction_, arg1: Internal.DensityFunction_, arg2: Internal.DensityFunction_, arg3: Internal.DensityFunction_, arg4: Internal.PositionalRandomFactory_, arg5: Internal.PositionalRandomFactory_, arg6: Internal.DensityFunction_, arg7: Internal.DensityFunction_, arg8: Internal.DensityFunction_, arg9: Internal.DensityFunction_, arg10: Internal.DensityFunction_, arg11: Internal.DensityFunction_, arg12: Internal.DensityFunction_, arg13: Internal.DensityFunction_, arg14: Internal.DensityFunction_, arg15: Internal.DensityFunction_, arg16: Internal.DensityFunction_, arg17: Internal.List_<Internal.Climate$ParameterPoint_>)
        barrierNoise(): Internal.DensityFunction;
        continents(): Internal.DensityFunction;
        toString(): string;
        veinToggle(): Internal.DensityFunction;
        finalDensity(): Internal.DensityFunction;
        veinGap(): Internal.DensityFunction;
        oreVeinsPositionalRandomFactory(): Internal.PositionalRandomFactory;
        initialDensityWithoutJaggedness(): Internal.DensityFunction;
        aquiferPositionalRandomFactory(): Internal.PositionalRandomFactory;
        ridges(): Internal.DensityFunction;
        fluidLevelSpreadNoise(): Internal.DensityFunction;
        lavaNoise(): Internal.DensityFunction;
        spawnTarget(): Internal.List<Internal.Climate$ParameterPoint>;
        hashCode(): number;
        temperature(): Internal.DensityFunction;
        veinRidged(): Internal.DensityFunction;
        humidity(): Internal.DensityFunction;
        equals(arg0: any): boolean;
        depth(): Internal.DensityFunction;
        fluidLevelFloodednessNoise(): Internal.DensityFunction;
        erosion(): Internal.DensityFunction;
    }
    type NoiseRouter_ = NoiseRouter;
    class TickEvent$WorldTickEvent extends Internal.TickEvent {
        constructor()
        constructor(arg0: Internal.LogicalSide_, arg1: Internal.TickEvent$Phase_, arg2: Internal.Level_)
        constructor(arg0: Internal.LogicalSide_, arg1: Internal.TickEvent$Phase_, arg2: Internal.Level_, arg3: Internal.BooleanSupplier_)
        getListenerList(): Internal.ListenerList;
        haveTime(): boolean;
        get listenerList(): Internal.ListenerList
        readonly "world": Internal.Level;
    }
    type TickEvent$WorldTickEvent_ = TickEvent$WorldTickEvent;
    interface Int2ByteFunction extends Internal.IntUnaryOperator, it.unimi.dsi.fastutil.Function<number, number> {
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Int2IntFunction;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2ByteFunction;
        getOrDefault(arg0: any, arg1: any): any;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Int2FloatFunction;
        andThenByte(arg0: Internal.Byte2ByteFunction_): this;
        containsKey(arg0: number): boolean;
        put(arg0: number, arg1: number): number;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeObject(arg0: Internal.Object2IntFunction_<any>): Internal.Object2ByteFunction<T>;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Int2DoubleFunction;
        getOrDefault(arg0: number, arg1: number): number;
        composeReference(arg0: Internal.Reference2IntFunction_<any>): Internal.Reference2ByteFunction<T>;
        containsKey(arg0: any): boolean;
        defaultReturnValue(arg0: number): void;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Int2CharFunction;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2ByteFunction;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        applyAsInt(arg0: number): number;
        put(arg0: any, arg1: any): any;
        defaultReturnValue(): number;
        apply(arg0: number): number;
        get(arg0: any): number;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2ByteFunction;
        andThenReference(arg0: Internal.Byte2ReferenceFunction_<any>): Internal.Int2ReferenceFunction<T>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeInt(arg0: Internal.Int2IntFunction_): this;
        get(arg0: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Int2ShortFunction;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        andThenObject(arg0: Internal.Byte2ObjectFunction_<any>): Internal.Int2ObjectFunction<T>;
        size(): number;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Int2LongFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2ByteFunction;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2ByteFunction;
        remove(arg0: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2ByteFunction;
    }
    type Int2ByteFunction_ = ((arg0: number)=>number) | Int2ByteFunction;
    class ClientSuggestionProvider implements Internal.SharedSuggestionProvider {
        constructor(arg0: Internal.ClientPacketListener_, arg1: Internal.Minecraft_)
        suggestRegistryElements(arg0: Internal.Registry_<any>, arg1: Internal.SharedSuggestionProvider$ElementSuggestionType_, arg2: Internal.SuggestionsBuilder_): void;
        getSelectedEntities(): Internal.Collection<string>;
        customSuggestion(arg0: Internal.CommandContext_<any>): Internal.CompletableFuture<Internal.Suggestions>;
        getAllTeams(): Internal.Collection<string>;
        getAvailableSoundEvents(): Internal.Collection<ResourceLocation>;
        registryAccess(): Internal.RegistryAccess;
        getRelevantCoordinates(): Internal.Collection<Internal.SharedSuggestionProvider$TextCoordinates>;
        getAbsoluteCoordinates(): Internal.Collection<Internal.SharedSuggestionProvider$TextCoordinates>;
        hasPermission(arg0: number): boolean;
        getRecipeNames(): Internal.Stream<ResourceLocation>;
        completeCustomSuggestions(arg0: number, arg1: Internal.Suggestions_): void;
        suggestRegistryElements(arg0: Internal.ResourceKey_<any>, arg1: Internal.SharedSuggestionProvider$ElementSuggestionType_, arg2: Internal.SuggestionsBuilder_, arg3: Internal.CommandContext_<any>): Internal.CompletableFuture<Internal.Suggestions>;
        levels(): Internal.Set<Internal.ResourceKey<Internal.Level>>;
        getOnlinePlayerNames(): Internal.Collection<string>;
        get selectedEntities(): Internal.Collection<string>
        get allTeams(): Internal.Collection<string>
        get availableSoundEvents(): Internal.Collection<ResourceLocation>
        get relevantCoordinates(): Internal.Collection<Internal.SharedSuggestionProvider$TextCoordinates>
        get absoluteCoordinates(): Internal.Collection<Internal.SharedSuggestionProvider$TextCoordinates>
        get recipeNames(): Internal.Stream<ResourceLocation>
        get onlinePlayerNames(): Internal.Collection<string>
    }
    type ClientSuggestionProvider_ = ClientSuggestionProvider;
    class SimpleDateFormat extends Internal.DateFormat {
        constructor()
        constructor(arg0: string, arg1: Internal.Locale_)
        constructor(arg0: string, arg1: Internal.DateFormatSymbols_)
        constructor(arg0: string)
        clone(): any;
        toPattern(): string;
        setDateFormatSymbols(arg0: Internal.DateFormatSymbols_): void;
        toLocalizedPattern(): string;
        get2DigitYearStart(): Internal.Date;
        set2DigitYearStart(arg0: Internal.Date_): void;
        hashCode(): number;
        parse(arg0: string, arg1: Internal.ParsePosition_): Internal.Date;
        formatToCharacterIterator(arg0: any): Internal.AttributedCharacterIterator;
        applyPattern(arg0: string): void;
        applyLocalizedPattern(arg0: string): void;
        format(arg0: Internal.Date_, arg1: Internal.StringBuffer_, arg2: Internal.FieldPosition_): Internal.StringBuffer;
        equals(arg0: any): boolean;
        getDateFormatSymbols(): Internal.DateFormatSymbols;
        set dateFormatSymbols(arg0: Internal.DateFormatSymbols_)
        get dateFormatSymbols(): Internal.DateFormatSymbols
    }
    type SimpleDateFormat_ = SimpleDateFormat;
    interface Char2LongFunction extends it.unimi.dsi.fastutil.Function<string, number>, Internal.IntToLongFunction {
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2LongFunction;
        put(arg0: string, arg1: number): number;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Char2DoubleFunction;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Char2CharFunction;
        getOrDefault(arg0: any, arg1: any): any;
        andThenReference(arg0: Internal.Long2ReferenceFunction_<any>): Internal.Char2ReferenceFunction<T>;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Char2IntFunction;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2LongFunction;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2LongFunction;
        get(arg0: string): number;
        put(arg0: string, arg1: number): number;
        containsKey(arg0: string): boolean;
        get(arg0: any): number;
        containsKey(arg0: any): boolean;
        getOrDefault(arg0: string, arg1: number): number;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2LongFunction;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Char2FloatFunction;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Char2ByteFunction;
        put(arg0: any, arg1: any): any;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2LongFunction;
        composeObject(arg0: Internal.Object2CharFunction_<any>): Internal.Object2LongFunction<T>;
        defaultReturnValue(): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        getOrDefault(arg0: any, arg1: number): number;
        remove(arg0: string): number;
        apply(arg0: string): number;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Char2ShortFunction;
        composeReference(arg0: Internal.Reference2CharFunction_<any>): Internal.Reference2LongFunction<T>;
        size(): number;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2LongFunction;
        composeChar(arg0: Internal.Char2CharFunction_): this;
        andThenLong(arg0: Internal.Long2LongFunction_): this;
        clear(): void;
        applyAsLong(arg0: number): number;
        remove(arg0: any): any;
        andThenObject(arg0: Internal.Long2ObjectFunction_<any>): Internal.Char2ObjectFunction<T>;
        defaultReturnValue(arg0: number): void;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<string, T>;
    }
    type Char2LongFunction_ = Char2LongFunction | ((arg0: string)=>number);
    interface InjectedFluidExtension extends Internal.InjectedRegistryEntryExtension<Internal.Fluid> {
        arch$holder(): Internal.Holder<Internal.Fluid>;
        arch$registryName(): ResourceLocation;
    }
    type InjectedFluidExtension_ = InjectedFluidExtension;
    class ClientboundSetBorderCenterPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.WorldBorder_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getNewCenterX(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getNewCenterZ(): number;
        isSkippable(): boolean;
        get newCenterX(): number
        get newCenterZ(): number
        get skippable(): boolean
    }
    type ClientboundSetBorderCenterPacket_ = ClientboundSetBorderCenterPacket;
    class LootContext {
        getLootTable(arg0: ResourceLocation_): Internal.LootTable;
        removeVisitedCondition(arg0: Internal.LootItemCondition_): void;
        getParamOrNull(arg0: Internal.LootContextParam_<T>): T;
        getLootingModifier(): number;
        addVisitedTable(arg0: Internal.LootTable_): boolean;
        getLevel(): Internal.ServerLevel;
        getParam(arg0: Internal.LootContextParam_<T>): T;
        getRandom(): Internal.Random;
        setQueriedLootTableId(arg0: ResourceLocation_): void;
        getQueriedLootTableId(): ResourceLocation;
        getCondition(arg0: ResourceLocation_): Internal.LootItemCondition;
        getLuck(): number;
        hasParam(arg0: Internal.LootContextParam_<any>): boolean;
        addDynamicDrops(arg0: ResourceLocation_, arg1: Internal.Consumer_<Internal.ItemStack_>): void;
        removeVisitedTable(arg0: Internal.LootTable_): void;
        addVisitedCondition(arg0: Internal.LootItemCondition_): boolean;
        get lootingModifier(): number
        get level(): Internal.ServerLevel
        get random(): Internal.Random
        set queriedLootTableId(arg0: ResourceLocation_)
        get queriedLootTableId(): ResourceLocation
        get luck(): number
    }
    type LootContext_ = LootContext;
    class ClientboundPingPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        getId(): number;
        get skippable(): boolean
        get id(): number
    }
    type ClientboundPingPacket_ = ClientboundPingPacket;
    class ShaderInstance implements Internal.Shader, Internal.AutoCloseable {
        constructor(arg0: Internal.ResourceProvider_, arg1: ResourceLocation_, arg2: Internal.VertexFormat_)
        constructor(arg0: Internal.ResourceProvider_, arg1: string, arg2: Internal.VertexFormat_)
        markDirty(): void;
        static parseBlendNode(arg0: Internal.JsonObject_): Internal.BlendMode;
        attachToProgram(): void;
        getVertexProgram(): Internal.Program;
        setSampler(arg0: string, arg1: any): void;
        apply(): void;
        getFragmentProgram(): Internal.Program;
        getUniform(arg0: string): Internal.Uniform;
        getVertexFormat(): Internal.VertexFormat;
        getName(): string;
        clear(): void;
        close(): void;
        safeGetUniform(arg0: string): Internal.AbstractUniform;
        getId(): number;
        get vertexProgram(): Internal.Program
        get fragmentProgram(): Internal.Program
        get vertexFormat(): Internal.VertexFormat
        get name(): string
        get id(): number
        readonly "LINE_WIDTH": Internal.Uniform;
        readonly "SCREEN_SIZE": Internal.Uniform;
        readonly "TEXTURE_MATRIX": Internal.Uniform;
        readonly "COLOR_MODULATOR": Internal.Uniform;
        readonly "LIGHT1_DIRECTION": Internal.Uniform;
        readonly "FOG_COLOR": Internal.Uniform;
        readonly "INVERSE_VIEW_ROTATION_MATRIX": Internal.Uniform;
        readonly "LIGHT0_DIRECTION": Internal.Uniform;
        readonly "PROJECTION_MATRIX": Internal.Uniform;
        readonly "FOG_START": Internal.Uniform;
        readonly "FOG_END": Internal.Uniform;
        readonly "CHUNK_OFFSET": Internal.Uniform;
        readonly "FOG_SHAPE": Internal.Uniform;
        readonly "MODEL_VIEW_MATRIX": Internal.Uniform;
        readonly "GAME_TIME": Internal.Uniform;
    }
    type ShaderInstance_ = ShaderInstance;
    interface Map$Entry <K, V> {
        getKey(): K;
        comparingByValue(): Internal.Comparator<Internal.Map$Entry<K, V>>;
        hashCode(): number;
        copyOf(arg0: Internal.Map$Entry_<any, any>): this;
        getValue(): V;
        comparingByValue(arg0: Internal.Comparator_<any>): Internal.Comparator<Internal.Map$Entry<K, V>>;
        comparingByKey(): Internal.Comparator<Internal.Map$Entry<K, V>>;
        comparingByKey(arg0: Internal.Comparator_<any>): Internal.Comparator<Internal.Map$Entry<K, V>>;
        equals(arg0: any): boolean;
        setValue(arg0: V): V;
        get key(): K
        get value(): V
        set value(arg0: V)
    }
    type Map$Entry_<K, V> = Map$Entry<K, V>;
    interface IntToDoubleFunction {
        applyAsDouble(arg0: number): number;
    }
    type IntToDoubleFunction_ = ((arg0: number)=>number) | IntToDoubleFunction;
    class CubeListBuilder {
        constructor()
        addBox(arg0: string, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number): this;
        addBox(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): this;
        static create(): Internal.CubeListBuilder;
        getCubes(): Internal.List<Internal.CubeDefinition>;
        texOffs(arg0: number, arg1: number): this;
        addBox(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.CubeDeformation_, arg7: number, arg8: number): this;
        mirror(): this;
        mirror(arg0: boolean): this;
        addBox(arg0: string, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.CubeDeformation_, arg8: number, arg9: number): this;
        addBox(arg0: string, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): this;
        addBox(arg0: string, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.CubeDeformation_): this;
        addBox(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.CubeDeformation_): this;
        addBox(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: boolean): this;
        get cubes(): Internal.List<Internal.CubeDefinition>
    }
    type CubeListBuilder_ = CubeListBuilder;
    class ClientboundSoundEntityPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.SoundEvent_, arg1: Internal.SoundSource_, arg2: Internal.Entity_, arg3: number, arg4: number)
        handle(arg0: Internal.PacketListener_): void;
        getVolume(): number;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getSource(): Internal.SoundSource;
        getPitch(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getSound(): Internal.SoundEvent;
        isSkippable(): boolean;
        getId(): number;
        get volume(): number
        get source(): Internal.SoundSource
        get pitch(): number
        get sound(): Internal.SoundEvent
        get skippable(): boolean
        get id(): number
    }
    type ClientboundSoundEntityPacket_ = ClientboundSoundEntityPacket;
    interface Decoder$Simple <A> {
        decoder(): Internal.Decoder<A>;
        decode(arg0: Internal.Dynamic_<T>): Internal.DataResult<A>;
    }
    type Decoder$Simple_<A> = Decoder$Simple<A>;
    class DebugRenderer {
        constructor(arg0: Internal.Minecraft_)
        static renderFloatingText(arg0: string, arg1: number, arg2: number, arg3: number, arg4: number): void;
        static renderFilledBox(arg0: BlockPos_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        static renderFloatingText(arg0: string, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        static renderFilledBox(arg0: Internal.AABB_, arg1: number, arg2: number, arg3: number, arg4: number): void;
        switchRenderChunkborder(): boolean;
        static renderFilledBox(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number): void;
        static renderFloatingText(arg0: string, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: boolean, arg7: number, arg8: boolean): void;
        clear(): void;
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource$BufferSource_, arg2: number, arg3: number, arg4: number): void;
        static renderFilledBox(arg0: BlockPos_, arg1: BlockPos_, arg2: number, arg3: number, arg4: number, arg5: number): void;
        static renderFloatingText(arg0: string, arg1: number, arg2: number, arg3: number, arg4: number): void;
        static getTargetedEntity(arg0: Internal.Entity_, arg1: number): Internal.Optional<Internal.Entity>;
        readonly "collisionBoxRenderer": Internal.DebugRenderer$SimpleDebugRenderer;
        readonly "villageSectionsDebugRenderer": Internal.VillageSectionsDebugRenderer;
        readonly "worldGenAttemptRenderer": Internal.DebugRenderer$SimpleDebugRenderer;
        readonly "pathfindingRenderer": Internal.PathfindingRenderer;
        readonly "goalSelectorRenderer": Internal.GoalSelectorDebugRenderer;
        readonly "heightMapRenderer": Internal.DebugRenderer$SimpleDebugRenderer;
        readonly "lightDebugRenderer": Internal.DebugRenderer$SimpleDebugRenderer;
        readonly "gameTestDebugRenderer": Internal.GameTestDebugRenderer;
        readonly "neighborsUpdateRenderer": Internal.DebugRenderer$SimpleDebugRenderer;
        readonly "brainDebugRenderer": Internal.BrainDebugRenderer;
        readonly "beeDebugRenderer": Internal.BeeDebugRenderer;
        readonly "chunkRenderer": Internal.DebugRenderer$SimpleDebugRenderer;
        readonly "solidFaceRenderer": Internal.DebugRenderer$SimpleDebugRenderer;
        readonly "chunkBorderRenderer": Internal.DebugRenderer$SimpleDebugRenderer;
        readonly "structureRenderer": Internal.StructureRenderer;
        readonly "raidDebugRenderer": Internal.RaidDebugRenderer;
        readonly "gameEventListenerRenderer": Internal.GameEventListenerRenderer;
        readonly "waterDebugRenderer": Internal.DebugRenderer$SimpleDebugRenderer;
    }
    type DebugRenderer_ = DebugRenderer;
    interface TemporalAdjuster {
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
    }
    type TemporalAdjuster_ = ((arg0: Internal.Temporal)=>Internal.Temporal_) | TemporalAdjuster;
    class FrameTimer {
        constructor()
        getLog(): number[];
        scaleSampleTo(arg0: number, arg1: number, arg2: number): number;
        getAverageDuration(arg0: number): number;
        logFrameDuration(arg0: number): void;
        scaleAverageDurationTo(arg0: number, arg1: number): number;
        getLogStart(): number;
        getLogEnd(): number;
        wrapIndex(arg0: number): number;
        get log(): number[]
        get logStart(): number
        get logEnd(): number
        readonly static "LOGGING_LENGTH": 240;
    }
    type FrameTimer_ = FrameTimer;
    class ToastComponent extends Internal.GuiComponent {
        constructor(arg0: Internal.Minecraft_)
        addToast(arg0: Internal.Toast_): void;
        getToast(arg0: Internal.Class_<any>, arg1: any): T;
        getMinecraft(): Internal.Minecraft;
        clear(): void;
        render(arg0: Internal.PoseStack_): void;
        get minecraft(): Internal.Minecraft
    }
    type ToastComponent_ = ToastComponent;
    interface Registrar <T> extends Internal.Iterable<T> {
        getKey(arg0: T): Internal.Optional<Internal.ResourceKey<T>>;
        getIds(): Internal.Set<ResourceLocation>;
        getRawId(arg0: T): number;
        getId(arg0: T): ResourceLocation;
        contains(arg0: ResourceLocation_): boolean;
        forEach(arg0: Internal.Consumer_<any>): void;
        wrap(obj: R): Internal.RegistrySupplier<R>;
        spliterator(): Internal.Spliterator<T>;
        get(arg0: ResourceLocation_): T;
        containsValue(arg0: T): boolean;
        delegate(arg0: ResourceLocation_): Internal.RegistrySupplier<T>;
        register(arg0: ResourceLocation_, arg1: Internal.Supplier_<E>): Internal.RegistrySupplier<E>;
        byRawId(arg0: number): T;
        entrySet(): Internal.Set<Internal.Map$Entry<Internal.ResourceKey<T>, T>>;
        listen(arg0: ResourceLocation_, arg1: Internal.Consumer_<T>): void;
        key(): Internal.ResourceKey<any>;
        listen(supplier: Internal.RegistrySupplier_<R>, callback: Internal.Consumer_<R>): void;
        get ids(): Internal.Set<ResourceLocation>
    }
    type Registrar_<T> = Registrar<T>;
    class PrimedTnt extends Internal.Entity {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number, arg4: Internal.LivingEntity_)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        setFuse(arg0: number): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        isPickable(): boolean;
        tick(): void;
        asKJS(): Internal.EntityJS;
        getFuse(): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getAddEntityPacket(): Internal.Packet<any>;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getOwner(): Internal.LivingEntity;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        set fuse(arg0: number)
        get stepHeight(): number
        get pickable(): boolean
        get fuse(): number
        get addEntityPacket(): Internal.Packet<any>
        get multipartEntity(): boolean
        get owner(): Internal.LivingEntity
        get parts(): Internal.PartEntity<any>[]
    }
    type PrimedTnt_ = PrimedTnt;
    class LootTables extends Internal.SimpleJsonResourceReloadListener implements Internal.LootTablesKJS {
        constructor(arg0: Internal.PredicateManager_)
        getIds(): Internal.Set<ResourceLocation>;
        static validate(arg0: Internal.ValidationContext_, arg1: ResourceLocation_, arg2: Internal.LootTable_): void;
        get(arg0: ResourceLocation_): Internal.LootTable;
        getName(): string;
        static serialize(arg0: Internal.LootTable_): Internal.JsonElement;
        applyKJS0(map: Internal.Map_<ResourceLocation_, Internal.JsonElement_>, action: Internal.BiConsumer_<ResourceLocation_, Internal.JsonElement_>): void;
        get ids(): Internal.Set<ResourceLocation>
        get name(): string
    }
    type LootTables_ = LootTables;
    class CallbackInfo implements Internal.Cancellable {
        constructor(arg0: string, arg1: boolean)
        static getCallInfoClassName(arg0: org.objectweb.asm.Type_): string;
        toString(): string;
        isCancellable(): boolean;
        cancel(): void;
        getId(): string;
        isCancelled(): boolean;
        get cancellable(): boolean
        get id(): string
        get cancelled(): boolean
    }
    type CallbackInfo_ = CallbackInfo;
    class ClientPlayerNetworkEvent$LoggedOutEvent extends Internal.ClientPlayerNetworkEvent {
        constructor()
        constructor(arg0: Internal.MultiPlayerGameMode_, arg1: Internal.LocalPlayer_, arg2: Internal.Connection_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ClientPlayerNetworkEvent$LoggedOutEvent_ = ClientPlayerNetworkEvent$LoggedOutEvent;
    class ChatFormatting extends Internal.Enum<Internal.ChatFormatting> implements Internal.Color {
        static getById(arg0: number): Internal.ChatFormatting;
        static values(): Internal.ChatFormatting[];
        getChar(): string;
        toString(): string;
        static getByName(arg0: string): Internal.ChatFormatting;
        getArgbJS(): number;
        specialEquals(o: any, shallow: boolean): boolean;
        static getByCode(arg0: string): Internal.ChatFormatting;
        static stripFormatting(arg0: string): string;
        getRgbJS(): number;
        static valueOf(arg0: string): Internal.ChatFormatting;
        getSerializeJS(): string;
        isFormat(): boolean;
        getName(): string;
        createTextColorJS(): Internal.TextColor;
        isColor(): boolean;
        getColor(): number;
        getHexJS(): string;
        getFireworkColorJS(): number;
        static getNames(arg0: boolean, arg1: boolean): Internal.Collection<string>;
        getId(): number;
        get char(): string
        get argbJS(): number
        get rgbJS(): number
        get serializeJS(): string
        get format(): boolean
        get name(): string
        get color(): boolean
        get color(): number
        get hexJS(): string
        get fireworkColorJS(): number
        get id(): number
        readonly static "AQUA": Internal.ChatFormatting;
        readonly static "OBFUSCATED": Internal.ChatFormatting;
        readonly static "RED": Internal.ChatFormatting;
        readonly static "LIGHT_PURPLE": Internal.ChatFormatting;
        readonly static "GRAY": Internal.ChatFormatting;
        readonly static "GOLD": Internal.ChatFormatting;
        readonly static "DARK_RED": Internal.ChatFormatting;
        readonly static "GREEN": Internal.ChatFormatting;
        readonly static "BLUE": Internal.ChatFormatting;
        readonly static "BOLD": Internal.ChatFormatting;
        readonly static "DARK_GREEN": Internal.ChatFormatting;
        readonly static "DARK_AQUA": Internal.ChatFormatting;
        readonly static "DARK_PURPLE": Internal.ChatFormatting;
        readonly static "YELLOW": Internal.ChatFormatting;
        readonly static "WHITE": Internal.ChatFormatting;
        readonly static "ITALIC": Internal.ChatFormatting;
        readonly static "UNDERLINE": Internal.ChatFormatting;
        readonly static "BLACK": Internal.ChatFormatting;
        readonly static "DARK_GRAY": Internal.ChatFormatting;
        readonly static "STRIKETHROUGH": Internal.ChatFormatting;
        readonly static "RESET": Internal.ChatFormatting;
        readonly static "DARK_BLUE": Internal.ChatFormatting;
        readonly static "PREFIX_CODE": "";
    }
    type ChatFormatting_ = "italic" | "dark_red" | "dark_gray" | "gold" | "bold" | "dark_green" | "red" | "obfuscated" | "black" | "green" | "dark_purple" | "dark_blue" | "yellow" | "aqua" | "white" | "reset" | "underline" | "gray" | "dark_aqua" | ChatFormatting | "blue" | "strikethrough" | "light_purple";
    abstract class ImmutableMultisetGwtSerializationDependencies <E> extends Internal.ImmutableCollection<E> {
        stream(): Internal.Stream<E>;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        forEach(arg0: Internal.Consumer_<any>): void;
        parallelStream(): Internal.Stream<E>;
    }
    type ImmutableMultisetGwtSerializationDependencies_<E> = ImmutableMultisetGwtSerializationDependencies<E>;
    class Products$P1 <F, T1> {
        constructor(arg0: Internal.App_<F, T1>)
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function_<T1, R>): Internal.App<F, R>;
        t1(): Internal.App<F, T1>;
        and(arg0: Internal.Products$P2_<F, T2, T3>): Internal.Products$P3<F, T1, T2, T3>;
        and(arg0: Internal.Products$P5_<F, T2, T3, T4, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        and(arg0: Internal.App_<F, T2>): Internal.Products$P2<F, T1, T2>;
        and(arg0: Internal.Products$P7_<F, T2, T3, T4, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        and(arg0: Internal.Products$P3_<F, T2, T3, T4>): Internal.Products$P4<F, T1, T2, T3, T4>;
        and(arg0: Internal.Products$P6_<F, T2, T3, T4, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function_<T1, R>>): Internal.App<F, R>;
        and(arg0: Internal.Products$P4_<F, T2, T3, T4, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>;
    }
    type Products$P1_<F, T1> = Products$P1<F, T1>;
    class StatType <T> extends Internal.ForgeRegistryEntry<Internal.StatType<any>> implements Internal.Iterable<Internal.Stat<T>> {
        constructor(arg0: Internal.Registry_<T>)
        contains(arg0: T): boolean;
        getDisplayName(): Internal.Component;
        getRegistry(): Internal.Registry<T>;
        spliterator(): Internal.Spliterator<Internal.Stat<T>>;
        iterator(): Internal.Iterator<Internal.Stat<T>>;
        forEach(arg0: Internal.Consumer_<any>): void;
        get(arg0: T): Internal.Stat<T>;
        getTranslationKey(): string;
        get(arg0: T, arg1: Internal.StatFormatter_): Internal.Stat<T>;
        get displayName(): Internal.Component
        get registry(): Internal.Registry<T>
        get translationKey(): string
    }
    type StatType_<T> = Special.StatType | StatType<T>;
    class Products$P3 <F, T1, T2, T3> {
        constructor(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>)
        and(arg0: Internal.App_<F, T4>): Internal.Products$P4<F, T1, T2, T3, T4>;
        and(arg0: Internal.Products$P4_<F, T4, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        and(arg0: Internal.Products$P2_<F, T4, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>;
        t1(): Internal.App<F, T1>;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        and(arg0: Internal.Products$P5_<F, T4, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function3_<T1, T2, T3, R>): Internal.App<F, R>;
        and(arg0: Internal.Products$P3_<F, T4, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function3_<T1, T2, T3, R>>): Internal.App<F, R>;
    }
    type Products$P3_<F, T1, T2, T3> = Products$P3<F, T1, T2, T3>;
    class Input {
        constructor()
        getMoveVector(): Internal.Vec2;
        hasForwardImpulse(): boolean;
        tick(arg0: boolean): void;
        get moveVector(): Internal.Vec2
        "up": boolean;
        "forwardImpulse": number;
        "down": boolean;
        "shiftKeyDown": boolean;
        "right": boolean;
        "jumping": boolean;
        "left": boolean;
        "leftImpulse": number;
    }
    type Input_ = Input;
    class Products$P2 <F, T1, T2> {
        constructor(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>)
        and(arg0: Internal.Products$P4_<F, T3, T4, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        t1(): Internal.App<F, T1>;
        t2(): Internal.App<F, T2>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.BiFunction_<T1, T2, R>>): Internal.App<F, R>;
        and(arg0: Internal.Products$P5_<F, T3, T4, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        and(arg0: Internal.Products$P3_<F, T3, T4, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.BiFunction_<T1, T2, R>): Internal.App<F, R>;
        and(arg0: Internal.Products$P2_<F, T3, T4>): Internal.Products$P4<F, T1, T2, T3, T4>;
        and(arg0: Internal.Products$P6_<F, T3, T4, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        and(arg0: Internal.App_<F, T3>): Internal.Products$P3<F, T1, T2, T3>;
    }
    type Products$P2_<F, T1, T2> = Products$P2<F, T1, T2>;
    interface WritableLevelData extends Internal.LevelData {
        setXSpawn(arg0: number): void;
        setZSpawn(arg0: number): void;
        setYSpawn(arg0: number): void;
        fillCrashReportCategory(arg0: Internal.CrashReportCategory_, arg1: Internal.LevelHeightAccessor_): void;
        setSpawnAngle(arg0: number): void;
        setSpawn(arg0: BlockPos_, arg1: number): void;
        set XSpawn(arg0: number)
        set ZSpawn(arg0: number)
        set YSpawn(arg0: number)
        set spawnAngle(arg0: number)
    }
    type WritableLevelData_ = WritableLevelData;
    class ServerBossEvent extends Internal.BossEvent {
        constructor(arg0: Internal.Component_, arg1: Internal.BossEvent$BossBarColor_, arg2: Internal.BossEvent$BossBarOverlay_)
        setCreateWorldFog(arg0: boolean): Internal.BossEvent;
        setPlayBossMusic(arg0: boolean): Internal.BossEvent;
        setOverlay(arg0: Internal.BossEvent$BossBarOverlay_): void;
        getPlayers(): Internal.Collection<Internal.ServerPlayer>;
        removePlayer(arg0: Internal.ServerPlayer_): void;
        setColor(arg0: Internal.BossEvent$BossBarColor_): void;
        removeAllPlayers(): void;
        setProgress(arg0: number): void;
        setDarkenScreen(arg0: boolean): Internal.BossEvent;
        setName(arg0: Internal.Component_): void;
        addPlayer(arg0: Internal.ServerPlayer_): void;
        isVisible(): boolean;
        setVisible(arg0: boolean): void;
        set createWorldFog(arg0: boolean)
        set playBossMusic(arg0: boolean)
        set overlay(arg0: Internal.BossEvent$BossBarOverlay_)
        get players(): Internal.Collection<Internal.ServerPlayer>
        set color(arg0: Internal.BossEvent$BossBarColor_)
        set progress(arg0: number)
        set darkenScreen(arg0: boolean)
        set name(arg0: Internal.Component_)
        get visible(): boolean
        set visible(arg0: boolean)
    }
    type ServerBossEvent_ = ServerBossEvent;
    class SuggestionsBuilder {
        constructor(arg0: string, arg1: number)
        constructor(arg0: string, arg1: string, arg2: number)
        getRemainingLowerCase(): string;
        getStart(): number;
        buildFuture(): Internal.CompletableFuture<Internal.Suggestions>;
        suggest(arg0: string, arg1: Internal.Message_): this;
        suggest(arg0: string): this;
        getInput(): string;
        build(): Internal.Suggestions;
        suggest(arg0: number): this;
        restart(): this;
        suggest(arg0: number, arg1: Internal.Message_): this;
        getRemaining(): string;
        add(arg0: Internal.SuggestionsBuilder_): this;
        createOffset(arg0: number): this;
        get remainingLowerCase(): string
        get start(): number
        get input(): string
        get remaining(): string
    }
    type SuggestionsBuilder_ = SuggestionsBuilder;
    class Products$P9 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9> {
        constructor(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>)
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>): Internal.App<F, R>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>): Internal.App<F, R>;
    }
    type Products$P9_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9> = Products$P9<F, T1, T2, T3, T4, T5, T6, T7, T8, T9>;
    class Products$P8 <F, T1, T2, T3, T4, T5, T6, T7, T8> {
        constructor(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>)
        t4(): Internal.App<F, T4>;
        t5(): Internal.App<F, T5>;
        t6(): Internal.App<F, T6>;
        t7(): Internal.App<F, T7>;
        t8(): Internal.App<F, T8>;
        t1(): Internal.App<F, T1>;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function8_<T1, T2, T3, T4, T5, T6, T7, T8, R>): Internal.App<F, R>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function8_<T1, T2, T3, T4, T5, T6, T7, T8, R>>): Internal.App<F, R>;
    }
    type Products$P8_<F, T1, T2, T3, T4, T5, T6, T7, T8> = Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
    class TrunkPlacerType <P> {
        codec(): Internal.Codec<P>;
        readonly static "STRAIGHT_TRUNK_PLACER": Internal.TrunkPlacerType<any>;
        readonly static "FANCY_TRUNK_PLACER": Internal.TrunkPlacerType<any>;
        readonly static "DARK_OAK_TRUNK_PLACER": Internal.TrunkPlacerType<any>;
        readonly static "FORKING_TRUNK_PLACER": Internal.TrunkPlacerType<any>;
        readonly static "BENDING_TRUNK_PLACER": Internal.TrunkPlacerType<any>;
        readonly static "GIANT_TRUNK_PLACER": Internal.TrunkPlacerType<any>;
        readonly static "MEGA_JUNGLE_TRUNK_PLACER": Internal.TrunkPlacerType<any>;
    }
    type TrunkPlacerType_<P> = Special.TrunkPlacerType | TrunkPlacerType<P>;
    class Products$P5 <F, T1, T2, T3, T4, T5> {
        constructor(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>)
        t4(): Internal.App<F, T4>;
        t5(): Internal.App<F, T5>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function5_<T1, T2, T3, T4, T5, R>): Internal.App<F, R>;
        t1(): Internal.App<F, T1>;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        and(arg0: Internal.App_<F, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        and(arg0: Internal.Products$P2_<F, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function5_<T1, T2, T3, T4, T5, R>>): Internal.App<F, R>;
        and(arg0: Internal.Products$P3_<F, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
    }
    type Products$P5_<F, T1, T2, T3, T4, T5> = Products$P5<F, T1, T2, T3, T4, T5>;
    class LivingEvent$LivingJumpEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.LivingEntity_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type LivingEvent$LivingJumpEvent_ = LivingEvent$LivingJumpEvent;
    class Products$P4 <F, T1, T2, T3, T4> {
        constructor(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>)
        t4(): Internal.App<F, T4>;
        t1(): Internal.App<F, T1>;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function4_<T1, T2, T3, T4, R>>): Internal.App<F, R>;
        and(arg0: Internal.App_<F, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function4_<T1, T2, T3, T4, R>): Internal.App<F, R>;
        and(arg0: Internal.Products$P3_<F, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        and(arg0: Internal.Products$P4_<F, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        and(arg0: Internal.Products$P2_<F, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
    }
    type Products$P4_<F, T1, T2, T3, T4> = Products$P4<F, T1, T2, T3, T4>;
    class Products$P7 <F, T1, T2, T3, T4, T5, T6, T7> {
        constructor(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>)
        t4(): Internal.App<F, T4>;
        t5(): Internal.App<F, T5>;
        t6(): Internal.App<F, T6>;
        t7(): Internal.App<F, T7>;
        t1(): Internal.App<F, T1>;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        and(arg0: Internal.App_<F, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function7_<T1, T2, T3, T4, T5, T6, T7, R>): Internal.App<F, R>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function7_<T1, T2, T3, T4, T5, T6, T7, R>>): Internal.App<F, R>;
    }
    type Products$P7_<F, T1, T2, T3, T4, T5, T6, T7> = Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
    class AreaEffectCloud extends Internal.Entity {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getStepHeight(): number;
        setOwner(arg0: Internal.LivingEntity_): void;
        asKJS(): Internal.EntityJS;
        getRadius(): number;
        getColor(): number;
        getAddEntityPacket(): Internal.Packet<any>;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        setDurationOnUse(arg0: number): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getRadiusOnUse(): number;
        getOwner(): Internal.LivingEntity;
        getDimensions(arg0: Internal.Pose_): Internal.EntityDimensions;
        refreshDimensions(): void;
        getPistonPushReaction(): Internal.PushReaction;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        isWaiting(): boolean;
        setRadiusPerTick(arg0: number): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getRadiusPerTick(): number;
        setPotion(arg0: Internal.Potion_): void;
        setRadius(arg0: number): void;
        setParticle(arg0: Internal.ParticleOptions_): void;
        setDuration(arg0: number): void;
        getParticle(): Internal.ParticleOptions;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        addEffect(arg0: Internal.MobEffectInstance_): void;
        getWaitTime(): number;
        getPotion(): Internal.Potion;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        setWaitTime(arg0: number): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        setFixedColor(arg0: number): void;
        getDurationOnUse(): number;
        setRadiusOnUse(arg0: number): void;
        getDuration(): number;
        get stepHeight(): number
        set owner(arg0: Internal.LivingEntity_)
        get radius(): number
        get color(): number
        get addEntityPacket(): Internal.Packet<any>
        get multipartEntity(): boolean
        set durationOnUse(arg0: number)
        get radiusOnUse(): number
        get owner(): Internal.LivingEntity
        get pistonPushReaction(): Internal.PushReaction
        get parts(): Internal.PartEntity<any>[]
        get waiting(): boolean
        set radiusPerTick(arg0: number)
        get radiusPerTick(): number
        set potion(arg0: Internal.Potion_)
        set radius(arg0: number)
        set particle(arg0: Internal.ParticleOptions_)
        set duration(arg0: number)
        get particle(): Internal.ParticleOptions
        get waitTime(): number
        get potion(): Internal.Potion
        set waitTime(arg0: number)
        set fixedColor(arg0: number)
        get durationOnUse(): number
        set radiusOnUse(arg0: number)
        get duration(): number
    }
    type AreaEffectCloud_ = AreaEffectCloud;
    class Products$P6 <F, T1, T2, T3, T4, T5, T6> {
        constructor(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>)
        t4(): Internal.App<F, T4>;
        t5(): Internal.App<F, T5>;
        t6(): Internal.App<F, T6>;
        t1(): Internal.App<F, T1>;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function6_<T1, T2, T3, T4, T5, T6, R>): Internal.App<F, R>;
        and(arg0: Internal.Products$P2_<F, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function6_<T1, T2, T3, T4, T5, T6, R>>): Internal.App<F, R>;
        and(arg0: Internal.App_<F, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
    }
    type Products$P6_<F, T1, T2, T3, T4, T5, T6> = Products$P6<F, T1, T2, T3, T4, T5, T6>;
    interface PosRuleTestType <P> {
        codec(): Internal.Codec<P>;
        register(arg0: string, arg1: Internal.Codec_<P>): this;
        readonly static "LINEAR_POS_TEST": any;
        readonly static "AXIS_ALIGNED_LINEAR_POS_TEST": any;
        readonly static "ALWAYS_TRUE_TEST": any;
    }
    type PosRuleTestType_<P> = Special.PosRuleTestType | PosRuleTestType<P>;
    abstract class ChunkAccess implements Internal.FeatureAccess, Internal.BiomeManager$NoiseBiomeSource, Internal.BlockGetter {
        constructor(arg0: Internal.ChunkPos_, arg1: Internal.UpgradeData_, arg2: Internal.LevelHeightAccessor_, arg3: Internal.Registry_<Internal.Biome_>, arg4: number, arg5: Internal.LevelChunkSection_[], arg6: Internal.BlendingData_)
        static getOrCreateOffsetList(arg0: Internal.ShortList_[], arg1: number): Internal.ShortList;
        getMinSection(): number;
        clipWithInteractionOverride(arg0: Vec3_, arg1: Vec3_, arg2: BlockPos_, arg3: Internal.VoxelShape_, arg4: Internal.BlockState_): Internal.BlockHitResult;
        getMaxSection(): number;
        isUnsaved(): boolean;
        setLightCorrect(arg0: boolean): void;
        setAllReferences(arg0: Internal.Map_<Internal.ConfiguredStructureFeature_<any, any>, Internal.LongSet_>): void;
        getBlockFloorHeight(arg0: BlockPos_): number;
        getLightEmission(arg0: BlockPos_): number;
        getOrCreateHeightmapUnprimed(arg0: Internal.Heightmap$Types_): Internal.Heightmap;
        getSectionYFromSectionIndex(arg0: number): number;
        getBelowZeroRetrogen(): Internal.BelowZeroRetrogen;
        hasAnyStructureReferences(): boolean;
        clip(arg0: Internal.ClipContext_): Internal.BlockHitResult;
        isOutsideBuildHeight(arg0: BlockPos_): boolean;
        getReferencesForFeature(arg0: Internal.ConfiguredStructureFeature_<any, any>): Internal.LongSet;
        getBlockEntity(arg0: BlockPos_, arg1: Internal.BlockEntityType_<T>): Internal.Optional<T>;
        getHeightAccessorForGeneration(): Internal.LevelHeightAccessor;
        setBlockEntity(arg0: Internal.BlockEntity_): void;
        getEventDispatcher(arg0: number): Internal.GameEventDispatcher;
        setInhabitedTime(arg0: number): void;
        setBlockState(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: boolean): Internal.BlockState;
        getAllStarts(): Internal.Map<Internal.ConfiguredStructureFeature<any, any>, Internal.StructureStart>;
        getBlockStates(arg0: Internal.AABB_): Internal.Stream<Internal.BlockState>;
        getPostProcessing(): Internal.ShortList[];
        getBlockEntityNbtForSaving(arg0: BlockPos_): Internal.CompoundTag;
        carverBiome(arg0: Internal.Supplier_<Internal.Holder_<Internal.Biome_>>): Internal.Holder<Internal.Biome>;
        getHeightmaps(): Internal.Collection<Internal.Map$Entry<Internal.Heightmap$Types, Internal.Heightmap>>;
        removeBlockEntity(arg0: BlockPos_): void;
        fillBiomesFromNoise(arg0: Internal.BiomeResolver_, arg1: Internal.Climate$Sampler_): void;
        getPos(): Internal.ChunkPos;
        getStartForFeature(arg0: Internal.ConfiguredStructureFeature_<any, any>): Internal.StructureStart;
        getUpgradeData(): Internal.UpgradeData;
        getHeight(arg0: Internal.Heightmap$Types_, arg1: number, arg2: number): number;
        getSectionsCount(): number;
        getOrCreateNoiseChunk(arg0: Internal.NoiseRouter_, arg1: Internal.Supplier_<Internal.DensityFunctions$BeardifierOrMarker_>, arg2: Internal.NoiseGeneratorSettings_, arg3: Internal.Aquifer$FluidPicker_, arg4: Internal.Blender_): Internal.NoiseChunk;
        getMinBuildHeight(): number;
        incrementInhabitedTime(arg0: number): void;
        getSectionIndexFromSectionY(arg0: number): number;
        getBlendingData(): Internal.BlendingData;
        setAllStarts(arg0: Internal.Map_<Internal.ConfiguredStructureFeature_<any, any>, Internal.StructureStart_>): void;
        markPosForPostprocessing(arg0: BlockPos_): void;
        getSection(arg0: number): Internal.LevelChunkSection;
        getLights(): Internal.Stream<BlockPos>;
        addPackedPostProcess(arg0: number, arg1: number): void;
        getSectionIndex(arg0: number): number;
        getTicksForSerialization(): Internal.ChunkAccess$TicksToSave;
        getMaxBuildHeight(): number;
        setUnsaved(arg0: boolean): void;
        setBlendingData(arg0: Internal.BlendingData_): void;
        getAllReferences(): Internal.Map<Internal.ConfiguredStructureFeature<any, any>, Internal.LongSet>;
        setHeightmap(arg0: Internal.Heightmap$Types_, arg1: number[]): void;
        isLightCorrect(): boolean;
        setBlockEntityNbt(arg0: Internal.CompoundTag_): void;
        getBlockEntitiesPos(): Internal.Set<BlockPos>;
        getFluidTicks(): Internal.TickContainerAccess<Internal.Fluid>;
        getBlockFloorHeight(arg0: Internal.VoxelShape_, arg1: Internal.Supplier_<Internal.VoxelShape_>): number;
        getHeight(): number;
        getNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
        getBlockTicks(): Internal.TickContainerAccess<Internal.Block>;
        getWorldForge(): Internal.LevelAccessor;
        isOutsideBuildHeight(arg0: number): boolean;
        isBlockInLine(arg0: Internal.ClipBlockStateContext_): Internal.BlockHitResult;
        hasPrimedHeightmap(arg0: Internal.Heightmap$Types_): boolean;
        getHighestSection(): Internal.LevelChunkSection;
        getInhabitedTime(): number;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        isOldNoiseGeneration(): boolean;
        getHighestSectionPosition(): number;
        addEntity(arg0: Internal.Entity_): void;
        isYSpaceEmpty(arg0: number, arg1: number): boolean;
        isUpgrading(): boolean;
        getSections(): Internal.LevelChunkSection[];
        getStatus(): Internal.ChunkStatus;
        getMaxLightLevel(): number;
        setStartForFeature(arg0: Internal.ConfiguredStructureFeature_<any, any>, arg1: Internal.StructureStart_): void;
        addReferenceForFeature(arg0: Internal.ConfiguredStructureFeature_<any, any>, arg1: number): void;
        getBlockEntityNbt(arg0: BlockPos_): Internal.CompoundTag;
        get minSection(): number
        get maxSection(): number
        get unsaved(): boolean
        set lightCorrect(arg0: boolean)
        set allReferences(arg0: Internal.Map_<Internal.ConfiguredStructureFeature_<any, any>, Internal.LongSet_>)
        get belowZeroRetrogen(): Internal.BelowZeroRetrogen
        get heightAccessorForGeneration(): Internal.LevelHeightAccessor
        set blockEntity(arg0: Internal.BlockEntity_)
        set inhabitedTime(arg0: number)
        get allStarts(): Internal.Map<Internal.ConfiguredStructureFeature<any, any>, Internal.StructureStart>
        get postProcessing(): Internal.ShortList[]
        get heightmaps(): Internal.Collection<Internal.Map$Entry<Internal.Heightmap$Types, Internal.Heightmap>>
        get pos(): Internal.ChunkPos
        get upgradeData(): Internal.UpgradeData
        get sectionsCount(): number
        get minBuildHeight(): number
        get blendingData(): Internal.BlendingData
        set allStarts(arg0: Internal.Map_<Internal.ConfiguredStructureFeature_<any, any>, Internal.StructureStart_>)
        get lights(): Internal.Stream<BlockPos>
        get ticksForSerialization(): Internal.ChunkAccess$TicksToSave
        get maxBuildHeight(): number
        set unsaved(arg0: boolean)
        set blendingData(arg0: Internal.BlendingData_)
        get allReferences(): Internal.Map<Internal.ConfiguredStructureFeature<any, any>, Internal.LongSet>
        get lightCorrect(): boolean
        set blockEntityNbt(arg0: Internal.CompoundTag_)
        get blockEntitiesPos(): Internal.Set<BlockPos>
        get fluidTicks(): Internal.TickContainerAccess<Internal.Fluid>
        get height(): number
        get blockTicks(): Internal.TickContainerAccess<Internal.Block>
        get worldForge(): Internal.LevelAccessor
        get highestSection(): Internal.LevelChunkSection
        get inhabitedTime(): number
        get oldNoiseGeneration(): boolean
        get highestSectionPosition(): number
        get upgrading(): boolean
        get sections(): Internal.LevelChunkSection[]
        get status(): Internal.ChunkStatus
        get maxLightLevel(): number
    }
    type ChunkAccess_ = ChunkAccess;
    class SoundEvent extends Internal.ForgeRegistryEntry<Internal.SoundEvent> {
        constructor(arg0: ResourceLocation_)
        getLocation(): ResourceLocation;
        get location(): ResourceLocation
        readonly static "CODEC": any;
    }
    type SoundEvent_ = SoundEvent | Special.SoundEvent;
    interface Type {
        getTypeName(): string;
        get typeName(): string
    }
    type Type_ = Type;
    interface DensityFunction {
        halfNegative(): this;
        abs(): this;
        maxValue(): number;
        compute(arg0: Internal.DensityFunction$FunctionContext_): number;
        squeeze(): this;
        square(): this;
        mapAll(arg0: Internal.DensityFunction$Visitor_): this;
        codec(): Internal.Codec<any>;
        clamp(arg0: number, arg1: number): this;
        quarterNegative(): this;
        cube(): this;
        fillArray(arg0: number[], arg1: Internal.DensityFunction$ContextProvider_): void;
        minValue(): number;
        readonly static "CODEC": any;
        readonly static "DIRECT_CODEC": any;
        readonly static "HOLDER_HELPER_CODEC": any;
    }
    type DensityFunction_ = DensityFunction | Special.DensityFunction;
    interface ChannelOutboundInvoker {
        newFailedFuture(arg0: Internal.Throwable_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.SocketAddress_, arg2: Internal.ChannelPromise_): Internal.ChannelFuture;
        deregister(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        newSucceededFuture(): Internal.ChannelFuture;
        close(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        newProgressivePromise(): Internal.ChannelProgressivePromise;
        flush(): this;
        write(arg0: any): Internal.ChannelFuture;
        writeAndFlush(arg0: any): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress_, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        disconnect(): Internal.ChannelFuture;
        writeAndFlush(arg0: any, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress_): Internal.ChannelFuture;
        close(): Internal.ChannelFuture;
        write(arg0: any, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.SocketAddress_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_): Internal.ChannelFuture;
        read(): this;
        deregister(): Internal.ChannelFuture;
        voidPromise(): Internal.ChannelPromise;
        disconnect(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        newPromise(): Internal.ChannelPromise;
    }
    type ChannelOutboundInvoker_ = ChannelOutboundInvoker;
    interface LootContextUser {
        getReferencedContextParams(): Internal.Set<Internal.LootContextParam<any>>;
        validate(arg0: Internal.ValidationContext_): void;
        get referencedContextParams(): Internal.Set<Internal.LootContextParam<any>>
    }
    type LootContextUser_ = LootContextUser;
    class PlayerInfo {
        constructor(arg0: Internal.ClientboundPlayerInfoPacket$PlayerUpdate_)
        getTabListDisplayName(): Internal.Component;
        setDisplayHealth(arg0: number): void;
        setHealthBlinkTime(arg0: number): void;
        getModelName(): string;
        getTeam(): Internal.PlayerTeam;
        setLastHealth(arg0: number): void;
        getLastHealthTime(): number;
        getDisplayHealth(): number;
        getLastHealth(): number;
        getElytraLocation(): ResourceLocation;
        getCapeLocation(): ResourceLocation;
        setTabListDisplayName(arg0: Internal.Component_): void;
        getProfile(): Internal.GameProfile;
        getHealthBlinkTime(): number;
        getGameMode(): Internal.GameType;
        getSkinLocation(): ResourceLocation;
        isSkinLoaded(): boolean;
        setRenderVisibilityId(arg0: number): void;
        getRenderVisibilityId(): number;
        setLastHealthTime(arg0: number): void;
        getLatency(): number;
        isCapeLoaded(): boolean;
        get tabListDisplayName(): Internal.Component
        set displayHealth(arg0: number)
        set healthBlinkTime(arg0: number)
        get modelName(): string
        get team(): Internal.PlayerTeam
        set lastHealth(arg0: number)
        get lastHealthTime(): number
        get displayHealth(): number
        get lastHealth(): number
        get elytraLocation(): ResourceLocation
        get capeLocation(): ResourceLocation
        set tabListDisplayName(arg0: Internal.Component_)
        get profile(): Internal.GameProfile
        get healthBlinkTime(): number
        get gameMode(): Internal.GameType
        get skinLocation(): ResourceLocation
        get skinLoaded(): boolean
        set renderVisibilityId(arg0: number)
        get renderVisibilityId(): number
        set lastHealthTime(arg0: number)
        get latency(): number
        get capeLoaded(): boolean
    }
    type PlayerInfo_ = PlayerInfo;
    class ClientboundPlayerAbilitiesPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.Abilities_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        canInstabuild(): boolean;
        canFly(): boolean;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getFlyingSpeed(): number;
        getWalkingSpeed(): number;
        isInvulnerable(): boolean;
        isSkippable(): boolean;
        isFlying(): boolean;
        get flyingSpeed(): number
        get walkingSpeed(): number
        get invulnerable(): boolean
        get skippable(): boolean
        get flying(): boolean
    }
    type ClientboundPlayerAbilitiesPacket_ = ClientboundPlayerAbilitiesPacket;
    class DimensionType {
        static defaultDimensions(arg0: Internal.RegistryAccess_, arg1: number): Internal.Registry<Internal.LevelStem>;
        static parseLegacy(arg0: Internal.Dynamic_<any>): Internal.DataResult<Internal.ResourceKey<Internal.Level>>;
        respawnAnchorWorks(): boolean;
        bedWorks(): boolean;
        coordinateScale(): number;
        piglinSafe(): boolean;
        hasFixedTime(): boolean;
        createDragonFight(): boolean;
        brightness(arg0: number): number;
        infiniburn(): Internal.TagKey<Internal.Block>;
        static getTeleportationScale(arg0: Internal.DimensionType_, arg1: Internal.DimensionType_): number;
        effectsLocation(): ResourceLocation;
        hasCeiling(): boolean;
        hasSkyLight(): boolean;
        height(): number;
        static getStorageFolder(arg0: Internal.ResourceKey_<Internal.Level_>, arg1: Internal.Path_): Internal.Path;
        moonPhase(arg0: number): number;
        static defaultDimensions(arg0: Internal.RegistryAccess_, arg1: number, arg2: boolean): Internal.Registry<Internal.LevelStem>;
        natural(): boolean;
        minY(): number;
        timeOfDay(arg0: number): number;
        logicalHeight(): number;
        static registerBuiltin(arg0: Internal.RegistryAccess$Writable_): Internal.RegistryAccess$Writable;
        ultraWarm(): boolean;
        hasRaids(): boolean;
        static create(arg0: Internal.OptionalLong_, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: number, arg6: boolean, arg7: boolean, arg8: boolean, arg9: boolean, arg10: boolean, arg11: number, arg12: number, arg13: number, arg14: Internal.TagKey_<Internal.Block_>, arg15: ResourceLocation_, arg16: number): Internal.DimensionType;
        readonly static "WAY_ABOVE_MAX_Y": 32496;
        readonly static "CODEC": any;
        readonly static "BITS_FOR_Y": 12;
        readonly static "WAY_BELOW_MIN_Y": -32512;
        readonly static "NETHER_EFFECTS": ResourceLocation;
        readonly static "OVERWORLD_EFFECTS": ResourceLocation;
        readonly static "OVERWORLD_CAVES_LOCATION": Internal.ResourceKey<any>;
        readonly static "MIN_HEIGHT": 16;
        readonly static "MIN_Y": -2032;
        readonly static "Y_SIZE": 4064;
        readonly static "MAX_Y": 2031;
        readonly static "DIRECT_CODEC": any;
        readonly static "MOON_BRIGHTNESS_PER_PHASE": any;
        readonly static "END_EFFECTS": ResourceLocation;
        readonly static "OVERWORLD_LOCATION": Internal.ResourceKey<any>;
        readonly static "END_LOCATION": Internal.ResourceKey<any>;
        readonly static "NETHER_LOCATION": Internal.ResourceKey<any>;
    }
    type DimensionType_ = DimensionType | Special.DimensionType;
    interface IPermissionHandler {
        getRegisteredNodes(): Internal.Set<Internal.PermissionNode<any>>;
        getPermission(arg0: Internal.ServerPlayer_, arg1: Internal.PermissionNode_<T>, ...arg2: any_<any>[]): T;
        getOfflinePermission(arg0: Internal.UUID_, arg1: Internal.PermissionNode_<T>, ...arg2: any_<any>[]): T;
        getIdentifier(): ResourceLocation;
        get registeredNodes(): Internal.Set<Internal.PermissionNode<any>>
        get identifier(): ResourceLocation
    }
    type IPermissionHandler_ = IPermissionHandler;
    class ClientPlayerJS extends Internal.PlayerJS<Internal.Player> {
        constructor(data: Internal.ClientPlayerDataJS_, player: Internal.Player_, self: boolean)
        isMiningBlock(): boolean;
        getStats(): Internal.PlayerStatsJS;
        paint(tag: Internal.CompoundTag_): void;
        sendData(channel: string, data: Internal.CompoundTag_): void;
        isSelf(): boolean;
        rayTrace(distance: number): Internal.RayTraceResultJS;
        get miningBlock(): boolean
        get stats(): Internal.PlayerStatsJS
        get self(): boolean
    }
    type ClientPlayerJS_ = ClientPlayerJS;
    class AttackIndicatorStatus extends Internal.Enum<Internal.AttackIndicatorStatus> {
        getKey(): string;
        static valueOf(arg0: string): Internal.AttackIndicatorStatus;
        static values(): Internal.AttackIndicatorStatus[];
        static byId(arg0: number): Internal.AttackIndicatorStatus;
        getId(): number;
        get key(): string
        get id(): number
        readonly static "CROSSHAIR": Internal.AttackIndicatorStatus;
        readonly static "OFF": Internal.AttackIndicatorStatus;
        readonly static "HOTBAR": Internal.AttackIndicatorStatus;
    }
    type AttackIndicatorStatus_ = "hotbar" | "crosshair" | AttackIndicatorStatus | "off";
    class CoderResult {
        isMalformed(): boolean;
        isUnderflow(): boolean;
        toString(): string;
        static malformedForLength(arg0: number): Internal.CoderResult;
        isError(): boolean;
        isUnmappable(): boolean;
        isOverflow(): boolean;
        throwException(): void;
        static unmappableForLength(arg0: number): Internal.CoderResult;
        length(): number;
        get malformed(): boolean
        get underflow(): boolean
        get error(): boolean
        get unmappable(): boolean
        get overflow(): boolean
        readonly static "UNDERFLOW": Internal.CoderResult;
        readonly static "OVERFLOW": Internal.CoderResult;
    }
    type CoderResult_ = CoderResult;
    class DarkOakFoliagePlacer extends Internal.FoliagePlacer {
        constructor(arg0: Internal.IntProvider_, arg1: Internal.IntProvider_)
        foliageHeight(arg0: Internal.Random_, arg1: number, arg2: Internal.TreeConfiguration_): number;
        readonly static "CODEC": any;
    }
    type DarkOakFoliagePlacer_ = DarkOakFoliagePlacer;
    abstract class ItemCombinerMenu extends Internal.AbstractContainerMenu {
        constructor(arg0: Internal.MenuType_<any>, arg1: number, arg2: Internal.Inventory_, arg3: any_)
        stillValid(arg0: Internal.Player_): boolean;
        slotsChanged(arg0: Internal.Container_): void;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        createResult(): void;
        removed(arg0: Internal.Player_): void;
        readonly static "INPUT_SLOT": 0;
        readonly static "RESULT_SLOT": 2;
        readonly static "ADDITIONAL_SLOT": 1;
    }
    type ItemCombinerMenu_ = ItemCombinerMenu;
    class CaveSpider extends Internal.Spider {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        static createCaveSpider(): Internal.AttributeSupplier$Builder;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type CaveSpider_ = CaveSpider;
    interface PackResources extends Internal.IForgePackResources, Internal.AutoCloseable {
        hasResource(arg0: Internal.PackType_, arg1: ResourceLocation_): boolean;
        getName(): string;
        getNamespaces(arg0: Internal.PackType_): Internal.Set<string>;
        close(): void;
        getResources(arg0: Internal.PackType_, arg1: string, arg2: string, arg3: number, arg4: Internal.Predicate_<string>): Internal.Collection<ResourceLocation>;
        isHidden(): boolean;
        getRootResource(arg0: string): Internal.InputStream;
        getResource(arg0: Internal.PackType_, arg1: ResourceLocation_): Internal.InputStream;
        getMetadataSection(arg0: Internal.MetadataSectionSerializer_<T>): T;
        get name(): string
        get hidden(): boolean
        readonly static "METADATA_EXTENSION": ".mcmeta";
        readonly static "PACK_META": "pack.mcmeta";
    }
    type PackResources_ = PackResources;
    class RenderPlayerEvent$Pre extends Internal.RenderPlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.PlayerRenderer_, arg2: number, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type RenderPlayerEvent$Pre_ = RenderPlayerEvent$Pre;
    class MushroomCow$MushroomType extends Internal.Enum<Internal.MushroomCow$MushroomType> {
        static valueOf(arg0: string): Internal.MushroomCow$MushroomType;
        getBlockState(): Internal.BlockState;
        static values(): Internal.MushroomCow$MushroomType[];
        get blockState(): Internal.BlockState
        readonly static "RED": Internal.MushroomCow$MushroomType;
        readonly static "BROWN": Internal.MushroomCow$MushroomType;
    }
    type MushroomCow$MushroomType_ = MushroomCow$MushroomType | "red" | "brown";
    interface BiomeManager$NoiseBiomeSource {
        getNoiseBiome(arg0: number, arg1: number, arg2: number): Internal.Holder<Internal.Biome>;
    }
    type BiomeManager$NoiseBiomeSource_ = BiomeManager$NoiseBiomeSource;
    class PlaySoundSourceEvent extends Internal.SoundEvent$SoundSourceEvent {
        constructor()
        constructor(arg0: Internal.SoundEngine_, arg1: Internal.SoundInstance_, arg2: com.mojang.blaze3d.audio.Channel_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type PlaySoundSourceEvent_ = PlaySoundSourceEvent;
    class NamedPackage {
    }
    type NamedPackage_ = NamedPackage;
    class Scoreboard {
        constructor()
        getPlayersTeam(arg0: string): Internal.PlayerTeam;
        getPlayerScores(arg0: Internal.Objective_): Internal.Collection<Internal.Score>;
        getDisplayObjective(arg0: number): Internal.Objective;
        hasPlayerScore(arg0: string, arg1: Internal.Objective_): boolean;
        onTeamAdded(arg0: Internal.PlayerTeam_): void;
        removePlayerFromTeam(arg0: string, arg1: Internal.PlayerTeam_): void;
        removePlayerTeam(arg0: Internal.PlayerTeam_): void;
        static getDisplaySlotName(arg0: number): string;
        static getDisplaySlotByName(arg0: string): number;
        onObjectiveChanged(arg0: Internal.Objective_): void;
        onScoreChanged(arg0: Internal.Score_): void;
        onObjectiveAdded(arg0: Internal.Objective_): void;
        onPlayerRemoved(arg0: string): void;
        removeObjective(arg0: Internal.Objective_): void;
        addObjective(arg0: string, arg1: Internal.ObjectiveCriteria_, arg2: Internal.Component_, arg3: Internal.ObjectiveCriteria$RenderType_): Internal.Objective;
        getPlayerScores(arg0: string): Internal.Map<Internal.Objective, Internal.Score>;
        forAllObjectives(arg0: Internal.ObjectiveCriteria_, arg1: string, arg2: Internal.Consumer_<Internal.Score_>): void;
        onTeamRemoved(arg0: Internal.PlayerTeam_): void;
        removePlayerFromTeam(arg0: string): boolean;
        getOrCreateObjective(arg0: string): Internal.Objective;
        addPlayerTeam(arg0: string): Internal.PlayerTeam;
        onTeamChanged(arg0: Internal.PlayerTeam_): void;
        getPlayerTeam(arg0: string): Internal.PlayerTeam;
        resetPlayerScore(arg0: string, arg1: Internal.Objective_): void;
        entityRemoved(arg0: Internal.Entity_): void;
        getObjectives(): Internal.Collection<Internal.Objective>;
        onPlayerScoreRemoved(arg0: string, arg1: Internal.Objective_): void;
        hasObjective(arg0: string): boolean;
        addPlayerToTeam(arg0: string, arg1: Internal.PlayerTeam_): boolean;
        getOrCreatePlayerScore(arg0: string, arg1: Internal.Objective_): Internal.Score;
        getPlayerTeams(): Internal.Collection<Internal.PlayerTeam>;
        getObjectiveNames(): Internal.Collection<string>;
        getTrackedPlayers(): Internal.Collection<string>;
        getTeamNames(): Internal.Collection<string>;
        onObjectiveRemoved(arg0: Internal.Objective_): void;
        static getDisplaySlotNames(): string[];
        getObjective(arg0: string): Internal.Objective;
        setDisplayObjective(arg0: number, arg1: Internal.Objective_): void;
        get objectives(): Internal.Collection<Internal.Objective>
        get playerTeams(): Internal.Collection<Internal.PlayerTeam>
        get objectiveNames(): Internal.Collection<string>
        get trackedPlayers(): Internal.Collection<string>
        get teamNames(): Internal.Collection<string>
        get displaySlotNames(): string[]
        readonly static "DISPLAY_SLOTS": 19;
        readonly static "DISPLAY_SLOT_TEAMS_SIDEBAR_END": 18;
        readonly static "DISPLAY_SLOT_SIDEBAR": 1;
        readonly static "DISPLAY_SLOT_TEAMS_SIDEBAR_START": 3;
        readonly static "DISPLAY_SLOT_BELOW_NAME": 2;
        readonly static "DISPLAY_SLOT_LIST": 0;
    }
    type Scoreboard_ = Scoreboard;
    class ScreenEvent$InitScreenEvent$Post extends Internal.ScreenEvent$InitScreenEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: Internal.List_<Internal.GuiEventListener_>, arg2: Internal.Consumer_<Internal.GuiEventListener_>, arg3: Internal.Consumer_<Internal.GuiEventListener_>)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$InitScreenEvent$Post_ = ScreenEvent$InitScreenEvent$Post;
    abstract class Clock implements Internal.InstantSource {
        static offset(arg0: Internal.Clock_, arg1: Internal.Duration_): Internal.Clock;
        static tickSeconds(arg0: Internal.ZoneId_): Internal.Clock;
        static tickMinutes(arg0: Internal.ZoneId_): Internal.Clock;
        static fixed(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.Clock;
        withZone(arg0: Internal.ZoneId_): this;
        static systemDefaultZone(): Internal.Clock;
        static systemUTC(): Internal.Clock;
        millis(): number;
        static tick(arg0: Internal.Clock_, arg1: Internal.Duration_): Internal.Clock;
        hashCode(): number;
        getZone(): Internal.ZoneId;
        static tickMillis(arg0: Internal.ZoneId_): Internal.Clock;
        static system(arg0: Internal.ZoneId_): Internal.Clock;
        instant(): Internal.Instant;
        equals(arg0: any): boolean;
        get zone(): Internal.ZoneId
    }
    type Clock_ = Clock;
    abstract class Format implements Internal.Cloneable, Internal.Serializable {
        clone(): any;
        format(arg0: any, arg1: Internal.StringBuffer_, arg2: Internal.FieldPosition_): Internal.StringBuffer;
        formatToCharacterIterator(arg0: any): Internal.AttributedCharacterIterator;
        parseObject(arg0: string): any;
        parseObject(arg0: string, arg1: Internal.ParsePosition_): any;
        format(arg0: any): string;
    }
    type Format_ = Format;
    interface Enumeration <E> {
        nextElement(): E;
        asIterator(): Internal.Iterator<E>;
        hasMoreElements(): boolean;
    }
    type Enumeration_<E> = Enumeration<E>;
    class ExemptionMechanism {
        init(arg0: Internal.Key_, arg1: Internal.AlgorithmParameterSpec_): void;
        genExemptionBlob(): number[];
        static getInstance(arg0: string, arg1: Internal.Provider_): Internal.ExemptionMechanism;
        genExemptionBlob(arg0: number[], arg1: number): number;
        static getInstance(arg0: string, arg1: string): Internal.ExemptionMechanism;
        init(arg0: Internal.Key_): void;
        isCryptoAllowed(arg0: Internal.Key_): boolean;
        getProvider(): Internal.Provider;
        getOutputSize(arg0: number): number;
        genExemptionBlob(arg0: number[]): number;
        init(arg0: Internal.Key_, arg1: Internal.AlgorithmParameters_): void;
        getName(): string;
        static getInstance(arg0: string): Internal.ExemptionMechanism;
        get provider(): Internal.Provider
        get name(): string
    }
    type ExemptionMechanism_ = ExemptionMechanism;
    class AbstractArrow$Pickup extends Internal.Enum<Internal.AbstractArrow$Pickup> {
        static values(): Internal.AbstractArrow$Pickup[];
        static byOrdinal(arg0: number): Internal.AbstractArrow$Pickup;
        static valueOf(arg0: string): Internal.AbstractArrow$Pickup;
        readonly static "DISALLOWED": Internal.AbstractArrow$Pickup;
        readonly static "ALLOWED": Internal.AbstractArrow$Pickup;
        readonly static "CREATIVE_ONLY": Internal.AbstractArrow$Pickup;
    }
    type AbstractArrow$Pickup_ = "allowed" | "disallowed" | "creative_only" | AbstractArrow$Pickup;
    class VertexFormatElement {
        constructor(arg0: number, arg1: Internal.VertexFormatElement$Type_, arg2: Internal.VertexFormatElement$Usage_, arg3: number)
        getType(): Internal.VertexFormatElement$Type;
        getByteSize(): number;
        hashCode(): number;
        getCount(): number;
        getElementCount(): number;
        toString(): string;
        getUsage(): Internal.VertexFormatElement$Usage;
        getIndex(): number;
        equals(arg0: any): boolean;
        setupBufferState(arg0: number, arg1: number, arg2: number): void;
        isPosition(): boolean;
        clearBufferState(arg0: number): void;
        get type(): Internal.VertexFormatElement$Type
        get byteSize(): number
        get count(): number
        get elementCount(): number
        get usage(): Internal.VertexFormatElement$Usage
        get index(): number
        get position(): boolean
    }
    type VertexFormatElement_ = VertexFormatElement;
    class WitherSkull extends Internal.AbstractHurtingProjectile {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        constructor(arg0: Internal.Level_, arg1: Internal.LivingEntity_, arg2: number, arg3: number, arg4: number)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getBlockExplosionResistance(arg0: Internal.Explosion_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: Internal.FluidState_, arg5: number): number;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        isPickable(): boolean;
        isDangerous(): boolean;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        setDangerous(arg0: boolean): void;
        isMultipartEntity(): boolean;
        isOnFire(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        get pickable(): boolean
        get dangerous(): boolean
        set dangerous(arg0: boolean)
        get multipartEntity(): boolean
        get onFire(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type WitherSkull_ = WitherSkull;
    class ScreenEvent$DrawScreenEvent$Post extends Internal.ScreenEvent$DrawScreenEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: Internal.PoseStack_, arg2: number, arg3: number, arg4: number)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$DrawScreenEvent$Post_ = ScreenEvent$DrawScreenEvent$Post;
    class RenderShape extends Internal.Enum<Internal.RenderShape> {
        static values(): Internal.RenderShape[];
        static valueOf(arg0: string): Internal.RenderShape;
        readonly static "ENTITYBLOCK_ANIMATED": Internal.RenderShape;
        readonly static "MODEL": Internal.RenderShape;
        readonly static "INVISIBLE": Internal.RenderShape;
    }
    type RenderShape_ = RenderShape | "model" | "invisible" | "entityblock_animated";
    abstract class Pointer$Default implements Internal.Pointer {
        hashCode(): number;
        toString(): string;
        equals(arg0: any): boolean;
        address(): number;
    }
    type Pointer$Default_ = Pointer$Default;
    class Proxy {
        constructor(arg0: Internal.Proxy$Type_, arg1: Internal.SocketAddress_)
        hashCode(): number;
        address(): Internal.SocketAddress;
        toString(): string;
        type(): Internal.Proxy$Type;
        equals(arg0: any): boolean;
        readonly static "NO_PROXY": Internal.Proxy;
    }
    type Proxy_ = Proxy;
    class PlayerXpEvent extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type PlayerXpEvent_ = PlayerXpEvent;
    class ClientboundRotateHeadPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.Entity_, arg1: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getYHeadRot(): number;
        getEntity(arg0: Internal.Level_): Internal.Entity;
        isSkippable(): boolean;
        get YHeadRot(): number
        get skippable(): boolean
    }
    type ClientboundRotateHeadPacket_ = ClientboundRotateHeadPacket;
    interface PreparableReloadListener {
        getName(): string;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        get name(): string
    }
    type PreparableReloadListener_ = PreparableReloadListener;
    class LivingSpawnEvent$AllowDespawn extends Internal.LivingSpawnEvent {
        constructor()
        constructor(arg0: Internal.Mob_)
        hasResult(): boolean;
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
    }
    type LivingSpawnEvent$AllowDespawn_ = LivingSpawnEvent$AllowDespawn;
    abstract class ReentrantBlockableEventLoop <R> extends Internal.BlockableEventLoop<R> {
        constructor(arg0: string)
        scheduleExecutables(): boolean;
        doRunTask(arg0: R): void;
        ask(arg0: Internal.Function_<any, any>): Internal.CompletableFuture<Source>;
        close(): void;
        askEither(arg0: Internal.Function_<any, any>): Internal.CompletableFuture<Source>;
    }
    type ReentrantBlockableEventLoop_<R> = ReentrantBlockableEventLoop<R>;
    class Window implements Internal.AutoCloseable {
        constructor(arg0: Internal.WindowEventHandler_, arg1: any_, arg2: any_, arg3: string, arg4: string)
        setFramerateLimit(arg0: number): void;
        getX(): number;
        getY(): number;
        getPreferredFullscreenVideoMode(): Internal.Optional<Internal.VideoMode>;
        findBestMonitor(): Internal.Monitor;
        calculateScale(arg0: number, arg1: boolean): number;
        isFullscreen(): boolean;
        setErrorSection(arg0: string): void;
        setGuiScale(arg0: number): void;
        setPreferredFullscreenVideoMode(arg0: Internal.Optional_<Internal.VideoMode_>): void;
        shouldClose(): boolean;
        changeFullscreenVideoMode(): void;
        setWidth(arg0: number): void;
        getHeight(): number;
        defaultErrorCallback(arg0: number, arg1: number): void;
        updateRawMouseInput(arg0: boolean): void;
        getGuiScaledWidth(): number;
        setDefaultErrorCallback(): void;
        static checkGlfwError(arg0: Internal.BiConsumer_<number, string>): void;
        getFramerateLimit(): number;
        getScreenHeight(): number;
        getWidth(): number;
        getGuiScaledHeight(): number;
        updateVsync(arg0: boolean): void;
        getWindow(): number;
        setWindowed(arg0: number, arg1: number): void;
        setTitle(arg0: string): void;
        getScreenWidth(): number;
        getGuiScale(): number;
        close(): void;
        toggleFullScreen(): void;
        setIcon(arg0: Internal.InputStream_, arg1: Internal.InputStream_): void;
        setHeight(arg0: number): void;
        updateDisplay(): void;
        getRefreshRate(): number;
        set framerateLimit(arg0: number)
        get x(): number
        get y(): number
        get preferredFullscreenVideoMode(): Internal.Optional<Internal.VideoMode>
        get fullscreen(): boolean
        set errorSection(arg0: string)
        set guiScale(arg0: number)
        set preferredFullscreenVideoMode(arg0: Internal.Optional_<Internal.VideoMode_>)
        set width(arg0: number)
        get height(): number
        get guiScaledWidth(): number
        get framerateLimit(): number
        get screenHeight(): number
        get width(): number
        get guiScaledHeight(): number
        get window(): number
        set title(arg0: string)
        get screenWidth(): number
        get guiScale(): number
        set height(arg0: number)
        get refreshRate(): number
    }
    type Window_ = Window;
    class RenderType$CompositeState$CompositeStateBuilder {
        setLightmapState(arg0: Internal.RenderStateShard$LightmapStateShard_): this;
        setLineState(arg0: Internal.RenderStateShard$LineStateShard_): this;
        setCullState(arg0: Internal.RenderStateShard$CullStateShard_): this;
        setTransparencyState(arg0: Internal.RenderStateShard$TransparencyStateShard_): this;
        setTextureState(arg0: Internal.RenderStateShard$EmptyTextureStateShard_): this;
        setTexturingState(arg0: Internal.RenderStateShard$TexturingStateShard_): this;
        setShaderState(arg0: Internal.RenderStateShard$ShaderStateShard_): this;
        setDepthTestState(arg0: Internal.RenderStateShard$DepthTestStateShard_): this;
        setOverlayState(arg0: Internal.RenderStateShard$OverlayStateShard_): this;
        setWriteMaskState(arg0: Internal.RenderStateShard$WriteMaskStateShard_): this;
        setOutputState(arg0: Internal.RenderStateShard$OutputStateShard_): this;
        setLayeringState(arg0: Internal.RenderStateShard$LayeringStateShard_): this;
        createCompositeState(arg0: boolean): Internal.RenderType$CompositeState;
        createCompositeState(arg0: Internal.RenderType$OutlineProperty_): Internal.RenderType$CompositeState;
        set lightmapState(arg0: Internal.RenderStateShard$LightmapStateShard_)
        set lineState(arg0: Internal.RenderStateShard$LineStateShard_)
        set cullState(arg0: Internal.RenderStateShard$CullStateShard_)
        set transparencyState(arg0: Internal.RenderStateShard$TransparencyStateShard_)
        set textureState(arg0: Internal.RenderStateShard$EmptyTextureStateShard_)
        set texturingState(arg0: Internal.RenderStateShard$TexturingStateShard_)
        set shaderState(arg0: Internal.RenderStateShard$ShaderStateShard_)
        set depthTestState(arg0: Internal.RenderStateShard$DepthTestStateShard_)
        set overlayState(arg0: Internal.RenderStateShard$OverlayStateShard_)
        set writeMaskState(arg0: Internal.RenderStateShard$WriteMaskStateShard_)
        set outputState(arg0: Internal.RenderStateShard$OutputStateShard_)
        set layeringState(arg0: Internal.RenderStateShard$LayeringStateShard_)
    }
    type RenderType$CompositeState$CompositeStateBuilder_ = RenderType$CompositeState$CompositeStateBuilder;
    class RecipeEventJS extends Internal.EventJS {
        constructor(t: Internal.Map_<ResourceLocation_, Internal.RecipeTypeJS_>)
        replaceInput(filter: Internal.RecipeFilter_, ingredient: Internal.IngredientJS_, with_: Internal.IngredientJS_): number;
        replaceInput(ingredient: Internal.IngredientJS_, with_: Internal.IngredientJS_): number;
        printAllTypes(): void;
        forEachRecipeAsync(filter: Internal.RecipeFilter_, consumer: Internal.Consumer_<Internal.RecipeJS_>): void;
        replaceInput(filter: Internal.RecipeFilter_, ingredient: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean): number;
        printExamples(type: string): void;
        stage(filter: Internal.RecipeFilter_, stage: string): void;
        printTypes(): void;
        addRecipe(r: Internal.RecipeJS_, type: Internal.RecipeTypeJS_, args1: Internal.ListJS_): Internal.RecipeJS;
        forEachRecipe(filter: Internal.RecipeFilter_, consumer: Internal.Consumer_<Internal.RecipeJS_>): void;
        replaceOutput(filter: Internal.RecipeFilter_, ingredient: Internal.IngredientJS_, with_: Internal.ItemStackJS_): number;
        getRecipes(): Internal.Map<string, any>;
        countRecipes(filter: Internal.RecipeFilter_): number;
        remove(filter: Internal.RecipeFilter_): number;
        getRecipeFunction(id: string): Internal.RecipeFunction;
        replaceOutput(ingredient: Internal.IngredientJS_, with_: Internal.ItemStackJS_): number;
        containsRecipe(filter: Internal.RecipeFilter_): boolean;
        customFilter(filter: Internal.RecipeFilter_): Internal.RecipeFilter;
        setItemErrors(b: boolean): void;
        custom(o: any): Internal.RecipeJS;
        replaceOutput(filter: Internal.RecipeFilter_, ingredient: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean): number;
        get recipes(): Internal.Map<string, any>
        set itemErrors(b: boolean)
        readonly static "FORGE_CONDITIONAL": "forge:conditional";
        readonly "smithing": Internal.RecipeFunction;
        readonly "smelting": Internal.RecipeFunction;
        readonly "blasting": Internal.RecipeFunction;
        readonly "shapeless": Internal.RecipeFunction;
        readonly "campfireCooking": Internal.RecipeFunction;
        static "modifyResultCallbackMap": {};
        readonly "smoking": Internal.RecipeFunction;
        readonly "stonecutting": Internal.RecipeFunction;
        static "instance": Internal.RecipeEventJS;
        readonly "shaped": Internal.RecipeFunction;
        static "customIngredientMap": {};
    }
    type RecipeEventJS_ = RecipeEventJS;
    interface DoubleSpliterator extends Internal.Spliterator$OfDouble {
        forEachRemaining(arg0: any): void;
        forEachRemaining(arg0: it.unimi.dsi.fastutil.doubles.DoubleConsumer_): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        getComparator(): Internal.Comparator<any>;
        trySplit(): Internal.Spliterator<any>;
        getExactSizeIfKnown(): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: Internal.DoubleConsumer_): void;
        tryAdvance(arg0: Internal.Consumer_<any>): boolean;
        tryAdvance(arg0: it.unimi.dsi.fastutil.doubles.DoubleConsumer_): boolean;
        skip(arg0: number): number;
        tryAdvance(arg0: any): boolean;
        get comparator(): Internal.Comparator<any>
        get exactSizeIfKnown(): number
    }
    type DoubleSpliterator_ = DoubleSpliterator;
    interface StructureProcessorType <P> {
        codec(): Internal.Codec<P>;
        register(arg0: string, arg1: Internal.Codec_<P>): this;
        readonly static "LIST_CODEC": any;
        readonly static "SINGLE_CODEC": any;
        readonly static "LIST_OBJECT_CODEC": any;
        readonly static "BLACKSTONE_REPLACE": any;
        readonly static "LAVA_SUBMERGED_BLOCK": any;
        readonly static "PROTECTED_BLOCKS": any;
        readonly static "BLOCK_ROT": any;
        readonly static "DIRECT_CODEC": any;
        readonly static "BLOCK_IGNORE": any;
        readonly static "GRAVITY": any;
        readonly static "RULE": any;
        readonly static "NOP": any;
        readonly static "JIGSAW_REPLACEMENT": any;
        readonly static "BLOCK_AGE": any;
    }
    type StructureProcessorType_<P> = Special.StructureProcessorType | StructureProcessorType<P>;
    class ServerSettings {
        constructor()
        static exportData(): void;
        "logSkippedRecipes": boolean;
        "logErroringRecipes": boolean;
        static "instance": Internal.ServerSettings;
        "useOriginalRecipeForFilters": boolean;
        "logAddedRecipes": boolean;
        "dataPackOutput": boolean;
        "logRemovedRecipes": boolean;
        "logOverrides": boolean;
        "logInvalidRecipeHandlers": boolean;
    }
    type ServerSettings_ = ServerSettings;
    class ChestMenu extends Internal.AbstractContainerMenu {
        constructor(arg0: Internal.MenuType_<any>, arg1: number, arg2: Internal.Inventory_, arg3: Internal.Container_, arg4: number)
        static oneRow(arg0: number, arg1: Internal.Inventory_): Internal.ChestMenu;
        static threeRows(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Container_): Internal.ChestMenu;
        getRowCount(): number;
        static sixRows(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Container_): Internal.ChestMenu;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        getContainer(): Internal.Container;
        static sixRows(arg0: number, arg1: Internal.Inventory_): Internal.ChestMenu;
        static fiveRows(arg0: number, arg1: Internal.Inventory_): Internal.ChestMenu;
        static fourRows(arg0: number, arg1: Internal.Inventory_): Internal.ChestMenu;
        stillValid(arg0: Internal.Player_): boolean;
        static twoRows(arg0: number, arg1: Internal.Inventory_): Internal.ChestMenu;
        static threeRows(arg0: number, arg1: Internal.Inventory_): Internal.ChestMenu;
        removed(arg0: Internal.Player_): void;
        get rowCount(): number
        get container(): Internal.Container
    }
    type ChestMenu_ = ChestMenu;
    class GeodeCrackSettings {
        constructor(arg0: number, arg1: number, arg2: number)
        readonly static "CODEC": any;
        readonly "generateCrackChance": number;
        readonly "baseCrackSize": number;
        readonly "crackPointOffset": number;
    }
    type GeodeCrackSettings_ = GeodeCrackSettings;
    class SmithingRecipeJS extends Internal.RecipeJS {
        constructor()
        create(args: Internal.ListJS_): void;
        serialize(): void;
        deserialize(): void;
    }
    type SmithingRecipeJS_ = SmithingRecipeJS;
    class FishingLootEventJS extends Internal.LootEventJS {
        constructor(c: Internal.Map_<ResourceLocation_, Internal.JsonElement_>)
        addFishing(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        getType(): string;
        getDirectory(): string;
        get type(): string
        get directory(): string
    }
    type FishingLootEventJS_ = FishingLootEventJS;
    class BlockMatchTest extends Internal.RuleTest {
        constructor(arg0: Internal.Block_)
        test(arg0: Internal.BlockState_, arg1: Internal.Random_): boolean;
        readonly static "CODEC": any;
    }
    type BlockMatchTest_ = BlockMatchTest;
    abstract class ShoulderRidingEntity extends Internal.TamableAnimal {
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        canSitOnShoulder(): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        setEntityOnShoulder(arg0: Internal.ServerPlayer_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        tick(): void;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        set entityOnShoulder(arg0: Internal.ServerPlayer_)
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type ShoulderRidingEntity_ = ShoulderRidingEntity;
    interface RedirectModifier <S> {
        apply(arg0: Internal.CommandContext_<S>): Internal.Collection<S>;
    }
    type RedirectModifier_<S> = RedirectModifier<S> | ((arg0: Internal.CommandContext<S>)=>Internal.Collection_<S>);
    interface DragonPhaseInstance {
        doClientTick(): void;
        onHurt(arg0: Internal.DamageSource_, arg1: number): number;
        isSitting(): boolean;
        end(): void;
        getFlyTargetLocation(): Vec3;
        getFlySpeed(): number;
        getTurnSpeed(): number;
        begin(): void;
        onCrystalDestroyed(arg0: Internal.EndCrystal_, arg1: BlockPos_, arg2: Internal.DamageSource_, arg3: Internal.Player_): void;
        getPhase(): Internal.EnderDragonPhase<any>;
        doServerTick(): void;
        get sitting(): boolean
        get flyTargetLocation(): Vec3
        get flySpeed(): number
        get turnSpeed(): number
        get phase(): Internal.EnderDragonPhase<any>
    }
    type DragonPhaseInstance_ = DragonPhaseInstance;
    class PiglinArmPose extends Internal.Enum<Internal.PiglinArmPose> {
        static valueOf(arg0: string): Internal.PiglinArmPose;
        static values(): Internal.PiglinArmPose[];
        readonly static "CROSSBOW_CHARGE": Internal.PiglinArmPose;
        readonly static "DEFAULT": Internal.PiglinArmPose;
        readonly static "ADMIRING_ITEM": Internal.PiglinArmPose;
        readonly static "DANCING": Internal.PiglinArmPose;
        readonly static "ATTACKING_WITH_MELEE_WEAPON": Internal.PiglinArmPose;
        readonly static "CROSSBOW_HOLD": Internal.PiglinArmPose;
    }
    type PiglinArmPose_ = "admiring_item" | "dancing" | "crossbow_hold" | "crossbow_charge" | PiglinArmPose | "default" | "attacking_with_melee_weapon";
    class EnumProperty <T> extends Internal.Property<T> {
        static create(arg0: string, arg1: Internal.Class_<T>): Internal.EnumProperty<T>;
        static create(arg0: string, arg1: Internal.Class_<T>, arg2: Internal.Predicate_<T>): Internal.EnumProperty<T>;
        generateHashCode(): number;
        getPossibleValues(): Internal.Collection<T>;
        getName(arg0: T): string;
        getValue(arg0: string): Internal.Optional<T>;
        static create(arg0: string, arg1: Internal.Class_<T>, ...arg2: T[]): Internal.EnumProperty<T>;
        getName(arg0: Internal.Comparable_<any>): string;
        static create(arg0: string, arg1: Internal.Class_<T>, arg2: Internal.Collection_<T>): Internal.EnumProperty<T>;
        equals(arg0: any): boolean;
        get possibleValues(): Internal.Collection<T>
    }
    type EnumProperty_<T> = EnumProperty<T>;
    class OnDatapackSyncEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.PlayerList_, arg1: Internal.ServerPlayer_)
        getListenerList(): Internal.ListenerList;
        getPlayerList(): Internal.PlayerList;
        getPlayer(): Internal.ServerPlayer;
        get listenerList(): Internal.ListenerList
        get playerList(): Internal.PlayerList
        get player(): Internal.ServerPlayer
    }
    type OnDatapackSyncEvent_ = OnDatapackSyncEvent;
    class OpticParts <A, B> {
        constructor(arg0: Internal.Set_<Internal.TypeToken_<any>>, arg1: Internal.Optic_<any, any, any, A, B>)
        bounds(): Internal.Set<Internal.TypeToken<any>>;
        optic(): Internal.Optic<any, any, any, A, B>;
    }
    type OpticParts_<A, B> = OpticParts<A, B>;
    class ClientboundSoundPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.SoundEvent_, arg1: Internal.SoundSource_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number)
        handle(arg0: Internal.PacketListener_): void;
        getX(): number;
        getY(): number;
        getVolume(): number;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getZ(): number;
        getSource(): Internal.SoundSource;
        getPitch(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getSound(): Internal.SoundEvent;
        isSkippable(): boolean;
        get x(): number
        get y(): number
        get volume(): number
        get z(): number
        get source(): Internal.SoundSource
        get pitch(): number
        get sound(): Internal.SoundEvent
        get skippable(): boolean
        readonly static "LOCATION_ACCURACY": 8.0;
    }
    type ClientboundSoundPacket_ = ClientboundSoundPacket;
    class SoundManager extends Internal.SimplePreparableReloadListener<any> {
        constructor(arg0: Internal.ResourceManager_, arg1: Internal.Options_)
        play(arg0: Internal.SoundInstance_): void;
        updateSource(arg0: Internal.Camera_): void;
        queueTickingSound(arg0: Internal.TickableSoundInstance_): void;
        reload(): void;
        getSoundEvent(arg0: ResourceLocation_): Internal.WeighedSoundEvents;
        destroy(): void;
        updateSourceVolume(arg0: Internal.SoundSource_, arg1: number): void;
        getAvailableSounds(): Internal.Collection<ResourceLocation>;
        stop(arg0: Internal.SoundInstance_): void;
        resume(): void;
        getAvailableSoundDevices(): Internal.List<string>;
        getDebugString(): string;
        addListener(arg0: Internal.SoundEventListener_): void;
        removeListener(arg0: Internal.SoundEventListener_): void;
        playDelayed(arg0: Internal.SoundInstance_, arg1: number): void;
        getName(): string;
        tick(arg0: boolean): void;
        stop(): void;
        isActive(arg0: Internal.SoundInstance_): boolean;
        pause(): void;
        stop(arg0: ResourceLocation_, arg1: Internal.SoundSource_): void;
        get availableSounds(): Internal.Collection<ResourceLocation>
        get availableSoundDevices(): Internal.List<string>
        get debugString(): string
        get name(): string
        readonly static "EMPTY_SOUND": Internal.Sound;
    }
    type SoundManager_ = SoundManager;
    class FireworksJS {
        constructor()
        static of(o: any): Internal.FireworksJS;
        createFireworkRocket(w: Internal.Level_, x: number, y: number, z: number): Internal.FireworkRocketEntity;
        "lifetime": number;
        readonly "explosions": Internal.List<Internal.FireworksJS$Explosion>;
        "flight": number;
    }
    type FireworksJS_ = FireworksJS;
    interface IForgeItemStack extends Internal.ICapabilitySerializable<Internal.CompoundTag> {
        isBookEnchantable(arg0: Internal.ItemStack_): boolean;
        getEntityLifespan(arg0: Internal.Level_): number;
        onItemUseFirst(arg0: Internal.UseOnContext_): Internal.InteractionResult;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_): boolean;
        onArmorTick(arg0: Internal.Level_, arg1: Internal.Player_): void;
        elytraFlightTick(arg0: Internal.LivingEntity_, arg1: number): boolean;
        isEnderMask(arg0: Internal.Player_, arg1: Internal.EnderMan_): boolean;
        doesSneakBypassUse(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        serializeNBT(): Internal.Tag;
        isPiglinCurrency(): boolean;
        getFoodProperties(arg0: Internal.LivingEntity_): Internal.FoodProperties;
        getShareTag(): Internal.CompoundTag;
        getXpRepairRatio(): number;
        makesPiglinsNeutral(arg0: Internal.LivingEntity_): boolean;
        onUsingTick(arg0: Internal.LivingEntity_, arg1: number): void;
        areShareTagsEqual(arg0: Internal.ItemStack_): boolean;
        canWalkOnPowderedSnow(arg0: Internal.LivingEntity_): boolean;
        getEquipmentSlot(): EquipmentSlot;
        getBurnTime(arg0: Internal.RecipeType_<any>): number;
        getHighlightTip(arg0: Internal.Component_): Internal.Component;
        onEntityItemUpdate(arg0: Internal.ItemEntity_): boolean;
        canPerformAction(arg0: Internal.ToolAction_): boolean;
        hasContainerItem(): boolean;
        isRepairable(): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        readShareTag(arg0: Internal.CompoundTag_): void;
        getSweepHitBox(arg0: Internal.Player_, arg1: Internal.Entity_): Internal.AABB;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: Internal.LivingEntity_): boolean;
        onDroppedByPlayer(arg0: Internal.Player_): boolean;
        equals(arg0: Internal.ItemStack_, arg1: boolean): boolean;
        canEquip(arg0: EquipmentSlot_, arg1: Internal.Entity_): boolean;
        getContainerItem(): Internal.ItemStack;
        canApplyAtEnchantingTable(arg0: Internal.Enchantment_): boolean;
        getItemEnchantability(): number;
        onEntitySwing(arg0: Internal.LivingEntity_): boolean;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        onBlockStartBreak(arg0: BlockPos_, arg1: Internal.Player_): boolean;
        onHorseArmorTick(arg0: Internal.Level_, arg1: Internal.Mob_): void;
        canElytraFly(arg0: Internal.LivingEntity_): boolean;
        get piglinCurrency(): boolean
        get shareTag(): Internal.CompoundTag
        get xpRepairRatio(): number
        get equipmentSlot(): EquipmentSlot
        get repairable(): boolean
        get containerItem(): Internal.ItemStack
        get itemEnchantability(): number
    }
    type IForgeItemStack_ = IForgeItemStack;
    interface EventHandlerImplCommon$WorldEventAttachment {
        architectury$getAttachedLevel(): Internal.LevelAccessor;
        architectury$attachLevel(arg0: Internal.LevelAccessor_): void;
    }
    type EventHandlerImplCommon$WorldEventAttachment_ = EventHandlerImplCommon$WorldEventAttachment;
    class BlockEntityWithoutLevelRenderer implements Internal.ResourceManagerReloadListener {
        constructor(arg0: Internal.BlockEntityRenderDispatcher_, arg1: Internal.EntityModelSet_)
        getName(): string;
        onResourceManagerReload(arg0: Internal.ResourceManager_): void;
        renderByItem(arg0: Internal.ItemStack_, arg1: Internal.ItemTransforms$TransformType_, arg2: Internal.PoseStack_, arg3: Internal.MultiBufferSource_, arg4: number, arg5: number): void;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        get name(): string
    }
    type BlockEntityWithoutLevelRenderer_ = BlockEntityWithoutLevelRenderer;
    interface IntToLongFunction {
        applyAsLong(arg0: number): number;
    }
    type IntToLongFunction_ = IntToLongFunction | ((arg0: number)=>number);
    class PiglinSpecificSensor extends Internal.Sensor<Internal.LivingEntity> {
        constructor()
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
    }
    type PiglinSpecificSensor_ = PiglinSpecificSensor;
    class ServerJS implements Internal.WithAttachedData, Internal.MessageSender {
        constructor(ms: Internal.MinecraftServer_, m: any_)
        isSinglePlayer(): boolean;
        getDisplayName(): Internal.Component;
        schedule(timer: number, data: any, event: Internal.IScheduledEventCallback_): Internal.ScheduledEvent;
        getPlayer(selector: Internal.PlayerSelector_): Internal.ServerPlayerJS;
        getLevel(dimension: ResourceLocation_): Internal.ServerLevelJS;
        getAdvancement(id: ResourceLocation_): Internal.AdvancementJS;
        getHardcore(): boolean;
        schedule(timer: number, event: Internal.IScheduledEventCallback_): Internal.ScheduledEvent;
        getMotd(): string;
        getMinecraftServer(): Internal.MinecraftServer;
        getName(): Internal.Component;
        isRunning(): boolean;
        getFakePlayer(selector: Internal.PlayerSelector_): Internal.ServerPlayerJS;
        toString(): string;
        runCommandSilent(command: string): number;
        getEntities(): Internal.EntityArrayList;
        scheduleInTicks(ticks: number, event: Internal.IScheduledEventCallback_): Internal.ScheduledEvent;
        tell(message: Internal.Component_): void;
        getData(): Internal.AttachedData;
        scheduleInTicks(ticks: number, data: any, event: Internal.IScheduledEventCallback_): Internal.ScheduledEvent;
        sendDataToAll(channel: string, data: Internal.CompoundTag_): void;
        setStatusMessage(message: Internal.Component_): void;
        getPlayers(): Internal.EntityArrayList;
        getOverworld(): Internal.ServerLevelJS;
        release(): void;
        getAllLevels(): Internal.List<Internal.ServerLevelJS>;
        stop(): void;
        getEntities(filter: string): Internal.EntityArrayList;
        runCommand(command: string): number;
        updateWorldList(): void;
        isDedicated(): boolean;
        setMotd(text: Internal.Component_): void;
        get singlePlayer(): boolean
        get displayName(): Internal.Component
        get hardcore(): boolean
        get motd(): string
        get minecraftServer(): Internal.MinecraftServer
        get name(): Internal.Component
        get running(): boolean
        get entities(): Internal.EntityArrayList
        get data(): Internal.AttachedData
        set statusMessage(message: Internal.Component_)
        get players(): Internal.EntityArrayList
        get overworld(): Internal.ServerLevelJS
        get allLevels(): Internal.List<Internal.ServerLevelJS>
        get dedicated(): boolean
        set motd(text: Internal.Component_)
        "overworld": Internal.ServerLevelJS;
        static "instance": Internal.ServerJS;
        readonly "persistentData": Internal.CompoundTag;
    }
    type ServerJS_ = ServerJS;
    class SpawnData$CustomSpawnRules extends Internal.Record {
        constructor(arg0: Internal.InclusiveRange_<number>, arg1: Internal.InclusiveRange_<number>)
        hashCode(): number;
        toString(): string;
        skyLightLimit(): Internal.InclusiveRange<number>;
        blockLightLimit(): Internal.InclusiveRange<number>;
        equals(arg0: any): boolean;
        readonly static "CODEC": any;
    }
    type SpawnData$CustomSpawnRules_ = SpawnData$CustomSpawnRules;
    class Aquifer$FluidStatus {
        constructor(arg0: number, arg1: Internal.BlockState_)
        at(arg0: number): Internal.BlockState;
    }
    type Aquifer$FluidStatus_ = Aquifer$FluidStatus;
    class WorldStem extends Internal.Record implements Internal.AutoCloseable {
        constructor(arg0: Internal.CloseableResourceManager_, arg1: Internal.ReloadableServerResources_, arg2: Internal.RegistryAccess$Frozen_, arg3: Internal.WorldData_)
        registryAccess(): Internal.RegistryAccess$Frozen;
        hashCode(): number;
        dataPackResources(): Internal.ReloadableServerResources;
        toString(): string;
        static load(arg0: Internal.WorldStem$InitConfig_, arg1: Internal.WorldStem$DataPackConfigSupplier_, arg2: Internal.WorldStem$WorldDataSupplier_, arg3: Internal.Executor_, arg4: Internal.Executor_): Internal.CompletableFuture<Internal.WorldStem>;
        resourceManager(): Internal.CloseableResourceManager;
        close(): void;
        updateGlobals(): void;
        equals(arg0: any): boolean;
        worldData(): Internal.WorldData;
    }
    type WorldStem_ = WorldStem;
    class RecipesUpdatedEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.RecipeManager_)
        getRecipeManager(): Internal.RecipeManager;
        getListenerList(): Internal.ListenerList;
        get recipeManager(): Internal.RecipeManager
        get listenerList(): Internal.ListenerList
    }
    type RecipesUpdatedEvent_ = RecipesUpdatedEvent;
    interface Short2ReferenceFunction <V> extends Internal.IntFunction<V>, it.unimi.dsi.fastutil.Function<number, V> {
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Short2LongFunction;
        composeObject(arg0: Internal.Object2ShortFunction_<any>): Internal.Object2ReferenceFunction<T, V>;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Short2DoubleFunction;
        remove(arg0: number): V;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Short2ByteFunction;
        getOrDefault(arg0: any, arg1: V): V;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2ReferenceFunction<V>;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2ReferenceFunction<V>;
        composeReference(arg0: Internal.Reference2ShortFunction_<any>): Internal.Reference2ReferenceFunction<T, V>;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Short2ShortFunction;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2ReferenceFunction<V>;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        getOrDefault(arg0: number, arg1: V): V;
        andThenObject(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Short2ObjectFunction<T>;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Short2CharFunction;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2ReferenceFunction<V>;
        get(arg0: any): V;
        put(arg0: any, arg1: any): any;
        apply(arg0: number): V;
        remove(arg0: any): V;
        composeShort(arg0: Internal.Short2ShortFunction_): this;
        put(arg0: number, arg1: V): V;
        containsKey(arg0: number): boolean;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Short2IntFunction;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2ReferenceFunction<V>;
        andThenReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Short2ReferenceFunction<T>;
        put(arg0: number, arg1: V): V;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, V>;
        size(): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
        get(arg0: number): V;
        clear(): void;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2ReferenceFunction<V>;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Short2FloatFunction;
        defaultReturnValue(): V;
        defaultReturnValue(arg0: V): void;
    }
    type Short2ReferenceFunction_<V> = ((arg0: number)=>V) | Short2ReferenceFunction<V>;
    interface FloatBinaryOperator extends Internal.DoubleBinaryOperator, Internal.BinaryOperator<number> {
        apply(arg0: number, arg1: number): number;
        apply(arg0: any, arg1: any): any;
        applyAsDouble(arg0: number, arg1: number): number;
        apply(arg0: number, arg1: number): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.BiFunction<number, number, V>;
    }
    type FloatBinaryOperator_ = FloatBinaryOperator | ((arg0: number, arg1: number)=>number);
    class Minecart extends Internal.AbstractMinecart {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        isPoweredCart(): boolean;
        activateMinecart(arg0: number, arg1: number, arg2: number, arg3: boolean): void;
        getCurrentRailPosition(): BlockPos;
        getMaxCartSpeedOnRail(): number;
        interact(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        getSlopeAdjustment(): number;
        shouldDoRailFunctions(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        canBeRidden(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getCartItem(): Internal.ItemStack;
        getMinecartType(): Internal.AbstractMinecart$Type;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getComparatorLevel(): number;
        get poweredCart(): boolean
        get currentRailPosition(): BlockPos
        get maxCartSpeedOnRail(): number
        get stepHeight(): number
        get slopeAdjustment(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get cartItem(): Internal.ItemStack
        get minecartType(): Internal.AbstractMinecart$Type
        get comparatorLevel(): number
    }
    type Minecart_ = Minecart;
    class ClientboundEntityEventPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.Entity_, arg1: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getEventId(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getEntity(arg0: Internal.Level_): Internal.Entity;
        isSkippable(): boolean;
        get eventId(): number
        get skippable(): boolean
    }
    type ClientboundEntityEventPacket_ = ClientboundEntityEventPacket;
    interface CubicSpline$CoordinateVisitor <C> {
        visit(arg0: Internal.ToFloatFunction_<C>): Internal.ToFloatFunction<C>;
    }
    type CubicSpline$CoordinateVisitor_<C> = CubicSpline$CoordinateVisitor<C>;
    class ShipwreckConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: boolean)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "isBeached": boolean;
        readonly static "CODEC": any;
    }
    type ShipwreckConfiguration_ = ShipwreckConfiguration;
    class FoliagePlacerType <P> extends Internal.ForgeRegistryEntry<Internal.FoliagePlacerType<any>> {
        constructor(arg0: Internal.Codec_<P>)
        codec(): Internal.Codec<P>;
        readonly static "MEGA_JUNGLE_FOLIAGE_PLACER": Internal.FoliagePlacerType<any>;
        readonly static "FANCY_FOLIAGE_PLACER": Internal.FoliagePlacerType<any>;
        readonly static "RANDOM_SPREAD_FOLIAGE_PLACER": Internal.FoliagePlacerType<any>;
        readonly static "DARK_OAK_FOLIAGE_PLACER": Internal.FoliagePlacerType<any>;
        readonly static "SPRUCE_FOLIAGE_PLACER": Internal.FoliagePlacerType<any>;
        readonly static "BLOB_FOLIAGE_PLACER": Internal.FoliagePlacerType<any>;
        readonly static "PINE_FOLIAGE_PLACER": Internal.FoliagePlacerType<any>;
        readonly static "MEGA_PINE_FOLIAGE_PLACER": Internal.FoliagePlacerType<any>;
        readonly static "ACACIA_FOLIAGE_PLACER": Internal.FoliagePlacerType<any>;
        readonly static "BUSH_FOLIAGE_PLACER": Internal.FoliagePlacerType<any>;
    }
    type FoliagePlacerType_<P> = FoliagePlacerType<P> | Special.FoliagePlacerType;
    class EventObject implements Internal.Serializable {
        constructor(arg0: any)
        toString(): string;
        getSource(): any;
        get source(): any
    }
    type EventObject_ = EventObject;
    interface NarratableEntry extends Internal.NarrationSupplier {
        narrationPriority(): Internal.NarratableEntry$NarrationPriority;
        isActive(): boolean;
        get active(): boolean
    }
    type NarratableEntry_ = NarratableEntry;
    abstract class IntBuffer extends Internal.Buffer implements Internal.Comparable<Internal.IntBuffer> {
        put(arg0: number, arg1: Internal.IntBuffer_, arg2: number, arg3: number): this;
        reset(): Internal.Buffer;
        isDirect(): boolean;
        arrayOffset(): number;
        compareTo(arg0: any): number;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.IntBuffer;
        flip(): Internal.Buffer;
        clear(): Internal.Buffer;
        order(): Internal.ByteOrder;
        static wrap(arg0: number[]): Internal.IntBuffer;
        put(arg0: Internal.IntBuffer_): this;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): this;
        hasArray(): boolean;
        compareTo(arg0: Internal.IntBuffer_): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): this;
        mismatch(arg0: Internal.IntBuffer_): number;
        put(arg0: number[]): this;
        toString(): string;
        put(arg0: number): this;
        rewind(): Internal.Buffer;
        compact(): this;
        static allocate(arg0: number): Internal.IntBuffer;
        duplicate(): this;
        mark(): Internal.Buffer;
        hashCode(): number;
        slice(): Internal.Buffer;
        put(arg0: number[], arg1: number, arg2: number): this;
        get(arg0: number, arg1: number[]): this;
        put(arg0: number, arg1: number): this;
        get(arg0: number): number;
        put(arg0: number, arg1: number[]): this;
        asReadOnlyBuffer(): this;
        slice(arg0: number, arg1: number): Internal.Buffer;
        limit(arg0: number): this;
        position(arg0: number): this;
        get(arg0: number[]): this;
        equals(arg0: any): boolean;
        get(arg0: number[], arg1: number, arg2: number): this;
        array(): number[];
        get(): number;
        get direct(): boolean
    }
    type IntBuffer_ = IntBuffer;
    class ClassDataCache {
        constructor(d: Internal.SharedContextData_)
        of(c: Internal.Class_<any>): Internal.ClassData;
        readonly "data": Internal.SharedContextData;
    }
    type ClassDataCache_ = ClassDataCache;
    class ChunkStatus$ChunkType extends Internal.Enum<Internal.ChunkStatus$ChunkType> {
        static values(): Internal.ChunkStatus$ChunkType[];
        static valueOf(arg0: string): Internal.ChunkStatus$ChunkType;
        readonly static "PROTOCHUNK": Internal.ChunkStatus$ChunkType;
        readonly static "LEVELCHUNK": Internal.ChunkStatus$ChunkType;
    }
    type ChunkStatus$ChunkType_ = ChunkStatus$ChunkType | "levelchunk" | "protochunk";
    class RecordItem extends Internal.Item {
        constructor(arg0: number, arg1: Internal.Supplier_<Internal.SoundEvent_>, arg2: Internal.Item$Properties_)
        constructor(arg0: number, arg1: Internal.SoundEvent_, arg2: Internal.Item$Properties_)
        getMaxDamage(arg0: Internal.ItemStack_): number;
        elytraFlightTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getShareTag(arg0: Internal.ItemStack_): Internal.CompoundTag;
        isDamageable(arg0: Internal.ItemStack_): boolean;
        isEnderMask(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.EnderMan_): boolean;
        getBurnTime(arg0: Internal.ItemStack_, arg1: Internal.RecipeType_<any>): number;
        onItemUseFirst(arg0: Internal.ItemStack_, arg1: Internal.UseOnContext_): Internal.InteractionResult;
        onUsingTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack_): boolean;
        isCorrectToolForDrops(arg0: Internal.ItemStack_, arg1: Internal.BlockState_): boolean;
        getItemStackLimit(arg0: Internal.ItemStack_): number;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_, arg3: Internal.LivingEntity_): boolean;
        appendHoverText(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.List_<Internal.Component_>, arg3: Internal.TooltipFlag_): void;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_, arg1: Internal.Enchantment_): boolean;
        canWalkOnPowderedSnow(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        hasContainerItem(arg0: Internal.ItemStack_): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        getXpRepairRatio(arg0: Internal.ItemStack_): number;
        isBookEnchantable(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        initCapabilities(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): Internal.ICapabilityProvider;
        onDroppedByPlayer(arg0: Internal.ItemStack_, arg1: Internal.Player_): boolean;
        isDamaged(arg0: Internal.ItemStack_): boolean;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack_): number;
        getCreatorModId(arg0: Internal.ItemStack_): string;
        canContinueUsing(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getFoodProperties(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): Internal.FoodProperties;
        getHighlightTip(arg0: Internal.ItemStack_, arg1: Internal.Component_): Internal.Component;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        onLeftClickEntity(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): boolean;
        canEquip(arg0: Internal.ItemStack_, arg1: EquipmentSlot_, arg2: Internal.Entity_): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        canPerformAction(arg0: Internal.ItemStack_, arg1: Internal.ToolAction_): boolean;
        getItemEnchantability(arg0: Internal.ItemStack_): number;
        hasCustomEntity(arg0: Internal.ItemStack_): boolean;
        onEntityItemUpdate(arg0: Internal.ItemStack_, arg1: Internal.ItemEntity_): boolean;
        getSound(): Internal.SoundEvent;
        getDamage(arg0: Internal.ItemStack_): number;
        onArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Player_): void;
        readShareTag(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): void;
        useOn(arg0: Internal.UseOnContext_): Internal.InteractionResult;
        getEquipmentSlot(arg0: Internal.ItemStack_): EquipmentSlot;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        damageItem(arg0: Internal.ItemStack_, arg1: number, arg2: T, arg3: Internal.Consumer_<T>): number;
        arch$registryName(): ResourceLocation;
        getAttributeModifiers(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        arch$holder(): Internal.Holder<Internal.Item>;
        canElytraFly(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getArmorTexture(arg0: Internal.ItemStack_, arg1: Internal.Entity_, arg2: EquipmentSlot_, arg3: string): string;
        createEntity(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.ItemStack_): Internal.Entity;
        static getBySound(arg0: Internal.SoundEvent_): Internal.RecordItem;
        onEntitySwing(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getEntityLifespan(arg0: Internal.ItemStack_, arg1: Internal.Level_): number;
        getDisplayName(): Internal.MutableComponent;
        setDamage(arg0: Internal.ItemStack_, arg1: number): void;
        getSweepHitBox(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): Internal.AABB;
        getAnalogOutput(): number;
        doesSneakBypassUse(arg0: Internal.ItemStack_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: boolean): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Mob_): void;
        getContainerItem(arg0: Internal.ItemStack_): Internal.ItemStack;
        onBlockStartBreak(arg0: Internal.ItemStack_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>
        get sound(): Internal.SoundEvent
        get displayName(): Internal.MutableComponent
        get analogOutput(): number
        /**
         * @java.lang.Deprecated(forRemoval=false, since="")
        */
        readonly static "BY_NAME": {[key: Internal.SoundEvent]: Internal.RecordItem, [key: Internal.SoundEvent]: Internal.RecordItem, [key: Internal.SoundEvent]: Internal.RecordItem, [key: Internal.SoundEvent]: Internal.RecordItem, [key: Internal.SoundEvent]: Internal.RecordItem, [key: Internal.SoundEvent]: Internal.RecordItem, [key: Internal.SoundEvent]: Internal.RecordItem, [key: Internal.SoundEvent]: Internal.RecordItem, [key: Internal.SoundEvent]: Internal.RecordItem, [key: Internal.SoundEvent]: Internal.RecordItem, [key: Internal.SoundEvent]: Internal.RecordItem, [key: Internal.SoundEvent]: Internal.RecordItem, [key: Internal.SoundEvent]: Internal.RecordItem, [key: Internal.SoundEvent]: Internal.RecordItem};
    }
    type RecordItem_ = RecordItem;
    class NonNullList <E> extends Internal.AbstractList<E> {
        get(arg0: number): E;
        replaceAll(arg0: Internal.UnaryOperator_<E>): void;
        static createWithCapacity(arg0: number): Internal.NonNullList<E>;
        add(arg0: number, arg1: E): void;
        forEach(arg0: Internal.Consumer_<any>): void;
        parallelStream(): Internal.Stream<E>;
        sort(arg0: Internal.Comparator_<any>): void;
        static of(arg0: E, ...arg1: E[]): Internal.NonNullList<E>;
        set(arg0: number, arg1: E): E;
        size(): number;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        stream(): Internal.Stream<E>;
        static withSize(arg0: number, arg1: E): Internal.NonNullList<E>;
        clear(): void;
        spliterator(): Internal.Spliterator<E>;
        remove(arg0: number): E;
        static create(): Internal.NonNullList<E>;
    }
    type NonNullList_<E> = NonNullList<E>;
    class JigsawBlockEntity extends Internal.BlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        getTarget(): ResourceLocation;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getUpdateTag(): Internal.CompoundTag;
        getJoint(): Internal.JigsawBlockEntity$JointType;
        getName(): ResourceLocation;
        getPool(): ResourceLocation;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        setName(arg0: ResourceLocation_): void;
        setPool(arg0: ResourceLocation_): void;
        serializeNBT(): Internal.CompoundTag;
        generate(arg0: Internal.ServerLevel_, arg1: number, arg2: boolean): void;
        setTarget(arg0: ResourceLocation_): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        load(arg0: Internal.CompoundTag_): void;
        getUpdatePacket(): Internal.Packet<any>;
        getFinalState(): string;
        setJoint(arg0: Internal.JigsawBlockEntity$JointType_): void;
        onLoad(): void;
        setFinalState(arg0: string): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get target(): ResourceLocation
        get modelData(): Internal.IModelData
        get updateTag(): Internal.CompoundTag
        get joint(): Internal.JigsawBlockEntity$JointType
        get name(): ResourceLocation
        get pool(): ResourceLocation
        set name(arg0: ResourceLocation_)
        set pool(arg0: ResourceLocation_)
        set target(arg0: ResourceLocation_)
        get updatePacket(): Internal.Packet<any>
        get finalState(): string
        set joint(arg0: Internal.JigsawBlockEntity$JointType_)
        set finalState(arg0: string)
        get renderBoundingBox(): Internal.AABB
        readonly static "NAME": "name";
        readonly static "POOL": "pool";
        readonly static "JOINT": "joint";
        readonly static "TARGET": "target";
        readonly static "FINAL_STATE": "final_state";
    }
    type JigsawBlockEntity_ = JigsawBlockEntity;
    interface HeadedModel {
        getHead(): Internal.ModelPart;
        get head(): Internal.ModelPart
    }
    type HeadedModel_ = HeadedModel;
    abstract class ImmutableCollection$Builder <E> {
        build(): Internal.ImmutableCollection<E>;
        addAll(arg0: Internal.Iterable_<any>): this;
        add(...arg0: E[]): this;
        add(arg0: E): this;
        addAll(arg0: Internal.Iterator_<any>): this;
    }
    type ImmutableCollection$Builder_<E> = ImmutableCollection$Builder<E>;
    class SpruceFoliagePlacer extends Internal.FoliagePlacer {
        constructor(arg0: Internal.IntProvider_, arg1: Internal.IntProvider_, arg2: Internal.IntProvider_)
        foliageHeight(arg0: Internal.Random_, arg1: number, arg2: Internal.TreeConfiguration_): number;
        readonly static "CODEC": any;
    }
    type SpruceFoliagePlacer_ = SpruceFoliagePlacer;
    abstract class BlockableEventLoop <R> implements Internal.ProfilerMeasured, Internal.Executor, Internal.ProcessorHandle<R> {
        executeIfPossible(arg0: Internal.Runnable_): void;
        tell(arg0: any): void;
        pollTask(): boolean;
        submit(arg0: Internal.Supplier_<V>): Internal.CompletableFuture<V>;
        ask(arg0: Internal.Function_<any, any>): Internal.CompletableFuture<Source>;
        executeBlocking(arg0: Internal.Runnable_): void;
        getPendingTasksCount(): number;
        profiledMetrics(): Internal.List<Internal.MetricSampler>;
        name(): string;
        submit(arg0: Internal.Runnable_): Internal.CompletableFuture<void>;
        close(): void;
        execute(arg0: Internal.Runnable_): void;
        submitAsync(arg0: Internal.Runnable_): Internal.CompletableFuture<void>;
        askEither(arg0: Internal.Function_<any, any>): Internal.CompletableFuture<Source>;
        isSameThread(): boolean;
        managedBlock(arg0: Internal.BooleanSupplier_): void;
        tell(arg0: R): void;
        get pendingTasksCount(): number
        get sameThread(): boolean
    }
    type BlockableEventLoop_<R> = BlockableEventLoop<R>;
    interface RecipeFilter extends Internal.Predicate<Internal.RecipeJS> {
        test(arg0: any): boolean;
        negate(): Internal.Predicate<Internal.RecipeJS>;
        or(arg0: Internal.Predicate_<any>): Internal.Predicate<Internal.RecipeJS>;
        test(arg0: Internal.RecipeJS_): boolean;
        and(arg0: Internal.Predicate_<any>): Internal.Predicate<Internal.RecipeJS>;
        of(o: any): this;
        readonly static "ALWAYS_FALSE": any;
        readonly static "ALWAYS_TRUE": any;
    }
    type RecipeFilter_ = RecipeFilter | ((arg0: Internal.RecipeJS)=>boolean);
    class EnderMan extends Internal.Monster implements Internal.NeutralMob {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        playerDied(arg0: Internal.Player_): void;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        isAngry(): boolean;
        getStepHeight(): number;
        requiresCustomPersistence(): boolean;
        forgetCurrentTargetAndRefreshUniversalAnger(): void;
        asKJS(): Internal.EntityJS;
        startPersistentAngerTimer(): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        setTarget(arg0: Internal.LivingEntity_): void;
        addPersistentAngerSaveData(arg0: Internal.CompoundTag_): void;
        isMultipartEntity(): boolean;
        setRemainingPersistentAngerTime(arg0: number): void;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        isAngryAt(arg0: Internal.LivingEntity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getRemainingPersistentAngerTime(): number;
        hasBeenStaredAt(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getPersistentAngerTarget(): Internal.UUID;
        playStareSound(): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isCreepy(): boolean;
        readPersistentAngerSaveData(arg0: Internal.Level_, arg1: Internal.CompoundTag_): void;
        isSensitiveToWater(): boolean;
        stopBeingAngry(): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        setPersistentAngerTarget(arg0: Internal.UUID_): void;
        updatePersistentAnger(arg0: Internal.ServerLevel_, arg1: boolean): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        setBeingStaredAt(): void;
        isAngryAtAllPlayers(arg0: Internal.Level_): boolean;
        setCarriedBlock(arg0: Internal.BlockState_): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        getCarriedBlock(): Internal.BlockState;
        get angry(): boolean
        get stepHeight(): number
        set target(arg0: Internal.LivingEntity_)
        get multipartEntity(): boolean
        set remainingPersistentAngerTime(arg0: number)
        get parts(): Internal.PartEntity<any>[]
        get remainingPersistentAngerTime(): number
        get persistentAngerTarget(): Internal.UUID
        get creepy(): boolean
        get sensitiveToWater(): boolean
        set persistentAngerTarget(arg0: Internal.UUID_)
        set carriedBlock(arg0: Internal.BlockState_)
        get carriedBlock(): Internal.BlockState
    }
    type EnderMan_ = EnderMan;
    interface NonNullFunction <T, R> {
        apply(arg0: T): R;
    }
    type NonNullFunction_<T, R> = ((arg0: T)=>R) | NonNullFunction<T, R>;
    interface ModelPart$Visitor {
        visit(arg0: Internal.PoseStack$Pose_, arg1: string, arg2: number, arg3: Internal.ModelPart$Cube_): void;
    }
    type ModelPart$Visitor_ = ((arg0: Internal.PoseStack$Pose, arg1: string, arg2: number, arg3: Internal.ModelPart$Cube)=>void) | ModelPart$Visitor;
    class ClientboundTeleportEntityPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: Internal.Entity_)
        handle(arg0: Internal.PacketListener_): void;
        getX(): number;
        getY(): number;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getZ(): number;
        getxRot(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getyRot(): number;
        isOnGround(): boolean;
        isSkippable(): boolean;
        getId(): number;
        get x(): number
        get y(): number
        get z(): number
        get xRot(): number
        get yRot(): number
        get onGround(): boolean
        get skippable(): boolean
        get id(): number
    }
    type ClientboundTeleportEntityPacket_ = ClientboundTeleportEntityPacket;
    class CookingRecipeJS extends Internal.RecipeJS {
        constructor()
        create(args: Internal.ListJS_): void;
        xp(xp: number): this;
        serialize(): void;
        cookingTime(time: number): this;
        deserialize(): void;
    }
    type CookingRecipeJS_ = CookingRecipeJS;
    interface ProcessorHandle <Msg> extends Internal.AutoCloseable {
        name(): string;
        tell(arg0: Msg): void;
        ask(arg0: Internal.Function_<any, any>): Internal.CompletableFuture<Source>;
        of(arg0: string, arg1: Internal.Consumer_<Msg>): this;
        close(): void;
        askEither(arg0: Internal.Function_<any, any>): Internal.CompletableFuture<Source>;
    }
    type ProcessorHandle_<Msg> = ProcessorHandle<Msg>;
    class CartographyTableMenu extends Internal.AbstractContainerMenu {
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: any_)
        constructor(arg0: number, arg1: Internal.Inventory_)
        stillValid(arg0: Internal.Player_): boolean;
        canTakeItemForPickAll(arg0: Internal.ItemStack_, arg1: Internal.Slot_): boolean;
        slotsChanged(arg0: Internal.Container_): void;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        removed(arg0: Internal.Player_): void;
        readonly static "RESULT_SLOT": 2;
        readonly static "MAP_SLOT": 0;
        readonly "container": Internal.Container;
        readonly static "ADDITIONAL_SLOT": 1;
    }
    type CartographyTableMenu_ = CartographyTableMenu;
    interface IntStream extends Internal.BaseStream<number, Internal.IntStream> {
        concat(arg0: Internal.IntStream_, arg1: Internal.IntStream_): this;
        range(arg0: number, arg1: number): this;
        collect(arg0: Internal.Supplier_<R>, arg1: Internal.ObjIntConsumer_<R>, arg2: Internal.BiConsumer_<R, R>): R;
        spliterator(): Internal.Spliterator$OfInt;
        min(): Internal.OptionalInt;
        mapToDouble(arg0: Internal.IntToDoubleFunction_): Internal.DoubleStream;
        map(arg0: Internal.IntUnaryOperator_): this;
        sorted(): this;
        forEach(arg0: Internal.IntConsumer_): void;
        toArray(): number[];
        noneMatch(arg0: Internal.IntPredicate_): boolean;
        generate(arg0: Internal.IntSupplier_): this;
        sequential(): Internal.BaseStream<any, any>;
        builder(): Internal.IntStream$Builder;
        sum(): number;
        empty(): this;
        findFirst(): Internal.OptionalInt;
        max(): Internal.OptionalInt;
        dropWhile(arg0: Internal.IntPredicate_): this;
        rangeClosed(arg0: number, arg1: number): this;
        count(): number;
        findAny(): Internal.OptionalInt;
        iterator(): Internal.Iterator<any>;
        parallel(): this;
        mapMulti(arg0: Internal.IntStream$IntMapMultiConsumer_): this;
        limit(arg0: number): this;
        reduce(arg0: Internal.IntBinaryOperator_): Internal.OptionalInt;
        of(arg0: number): this;
        asDoubleStream(): Internal.DoubleStream;
        of(...arg0: number[]): this;
        allMatch(arg0: Internal.IntPredicate_): boolean;
        mapToLong(arg0: Internal.IntToLongFunction_): Internal.LongStream;
        iterate(arg0: number, arg1: Internal.IntUnaryOperator_): this;
        mapToObj(arg0: Internal.IntFunction_<any>): Internal.Stream<U>;
        asLongStream(): Internal.LongStream;
        boxed(): Internal.Stream<number>;
        forEachOrdered(arg0: Internal.IntConsumer_): void;
        reduce(arg0: number, arg1: Internal.IntBinaryOperator_): number;
        flatMap(arg0: Internal.IntFunction_<any>): this;
        summaryStatistics(): Internal.IntSummaryStatistics;
        anyMatch(arg0: Internal.IntPredicate_): boolean;
        average(): Internal.OptionalDouble;
        distinct(): this;
        iterate(arg0: number, arg1: Internal.IntPredicate_, arg2: Internal.IntUnaryOperator_): this;
        filter(arg0: Internal.IntPredicate_): this;
        takeWhile(arg0: Internal.IntPredicate_): this;
        peek(arg0: Internal.IntConsumer_): this;
        skip(arg0: number): this;
    }
    type IntStream_ = IntStream;
    interface BlockEntityTicker <T> {
        tick(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: T): void;
    }
    type BlockEntityTicker_<T> = BlockEntityTicker<T> | ((arg0: Internal.Level, arg1: BlockPos, arg2: Internal.BlockState, arg3: T)=>void);
    interface ClimateProperties {
        getDownfall(): number;
        getTemperatureModifier(): Internal.Biome$TemperatureModifier;
        getPrecipitation(): Internal.Biome$Precipitation;
        getTemperature(): number;
        get downfall(): number
        get temperatureModifier(): Internal.Biome$TemperatureModifier
        get precipitation(): Internal.Biome$Precipitation
        get temperature(): number
    }
    type ClimateProperties_ = ClimateProperties;
    interface IForgeRegistryEntry <V> {
        getRegistryType(): Internal.Class<V>;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): V;
        get registryType(): Internal.Class<V>
        get registryName(): ResourceLocation
        set registryName(arg0: ResourceLocation_)
    }
    type IForgeRegistryEntry_<V> = IForgeRegistryEntry<V>;
    class AbstractUniform {
        constructor()
        setMat2x2(arg0: number, arg1: number, arg2: number, arg3: number): void;
        set(arg0: number, arg1: number, arg2: number): void;
        setMat3x4(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number, arg11: number): void;
        set(arg0: number): void;
        setSafe(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setMat3x2(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        set(arg0: number, arg1: number, arg2: number, arg3: number): void;
        set(arg0: Internal.Matrix3f_): void;
        setMat3x3(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number): void;
        set(arg0: Internal.Matrix4f_): void;
        set(arg0: number): void;
        set(arg0: number, arg1: number, arg2: number): void;
        set(arg0: number[]): void;
        setMat4x3(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number, arg11: number): void;
        set(arg0: Internal.Vector3f_): void;
        set(arg0: Internal.Vector4f_): void;
        setMat4x2(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        set(arg0: number, arg1: number): void;
        setMat4x4(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number, arg11: number, arg12: number, arg13: number, arg14: number, arg15: number): void;
        setMat2x4(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        setSafe(arg0: number, arg1: number, arg2: number, arg3: number): void;
        set(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setMat2x3(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        set(arg0: number, arg1: number): void;
    }
    type AbstractUniform_ = AbstractUniform;
    interface MethodTypeDesc extends Internal.ConstantDesc, Internal.TypeDescriptor$OfMethod<Internal.ClassDesc, Internal.MethodTypeDesc> {
        displayDescriptor(): string;
        dropParameterTypes(arg0: number, arg1: number): Internal.TypeDescriptor$OfMethod<any, any>;
        descriptorString(): string;
        parameterCount(): number;
        returnType(): Internal.ClassDesc;
        changeReturnType(arg0: Internal.ClassDesc_): this;
        insertParameterTypes(arg0: number, arg1: Internal.TypeDescriptor$OfField_<any>[]): Internal.TypeDescriptor$OfMethod<any, any>;
        of(arg0: Internal.ClassDesc_, ...arg1: Internal.ClassDesc_[]): this;
        parameterList(): Internal.List<Internal.ClassDesc>;
        changeParameterType(arg0: number, arg1: Internal.TypeDescriptor$OfField_<any>): Internal.TypeDescriptor$OfMethod<any, any>;
        changeParameterType(arg0: number, arg1: Internal.ClassDesc_): this;
        parameterType(arg0: number): Internal.TypeDescriptor$OfField<any>;
        changeReturnType(arg0: Internal.TypeDescriptor$OfField_<any>): Internal.TypeDescriptor$OfMethod<any, any>;
        equals(arg0: any): boolean;
        ofDescriptor(arg0: string): this;
        insertParameterTypes(arg0: number, ...arg1: Internal.ClassDesc_[]): this;
        parameterArray(): Internal.ClassDesc[];
    }
    type MethodTypeDesc_ = MethodTypeDesc;
    class Typed <A> {
        constructor(arg0: com.mojang.datafixers.types.Type_<A>, arg1: Internal.DynamicOps_<any>, arg2: A)
        getAllTyped(arg0: Internal.OpticFinder_<FT>): Internal.List<Internal.Typed<FT>>;
        updateTyped(arg0: Internal.OpticFinder_<FT>, arg1: com.mojang.datafixers.types.Type_<FR>, arg2: Internal.Function_<Internal.Typed_<any>, Internal.Typed_<any>>): Internal.Typed<any>;
        write(): Internal.DataResult<any>;
        getValue(): A;
        inj2(arg0: com.mojang.datafixers.types.Type_<B>): Internal.Typed<Internal.Either<B, A>>;
        getType(): com.mojang.datafixers.types.Type<A>;
        updateRecursive(arg0: Internal.OpticFinder_<FT>, arg1: Internal.Function_<FT, FT>): Internal.Typed<any>;
        out(): this;
        getOrCreateTyped(arg0: Internal.OpticFinder_<FT>): Internal.Typed<FT>;
        getTyped(arg0: Internal.OpticFinder_<FT>): Internal.Typed<FT>;
        getAll(arg0: Internal.TypedOptic_<A, any, FT, any>): Internal.List<FT>;
        getOptional(arg0: Internal.OpticFinder_<FT>): Internal.Optional<FT>;
        getOptionalTyped(arg0: Internal.OpticFinder_<FT>): Internal.Optional<Internal.Typed<FT>>;
        update(arg0: Internal.OpticFinder_<FT>, arg1: Internal.Function_<FT, FT>): Internal.Typed<any>;
        updateRecursiveTyped(arg0: Internal.OpticFinder_<FT>, arg1: com.mojang.datafixers.types.Type_<FR>, arg2: Internal.Function_<Internal.Typed_<any>, Internal.Typed_<any>>): Internal.Typed<any>;
        updateTyped(arg0: Internal.OpticFinder_<FT>, arg1: Internal.Function_<Internal.Typed_<any>, Internal.Typed_<any>>): Internal.Typed<any>;
        getOps(): Internal.DynamicOps<any>;
        toString(): string;
        inj1(arg0: com.mojang.datafixers.types.Type_<B>): Internal.Typed<Internal.Either<A, B>>;
        updateRecursive(arg0: Internal.OpticFinder_<FT>, arg1: com.mojang.datafixers.types.Type_<FR>, arg2: Internal.Function_<FT, FR>): Internal.Typed<any>;
        getOrCreate(arg0: Internal.OpticFinder_<FT>): FT;
        updateRecursiveTyped(arg0: Internal.OpticFinder_<FT>, arg1: Internal.Function_<Internal.Typed_<any>, Internal.Typed_<any>>): Internal.Typed<any>;
        set(arg0: Internal.OpticFinder_<FT>, arg1: com.mojang.datafixers.types.Type_<FR>, arg2: FR): Internal.Typed<any>;
        getOrDefault(arg0: Internal.OpticFinder_<FT>, arg1: FT): FT;
        static pair(arg0: Internal.Typed_<A>, arg1: Internal.Typed_<B>): Internal.Typed<com.mojang.datafixers.util.Pair<A, B>>;
        get(arg0: Internal.OpticFinder_<FT>): FT;
        update(arg0: Internal.OpticFinder_<FT>, arg1: com.mojang.datafixers.types.Type_<FR>, arg2: Internal.Function_<FT, FR>): Internal.Typed<any>;
        set(arg0: Internal.OpticFinder_<FT>, arg1: FT): Internal.Typed<any>;
        set(arg0: Internal.OpticFinder_<FT>, arg1: Internal.Typed_<FR>): Internal.Typed<any>;
        get value(): A
        get type(): com.mojang.datafixers.types.Type<A>
        get ops(): Internal.DynamicOps<any>
    }
    type Typed_<A> = Typed<A>;
    class IronGolem$Crackiness extends Internal.Enum<Internal.IronGolem$Crackiness> {
        static valueOf(arg0: string): Internal.IronGolem$Crackiness;
        static values(): Internal.IronGolem$Crackiness[];
        static byFraction(arg0: number): Internal.IronGolem$Crackiness;
        readonly static "NONE": Internal.IronGolem$Crackiness;
        readonly static "LOW": Internal.IronGolem$Crackiness;
        readonly static "HIGH": Internal.IronGolem$Crackiness;
        readonly static "MEDIUM": Internal.IronGolem$Crackiness;
    }
    type IronGolem$Crackiness_ = "medium" | "high" | "low" | "none" | IronGolem$Crackiness;
    interface BorderChangeListener {
        onBorderSetDamageSafeZOne(arg0: Internal.WorldBorder_, arg1: number): void;
        onBorderSizeLerping(arg0: Internal.WorldBorder_, arg1: number, arg2: number, arg3: number): void;
        onBorderCenterSet(arg0: Internal.WorldBorder_, arg1: number, arg2: number): void;
        onBorderSizeSet(arg0: Internal.WorldBorder_, arg1: number): void;
        onBorderSetDamagePerBlock(arg0: Internal.WorldBorder_, arg1: number): void;
        onBorderSetWarningBlocks(arg0: Internal.WorldBorder_, arg1: number): void;
        onBorderSetWarningTime(arg0: Internal.WorldBorder_, arg1: number): void;
    }
    type BorderChangeListener_ = BorderChangeListener;
    class JsonPrimitive extends Internal.JsonElement {
        constructor(arg0: string)
        constructor(arg0: Internal.Number_)
        constructor(arg0: boolean)
        constructor(arg0: string)
        getAsBigDecimal(): Internal.BigDecimal;
        getAsBigInteger(): Internal.BigInteger;
        isBoolean(): boolean;
        getAsDouble(): number;
        getAsCharacter(): string;
        getAsFloat(): number;
        getAsLong(): number;
        isString(): boolean;
        getAsString(): string;
        getAsInt(): number;
        hashCode(): number;
        getAsByte(): number;
        getAsNumber(): Internal.Number;
        deepCopy(): Internal.JsonElement;
        isNumber(): boolean;
        getAsShort(): number;
        equals(arg0: any): boolean;
        getAsBoolean(): boolean;
        get asBigDecimal(): Internal.BigDecimal
        get asBigInteger(): Internal.BigInteger
        get boolean(): boolean
        get asDouble(): number
        get asCharacter(): string
        get asFloat(): number
        get asLong(): number
        get string(): boolean
        get asString(): string
        get asInt(): number
        get asByte(): number
        get asNumber(): Internal.Number
        get number(): boolean
        get asShort(): number
        get asBoolean(): boolean
    }
    type JsonPrimitive_ = JsonPrimitive;
    class HurtBySensor extends Internal.Sensor<Internal.LivingEntity> {
        constructor()
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
    }
    type HurtBySensor_ = HurtBySensor;
    interface LongFunction <R> {
        apply(arg0: number): R;
    }
    type LongFunction_<R> = LongFunction<R> | ((arg0: number)=>R);
    interface Saddleable {
        equipSaddle(arg0: Internal.SoundSource_): void;
        isSaddled(): boolean;
        isSaddleable(): boolean;
        get saddled(): boolean
        get saddleable(): boolean
    }
    type Saddleable_ = Saddleable;
    class DataPackConfig {
        constructor(arg0: Internal.List_<string>, arg1: Internal.List_<string>)
        getEnabled(): Internal.List<string>;
        addModPacks(arg0: Internal.List_<string>): void;
        getDisabled(): Internal.List<string>;
        get enabled(): Internal.List<string>
        get disabled(): Internal.List<string>
        readonly static "CODEC": any;
        readonly static "DEFAULT": Internal.DataPackConfig;
    }
    type DataPackConfig_ = DataPackConfig;
    class Month extends Internal.Enum<Internal.Month> implements Internal.TemporalAccessor, Internal.TemporalAdjuster {
        static of(arg0: number): Internal.Month;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        static values(): Internal.Month[];
        minLength(): number;
        query(arg0: Internal.TemporalQuery_<R>): R;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        minus(arg0: number): this;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        length(arg0: boolean): number;
        static from(arg0: Internal.TemporalAccessor_): Internal.Month;
        get(arg0: Internal.TemporalField_): number;
        plus(arg0: number): this;
        firstMonthOfQuarter(): this;
        getLong(arg0: Internal.TemporalField_): number;
        firstDayOfYear(arg0: boolean): number;
        maxLength(): number;
        getValue(): number;
        static valueOf(arg0: string): Internal.Month;
        isSupported(arg0: Internal.TemporalField_): boolean;
        get value(): number
        readonly static "JANUARY": Internal.Month;
        readonly static "JUNE": Internal.Month;
        readonly static "FEBRUARY": Internal.Month;
        readonly static "APRIL": Internal.Month;
        readonly static "MAY": Internal.Month;
        readonly static "MARCH": Internal.Month;
        readonly static "AUGUST": Internal.Month;
        readonly static "OCTOBER": Internal.Month;
        readonly static "JULY": Internal.Month;
        readonly static "SEPTEMBER": Internal.Month;
        readonly static "NOVEMBER": Internal.Month;
        readonly static "DECEMBER": Internal.Month;
    }
    type Month_ = "march" | "april" | "september" | "may" | "june" | "august" | Month | "december" | "january" | "july" | "october" | "february" | "november";
    class ProtectedBlockProcessor extends Internal.StructureProcessor {
        constructor(arg0: Internal.TagKey_<Internal.Block_>)
        processBlock(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.StructureTemplate$StructureBlockInfo_, arg4: Internal.StructureTemplate$StructureBlockInfo_, arg5: Internal.StructurePlaceSettings_): Internal.StructureTemplate$StructureBlockInfo;
        readonly static "CODEC": any;
        readonly "cannotReplace": Internal.TagKey<Internal.Block>;
    }
    type ProtectedBlockProcessor_ = ProtectedBlockProcessor;
    class WeightedStateProvider extends Internal.BlockStateProvider {
        constructor(arg0: Internal.SimpleWeightedRandomList$Builder_<Internal.BlockState_>)
        constructor(arg0: Internal.SimpleWeightedRandomList_<Internal.BlockState_>)
        getState(arg0: Internal.Random_, arg1: BlockPos_): Internal.BlockState;
        readonly static "CODEC": any;
    }
    type WeightedStateProvider_ = WeightedStateProvider;
    abstract class EntityViewRenderEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.GameRenderer_, arg1: Internal.Camera_, arg2: number)
        getRenderer(): Internal.GameRenderer;
        getListenerList(): Internal.ListenerList;
        getCamera(): Internal.Camera;
        getPartialTicks(): number;
        get renderer(): Internal.GameRenderer
        get listenerList(): Internal.ListenerList
        get camera(): Internal.Camera
        get partialTicks(): number
    }
    type EntityViewRenderEvent_ = EntityViewRenderEvent;
    abstract class ContentHandler {
        constructor()
        getContent(arg0: Internal.URLConnection_, arg1: Internal.Class_<any>[]): any;
        getContent(arg0: Internal.URLConnection_): any;
    }
    type ContentHandler_ = ContentHandler;
    class StructureBlockEntity extends Internal.BlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        getStructurePos(): BlockPos;
        getShowBoundingBox(): boolean;
        requestModelDataUpdate(): void;
        getSeed(): number;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getUpdateTag(): Internal.CompoundTag;
        hasStructureName(): boolean;
        getStructureName(): string;
        loadStructure(arg0: Internal.ServerLevel_, arg1: boolean, arg2: Internal.StructureTemplate_): boolean;
        isStructureLoadable(): boolean;
        loadStructure(arg0: Internal.ServerLevel_, arg1: boolean): boolean;
        load(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        getMode(): Internal.StructureMode;
        getMetaData(): string;
        getStructureSize(): Vec3i;
        isPowered(): boolean;
        getModelData(): Internal.IModelData;
        setSeed(arg0: number): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        usedBy(arg0: Internal.Player_): boolean;
        getRotation(): Internal.Rotation;
        setStructureName(arg0: string): void;
        setPowered(arg0: boolean): void;
        setRotation(arg0: Internal.Rotation_): void;
        getRenderBoundingBox(): Internal.AABB;
        createdBy(arg0: Internal.LivingEntity_): void;
        setIntegrity(arg0: number): void;
        saveStructure(arg0: boolean): boolean;
        loadStructure(arg0: Internal.ServerLevel_): boolean;
        detectSize(): boolean;
        setStructurePos(arg0: BlockPos_): void;
        setMode(arg0: Internal.StructureMode_): void;
        getMirror(): Internal.Mirror;
        setShowAir(arg0: boolean): void;
        getIntegrity(): number;
        setShowBoundingBox(arg0: boolean): void;
        saveStructure(): boolean;
        unloadStructure(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getStructurePath(): string;
        setIgnoreEntities(arg0: boolean): void;
        isIgnoreEntities(): boolean;
        setMetaData(arg0: string): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        setStructureSize(arg0: Vec3i_): void;
        getUpdatePacket(): Internal.ClientboundBlockEntityDataPacket;
        serializeNBT(): Internal.CompoundTag;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getShowAir(): boolean;
        setStructureName(arg0: ResourceLocation_): void;
        setMirror(arg0: Internal.Mirror_): void;
        get structurePos(): BlockPos
        get showBoundingBox(): boolean
        get seed(): number
        get updateTag(): Internal.CompoundTag
        get structureName(): string
        get structureLoadable(): boolean
        get mode(): Internal.StructureMode
        get metaData(): string
        get structureSize(): Vec3i
        get powered(): boolean
        get modelData(): Internal.IModelData
        set seed(arg0: number)
        get rotation(): Internal.Rotation
        set structureName(arg0: string)
        set powered(arg0: boolean)
        set rotation(arg0: Internal.Rotation_)
        get renderBoundingBox(): Internal.AABB
        set integrity(arg0: number)
        set structurePos(arg0: BlockPos_)
        set mode(arg0: Internal.StructureMode_)
        get mirror(): Internal.Mirror
        set showAir(arg0: boolean)
        get integrity(): number
        set showBoundingBox(arg0: boolean)
        get structurePath(): string
        set ignoreEntities(arg0: boolean)
        get ignoreEntities(): boolean
        set metaData(arg0: string)
        set structureSize(arg0: Vec3i_)
        get updatePacket(): Internal.ClientboundBlockEntityDataPacket
        get showAir(): boolean
        set structureName(arg0: ResourceLocation_)
        set mirror(arg0: Internal.Mirror_)
        readonly static "MAX_OFFSET_PER_AXIS": 48;
        readonly static "MAX_SIZE_PER_AXIS": 48;
        readonly static "AUTHOR_TAG": "author";
    }
    type StructureBlockEntity_ = StructureBlockEntity;
    class PalettedContainer$Configuration <T> extends Internal.Record {
        hashCode(): number;
        toString(): string;
        bits(): number;
        equals(arg0: any): boolean;
        factory(): Internal.Palette$Factory;
        createData(arg0: Internal.IdMap_<T>, arg1: Internal.PaletteResize_<T>, arg2: number): Internal.PalettedContainer$Data<T>;
    }
    type PalettedContainer$Configuration_<T> = PalettedContainer$Configuration<T>;
    class NoiseSamplingSettings extends Internal.Record {
        constructor(arg0: number, arg1: number, arg2: number, arg3: number)
        hashCode(): number;
        yFactor(): number;
        toString(): string;
        xzFactor(): number;
        yScale(): number;
        equals(arg0: any): boolean;
        xzScale(): number;
        readonly static "CODEC": any;
    }
    type NoiseSamplingSettings_ = NoiseSamplingSettings;
    interface Float2CharFunction extends it.unimi.dsi.fastutil.Function<number, string>, Internal.DoubleToIntFunction {
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Float2IntFunction;
        getOrDefault(arg0: any, arg1: string): string;
        put(arg0: number, arg1: string): string;
        getOrDefault(arg0: any, arg1: any): any;
        composeReference(arg0: Internal.Reference2FloatFunction_<any>): Internal.Reference2CharFunction<T>;
        defaultReturnValue(): string;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2CharFunction;
        composeObject(arg0: Internal.Object2FloatFunction_<any>): Internal.Object2CharFunction<T>;
        put(arg0: number, arg1: string): string;
        containsKey(arg0: any): boolean;
        andThenObject(arg0: Internal.Char2ObjectFunction_<any>): Internal.Float2ObjectFunction<T>;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2CharFunction;
        andThenChar(arg0: Internal.Char2CharFunction_): this;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Float2ShortFunction;
        defaultReturnValue(arg0: string): void;
        get(arg0: any): string;
        put(arg0: any, arg1: any): any;
        containsKey(arg0: number): boolean;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2CharFunction;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2CharFunction;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Float2ByteFunction;
        getOrDefault(arg0: number, arg1: string): string;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Float2LongFunction;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2CharFunction;
        apply(arg0: number): string;
        remove(arg0: number): string;
        get(arg0: number): string;
        composeFloat(arg0: Internal.Float2FloatFunction_): this;
        andThenReference(arg0: Internal.Char2ReferenceFunction_<any>): Internal.Float2ReferenceFunction<T>;
        size(): number;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Float2DoubleFunction;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Float2FloatFunction;
        clear(): void;
        remove(arg0: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, string>;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2CharFunction;
        applyAsInt(arg0: number): number;
    }
    type Float2CharFunction_ = Float2CharFunction | ((arg0: number)=>string);
    class BlendingData {
        static sideByGenerationAge(arg0: Internal.WorldGenLevel_, arg1: number, arg2: number, arg3: boolean): Internal.Set<Internal.Direction8>;
        oldNoise(): boolean;
        static getOrUpdateBlendingData(arg0: Internal.WorldGenRegion_, arg1: number, arg2: number): Internal.BlendingData;
        readonly static "CODEC": any;
    }
    type BlendingData_ = BlendingData;
    class GameProfile {
        constructor(arg0: Internal.UUID_, arg1: string)
        setId(arg0: Internal.UUID_): void;
        hashCode(): number;
        toString(): string;
        getName(): string;
        isLegacy(): boolean;
        getId(): Internal.UUID;
        getProperties(): Internal.PropertyMap;
        equals(arg0: any): boolean;
        isComplete(): boolean;
        set id(arg0: Internal.UUID_)
        get name(): string
        get legacy(): boolean
        get id(): Internal.UUID
        get properties(): Internal.PropertyMap
        get complete(): boolean
    }
    type GameProfile_ = GameProfile;
    class Connection extends Internal.SimpleChannelInboundHandler<Internal.Packet<any>> {
        constructor(arg0: Internal.PacketFlow_)
        channelActive(arg0: Internal.ChannelHandlerContext_): void;
        static connectToLocalServer(arg0: Internal.SocketAddress_): Internal.Connection;
        isMemoryConnection(): boolean;
        handleDisconnection(): void;
        send(arg0: Internal.Packet_<any>, arg1: Internal.GenericFutureListener_<any>): void;
        static connectToServer(arg0: Internal.InetSocketAddress_, arg1: boolean): Internal.Connection;
        setProtocol(arg0: Internal.ConnectionProtocol_): void;
        setListener(arg0: Internal.PacketListener_): void;
        getAverageReceivedPackets(): number;
        getPacketListener(): Internal.PacketListener;
        setEncryptionKey(arg0: Internal.Cipher_, arg1: Internal.Cipher_): void;
        isConnecting(): boolean;
        isConnected(): boolean;
        disconnect(arg0: Internal.Component_): void;
        getDisconnectedReason(): Internal.Component;
        setupCompression(arg0: number, arg1: boolean): void;
        isEncrypted(): boolean;
        getAverageSentPackets(): number;
        getDirection(): Internal.PacketFlow;
        tick(): void;
        getRemoteAddress(): Internal.SocketAddress;
        channel(): io.netty.channel.Channel;
        channelInactive(arg0: Internal.ChannelHandlerContext_): void;
        getReceiving(): Internal.PacketFlow;
        setReadOnly(): void;
        exceptionCaught(arg0: Internal.ChannelHandlerContext_, arg1: Internal.Throwable_): void;
        getSending(): Internal.PacketFlow;
        send(arg0: Internal.Packet_<any>): void;
        get memoryConnection(): boolean
        set protocol(arg0: Internal.ConnectionProtocol_)
        set listener(arg0: Internal.PacketListener_)
        get averageReceivedPackets(): number
        get packetListener(): Internal.PacketListener
        get connecting(): boolean
        get connected(): boolean
        get disconnectedReason(): Internal.Component
        get encrypted(): boolean
        get averageSentPackets(): number
        get direction(): Internal.PacketFlow
        get remoteAddress(): Internal.SocketAddress
        get receiving(): Internal.PacketFlow
        get sending(): Internal.PacketFlow
        readonly static "PACKET_MARKER": any;
        readonly static "LOCAL_WORKER_GROUP": Internal.LazyLoadedValue<any>;
        readonly static "NETWORK_EPOLL_WORKER_GROUP": Internal.LazyLoadedValue<any>;
        readonly static "PACKET_SENT_MARKER": any;
        readonly static "ATTRIBUTE_PROTOCOL": Internal.AttributeKey<any>;
        readonly static "PACKET_RECEIVED_MARKER": any;
        readonly static "ROOT_MARKER": any;
        readonly static "NETWORK_WORKER_GROUP": Internal.LazyLoadedValue<any>;
    }
    type Connection_ = Connection;
    class FireworksJS$Explosion {
        constructor()
        readonly "fadeColors": Internal.IntOpenHashSet;
        "trail": boolean;
        "flicker": boolean;
        readonly "colors": Internal.IntOpenHashSet;
        "shape": Internal.FireworksJS$Shape;
    }
    type FireworksJS$Explosion_ = FireworksJS$Explosion;
    class ServerboundResourcePackPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.ServerboundResourcePackPacket$Action_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getAction(): Internal.ServerboundResourcePackPacket$Action;
        isSkippable(): boolean;
        get action(): Internal.ServerboundResourcePackPacket$Action
        get skippable(): boolean
    }
    type ServerboundResourcePackPacket_ = ServerboundResourcePackPacket;
    interface BooleanSupplier {
        getAsBoolean(): boolean;
        get asBoolean(): boolean
    }
    type BooleanSupplier_ = (()=>boolean) | BooleanSupplier;
    class InputEvent$MouseInputEvent extends Internal.InputEvent {
        constructor()
        constructor(arg0: number, arg1: number, arg2: number)
        getButton(): number;
        getModifiers(): number;
        getListenerList(): Internal.ListenerList;
        getAction(): number;
        get button(): number
        get modifiers(): number
        get listenerList(): Internal.ListenerList
        get action(): number
    }
    type InputEvent$MouseInputEvent_ = InputEvent$MouseInputEvent;
    class BigDecimal extends Internal.Number implements Internal.Comparable<Internal.BigDecimal> {
        constructor(arg0: number, arg1: Internal.MathContext_)
        constructor(arg0: Internal.BigInteger_, arg1: number)
        constructor(arg0: number, arg1: Internal.MathContext_)
        constructor(arg0: string[], arg1: number, arg2: number, arg3: Internal.MathContext_)
        constructor(arg0: number)
        constructor(arg0: number)
        constructor(arg0: Internal.BigInteger_, arg1: Internal.MathContext_)
        constructor(arg0: Internal.BigInteger_)
        constructor(arg0: string[], arg1: Internal.MathContext_)
        constructor(arg0: number)
        constructor(arg0: string[], arg1: number, arg2: number)
        constructor(arg0: Internal.BigInteger_, arg1: number, arg2: Internal.MathContext_)
        constructor(arg0: string, arg1: Internal.MathContext_)
        constructor(arg0: number, arg1: Internal.MathContext_)
        constructor(arg0: string)
        constructor(arg0: string[])
        doubleValue(): number;
        pow(arg0: number, arg1: Internal.MathContext_): this;
        abs(): this;
        min(arg0: Internal.BigDecimal_): this;
        precision(): number;
        subtract(arg0: Internal.BigDecimal_, arg1: Internal.MathContext_): this;
        compareTo(arg0: any): number;
        divide(arg0: Internal.BigDecimal_, arg1: number, arg2: number): this;
        setScale(arg0: number, arg1: Internal.RoundingMode_): this;
        subtract(arg0: Internal.BigDecimal_): this;
        divideToIntegralValue(arg0: Internal.BigDecimal_, arg1: Internal.MathContext_): this;
        divide(arg0: Internal.BigDecimal_, arg1: number, arg2: Internal.RoundingMode_): this;
        ulp(): this;
        movePointLeft(arg0: number): this;
        longValue(): number;
        static valueOf(arg0: number): Internal.BigDecimal;
        movePointRight(arg0: number): this;
        sqrt(arg0: Internal.MathContext_): this;
        toBigInteger(): Internal.BigInteger;
        round(arg0: Internal.MathContext_): this;
        scale(): number;
        multiply(arg0: Internal.BigDecimal_, arg1: Internal.MathContext_): this;
        remainder(arg0: Internal.BigDecimal_, arg1: Internal.MathContext_): this;
        toPlainString(): string;
        static valueOf(arg0: number, arg1: number): Internal.BigDecimal;
        divideAndRemainder(arg0: Internal.BigDecimal_, arg1: Internal.MathContext_): Internal.BigDecimal[];
        floatValue(): number;
        divideAndRemainder(arg0: Internal.BigDecimal_): Internal.BigDecimal[];
        plus(arg0: Internal.MathContext_): this;
        scaleByPowerOfTen(arg0: number): this;
        divide(arg0: Internal.BigDecimal_, arg1: Internal.MathContext_): this;
        add(arg0: Internal.BigDecimal_): this;
        divide(arg0: Internal.BigDecimal_, arg1: number): this;
        intValue(): number;
        compareTo(arg0: Internal.BigDecimal_): number;
        toEngineeringString(): string;
        add(arg0: Internal.BigDecimal_, arg1: Internal.MathContext_): this;
        intValueExact(): number;
        divide(arg0: Internal.BigDecimal_): this;
        plus(): this;
        abs(arg0: Internal.MathContext_): this;
        remainder(arg0: Internal.BigDecimal_): this;
        stripTrailingZeros(): this;
        divide(arg0: Internal.BigDecimal_, arg1: Internal.RoundingMode_): this;
        toString(): string;
        shortValueExact(): number;
        byteValueExact(): number;
        longValueExact(): number;
        negate(): this;
        divideToIntegralValue(arg0: Internal.BigDecimal_): this;
        static valueOf(arg0: number): Internal.BigDecimal;
        hashCode(): number;
        negate(arg0: Internal.MathContext_): this;
        toBigIntegerExact(): Internal.BigInteger;
        setScale(arg0: number): this;
        unscaledValue(): Internal.BigInteger;
        multiply(arg0: Internal.BigDecimal_): this;
        equals(arg0: any): boolean;
        setScale(arg0: number, arg1: number): this;
        max(arg0: Internal.BigDecimal_): this;
        signum(): number;
        pow(arg0: number): this;
        set scale(arg0: number)
        /**
         * @java.lang.Deprecated(forRemoval=false, since="9")
        */
        readonly static "ROUND_UP": 0;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="9")
        */
        readonly static "ROUND_DOWN": 1;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="9")
        */
        readonly static "ROUND_HALF_UP": 4;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="9")
        */
        readonly static "ROUND_HALF_DOWN": 5;
        readonly static "ONE": 1;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="9")
        */
        readonly static "ROUND_FLOOR": 3;
        readonly static "ZERO": 0;
        readonly static "TEN": 10;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="9")
        */
        readonly static "ROUND_CEILING": 2;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="9")
        */
        readonly static "ROUND_HALF_EVEN": 6;
        /**
         * @java.lang.Deprecated(forRemoval=false, since="9")
        */
        readonly static "ROUND_UNNECESSARY": 7;
    }
    type BigDecimal_ = BigDecimal;
    class UseAnim extends Internal.Enum<Internal.UseAnim> {
        static values(): Internal.UseAnim[];
        static valueOf(arg0: string): Internal.UseAnim;
        readonly static "BOW": Internal.UseAnim;
        readonly static "NONE": Internal.UseAnim;
        readonly static "EAT": Internal.UseAnim;
        readonly static "DRINK": Internal.UseAnim;
        readonly static "BLOCK": Internal.UseAnim;
        readonly static "SPYGLASS": Internal.UseAnim;
        readonly static "SPEAR": Internal.UseAnim;
        readonly static "CROSSBOW": Internal.UseAnim;
    }
    type UseAnim_ = "spear" | "eat" | "block" | UseAnim | "crossbow" | "spyglass" | "bow" | "drink" | "none";
    interface LongSet extends Internal.LongCollection, Internal.Set<number> {
        remove(arg0: number): boolean;
        stream(): Internal.Stream<number>;
        of(arg0: number, arg1: number, arg2: number): this;
        forEach(arg0: Internal.Consumer_<any>): void;
        longIterator(): Internal.LongIterator;
        removeIf(arg0: Internal.LongPredicate_): boolean;
        toLongArray(arg0: number[]): number[];
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        of(arg0: number): this;
        of(...arg0: number[]): this;
        parallelStream(): Internal.Stream<number>;
        contains(arg0: any): boolean;
        forEach(arg0: Internal.LongConsumer_): void;
        iterator(): Internal.Iterator<any>;
        remove(arg0: any): boolean;
        rem(arg0: number): boolean;
        add(arg0: any): boolean;
        of(): this;
        spliterator(): Internal.LongSpliterator;
        of(arg0: number, arg1: number): this;
        forEach(arg0: it.unimi.dsi.fastutil.longs.LongConsumer_): void;
        longParallelStream(): Internal.LongStream;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        longStream(): Internal.LongStream;
        add(arg0: number): boolean;
        longSpliterator(): Internal.LongSpliterator;
        removeIf(arg0: it.unimi.dsi.fastutil.longs.LongPredicate_): boolean;
    }
    type LongSet_ = LongSet;
    class ClientboundTabListPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.Component_, arg1: Internal.Component_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getFooter(): Internal.Component;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getHeader(): Internal.Component;
        isSkippable(): boolean;
        get footer(): Internal.Component
        get header(): Internal.Component
        get skippable(): boolean
    }
    type ClientboundTabListPacket_ = ClientboundTabListPacket;
    class InsideWorldBoundsPredicate implements net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate {
        constructor(arg0: Vec3i_)
        type(): Internal.BlockPredicateType<any>;
        and(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        or(arg0: Internal.BiPredicate_<any, any>): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: any, arg1: any): boolean;
        negate(): Internal.BiPredicate<Internal.WorldGenLevel, BlockPos>;
        test(arg0: Internal.WorldGenLevel_, arg1: BlockPos_): boolean;
        readonly static "CODEC": any;
    }
    type InsideWorldBoundsPredicate_ = InsideWorldBoundsPredicate;
    class ServerConnectionListener {
        constructor(arg0: Internal.MinecraftServer_)
        stop(): void;
        startMemoryChannel(): Internal.SocketAddress;
        getConnections(): Internal.List<Internal.Connection>;
        startTcpServerListener(arg0: Internal.InetAddress_, arg1: number): void;
        getServer(): Internal.MinecraftServer;
        tick(): void;
        get connections(): Internal.List<Internal.Connection>
        get server(): Internal.MinecraftServer
        readonly static "SERVER_EPOLL_EVENT_GROUP": Internal.LazyLoadedValue<any>;
        "running": boolean;
        readonly static "SERVER_EVENT_GROUP": Internal.LazyLoadedValue<any>;
    }
    type ServerConnectionListener_ = ServerConnectionListener;
    class ByteArrayTag extends Internal.CollectionTag<Internal.ByteTag> {
        constructor(arg0: Internal.List_<number>)
        constructor(arg0: number[])
        getType(): Internal.TagType<Internal.ByteArrayTag>;
        parallelStream(): Internal.Stream<Internal.ByteTag>;
        remove(arg0: number): any;
        set(arg0: number, arg1: Internal.Tag_): Internal.Tag;
        forEach(arg0: Internal.Consumer_<any>): void;
        addTag(arg0: number, arg1: Internal.Tag_): boolean;
        add(arg0: number, arg1: any): void;
        set(arg0: number, arg1: Internal.ByteTag_): Internal.ByteTag;
        setTag(arg0: number, arg1: Internal.Tag_): boolean;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        getAsByteArray(): number[];
        write(arg0: Internal.DataOutput_): void;
        getId(): number;
        spliterator(): Internal.Spliterator<Internal.ByteTag>;
        stream(): Internal.Stream<Internal.ByteTag>;
        replaceAll(arg0: Internal.UnaryOperator_<Internal.ByteTag_>): void;
        toString(): string;
        accept(arg0: Internal.TagVisitor_): void;
        add(arg0: number, arg1: Internal.Tag_): void;
        add(arg0: number, arg1: Internal.ByteTag_): void;
        sort(arg0: Internal.Comparator_<any>): void;
        getAsString(): string;
        size(): number;
        hashCode(): number;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        copy(): Internal.Tag;
        clear(): void;
        equals(arg0: any): boolean;
        accept(arg0: Internal.StreamTagVisitor_): Internal.StreamTagVisitor$ValueResult;
        set(arg0: number, arg1: any): any;
        getElementType(): number;
        get(arg0: number): Internal.ByteTag;
        get type(): Internal.TagType<Internal.ByteArrayTag>
        get asByteArray(): number[]
        get id(): number
        get asString(): string
        get elementType(): number
        readonly static "TYPE": any;
    }
    type ByteArrayTag_ = ByteArrayTag;
    class MethodHandles$Lookup {
        hasPrivateAccess(): boolean;
        hasFullPrivilegeAccess(): boolean;
        findVarHandle(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.Class_<any>): Internal.VarHandle;
        unreflectSetter(arg0: Internal.Field_): Internal.MethodHandle;
        findStaticVarHandle(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.Class_<any>): Internal.VarHandle;
        unreflectConstructor(arg0: Internal.Constructor_<any>): Internal.MethodHandle;
        findClass(arg0: string): Internal.Class<any>;
        unreflect(arg0: Internal.Method_): Internal.MethodHandle;
        findGetter(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.Class_<any>): Internal.MethodHandle;
        findSetter(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.Class_<any>): Internal.MethodHandle;
        findConstructor(arg0: Internal.Class_<any>, arg1: Internal.MethodType_): Internal.MethodHandle;
        dropLookupMode(arg0: number): this;
        defineHiddenClassWithClassData(arg0: number[], arg1: any, arg2: boolean, ...arg3: any_[]): this;
        unreflectSpecial(arg0: Internal.Method_, arg1: Internal.Class_<any>): Internal.MethodHandle;
        in(arg0: Internal.Class_<any>): this;
        lookupClass(): Internal.Class<any>;
        findStaticSetter(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.Class_<any>): Internal.MethodHandle;
        unreflectVarHandle(arg0: Internal.Field_): Internal.VarHandle;
        previousLookupClass(): Internal.Class<any>;
        unreflectGetter(arg0: Internal.Field_): Internal.MethodHandle;
        toString(): string;
        findSpecial(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.MethodType_, arg3: Internal.Class_<any>): Internal.MethodHandle;
        accessClass(arg0: Internal.Class_<any>): Internal.Class<any>;
        bind(arg0: any, arg1: string, arg2: Internal.MethodType_): Internal.MethodHandle;
        lookupModes(): number;
        ensureInitialized(arg0: Internal.Class_<any>): Internal.Class<any>;
        findVirtual(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.MethodType_): Internal.MethodHandle;
        defineClass(arg0: number[]): Internal.Class<any>;
        findStatic(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.MethodType_): Internal.MethodHandle;
        findStaticGetter(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.Class_<any>): Internal.MethodHandle;
        defineHiddenClass(arg0: number[], arg1: boolean, ...arg2: any_[]): this;
        revealDirect(arg0: Internal.MethodHandle_): Internal.MethodHandleInfo;
        readonly static "PACKAGE": 8;
        readonly static "PUBLIC": 1;
        readonly static "UNCONDITIONAL": 32;
        readonly static "MODULE": 16;
        readonly static "ORIGINAL": 64;
        readonly static "PRIVATE": 2;
        readonly static "PROTECTED": 4;
    }
    type MethodHandles$Lookup_ = MethodHandles$Lookup;
    abstract class AgeableListModel <E> extends Internal.EntityModel<E> {
        renderToBuffer(arg0: Internal.PoseStack_, arg1: Internal.VertexConsumer_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
    }
    type AgeableListModel_<E> = AgeableListModel<E>;
    abstract class BaseImmutableMultimap <K, V> extends Internal.AbstractMultimap<K, V> {
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
    }
    type BaseImmutableMultimap_<K, V> = BaseImmutableMultimap<K, V>;
    class RenderLivingEvent$Pre <T, M> extends Internal.RenderLivingEvent<T, M> {
        constructor()
        constructor(arg0: Internal.LivingEntity_, arg1: Internal.LivingEntityRenderer_<T, M>, arg2: number, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type RenderLivingEvent$Pre_<T, M> = RenderLivingEvent$Pre<T, M>;
    interface MessageSender {
        getDisplayName(): Internal.Component;
        setStatusMessage(message: Internal.Component_): void;
        getName(): Internal.Component;
        runCommandSilent(command: string): number;
        tell(arg0: Internal.Component_): void;
        runCommand(arg0: string): number;
        get displayName(): Internal.Component
        set statusMessage(message: Internal.Component_)
        get name(): Internal.Component
    }
    type MessageSender_ = MessageSender;
    class ScreenEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.Screen_)
        getListenerList(): Internal.ListenerList;
        getScreen(): Internal.Screen;
        get listenerList(): Internal.ListenerList
        get screen(): Internal.Screen
    }
    type ScreenEvent_ = ScreenEvent;
    class WorldEvent$PotentialSpawns extends Internal.WorldEvent {
        constructor()
        constructor(arg0: Internal.LevelAccessor_, arg1: Internal.MobCategory_, arg2: BlockPos_, arg3: Internal.WeightedRandomList_<Internal.MobSpawnSettings$SpawnerData_>)
        getPos(): BlockPos;
        addSpawnerData(arg0: Internal.MobSpawnSettings$SpawnerData_): void;
        isCancelable(): boolean;
        removeSpawnerData(arg0: Internal.MobSpawnSettings$SpawnerData_): boolean;
        getSpawnerDataList(): Internal.List<Internal.MobSpawnSettings$SpawnerData>;
        getListenerList(): Internal.ListenerList;
        getMobCategory(): Internal.MobCategory;
        get pos(): BlockPos
        get cancelable(): boolean
        get spawnerDataList(): Internal.List<Internal.MobSpawnSettings$SpawnerData>
        get listenerList(): Internal.ListenerList
        get mobCategory(): Internal.MobCategory
    }
    type WorldEvent$PotentialSpawns_ = WorldEvent$PotentialSpawns;
    interface Nameable {
        getDisplayName(): Internal.Component;
        getName(): Internal.Component;
        hasCustomName(): boolean;
        getCustomName(): Internal.Component;
        get displayName(): Internal.Component
        get name(): Internal.Component
        get customName(): Internal.Component
    }
    type Nameable_ = Nameable;
    interface IEventListener {
        invoke(arg0: Internal.Event_): void;
        listenerName(): string;
    }
    type IEventListener_ = IEventListener;
    interface Constant <T> extends Internal.Comparable<T> {
        name(): string;
        id(): number;
    }
    type Constant_<T> = Constant<T>;
    class DifficultyChangeEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.Difficulty_, arg1: Internal.Difficulty_)
        getOldDifficulty(): Internal.Difficulty;
        getDifficulty(): Internal.Difficulty;
        getListenerList(): Internal.ListenerList;
        get oldDifficulty(): Internal.Difficulty
        get difficulty(): Internal.Difficulty
        get listenerList(): Internal.ListenerList
    }
    type DifficultyChangeEvent_ = DifficultyChangeEvent;
    class BlockState extends Internal.BlockBehaviour$BlockStateBase implements Internal.IForgeBlockState {
        constructor(arg0: Internal.Block_, arg1: Internal.ImmutableMap_<Internal.Property_<any>, Internal.Comparable_<any>>, arg2: Internal.MapCodec_<Internal.BlockState_>)
        getFlammability(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): number;
        onBlockExploded(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Explosion_): void;
        isPortalFrame(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        getExpDrop(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: number, arg3: number): number;
        getSoundType(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Entity_): Internal.SoundType;
        canRedstoneConnectTo(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        collisionExtendsVertically(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Entity_): boolean;
        isBed(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.LivingEntity_): boolean;
        isConduitFrame(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_): boolean;
        canHarvestBlock(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        setBedOccupied(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.LivingEntity_, arg3: boolean): void;
        getBlockPathType(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.BlockPathTypes;
        shouldCheckWeakPower(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        getStateAtViewpoint(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Vec3_): this;
        isLadder(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.LivingEntity_): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.FluidState_): boolean;
        getToolModifiedState(arg0: Internal.UseOnContext_, arg1: Internal.ToolAction_, arg2: boolean): this;
        getBedDirection(arg0: Internal.LevelReader_, arg1: BlockPos_): Internal.Direction;
        canSustainPlant(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_, arg3: Internal.IPlantable_): boolean;
        isSlimeBlock(): boolean;
        canStickTo(arg0: Internal.BlockState_): boolean;
        getBeaconColorMultiplier(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_): number[];
        addLandingEffects(arg0: Internal.ServerLevel_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.LivingEntity_, arg4: number): boolean;
        isFlammable(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        isFertile(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        onCaughtFire(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Direction_, arg3: Internal.LivingEntity_): void;
        onBlockStateChange(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.BlockState_): void;
        hidesNeighborFace(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.Direction_): boolean;
        canDropFromExplosion(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Explosion_): boolean;
        supportsExternalFaceHiding(): boolean;
        isScaffolding(arg0: Internal.LivingEntity_): boolean;
        getBlockPathType(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Mob_): Internal.BlockPathTypes;
        rotate(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: Internal.Rotation_): this;
        onNeighborChange(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_): void;
        getEnchantPowerBonus(arg0: Internal.LevelReader_, arg1: BlockPos_): number;
        getToolModifiedState(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Player_, arg3: Internal.ItemStack_, arg4: Internal.ToolAction_): this;
        isValidSpawn(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.SpawnPlacements$Type_, arg3: Internal.EntityType_<any>): boolean;
        canEntityDestroy(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Entity_): boolean;
        isBurning(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        getRespawnPosition(arg0: Internal.EntityType_<any>, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: number, arg4: Internal.LivingEntity_): Internal.Optional<Vec3>;
        getWeakChanges(arg0: Internal.LevelReader_, arg1: BlockPos_): boolean;
        addRunningEffects(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Entity_): boolean;
        isFireSource(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        getLightEmission(arg0: Internal.BlockGetter_, arg1: BlockPos_): number;
        getFriction(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Entity_): number;
        isStickyBlock(): boolean;
        getCloneItemStack(arg0: Internal.HitResult_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Player_): Internal.ItemStack;
        onDestroyedByPlayer(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Player_, arg3: boolean, arg4: Internal.FluidState_): boolean;
        getExplosionResistance(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Explosion_): number;
        getFireSpreadSpeed(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): number;
        get slimeBlock(): boolean
        get stickyBlock(): boolean
        readonly static "CODEC": any;
    }
    type BlockState_ = BlockState;
    class ClientboundSetPlayerTeamPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        static createAddOrModifyPacket(arg0: Internal.PlayerTeam_, arg1: boolean): Internal.ClientboundSetPlayerTeamPacket;
        getTeamAction(): Internal.ClientboundSetPlayerTeamPacket$Action;
        write(arg0: Internal.FriendlyByteBuf_): void;
        static createPlayerPacket(arg0: Internal.PlayerTeam_, arg1: string, arg2: Internal.ClientboundSetPlayerTeamPacket$Action_): Internal.ClientboundSetPlayerTeamPacket;
        static createRemovePacket(arg0: Internal.PlayerTeam_): Internal.ClientboundSetPlayerTeamPacket;
        getPlayerAction(): Internal.ClientboundSetPlayerTeamPacket$Action;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getName(): string;
        getParameters(): Internal.Optional<Internal.ClientboundSetPlayerTeamPacket$Parameters>;
        isSkippable(): boolean;
        getPlayers(): Internal.Collection<string>;
        get teamAction(): Internal.ClientboundSetPlayerTeamPacket$Action
        get playerAction(): Internal.ClientboundSetPlayerTeamPacket$Action
        get name(): string
        get parameters(): Internal.Optional<Internal.ClientboundSetPlayerTeamPacket$Parameters>
        get skippable(): boolean
        get players(): Internal.Collection<string>
    }
    type ClientboundSetPlayerTeamPacket_ = ClientboundSetPlayerTeamPacket;
    interface RecordBuilder <T> {
        build(arg0: Internal.DataResult_<T>): Internal.DataResult<T>;
        add(arg0: T, arg1: Internal.DataResult_<T>): this;
        setLifecycle(arg0: Internal.Lifecycle_): this;
        add(arg0: string, arg1: E, arg2: Internal.Encoder_<E>): this;
        withErrorsFrom(arg0: Internal.DataResult_<any>): this;
        add(arg0: Internal.DataResult_<T>, arg1: Internal.DataResult_<T>): this;
        add(arg0: T, arg1: T): this;
        ops(): Internal.DynamicOps<T>;
        add(arg0: string, arg1: T): this;
        add(arg0: string, arg1: Internal.DataResult_<T>): this;
        build(arg0: T): Internal.DataResult<T>;
        mapError(arg0: Internal.UnaryOperator_<string>): this;
        set lifecycle(arg0: Internal.Lifecycle_)
    }
    type RecordBuilder_<T> = RecordBuilder<T>;
    class Panda extends Internal.Animal {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        eat(arg0: boolean): void;
        setOnBack(arg0: boolean): void;
        isEating(): boolean;
        getStepHeight(): number;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setAttributes(): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getSitAmount(arg0: number): number;
        getMainGene(): Internal.Panda$Gene;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canPerformAction(): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getLieOnBackAmount(arg0: number): number;
        tick(): void;
        isSneezing(): boolean;
        setSneezeCounter(arg0: number): void;
        alwaysAccepts(): boolean;
        setMainGene(arg0: Internal.Panda$Gene_): void;
        isBrown(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        isOnBack(): boolean;
        isAggressive(): boolean;
        setGeneFromParents(arg0: Internal.Panda_, arg1: Internal.Panda_): void;
        getUnhappyCounter(): number;
        sit(arg0: boolean): void;
        getSneezeCounter(): number;
        roll(arg0: boolean): void;
        asKJS(): Internal.EntityJS;
        isScared(): boolean;
        isWeak(): boolean;
        isFood(arg0: Internal.ItemStack_): boolean;
        sneeze(arg0: boolean): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        isPlayful(): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        isRolling(): boolean;
        canTakeItem(arg0: Internal.ItemStack_): boolean;
        getHiddenGene(): Internal.Panda$Gene;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        setHiddenGene(arg0: Internal.Panda$Gene_): void;
        setUnhappyCounter(arg0: number): void;
        isLazy(): boolean;
        canBeLeashed(arg0: Internal.Player_): boolean;
        getVariant(): Internal.Panda$Gene;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getRollAmount(arg0: number): number;
        isSitting(): boolean;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getClassification(arg0: boolean): Internal.MobCategory;
        isWorried(): boolean;
        set onBack(arg0: boolean)
        get eating(): boolean
        get stepHeight(): number
        get mainGene(): Internal.Panda$Gene
        get sneezing(): boolean
        set sneezeCounter(arg0: number)
        set mainGene(arg0: Internal.Panda$Gene_)
        get brown(): boolean
        get onBack(): boolean
        get aggressive(): boolean
        get unhappyCounter(): number
        get sneezeCounter(): number
        get scared(): boolean
        get weak(): boolean
        get multipartEntity(): boolean
        get playful(): boolean
        get parts(): Internal.PartEntity<any>[]
        get rolling(): boolean
        get hiddenGene(): Internal.Panda$Gene
        set hiddenGene(arg0: Internal.Panda$Gene_)
        set unhappyCounter(arg0: number)
        get lazy(): boolean
        get variant(): Internal.Panda$Gene
        get sitting(): boolean
        get worried(): boolean
        readonly static "TOTAL_ROLL_STEPS": 32;
        "rollCounter": number;
    }
    type Panda_ = Panda;
    interface TypeDescriptor$OfField <F> extends Internal.TypeDescriptor {
        isPrimitive(): boolean;
        isArray(): boolean;
        arrayType(): F;
        componentType(): F;
        get primitive(): boolean
        get array(): boolean
    }
    type TypeDescriptor$OfField_<F> = TypeDescriptor$OfField<F>;
    class SpectatorPage {
        constructor(arg0: Internal.List_<Internal.SpectatorMenuItem_>, arg1: number)
        getSelectedSlot(): number;
        getItem(arg0: number): Internal.SpectatorMenuItem;
        get selectedSlot(): number
        readonly static "NO_SELECTION": -1;
    }
    type SpectatorPage_ = SpectatorPage;
    class PoiRecord {
        constructor(arg0: BlockPos_, arg1: Internal.PoiType_, arg2: Internal.Runnable_)
        getPos(): BlockPos;
        hasSpace(): boolean;
        getPoiType(): Internal.PoiType;
        hashCode(): number;
        isOccupied(): boolean;
        getFreeTickets(): number;
        static codec(arg0: Internal.Runnable_): Internal.Codec<Internal.PoiRecord>;
        equals(arg0: any): boolean;
        get pos(): BlockPos
        get poiType(): Internal.PoiType
        get occupied(): boolean
        get freeTickets(): number
    }
    type PoiRecord_ = PoiRecord;
    class StructureTemplate {
        constructor()
        getAuthor(): string;
        setAuthor(arg0: string): void;
        static transformedVec3d(arg0: Internal.StructurePlaceSettings_, arg1: Vec3_): Vec3;
        placeInWorld(arg0: Internal.ServerLevelAccessor_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.StructurePlaceSettings_, arg4: Internal.Random_, arg5: number): boolean;
        static transform(arg0: Vec3_, arg1: Internal.Mirror_, arg2: Internal.Rotation_, arg3: BlockPos_): Vec3;
        filterBlocks(arg0: BlockPos_, arg1: Internal.StructurePlaceSettings_, arg2: Internal.Block_): Internal.List<Internal.StructureTemplate$StructureBlockInfo>;
        static processEntityInfos(arg0: Internal.StructureTemplate_, arg1: Internal.LevelAccessor_, arg2: BlockPos_, arg3: Internal.StructurePlaceSettings_, arg4: Internal.List_<Internal.StructureTemplate$StructureEntityInfo_>): Internal.List<Internal.StructureTemplate$StructureEntityInfo>;
        save(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        getSize(arg0: Internal.Rotation_): Vec3i;
        getBoundingBox(arg0: BlockPos_, arg1: Internal.Rotation_, arg2: BlockPos_, arg3: Internal.Mirror_): Internal.BoundingBox;
        getSize(): Vec3i;
        static updateShapeAtEdge(arg0: Internal.LevelAccessor_, arg1: number, arg2: Internal.DiscreteVoxelShape_, arg3: number, arg4: number, arg5: number): void;
        static processBlockInfos(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.StructurePlaceSettings_, arg4: Internal.List_<Internal.StructureTemplate$StructureBlockInfo_>, arg5: Internal.StructureTemplate_): Internal.List<Internal.StructureTemplate$StructureBlockInfo>;
        load(arg0: Internal.CompoundTag_): void;
        static transform(arg0: BlockPos_, arg1: Internal.Mirror_, arg2: Internal.Rotation_, arg3: BlockPos_): BlockPos;
        static getZeroPositionWithTransform(arg0: BlockPos_, arg1: Internal.Mirror_, arg2: Internal.Rotation_, arg3: number, arg4: number): BlockPos;
        getBoundingBox(arg0: Internal.StructurePlaceSettings_, arg1: BlockPos_): Internal.BoundingBox;
        static processBlockInfos(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.StructurePlaceSettings_, arg4: Internal.List_<Internal.StructureTemplate$StructureBlockInfo_>): Internal.List<Internal.StructureTemplate$StructureBlockInfo>;
        static calculateRelativePosition(arg0: Internal.StructurePlaceSettings_, arg1: BlockPos_): BlockPos;
        getZeroPositionWithTransform(arg0: BlockPos_, arg1: Internal.Mirror_, arg2: Internal.Rotation_): BlockPos;
        fillFromWorld(arg0: Internal.Level_, arg1: BlockPos_, arg2: Vec3i_, arg3: boolean, arg4: Internal.Block_): void;
        calculateConnectedPosition(arg0: Internal.StructurePlaceSettings_, arg1: BlockPos_, arg2: Internal.StructurePlaceSettings_, arg3: BlockPos_): BlockPos;
        filterBlocks(arg0: BlockPos_, arg1: Internal.StructurePlaceSettings_, arg2: Internal.Block_, arg3: boolean): Internal.List<Internal.StructureTemplate$StructureBlockInfo>;
        get author(): string
        set author(arg0: string)
        get size(): Vec3i
        readonly static "BLOCK_TAG_POS": "pos";
        readonly static "ENTITY_TAG_POS": "pos";
        readonly static "PALETTE_LIST_TAG": "palettes";
        readonly static "BLOCKS_TAG": "blocks";
        readonly static "ENTITY_TAG_NBT": "nbt";
        readonly static "ENTITY_TAG_BLOCKPOS": "blockPos";
        readonly static "BLOCK_TAG_STATE": "state";
        readonly static "BLOCK_TAG_NBT": "nbt";
        readonly static "SIZE_TAG": "size";
        readonly static "PALETTE_TAG": "palette";
        readonly static "ENTITIES_TAG": "entities";
    }
    type StructureTemplate_ = StructureTemplate;
    class BiomeSpecialEffects {
        getWaterColor(): number;
        getAmbientParticleSettings(): Internal.Optional<Internal.AmbientParticleSettings>;
        getAmbientAdditionsSettings(): Internal.Optional<Internal.AmbientAdditionsSettings>;
        getGrassColorModifier(): Internal.BiomeSpecialEffects$GrassColorModifier;
        getBackgroundMusic(): Internal.Optional<Internal.Music>;
        getAmbientLoopSoundEvent(): Internal.Optional<Internal.SoundEvent>;
        getWaterFogColor(): number;
        getGrassColorOverride(): Internal.Optional<number>;
        getFoliageColorOverride(): Internal.Optional<number>;
        getFogColor(): number;
        getSkyColor(): number;
        getAmbientMoodSettings(): Internal.Optional<Internal.AmbientMoodSettings>;
        get waterColor(): number
        get ambientParticleSettings(): Internal.Optional<Internal.AmbientParticleSettings>
        get ambientAdditionsSettings(): Internal.Optional<Internal.AmbientAdditionsSettings>
        get grassColorModifier(): Internal.BiomeSpecialEffects$GrassColorModifier
        get backgroundMusic(): Internal.Optional<Internal.Music>
        get ambientLoopSoundEvent(): Internal.Optional<Internal.SoundEvent>
        get waterFogColor(): number
        get grassColorOverride(): Internal.Optional<number>
        get foliageColorOverride(): Internal.Optional<number>
        get fogColor(): number
        get skyColor(): number
        get ambientMoodSettings(): Internal.Optional<Internal.AmbientMoodSettings>
        "ambientParticleSettings": Internal.Optional<Internal.AmbientParticleSettings>;
        "grassColorOverride": Internal.Optional<number>;
        "ambientMoodSettings": Internal.Optional<Internal.AmbientMoodSettings>;
        "waterColor": number;
        "fogColor": number;
        "ambientAdditionsSettings": Internal.Optional<Internal.AmbientAdditionsSettings>;
        "backgroundMusic": Internal.Optional<Internal.Music>;
        "grassColorModifier": Internal.BiomeSpecialEffects$GrassColorModifier;
        "waterFogColor": number;
        readonly static "CODEC": any;
        "ambientLoopSoundEvent": Internal.Optional<Internal.SoundEvent>;
        "foliageColorOverride": Internal.Optional<number>;
        "skyColor": number;
    }
    type BiomeSpecialEffects_ = BiomeSpecialEffects;
    class LivingSpawnEvent$CheckSpawn extends Internal.LivingSpawnEvent {
        constructor()
        constructor(arg0: Internal.Mob_, arg1: Internal.LevelAccessor_, arg2: number, arg3: number, arg4: number, arg5: Internal.BaseSpawner_, arg6: Internal.MobSpawnType_)
        hasResult(): boolean;
        isSpawner(): boolean;
        getListenerList(): Internal.ListenerList;
        getSpawner(): Internal.BaseSpawner;
        getSpawnReason(): Internal.MobSpawnType;
        get spawner(): boolean
        get listenerList(): Internal.ListenerList
        get spawner(): Internal.BaseSpawner
        get spawnReason(): Internal.MobSpawnType
    }
    type LivingSpawnEvent$CheckSpawn_ = LivingSpawnEvent$CheckSpawn;
    class BlockPos$MutableBlockPos extends BlockPos {
        constructor()
        constructor(arg0: number, arg1: number, arg2: number)
        constructor(arg0: number, arg1: number, arg2: number)
        north(): Vec3i;
        south(arg0: number): Vec3i;
        move(arg0: Vec3i_): this;
        set(arg0: number): this;
        above(arg0: number): Vec3i;
        clamp(arg0: Internal.Direction$Axis_, arg1: number, arg2: number): this;
        set(arg0: Internal.AxisCycle_, arg1: number, arg2: number, arg3: number): this;
        west(arg0: number): Vec3i;
        east(arg0: number): Vec3i;
        multiply(arg0: number): BlockPos;
        rotate(arg0: Internal.Rotation_): BlockPos;
        relative(arg0: Internal.Direction_): Vec3i;
        move(arg0: number, arg1: number, arg2: number): this;
        setWithOffset(arg0: Vec3i_, arg1: Internal.Direction_): this;
        below(arg0: number): Vec3i;
        above(): Vec3i;
        set(arg0: number, arg1: number, arg2: number): this;
        offset(arg0: number, arg1: number, arg2: number): Vec3i;
        immutable(): BlockPos;
        move(arg0: Internal.Direction_, arg1: number): this;
        east(): Vec3i;
        setWithOffset(arg0: Vec3i_, arg1: number, arg2: number, arg3: number): this;
        north(arg0: number): Vec3i;
        move(arg0: Internal.Direction_): this;
        below(): Vec3i;
        set(arg0: Vec3i_): this;
        west(): Vec3i;
        set(arg0: number, arg1: number, arg2: number): this;
        relative(arg0: Internal.Direction$Axis_, arg1: number): Vec3i;
        offset(arg0: Vec3i_): Vec3i;
        cross(arg0: Vec3i_): Vec3i;
        setWithOffset(arg0: Vec3i_, arg1: Vec3i_): this;
        south(): Vec3i;
        subtract(arg0: Vec3i_): Vec3i;
        relative(arg0: Internal.Direction_, arg1: number): Vec3i;
        offset(arg0: number, arg1: number, arg2: number): BlockPos;
        setZ(arg0: number): Vec3i;
        setX(arg0: number): Vec3i;
        setY(arg0: number): this;
        set z(arg0: number)
        set x(arg0: number)
        set y(arg0: number)
    }
    type BlockPos$MutableBlockPos_ = BlockPos$MutableBlockPos;
    class BasicMobEffect$Builder extends Internal.MobEffectBuilder {
        constructor(i: ResourceLocation_)
        createObject(): Internal.MobEffect;
    }
    type BasicMobEffect$Builder_ = BasicMobEffect$Builder;
    interface UnitToken {
        unstack(resultStack: Internal.Stack_<Internal.UnitToken_>): void;
        nextUnaryOperator(): boolean;
        interpret(stream: Internal.UnitTokenStream_): Internal.Unit;
    }
    type UnitToken_ = UnitToken;
    class ThrownTrident extends Internal.AbstractArrow {
        constructor(arg0: Internal.Level_, arg1: Internal.LivingEntity_, arg2: Internal.ItemStack_)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        isChanneling(): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        playerTouch(arg0: Internal.Player_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        tick(): void;
        asKJS(): Internal.EntityJS;
        shouldRender(arg0: number, arg1: number, arg2: number): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        tickDespawn(): void;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        isFoil(): boolean;
        get channeling(): boolean
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get foil(): boolean
        "clientSideReturnTridentTickCount": number;
    }
    type ThrownTrident_ = ThrownTrident;
    class BorderStatus extends Internal.Enum<Internal.BorderStatus> {
        getColor(): number;
        static valueOf(arg0: string): Internal.BorderStatus;
        static values(): Internal.BorderStatus[];
        get color(): number
        readonly static "STATIONARY": Internal.BorderStatus;
        readonly static "SHRINKING": Internal.BorderStatus;
        readonly static "GROWING": Internal.BorderStatus;
    }
    type BorderStatus_ = "shrinking" | "stationary" | BorderStatus | "growing";
    class NativeImage$Format extends Internal.Enum<Internal.NativeImage$Format> {
        glFormat(): number;
        hasLuminanceOrBlue(): boolean;
        blueOffset(): number;
        setUnpackPixelStoreState(): void;
        redOffset(): number;
        hasAlpha(): boolean;
        setPackPixelStoreState(): void;
        hasLuminance(): boolean;
        hasLuminanceOrGreen(): boolean;
        luminanceOrBlueOffset(): number;
        luminanceOrGreenOffset(): number;
        hasLuminanceOrRed(): boolean;
        hasRed(): boolean;
        components(): number;
        static valueOf(arg0: string): Internal.NativeImage$Format;
        hasGreen(): boolean;
        hasBlue(): boolean;
        luminanceOrRedOffset(): number;
        alphaOffset(): number;
        luminanceOrAlphaOffset(): number;
        hasLuminanceOrAlpha(): boolean;
        luminanceOffset(): number;
        static values(): Internal.NativeImage$Format[];
        supportedByStb(): boolean;
        greenOffset(): number;
        readonly static "LUMINANCE": Internal.NativeImage$Format;
        readonly static "RGB": Internal.NativeImage$Format;
        readonly static "RGBA": Internal.NativeImage$Format;
        readonly static "LUMINANCE_ALPHA": Internal.NativeImage$Format;
    }
    type NativeImage$Format_ = NativeImage$Format | "rgb" | "rgba" | "luminance" | "luminance_alpha";
    interface FileFilter {
        accept(arg0: Internal.File_): boolean;
    }
    type FileFilter_ = ((arg0: Internal.File)=>boolean) | FileFilter;
    abstract class CommandNode <S> implements Internal.Comparable<Internal.CommandNode<S>> {
        getRelevantNodes(arg0: Internal.StringReader_): Internal.Collection<any>;
        parse(arg0: Internal.StringReader_, arg1: Internal.CommandContextBuilder_<S>): void;
        createBuilder(): Internal.ArgumentBuilder<S, any>;
        canUse(arg0: S): boolean;
        listSuggestions(arg0: Internal.CommandContext_<S>, arg1: Internal.SuggestionsBuilder_): Internal.CompletableFuture<Internal.Suggestions>;
        getUsageText(): string;
        compareTo(arg0: any): number;
        getRedirectModifier(): Internal.RedirectModifier<S>;
        getRequirement(): Internal.Predicate<S>;
        hashCode(): number;
        getExamples(): Internal.Collection<string>;
        addChild(arg0: Internal.CommandNode_<S>): void;
        getName(): string;
        compareTo(arg0: Internal.CommandNode_<S>): number;
        getRedirect(): this;
        getChild(arg0: string): this;
        isFork(): boolean;
        findAmbiguities(arg0: Internal.AmbiguityConsumer_<S>): void;
        getCommand(): Internal.Command<S>;
        equals(arg0: any): boolean;
        getChildren(): Internal.Collection<Internal.CommandNode<S>>;
        get usageText(): string
        get redirectModifier(): Internal.RedirectModifier<S>
        get requirement(): Internal.Predicate<S>
        get examples(): Internal.Collection<string>
        get name(): string
        get redirect(): Internal.CommandNode<S>
        get fork(): boolean
        get command(): Internal.Command<S>
        get children(): Internal.Collection<Internal.CommandNode<S>>
    }
    type CommandNode_<S> = CommandNode<S>;
    class ChunkStatus extends Internal.ForgeRegistryEntry<Internal.ChunkStatus> {
        constructor(arg0: string, arg1: Internal.ChunkStatus_, arg2: number, arg3: Internal.EnumSet_<Internal.Heightmap$Types_>, arg4: Internal.ChunkStatus$ChunkType_, arg5: any_, arg6: any_)
        getParent(): this;
        heightmapsAfter(): Internal.EnumSet<Internal.Heightmap$Types>;
        toString(): string;
        load(arg0: Internal.ServerLevel_, arg1: Internal.StructureManager_, arg2: Internal.ThreadedLevelLightEngine_, arg3: Internal.Function_<Internal.ChunkAccess_, Internal.CompletableFuture_<Internal.Either_<Internal.ChunkAccess_, Internal.ChunkHolder$ChunkLoadingFailure_>>>, arg4: Internal.ChunkAccess_): Internal.CompletableFuture<Internal.Either<Internal.ChunkAccess, Internal.ChunkHolder$ChunkLoadingFailure>>;
        getRange(): number;
        getIndex(): number;
        static byName(arg0: string): Internal.ChunkStatus;
        getChunkType(): Internal.ChunkStatus$ChunkType;
        generate(arg0: Internal.Executor_, arg1: Internal.ServerLevel_, arg2: Internal.ChunkGenerator_, arg3: Internal.StructureManager_, arg4: Internal.ThreadedLevelLightEngine_, arg5: Internal.Function_<Internal.ChunkAccess_, Internal.CompletableFuture_<Internal.Either_<Internal.ChunkAccess_, Internal.ChunkHolder$ChunkLoadingFailure_>>>, arg6: Internal.List_<Internal.ChunkAccess_>, arg7: boolean): Internal.CompletableFuture<Internal.Either<Internal.ChunkAccess, Internal.ChunkHolder$ChunkLoadingFailure>>;
        static getStatusList(): Internal.List<Internal.ChunkStatus>;
        getName(): string;
        static maxDistance(): number;
        isOrAfter(arg0: Internal.ChunkStatus_): boolean;
        static getDistance(arg0: Internal.ChunkStatus_): number;
        static getStatusAroundFullChunk(arg0: number): Internal.ChunkStatus;
        get parent(): Internal.ChunkStatus
        get range(): number
        get index(): number
        get chunkType(): Internal.ChunkStatus$ChunkType
        get statusList(): Internal.List<Internal.ChunkStatus>
        get name(): string
        readonly static "LIGHT": Internal.ChunkStatus;
        readonly static "EMPTY": Internal.ChunkStatus;
        readonly static "CARVERS": Internal.ChunkStatus;
        readonly static "FULL": Internal.ChunkStatus;
        readonly static "POST_FEATURES": any;
        readonly static "FEATURES": Internal.ChunkStatus;
        readonly static "HEIGHTMAPS": Internal.ChunkStatus;
        readonly static "SPAWN": Internal.ChunkStatus;
        readonly static "SURFACE": Internal.ChunkStatus;
        readonly static "STRUCTURE_REFERENCES": Internal.ChunkStatus;
        readonly static "STRUCTURE_STARTS": Internal.ChunkStatus;
        readonly static "BIOMES": Internal.ChunkStatus;
        readonly static "LIQUID_CARVERS": Internal.ChunkStatus;
        readonly static "MAX_STRUCTURE_DISTANCE": 8;
        readonly static "NOISE": Internal.ChunkStatus;
    }
    type ChunkStatus_ = Special.ChunkStatus | ChunkStatus;
    abstract class UnmodifiableIterator <E> implements Internal.Iterator<E> {
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
    }
    type UnmodifiableIterator_<E> = UnmodifiableIterator<E>;
    class ClickEvent implements Internal.JsonSerializable {
        constructor(arg0: Internal.ClickEvent$Action_, arg1: string)
        hashCode(): number;
        toString(): string;
        getValue(): string;
        equals(arg0: any): boolean;
        toJson(): Internal.JsonElement;
        getAction(): Internal.ClickEvent$Action;
        get value(): string
        get action(): Internal.ClickEvent$Action
    }
    type ClickEvent_ = ClickEvent;
    class ValidationContext {
        constructor(arg0: Internal.Multimap_<string, string>, arg1: Internal.Supplier_<string>, arg2: Internal.LootContextParamSet_, arg3: Internal.Function_<ResourceLocation_, Internal.LootItemCondition_>, arg4: Internal.Set_<ResourceLocation_>, arg5: Internal.Function_<ResourceLocation_, Internal.LootTable_>, arg6: Internal.Set_<ResourceLocation_>)
        constructor(arg0: Internal.LootContextParamSet_, arg1: Internal.Function_<ResourceLocation_, Internal.LootItemCondition_>, arg2: Internal.Function_<ResourceLocation_, Internal.LootTable_>)
        hasVisitedTable(arg0: ResourceLocation_): boolean;
        hasVisitedCondition(arg0: ResourceLocation_): boolean;
        forChild(arg0: string): this;
        validateUser(arg0: Internal.LootContextUser_): void;
        getProblems(): Internal.Multimap<string, string>;
        enterTable(arg0: string, arg1: ResourceLocation_): this;
        enterCondition(arg0: string, arg1: ResourceLocation_): this;
        setParams(arg0: Internal.LootContextParamSet_): this;
        resolveLootTable(arg0: ResourceLocation_): Internal.LootTable;
        reportProblem(arg0: string): void;
        resolveCondition(arg0: ResourceLocation_): Internal.LootItemCondition;
        get problems(): Internal.Multimap<string, string>
        set params(arg0: Internal.LootContextParamSet_)
    }
    type ValidationContext_ = ValidationContext;
    class CocoaDecorator extends Internal.TreeDecorator {
        constructor(arg0: number)
        place(arg0: Internal.LevelSimulatedReader_, arg1: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>, arg2: Internal.Random_, arg3: Internal.List_<BlockPos_>, arg4: Internal.List_<BlockPos_>): void;
        readonly static "CODEC": any;
    }
    type CocoaDecorator_ = CocoaDecorator;
    abstract class SocketAddress implements Internal.Serializable {
        constructor()
    }
    type SocketAddress_ = SocketAddress;
    class ByteTag extends Internal.NumericTag {
        static valueOf(arg0: number): Internal.ByteTag;
        getAsDouble(): number;
        accept(arg0: Internal.TagVisitor_): void;
        getAsLong(): number;
        getAsFloat(): number;
        hashCode(): number;
        getAsString(): string;
        getAsInt(): number;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        getAsByte(): number;
        getAsNumber(): Internal.Number;
        static valueOf(arg0: boolean): Internal.ByteTag;
        getType(): Internal.TagType<Internal.ByteTag>;
        write(arg0: Internal.DataOutput_): void;
        getId(): number;
        getAsShort(): number;
        equals(arg0: any): boolean;
        accept(arg0: Internal.StreamTagVisitor_): Internal.StreamTagVisitor$ValueResult;
        copy(): this;
        get asDouble(): number
        get asLong(): number
        get asFloat(): number
        get asString(): string
        get asInt(): number
        get asByte(): number
        get asNumber(): Internal.Number
        get type(): Internal.TagType<Internal.ByteTag>
        get id(): number
        get asShort(): number
        readonly static "ONE": Internal.ByteTag;
        readonly static "ZERO": Internal.ByteTag;
        readonly static "TYPE": any;
    }
    type ByteTag_ = ByteTag;
    class ComparatorMode extends Internal.Enum<Internal.ComparatorMode> implements Internal.StringRepresentable {
        toString(): string;
        getSerializedName(): string;
        static valueOf(arg0: string): Internal.ComparatorMode;
        static values(): Internal.ComparatorMode[];
        get serializedName(): string
        readonly static "COMPARE": Internal.ComparatorMode;
        readonly static "SUBTRACT": Internal.ComparatorMode;
    }
    type ComparatorMode_ = "compare" | ComparatorMode | "subtract";
    class ModCheck extends Internal.Record {
        constructor(arg0: Internal.ModCheck$Confidence_, arg1: string)
        shouldReportAsModified(): boolean;
        hashCode(): number;
        fullDescription(): string;
        toString(): string;
        static identify(arg0: string, arg1: Internal.Supplier_<string>, arg2: string, arg3: Internal.Class_<any>): Internal.ModCheck;
        equals(arg0: any): boolean;
        description(): string;
        merge(arg0: Internal.ModCheck_): this;
        confidence(): Internal.ModCheck$Confidence;
    }
    type ModCheck_ = ModCheck;
    interface ItemBuilder$FinishUsingCallback {
        finishUsingItem(arg0: Internal.ItemStackJS_, arg1: Internal.LevelJS_, arg2: Internal.LivingEntityJS_): Internal.ItemStackJS;
    }
    type ItemBuilder$FinishUsingCallback_ = ItemBuilder$FinishUsingCallback | ((arg0: Internal.ItemStackJS, arg1: Internal.LevelJS, arg2: Internal.LivingEntityJS)=>Internal.ItemStackJS_);
    class PlayerDataStorage {
        constructor(arg0: Internal.LevelStorageSource$LevelStorageAccess_, arg1: Internal.DataFixer_)
        load(arg0: Internal.Player_): Internal.CompoundTag;
        getSeenPlayers(): string[];
        getPlayerDataFolder(): Internal.File;
        save(arg0: Internal.Player_): void;
        get seenPlayers(): string[]
        get playerDataFolder(): Internal.File
    }
    type PlayerDataStorage_ = PlayerDataStorage;
    interface Int2IntFunction extends Internal.IntUnaryOperator, it.unimi.dsi.fastutil.Function<number, number> {
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2IntFunction;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Int2FloatFunction;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2IntFunction;
        getOrDefault(arg0: any, arg1: any): any;
        remove(arg0: number): number;
        defaultReturnValue(): number;
        apply(arg0: number): number;
        containsKey(arg0: number): boolean;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        containsKey(arg0: any): boolean;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Int2ByteFunction;
        composeObject(arg0: Internal.Object2IntFunction_<any>): Internal.Object2IntFunction<T>;
        getOrDefault(arg0: number, arg1: number): number;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        applyAsInt(arg0: number): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        put(arg0: any, arg1: any): any;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2IntFunction;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Int2DoubleFunction;
        remove(arg0: any): number;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2IntFunction;
        composeReference(arg0: Internal.Reference2IntFunction_<any>): Internal.Reference2IntFunction<T>;
        composeInt(arg0: Internal.Int2IntFunction_): this;
        getOrDefault(arg0: any, arg1: number): number;
        put(arg0: number, arg1: number): number;
        andThenInt(arg0: Internal.Int2IntFunction_): this;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Int2CharFunction;
        put(arg0: number, arg1: number): number;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Int2LongFunction;
        andThenObject(arg0: Internal.Int2ObjectFunction_<any>): Internal.Int2ObjectFunction<T>;
        andThenReference(arg0: Internal.Int2ReferenceFunction_<any>): Internal.Int2ReferenceFunction<T>;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Int2ShortFunction;
        size(): number;
        defaultReturnValue(arg0: number): void;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2IntFunction;
        clear(): void;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2IntFunction;
        get(arg0: number): number;
        get(arg0: any): any;
        identity(): this;
    }
    type Int2IntFunction_ = Int2IntFunction | ((arg0: number)=>number);
    class VanillaPackResources implements Internal.ResourceProvider, Internal.PackResources {
        constructor(arg0: Internal.PackMetadataSection_, ...arg1: string[])
        hasResource(arg0: Internal.PackType_, arg1: ResourceLocation_): boolean;
        getResource(arg0: ResourceLocation_): Internal.Resource;
        getName(): string;
        getNamespaces(arg0: Internal.PackType_): Internal.Set<string>;
        close(): void;
        isHidden(): boolean;
        getResources(arg0: Internal.PackType_, arg1: string, arg2: string, arg3: number, arg4: Internal.Predicate_<string>): Internal.Collection<ResourceLocation>;
        getRootResource(arg0: string): Internal.InputStream;
        getResource(arg0: Internal.PackType_, arg1: ResourceLocation_): Internal.InputStream;
        getMetadataSection(arg0: Internal.MetadataSectionSerializer_<T>): T;
        get name(): string
        get hidden(): boolean
        static "generatedDir": Internal.Path;
        readonly "packMetadata": Internal.PackMetadataSection;
        static "clientObject": Internal.Class<any>;
        readonly "namespaces": Internal.Set<string>;
    }
    type VanillaPackResources_ = VanillaPackResources;
    class RenderGameOverlayEvent$Chat extends Internal.RenderGameOverlayEvent$Pre {
        constructor()
        constructor(arg0: Internal.PoseStack_, arg1: Internal.RenderGameOverlayEvent_, arg2: number, arg3: number)
        getListenerList(): Internal.ListenerList;
        setPosX(arg0: number): void;
        setPosY(arg0: number): void;
        getPosY(): number;
        getPosX(): number;
        get listenerList(): Internal.ListenerList
        set posX(arg0: number)
        set posY(arg0: number)
        get posY(): number
        get posX(): number
    }
    type RenderGameOverlayEvent$Chat_ = RenderGameOverlayEvent$Chat;
    class Possible <T> extends Internal.Record {
        constructor(value: any)
        hashCode(): number;
        toString(): string;
        isSet(): boolean;
        value(): any;
        cast(type: Internal.Class_<C>): Internal.Possible<C>;
        isEmpty(): boolean;
        equals(o: any): boolean;
        static of(o: T): Internal.Possible<T>;
        static absent(): Internal.Possible<T>;
        get set(): boolean
        get empty(): boolean
        readonly static "NULL": Internal.Possible<any>;
        readonly static "EMPTY": Internal.Possible<any>;
    }
    type Possible_<T> = Possible<T>;
    class ScreenEvent$KeyboardKeyPressedEvent$Post extends Internal.ScreenEvent$KeyboardKeyPressedEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number, arg3: number)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$KeyboardKeyPressedEvent$Post_ = ScreenEvent$KeyboardKeyPressedEvent$Post;
    class MemoryStack extends Internal.Pointer$Default implements Internal.AutoCloseable {
        push(): this;
        shorts(arg0: number, arg1: number, arg2: number): Internal.ShortBuffer;
        static stackCallocDouble(arg0: number): Internal.DoubleBuffer;
        ncalloc(arg0: number, arg1: number, arg2: number): number;
        pointers(arg0: Internal.Buffer_, arg1: Internal.Buffer_, arg2: Internal.Buffer_, arg3: Internal.Buffer_): Internal.PointerBuffer;
        floats(...arg0: number[]): Internal.FloatBuffer;
        calloc(arg0: number, arg1: number): Internal.ByteBuffer;
        static stackFloats(arg0: number): Internal.FloatBuffer;
        static stackPush(): Internal.MemoryStack;
        static nstackMalloc(arg0: number): number;
        bytes(arg0: number, arg1: number, arg2: number, arg3: number): Internal.ByteBuffer;
        malloc(arg0: number, arg1: number): Internal.ByteBuffer;
        longs(arg0: number, arg1: number): Internal.LongBuffer;
        ASCIISafe(arg0: Internal.CharSequence_): Internal.ByteBuffer;
        getSize(): number;
        pointers(arg0: number, arg1: number, arg2: number, arg3: number): Internal.PointerBuffer;
        static stackMallocInt(arg0: number): Internal.IntBuffer;
        ASCIISafe(arg0: Internal.CharSequence_, arg1: boolean): Internal.ByteBuffer;
        UTF16(arg0: Internal.CharSequence_, arg1: boolean): Internal.ByteBuffer;
        static stackCallocFloat(arg0: number): Internal.FloatBuffer;
        static stackPointers(arg0: number, arg1: number, arg2: number, arg3: number): Internal.PointerBuffer;
        ints(arg0: number): Internal.IntBuffer;
        static stackLongs(arg0: number): Internal.LongBuffer;
        static stackInts(arg0: number): Internal.IntBuffer;
        ints(arg0: number, arg1: number, arg2: number, arg3: number): Internal.IntBuffer;
        static stackMallocFloat(arg0: number): Internal.FloatBuffer;
        UTF16(arg0: Internal.CharSequence_): Internal.ByteBuffer;
        static create(arg0: Internal.ByteBuffer_): Internal.MemoryStack;
        static stackCallocShort(arg0: number): Internal.ShortBuffer;
        ASCII(arg0: Internal.CharSequence_, arg1: boolean): Internal.ByteBuffer;
        shorts(arg0: number): Internal.ShortBuffer;
        doubles(arg0: number, arg1: number): Internal.DoubleBuffer;
        pointers(arg0: Internal.Buffer_, arg1: Internal.Buffer_, arg2: Internal.Buffer_): Internal.PointerBuffer;
        mallocInt(arg0: number): Internal.IntBuffer;
        pointers(...arg0: number[]): Internal.PointerBuffer;
        bytes(...arg0: number[]): Internal.ByteBuffer;
        static stackDoubles(arg0: number): Internal.DoubleBuffer;
        nUTF8Safe(arg0: Internal.CharSequence_, arg1: boolean): number;
        static stackUTF16Safe(arg0: Internal.CharSequence_, arg1: boolean): Internal.ByteBuffer;
        static stackShorts(arg0: number): Internal.ShortBuffer;
        pointers(...arg0: Internal.Buffer_[]): Internal.PointerBuffer;
        static stackUTF16(arg0: Internal.CharSequence_, arg1: boolean): Internal.ByteBuffer;
        static stackDoubles(arg0: number, arg1: number, arg2: number): Internal.DoubleBuffer;
        callocDouble(arg0: number): Internal.DoubleBuffer;
        static stackCalloc(arg0: number): Internal.ByteBuffer;
        longs(arg0: number, arg1: number, arg2: number): Internal.LongBuffer;
        getFrameIndex(): number;
        static stackFloats(...arg0: number[]): Internal.FloatBuffer;
        pointers(arg0: Internal.Pointer_): Internal.PointerBuffer;
        static stackShorts(arg0: number, arg1: number, arg2: number): Internal.ShortBuffer;
        static stackUTF16Safe(arg0: Internal.CharSequence_): Internal.ByteBuffer;
        UTF16Safe(arg0: Internal.CharSequence_, arg1: boolean): Internal.ByteBuffer;
        UTF8Safe(arg0: Internal.CharSequence_): Internal.ByteBuffer;
        static ncreate(arg0: number, arg1: number): Internal.MemoryStack;
        static stackUTF8(arg0: Internal.CharSequence_, arg1: boolean): Internal.ByteBuffer;
        static stackBytes(...arg0: number[]): Internal.ByteBuffer;
        static stackBytes(arg0: number, arg1: number): Internal.ByteBuffer;
        static stackMallocShort(arg0: number): Internal.ShortBuffer;
        UTF8Safe(arg0: Internal.CharSequence_, arg1: boolean): Internal.ByteBuffer;
        nmalloc(arg0: number, arg1: number): number;
        static nstackCalloc(arg0: number, arg1: number, arg2: number): number;
        ints(...arg0: number[]): Internal.IntBuffer;
        nASCII(arg0: Internal.CharSequence_, arg1: boolean): number;
        static stackPointers(arg0: number, arg1: number): Internal.PointerBuffer;
        static stackInts(arg0: number, arg1: number, arg2: number, arg3: number): Internal.IntBuffer;
        static stackDoubles(arg0: number, arg1: number): Internal.DoubleBuffer;
        static stackPointers(...arg0: Internal.Pointer_[]): Internal.PointerBuffer;
        getPointer(): number;
        UTF8(arg0: Internal.CharSequence_, arg1: boolean): Internal.ByteBuffer;
        static stackShorts(arg0: number, arg1: number, arg2: number, arg3: number): Internal.ShortBuffer;
        longs(arg0: number, arg1: number, arg2: number, arg3: number): Internal.LongBuffer;
        floats(arg0: number, arg1: number, arg2: number): Internal.FloatBuffer;
        setPointer(arg0: number): void;
        bytes(arg0: number, arg1: number, arg2: number): Internal.ByteBuffer;
        static stackPointers(arg0: number, arg1: number, arg2: number): Internal.PointerBuffer;
        static stackASCIISafe(arg0: Internal.CharSequence_, arg1: boolean): Internal.ByteBuffer;
        static stackPop(): Internal.MemoryStack;
        pointers(arg0: number): Internal.PointerBuffer;
        mallocFloat(arg0: number): Internal.FloatBuffer;
        bytes(arg0: number): Internal.ByteBuffer;
        static stackDoubles(...arg0: number[]): Internal.DoubleBuffer;
        callocShort(arg0: number): Internal.ShortBuffer;
        getPointerAddress(): number;
        static nstackMalloc(arg0: number, arg1: number): number;
        static stackASCIISafe(arg0: Internal.CharSequence_): Internal.ByteBuffer;
        pointers(arg0: number, arg1: number, arg2: number): Internal.PointerBuffer;
        static stackCallocLong(arg0: number): Internal.LongBuffer;
        mallocLong(arg0: number): Internal.LongBuffer;
        pointers(arg0: Internal.Buffer_): Internal.PointerBuffer;
        pointers(arg0: Internal.Pointer_, arg1: Internal.Pointer_, arg2: Internal.Pointer_, arg3: Internal.Pointer_): Internal.PointerBuffer;
        static stackShorts(...arg0: number[]): Internal.ShortBuffer;
        calloc(arg0: number): Internal.ByteBuffer;
        static stackCallocInt(arg0: number): Internal.IntBuffer;
        static stackASCII(arg0: Internal.CharSequence_): Internal.ByteBuffer;
        pointers(...arg0: Internal.Pointer_[]): Internal.PointerBuffer;
        nUTF16(arg0: Internal.CharSequence_, arg1: boolean): number;
        callocFloat(arg0: number): Internal.FloatBuffer;
        static stackASCII(arg0: Internal.CharSequence_, arg1: boolean): Internal.ByteBuffer;
        pointers(arg0: Internal.Pointer_, arg1: Internal.Pointer_): Internal.PointerBuffer;
        static stackLongs(arg0: number, arg1: number, arg2: number): Internal.LongBuffer;
        nUTF16Safe(arg0: Internal.CharSequence_, arg1: boolean): number;
        ints(arg0: number, arg1: number): Internal.IntBuffer;
        getAddress(): number;
        static stackBytes(arg0: number): Internal.ByteBuffer;
        longs(...arg0: number[]): Internal.LongBuffer;
        static stackBytes(arg0: number, arg1: number, arg2: number): Internal.ByteBuffer;
        callocPointer(arg0: number): Internal.PointerBuffer;
        static stackPointers(arg0: Internal.Pointer_, arg1: Internal.Pointer_, arg2: Internal.Pointer_): Internal.PointerBuffer;
        mallocPointer(arg0: number): Internal.PointerBuffer;
        floats(arg0: number, arg1: number): Internal.FloatBuffer;
        static stackFloats(arg0: number, arg1: number, arg2: number, arg3: number): Internal.FloatBuffer;
        static stackShorts(arg0: number, arg1: number): Internal.ShortBuffer;
        static stackPointers(arg0: Internal.Pointer_, arg1: Internal.Pointer_): Internal.PointerBuffer;
        pointers(arg0: Internal.Buffer_, arg1: Internal.Buffer_): Internal.PointerBuffer;
        static stackPointers(...arg0: number[]): Internal.PointerBuffer;
        static stackPointers(arg0: Internal.Pointer_): Internal.PointerBuffer;
        malloc(arg0: number): Internal.ByteBuffer;
        ints(arg0: number, arg1: number, arg2: number): Internal.IntBuffer;
        static stackPointers(arg0: Internal.Pointer_, arg1: Internal.Pointer_, arg2: Internal.Pointer_, arg3: Internal.Pointer_): Internal.PointerBuffer;
        static stackMallocDouble(arg0: number): Internal.DoubleBuffer;
        static stackGet(): Internal.MemoryStack;
        shorts(arg0: number, arg1: number): Internal.ShortBuffer;
        static stackInts(arg0: number, arg1: number): Internal.IntBuffer;
        static stackDoubles(arg0: number, arg1: number, arg2: number, arg3: number): Internal.DoubleBuffer;
        static create(arg0: number): Internal.MemoryStack;
        callocInt(arg0: number): Internal.IntBuffer;
        doubles(arg0: number): Internal.DoubleBuffer;
        mallocDouble(arg0: number): Internal.DoubleBuffer;
        UTF8(arg0: Internal.CharSequence_): Internal.ByteBuffer;
        static stackMallocLong(arg0: number): Internal.LongBuffer;
        floats(arg0: number, arg1: number, arg2: number, arg3: number): Internal.FloatBuffer;
        static stackLongs(arg0: number, arg1: number): Internal.LongBuffer;
        static stackFloats(arg0: number, arg1: number): Internal.FloatBuffer;
        static stackUTF8Safe(arg0: Internal.CharSequence_, arg1: boolean): Internal.ByteBuffer;
        callocLong(arg0: number): Internal.LongBuffer;
        static stackBytes(arg0: number, arg1: number, arg2: number, arg3: number): Internal.ByteBuffer;
        pointers(arg0: number, arg1: number): Internal.PointerBuffer;
        doubles(arg0: number, arg1: number, arg2: number): Internal.DoubleBuffer;
        floats(arg0: number): Internal.FloatBuffer;
        static stackMalloc(arg0: number): Internal.ByteBuffer;
        nUTF8(arg0: Internal.CharSequence_, arg1: boolean): number;
        nASCIISafe(arg0: Internal.CharSequence_, arg1: boolean): number;
        longs(arg0: number): Internal.LongBuffer;
        pointers(arg0: Internal.Pointer_, arg1: Internal.Pointer_, arg2: Internal.Pointer_): Internal.PointerBuffer;
        static stackCallocPointer(arg0: number): Internal.PointerBuffer;
        static stackUTF8Safe(arg0: Internal.CharSequence_): Internal.ByteBuffer;
        static stackUTF16(arg0: Internal.CharSequence_): Internal.ByteBuffer;
        static stackInts(arg0: number, arg1: number, arg2: number): Internal.IntBuffer;
        nmalloc(arg0: number): number;
        pop(): this;
        static stackLongs(...arg0: number[]): Internal.LongBuffer;
        doubles(arg0: number, arg1: number, arg2: number, arg3: number): Internal.DoubleBuffer;
        static stackPointers(arg0: number): Internal.PointerBuffer;
        static stackLongs(arg0: number, arg1: number, arg2: number, arg3: number): Internal.LongBuffer;
        mallocShort(arg0: number): Internal.ShortBuffer;
        static stackInts(...arg0: number[]): Internal.IntBuffer;
        UTF16Safe(arg0: Internal.CharSequence_): Internal.ByteBuffer;
        static stackMallocPointer(arg0: number): Internal.PointerBuffer;
        shorts(...arg0: number[]): Internal.ShortBuffer;
        static stackUTF8(arg0: Internal.CharSequence_): Internal.ByteBuffer;
        shorts(arg0: number, arg1: number, arg2: number, arg3: number): Internal.ShortBuffer;
        doubles(...arg0: number[]): Internal.DoubleBuffer;
        close(): void;
        static create(): Internal.MemoryStack;
        static stackFloats(arg0: number, arg1: number, arg2: number): Internal.FloatBuffer;
        ASCII(arg0: Internal.CharSequence_): Internal.ByteBuffer;
        bytes(arg0: number, arg1: number): Internal.ByteBuffer;
        get size(): number
        get frameIndex(): number
        get pointer(): number
        set pointer(arg0: number)
        get pointerAddress(): number
        get address(): number
    }
    type MemoryStack_ = MemoryStack;
    class LocalTime implements Internal.Comparable<Internal.LocalTime>, Internal.Temporal, Internal.TemporalAdjuster, Internal.Serializable {
        getHour(): number;
        minusMinutes(arg0: number): this;
        static parse(arg0: Internal.CharSequence_, arg1: Internal.DateTimeFormatter_): Internal.LocalTime;
        minusSeconds(arg0: number): this;
        compareTo(arg0: any): number;
        isBefore(arg0: Internal.LocalTime_): boolean;
        getMinute(): number;
        static parse(arg0: Internal.CharSequence_): Internal.LocalTime;
        toSecondOfDay(): number;
        plusHours(arg0: number): this;
        with(arg0: Internal.TemporalAdjuster_): Internal.Temporal;
        minus(arg0: Internal.TemporalAmount_): this;
        with(arg0: Internal.TemporalField_, arg1: number): Internal.Temporal;
        isSupported(arg0: Internal.TemporalField_): boolean;
        format(arg0: Internal.DateTimeFormatter_): string;
        isAfter(arg0: Internal.LocalTime_): boolean;
        withMinute(arg0: number): this;
        plusNanos(arg0: number): this;
        static ofInstant(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.LocalTime;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        get(arg0: Internal.TemporalField_): number;
        minusHours(arg0: number): this;
        compareTo(arg0: Internal.LocalTime_): number;
        toEpochSecond(arg0: Internal.LocalDate_, arg1: Internal.ZoneOffset_): number;
        withNano(arg0: number): this;
        static from(arg0: Internal.TemporalAccessor_): Internal.LocalTime;
        plus(arg0: number, arg1: Internal.TemporalUnit_): this;
        plusMinutes(arg0: number): this;
        plusSeconds(arg0: number): this;
        static ofNanoOfDay(arg0: number): Internal.LocalTime;
        static now(arg0: Internal.ZoneId_): Internal.LocalTime;
        getLong(arg0: Internal.TemporalField_): number;
        withSecond(arg0: number): this;
        atDate(arg0: Internal.LocalDate_): Internal.LocalDateTime;
        static of(arg0: number, arg1: number, arg2: number, arg3: number): Internal.LocalTime;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Temporal;
        static ofSecondOfDay(arg0: number): Internal.LocalTime;
        toNanoOfDay(): number;
        toString(): string;
        truncatedTo(arg0: Internal.TemporalUnit_): this;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        static now(arg0: Internal.Clock_): Internal.LocalTime;
        query(arg0: Internal.TemporalQuery_<R>): R;
        minusNanos(arg0: number): this;
        static of(arg0: number, arg1: number): Internal.LocalTime;
        atOffset(arg0: Internal.ZoneOffset_): Internal.OffsetTime;
        static now(): Internal.LocalTime;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        getNano(): number;
        getSecond(): number;
        plus(arg0: Internal.TemporalAmount_): Internal.Temporal;
        hashCode(): number;
        static of(arg0: number, arg1: number, arg2: number): Internal.LocalTime;
        equals(arg0: any): boolean;
        withHour(arg0: number): this;
        get hour(): number
        get minute(): number
        get nano(): number
        get second(): number
        readonly static "MAX": Internal.LocalTime;
        readonly static "NOON": Internal.LocalTime;
        readonly static "MIDNIGHT": Internal.LocalTime;
        readonly static "MIN": Internal.LocalTime;
    }
    type LocalTime_ = LocalTime;
    class StateDefinition <O, S> {
        toString(): string;
        getProperties(): Internal.Collection<Internal.Property<any>>;
        getPossibleStates(): Internal.ImmutableList<S>;
        getOwner(): O;
        any(): S;
        getProperty(arg0: string): Internal.Property<any>;
        get properties(): Internal.Collection<Internal.Property<any>>
        get possibleStates(): Internal.ImmutableList<S>
        get owner(): O
    }
    type StateDefinition_<O, S> = StateDefinition<O, S>;
    class ModuleDescriptor$Requires$Modifier extends Internal.Enum<Internal.ModuleDescriptor$Requires$Modifier> {
        static values(): Internal.ModuleDescriptor$Requires$Modifier[];
        static valueOf(arg0: string): Internal.ModuleDescriptor$Requires$Modifier;
        readonly static "STATIC": Internal.ModuleDescriptor$Requires$Modifier;
        readonly static "MANDATED": Internal.ModuleDescriptor$Requires$Modifier;
        readonly static "TRANSITIVE": Internal.ModuleDescriptor$Requires$Modifier;
        readonly static "SYNTHETIC": Internal.ModuleDescriptor$Requires$Modifier;
    }
    type ModuleDescriptor$Requires$Modifier_ = ModuleDescriptor$Requires$Modifier | "static" | "mandated" | "transitive" | "synthetic";
    class ClientboundStopSoundPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: ResourceLocation_, arg1: Internal.SoundSource_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getSource(): Internal.SoundSource;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getName(): ResourceLocation;
        isSkippable(): boolean;
        get source(): Internal.SoundSource
        get name(): ResourceLocation
        get skippable(): boolean
    }
    type ClientboundStopSoundPacket_ = ClientboundStopSoundPacket;
    class ChunkRenderDispatcher$CompiledChunk {
        constructor()
        facesCanSeeEachother(arg0: Internal.Direction_, arg1: Internal.Direction_): boolean;
        getRenderableBlockEntities(): Internal.List<Internal.BlockEntity>;
        hasNoRenderableLayers(): boolean;
        isEmpty(arg0: Internal.RenderType_): boolean;
        get renderableBlockEntities(): Internal.List<Internal.BlockEntity>
        readonly static "UNCOMPILED": any;
    }
    type ChunkRenderDispatcher$CompiledChunk_ = ChunkRenderDispatcher$CompiledChunk;
    class ClampedNormalInt extends Internal.IntProvider {
        getMinValue(): number;
        getType(): Internal.IntProviderType<any>;
        static sample(arg0: Internal.Random_, arg1: number, arg2: number, arg3: number, arg4: number): number;
        toString(): string;
        getMaxValue(): number;
        sample(arg0: Internal.Random_): number;
        static of(arg0: number, arg1: number, arg2: number, arg3: number): Internal.ClampedNormalInt;
        get minValue(): number
        get type(): Internal.IntProviderType<any>
        get maxValue(): number
        readonly static "CODEC": any;
    }
    type ClampedNormalInt_ = ClampedNormalInt;
    interface DensityFunctions$BeardifierOrMarker extends Internal.DensityFunction$SimpleFunction {
        halfNegative(): Internal.DensityFunction;
        abs(): Internal.DensityFunction;
        quarterNegative(): Internal.DensityFunction;
        cube(): Internal.DensityFunction;
        fillArray(arg0: number[], arg1: Internal.DensityFunction$ContextProvider_): void;
        squeeze(): Internal.DensityFunction;
        square(): Internal.DensityFunction;
        mapAll(arg0: Internal.DensityFunction$Visitor_): Internal.DensityFunction;
        codec(): Internal.Codec<any>;
        clamp(arg0: number, arg1: number): Internal.DensityFunction;
        readonly static "CODEC": any;
    }
    type DensityFunctions$BeardifierOrMarker_ = DensityFunctions$BeardifierOrMarker;
    class InetSocketAddress extends Internal.SocketAddress {
        constructor(arg0: string, arg1: number)
        constructor(arg0: number)
        constructor(arg0: Internal.InetAddress_, arg1: number)
        hashCode(): number;
        static createUnresolved(arg0: string, arg1: number): Internal.InetSocketAddress;
        getHostName(): string;
        toString(): string;
        isUnresolved(): boolean;
        getPort(): number;
        equals(arg0: any): boolean;
        getAddress(): Internal.InetAddress;
        getHostString(): string;
        get hostName(): string
        get unresolved(): boolean
        get port(): number
        get address(): Internal.InetAddress
        get hostString(): string
    }
    type InetSocketAddress_ = InetSocketAddress;
    class IronGolem extends Internal.AbstractGolem implements Internal.NeutralMob {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        playerDied(arg0: Internal.Player_): void;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        isAngry(): boolean;
        getOfferFlowerTick(): number;
        offerFlower(arg0: boolean): void;
        setPlayerCreated(arg0: boolean): void;
        getStepHeight(): number;
        forgetCurrentTargetAndRefreshUniversalAnger(): void;
        asKJS(): Internal.EntityJS;
        startPersistentAngerTimer(): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        addPersistentAngerSaveData(arg0: Internal.CompoundTag_): void;
        isMultipartEntity(): boolean;
        setRemainingPersistentAngerTime(arg0: number): void;
        serializeNBT(): Internal.Tag;
        checkSpawnObstruction(arg0: Internal.LevelReader_): boolean;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        isAngryAt(arg0: Internal.LivingEntity_): boolean;
        isPlayerCreated(): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        getRemainingPersistentAngerTime(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        getPersistentAngerTarget(): Internal.UUID;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getCrackiness(): Internal.IronGolem$Crackiness;
        readPersistentAngerSaveData(arg0: Internal.Level_, arg1: Internal.CompoundTag_): void;
        stopBeingAngry(): void;
        getAttackAnimationTick(): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        die(arg0: Internal.DamageSource_): void;
        setPersistentAngerTarget(arg0: Internal.UUID_): void;
        getLeashOffset(): Vec3;
        updatePersistentAnger(arg0: Internal.ServerLevel_, arg1: boolean): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        isAngryAtAllPlayers(arg0: Internal.Level_): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        canAttackType(arg0: Internal.EntityType_<any>): boolean;
        get angry(): boolean
        get offerFlowerTick(): number
        set playerCreated(arg0: boolean)
        get stepHeight(): number
        get multipartEntity(): boolean
        set remainingPersistentAngerTime(arg0: number)
        get playerCreated(): boolean
        get parts(): Internal.PartEntity<any>[]
        get remainingPersistentAngerTime(): number
        get persistentAngerTarget(): Internal.UUID
        get crackiness(): Internal.IronGolem$Crackiness
        get attackAnimationTick(): number
        set persistentAngerTarget(arg0: Internal.UUID_)
        get leashOffset(): Vec3
    }
    type IronGolem_ = IronGolem;
    class VarHandle$AccessMode extends Internal.Enum<Internal.VarHandle$AccessMode> {
        static valueFromMethodName(arg0: string): Internal.VarHandle$AccessMode;
        static values(): Internal.VarHandle$AccessMode[];
        static valueOf(arg0: string): Internal.VarHandle$AccessMode;
        methodName(): string;
        readonly static "GET_AND_BITWISE_AND_ACQUIRE": Internal.VarHandle$AccessMode;
        readonly static "GET_AND_BITWISE_OR": Internal.VarHandle$AccessMode;
        readonly static "COMPARE_AND_SET": Internal.VarHandle$AccessMode;
        readonly static "GET_AND_SET_RELEASE": Internal.VarHandle$AccessMode;
        readonly static "GET_AND_BITWISE_OR_ACQUIRE": Internal.VarHandle$AccessMode;
        readonly static "GET": Internal.VarHandle$AccessMode;
        readonly static "GET_AND_ADD": Internal.VarHandle$AccessMode;
        readonly static "GET_AND_BITWISE_AND_RELEASE": Internal.VarHandle$AccessMode;
        readonly static "GET_OPAQUE": Internal.VarHandle$AccessMode;
        readonly static "GET_AND_BITWISE_AND": Internal.VarHandle$AccessMode;
        readonly static "GET_AND_BITWISE_XOR": Internal.VarHandle$AccessMode;
        readonly static "SET_OPAQUE": Internal.VarHandle$AccessMode;
        readonly static "GET_AND_SET": Internal.VarHandle$AccessMode;
        readonly static "GET_AND_BITWISE_XOR_ACQUIRE": Internal.VarHandle$AccessMode;
        readonly static "SET_VOLATILE": Internal.VarHandle$AccessMode;
        readonly static "GET_AND_BITWISE_OR_RELEASE": Internal.VarHandle$AccessMode;
        readonly static "COMPARE_AND_EXCHANGE": Internal.VarHandle$AccessMode;
        readonly static "GET_AND_SET_ACQUIRE": Internal.VarHandle$AccessMode;
        readonly static "GET_VOLATILE": Internal.VarHandle$AccessMode;
        readonly static "GET_ACQUIRE": Internal.VarHandle$AccessMode;
        readonly static "GET_AND_ADD_RELEASE": Internal.VarHandle$AccessMode;
        readonly static "SET": Internal.VarHandle$AccessMode;
        readonly static "GET_AND_ADD_ACQUIRE": Internal.VarHandle$AccessMode;
        readonly static "WEAK_COMPARE_AND_SET": Internal.VarHandle$AccessMode;
        readonly static "COMPARE_AND_EXCHANGE_ACQUIRE": Internal.VarHandle$AccessMode;
        readonly static "GET_AND_BITWISE_XOR_RELEASE": Internal.VarHandle$AccessMode;
        readonly static "SET_RELEASE": Internal.VarHandle$AccessMode;
        readonly static "COMPARE_AND_EXCHANGE_RELEASE": Internal.VarHandle$AccessMode;
        readonly static "WEAK_COMPARE_AND_SET_ACQUIRE": Internal.VarHandle$AccessMode;
        readonly static "WEAK_COMPARE_AND_SET_RELEASE": Internal.VarHandle$AccessMode;
        readonly static "WEAK_COMPARE_AND_SET_PLAIN": Internal.VarHandle$AccessMode;
    }
    type VarHandle$AccessMode_ = "get_and_set_acquire" | "get_and_bitwise_and" | "weak_compare_and_set_acquire" | "get_and_set" | "get_and_bitwise_xor_acquire" | "compare_and_set" | "weak_compare_and_set_release" | "get_and_bitwise_xor_release" | "get_and_add_acquire" | "get_and_add_release" | "get_and_bitwise_xor" | "get_and_bitwise_or" | VarHandle$AccessMode | "get" | "set_release" | "weak_compare_and_set_plain" | "get_and_add" | "get_and_bitwise_or_acquire" | "get_acquire" | "get_and_bitwise_and_acquire" | "compare_and_exchange_acquire" | "get_opaque" | "compare_and_exchange" | "get_and_bitwise_or_release" | "set" | "get_volatile" | "set_volatile" | "weak_compare_and_set" | "get_and_set_release" | "compare_and_exchange_release" | "set_opaque" | "get_and_bitwise_and_release";
    class LootScoreProviderType extends Internal.SerializerType<any> {
        constructor(arg0: Internal.Serializer_<any>)
    }
    type LootScoreProviderType_ = Special.LootScoreProviderType | LootScoreProviderType;
    abstract class AbstractChestedHorse extends Internal.AbstractHorse {
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        setChest(arg0: boolean): void;
        deserializeNBT(arg0: Internal.Tag_): void;
        getInventoryColumns(): number;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        hasChest(): boolean;
        getSlot(arg0: number): Internal.SlotAccess;
        getPassengersRidingOffset(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        alwaysAccepts(): boolean;
        isMultipartEntity(): boolean;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        serializeNBT(): Internal.Tag;
        static createBaseChestedHorseAttributes(): Internal.AttributeSupplier$Builder;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        foodEatenKJS(is: Internal.ItemStack_): void;
        set chest(arg0: boolean)
        get inventoryColumns(): number
        get passengersRidingOffset(): number
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        readonly static "INV_CHEST_COUNT": 15;
    }
    type AbstractChestedHorse_ = AbstractChestedHorse;
    interface INBTSerializable <T> {
        serializeNBT(): T;
        deserializeNBT(arg0: T): void;
    }
    type INBTSerializable_<T> = INBTSerializable<T>;
    interface Double2ShortFunction extends Internal.DoubleToIntFunction, it.unimi.dsi.fastutil.Function<number, number> {
        andThenReference(arg0: Internal.Short2ReferenceFunction_<any>): Internal.Double2ReferenceFunction<T>;
        getOrDefault(arg0: number, arg1: number): number;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Double2FloatFunction;
        composeReference(arg0: Internal.Reference2DoubleFunction_<any>): Internal.Reference2ShortFunction<T>;
        andThenObject(arg0: Internal.Short2ObjectFunction_<any>): Internal.Double2ObjectFunction<T>;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Double2CharFunction;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2ShortFunction;
        getOrDefault(arg0: any, arg1: any): any;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Double2IntFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        containsKey(arg0: any): boolean;
        composeObject(arg0: Internal.Object2DoubleFunction_<any>): Internal.Object2ShortFunction<T>;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2ShortFunction;
        get(arg0: any): number;
        defaultReturnValue(): number;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Double2DoubleFunction;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Double2ByteFunction;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2ShortFunction;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2ShortFunction;
        put(arg0: number, arg1: number): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2ShortFunction;
        andThenShort(arg0: Internal.Short2ShortFunction_): this;
        containsKey(arg0: number): boolean;
        size(): number;
        apply(arg0: number): number;
        defaultReturnValue(arg0: number): void;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Double2LongFunction;
        clear(): void;
        composeDouble(arg0: Internal.Double2DoubleFunction_): this;
        getOrDefault(arg0: any, arg1: number): number;
        remove(arg0: any): any;
        get(arg0: number): number;
        remove(arg0: number): number;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2ShortFunction;
        applyAsInt(arg0: number): number;
    }
    type Double2ShortFunction_ = ((arg0: number)=>number) | Double2ShortFunction;
    class View <A, B> implements Internal.App2<any, A, B> {
        constructor(arg0: com.mojang.datafixers.types.Type_<A>, arg1: com.mojang.datafixers.types.Type_<B>, arg2: Internal.PointFree_<Internal.Function_<A, B>>)
        type(): com.mojang.datafixers.types.Type<A>;
        static nopView(arg0: com.mojang.datafixers.types.Type_<A>): Internal.View<A, A>;
        toString(): string;
        flatMap(arg0: Internal.Function_<com.mojang.datafixers.types.Type_<B>, Internal.View_<B, C>>): Internal.View<A, C>;
        compose(arg0: Internal.View_<C, A>): Internal.View<C, B>;
        static create(arg0: string, arg1: com.mojang.datafixers.types.Type_<A>, arg2: com.mojang.datafixers.types.Type_<B>, arg3: Internal.Function_<Internal.DynamicOps_<any>, Internal.Function_<A, B>>): Internal.View<A, B>;
        rewriteOrNop(arg0: Internal.PointFreeRule_): this;
        hashCode(): number;
        static create(arg0: com.mojang.datafixers.types.Type_<A>, arg1: com.mojang.datafixers.types.Type_<B>, arg2: Internal.PointFree_<Internal.Function_<A, B>>): Internal.View<A, B>;
        rewrite(arg0: Internal.PointFreeRule_): Internal.Optional<any>;
        getFuncType(): com.mojang.datafixers.types.Type<Internal.Function<A, B>>;
        equals(arg0: any): boolean;
        newType(): com.mojang.datafixers.types.Type<B>;
        function(): Internal.PointFree<Internal.Function<A, B>>;
        get funcType(): com.mojang.datafixers.types.Type<Internal.Function<A, B>>
    }
    type View_<A, B> = View<A, B>;
    class BlockStateModifyCallbackJS {
        constructor(state: Internal.BlockState_)
        hasProperty(property: Internal.Property_<T>): boolean;
        populateNeighbours(map: Internal.Map_<Internal.Map_<Internal.Property_<any>, Internal.Comparable_<any>>, Internal.BlockState_>): this;
        set(property: Internal.BooleanProperty_, value: boolean): this;
        set(property: Internal.EnumProperty_<T>, value: string): this;
        toString(): string;
        cycle(property: Internal.Property_<T>): this;
        getValues(): Internal.ImmutableMap<Internal.Property<any>, Internal.Comparable<any>>;
        set(property: Internal.EnumProperty_<T>, value: T): this;
        rotate(rotation: Internal.Rotation_): this;
        get(property: Internal.Property_<T>): T;
        set(property: Internal.IntegerProperty_, value: number): this;
        getValue(property: Internal.Property_<T>): T;
        updateShape(direction: Internal.Direction_, blockState: Internal.BlockState_, levelAccessor: Internal.LevelAccessor_, blockPos: BlockPos_, blockPos2: BlockPos_): this;
        mirror(mirror: Internal.Mirror_): this;
        getProperties(): Internal.Collection<Internal.Property<any>>;
        getState(): Internal.BlockState;
        getOptionalValue(property: Internal.Property_<T>): Internal.Optional<T>;
        setValue(property: Internal.Property_<T>, comparable: V): this;
        get values(): Internal.ImmutableMap<Internal.Property<any>, Internal.Comparable<any>>
        get properties(): Internal.Collection<Internal.Property<any>>
        get state(): Internal.BlockState
    }
    type BlockStateModifyCallbackJS_ = BlockStateModifyCallbackJS;
    class LivingEquipmentChangeEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.LivingEntity_, arg1: EquipmentSlot_, arg2: Internal.ItemStack_, arg3: Internal.ItemStack_)
        getSlot(): EquipmentSlot;
        getFrom(): Internal.ItemStack;
        getListenerList(): Internal.ListenerList;
        getTo(): Internal.ItemStack;
        get slot(): EquipmentSlot
        get from(): Internal.ItemStack
        get listenerList(): Internal.ListenerList
        get to(): Internal.ItemStack
    }
    type LivingEquipmentChangeEvent_ = LivingEquipmentChangeEvent;
    abstract class StructureProcessor {
        constructor()
        processEntity(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.StructureTemplate$StructureEntityInfo_, arg3: Internal.StructureTemplate$StructureEntityInfo_, arg4: Internal.StructurePlaceSettings_, arg5: Internal.StructureTemplate_): Internal.StructureTemplate$StructureEntityInfo;
        process(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.StructureTemplate$StructureBlockInfo_, arg4: Internal.StructureTemplate$StructureBlockInfo_, arg5: Internal.StructurePlaceSettings_, arg6: Internal.StructureTemplate_): Internal.StructureTemplate$StructureBlockInfo;
        processBlock(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.StructureTemplate$StructureBlockInfo_, arg4: Internal.StructureTemplate$StructureBlockInfo_, arg5: Internal.StructurePlaceSettings_): Internal.StructureTemplate$StructureBlockInfo;
    }
    type StructureProcessor_ = StructureProcessor;
    class BlockItemBuilder extends Internal.ItemBuilder {
        constructor(i: ResourceLocation_)
        createObject(): any;
        getTranslationKeyGroup(): string;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        get translationKeyGroup(): string
        "blockBuilder": Internal.BlockBuilder;
    }
    type BlockItemBuilder_ = BlockItemBuilder;
    abstract class BaseComponent implements Internal.MutableComponent {
        constructor()
        append(arg0: Internal.Component_): Internal.MutableComponent;
        getVisualOrderText(): Internal.FormattedCharSequence;
        hasStyle(): boolean;
        darkRed(): Internal.MutableComponent;
        visitSelf(arg0: Internal.FormattedText$StyledContentConsumer_<T>, arg1: Internal.Style_): Internal.Optional<T>;
        visit(arg0: Internal.FormattedText$ContentConsumer_<T>): Internal.Optional<T>;
        toJson(): Internal.JsonElement;
        visit(arg0: Internal.FormattedText$StyledContentConsumer_<T>, arg1: Internal.Style_): Internal.Optional<T>;
        visitSelf(arg0: Internal.FormattedText$ContentConsumer_<T>): Internal.Optional<T>;
        darkBlue(): Internal.MutableComponent;
        obfuscated(value: boolean): Internal.MutableComponent;
        getString(arg0: number): string;
        darkGreen(): Internal.MutableComponent;
        bold(): Internal.MutableComponent;
        color(c: Internal.Color_): Internal.MutableComponent;
        underlined(): Internal.MutableComponent;
        yellow(): Internal.MutableComponent;
        withStyle(arg0: Internal.UnaryOperator_<Internal.Style_>): Internal.MutableComponent;
        darkPurple(): Internal.MutableComponent;
        blue(): Internal.MutableComponent;
        hover(s: Internal.Component_): Internal.MutableComponent;
        bold(value: boolean): Internal.MutableComponent;
        withStyle(arg0: Internal.ChatFormatting_): Internal.MutableComponent;
        aqua(): Internal.MutableComponent;
        green(): Internal.MutableComponent;
        black(): Internal.MutableComponent;
        obfuscated(): Internal.MutableComponent;
        strikethrough(value: boolean): Internal.MutableComponent;
        insertion(s: string): Internal.MutableComponent;
        red(): Internal.MutableComponent;
        italic(): Internal.MutableComponent;
        forEach(arg0: Internal.Consumer_<any>): void;
        component(): Internal.Component;
        click(s: Internal.ClickEvent_): Internal.MutableComponent;
        underlined(value: boolean): Internal.MutableComponent;
        getStyle(): Internal.Style;
        self(): Internal.MutableComponent;
        rawComponent(): Internal.MutableComponent;
        gray(): Internal.MutableComponent;
        getContents(): string;
        font(s: ResourceLocation_): Internal.MutableComponent;
        getSiblings(): Internal.List<Internal.Component>;
        darkAqua(): Internal.MutableComponent;
        getString(): string;
        darkGray(): Internal.MutableComponent;
        spliterator(): Internal.Spliterator<Internal.Component>;
        toString(): string;
        iterator(): Internal.Iterator<any>;
        noColor(): Internal.MutableComponent;
        plainCopy(): Internal.MutableComponent;
        setStyle(arg0: Internal.Style_): Internal.MutableComponent;
        withStyle(arg0: Internal.Style_): Internal.MutableComponent;
        strikethrough(): Internal.MutableComponent;
        gold(): Internal.MutableComponent;
        hashCode(): number;
        white(): Internal.MutableComponent;
        hasSiblings(): boolean;
        italic(value: boolean): Internal.MutableComponent;
        withStyle(...arg0: Internal.ChatFormatting_[]): Internal.MutableComponent;
        rawCopy(): Internal.MutableComponent;
        toFlatList(arg0: Internal.Style_): Internal.List<Internal.Component>;
        lightPurple(): Internal.MutableComponent;
        copy(): Internal.MutableComponent;
        equals(arg0: any): boolean;
        get visualOrderText(): Internal.FormattedCharSequence
        get style(): Internal.Style
        get contents(): string
        get siblings(): Internal.List<Internal.Component>
        get string(): string
        set style(arg0: Internal.Style_)
    }
    type BaseComponent_ = BaseComponent;
    interface LongIterator extends Internal.PrimitiveIterator$OfLong {
        forEachRemaining(arg0: any): void;
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): any;
        skip(arg0: number): number;
        nextLong(): number;
        forEachRemaining(arg0: it.unimi.dsi.fastutil.longs.LongConsumer_): void;
        forEachRemaining(arg0: Internal.LongConsumer_): void;
    }
    type LongIterator_ = LongIterator;
    interface RegistrarBuilder <T> {
        build(): Internal.Registrar<T>;
        saveToDisc(): this;
        option(arg0: Internal.RegistrarOption_): this;
        syncToClients(): this;
    }
    type RegistrarBuilder_<T> = RegistrarBuilder<T>;
    class ScreenEvent$BackgroundDrawnEvent extends Internal.ScreenEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: Internal.PoseStack_)
        getPoseStack(): Internal.PoseStack;
        getListenerList(): Internal.ListenerList;
        get poseStack(): Internal.PoseStack
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$BackgroundDrawnEvent_ = ScreenEvent$BackgroundDrawnEvent;
    class ModuleDescriptor$Requires implements Internal.Comparable<Internal.ModuleDescriptor$Requires> {
        name(): string;
        compareTo(arg0: Internal.ModuleDescriptor$Requires_): number;
        hashCode(): number;
        rawCompiledVersion(): Internal.Optional<string>;
        compiledVersion(): Internal.Optional<Internal.ModuleDescriptor$Version>;
        toString(): string;
        equals(arg0: any): boolean;
        compareTo(arg0: any): number;
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Requires$Modifier>;
    }
    type ModuleDescriptor$Requires_ = ModuleDescriptor$Requires;
    class LeaveVineDecorator extends Internal.TreeDecorator {
        constructor()
        place(arg0: Internal.LevelSimulatedReader_, arg1: Internal.BiConsumer_<BlockPos_, Internal.BlockState_>, arg2: Internal.Random_, arg3: Internal.List_<BlockPos_>, arg4: Internal.List_<BlockPos_>): void;
        readonly static "INSTANCE": Internal.LeaveVineDecorator;
        readonly static "CODEC": any;
    }
    type LeaveVineDecorator_ = LeaveVineDecorator;
    class Advancement {
        constructor(arg0: ResourceLocation_, arg1: Internal.Advancement_, arg2: Internal.DisplayInfo_, arg3: Internal.AdvancementRewards_, arg4: Internal.Map_<string, Internal.Criterion_>, arg5: string[][])
        getCriteria(): Internal.Map<string, Internal.Criterion>;
        toString(): string;
        addChild(arg0: Internal.Advancement_): void;
        getParent(): this;
        hashCode(): number;
        getDisplay(): Internal.DisplayInfo;
        getId(): ResourceLocation;
        getRewards(): Internal.AdvancementRewards;
        getRequirements(): string[][];
        deconstruct(): Internal.Advancement$Builder;
        getChatComponent(): Internal.Component;
        equals(arg0: any): boolean;
        getMaxCriteraRequired(): number;
        getChildren(): Internal.Iterable<Internal.Advancement>;
        get criteria(): Internal.Map<string, Internal.Criterion>
        get parent(): Internal.Advancement
        get display(): Internal.DisplayInfo
        get id(): ResourceLocation
        get rewards(): Internal.AdvancementRewards
        get requirements(): string[][]
        get chatComponent(): Internal.Component
        get maxCriteraRequired(): number
        get children(): Internal.Iterable<Internal.Advancement>
    }
    type Advancement_ = Advancement;
    class TickEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.TickEvent$Type_, arg1: Internal.LogicalSide_, arg2: Internal.TickEvent$Phase_)
        getListenerList(): Internal.ListenerList;
        get listenerList(): Internal.ListenerList
        readonly "phase": Internal.TickEvent$Phase;
        readonly "type": Internal.TickEvent$Type;
        readonly "side": Internal.LogicalSide;
    }
    type TickEvent_ = TickEvent;
    class AttachCapabilitiesEvent <T> extends Internal.GenericEvent<T> {
        constructor()
        constructor(arg0: Internal.Class_<T>, arg1: T)
        addListener(arg0: Internal.Runnable_): void;
        getCapabilities(): Internal.Map<ResourceLocation, Internal.ICapabilityProvider>;
        getListeners(): Internal.List<Internal.Runnable>;
        getListenerList(): Internal.ListenerList;
        getObject(): T;
        addCapability(arg0: ResourceLocation_, arg1: Internal.ICapabilityProvider_): void;
        get capabilities(): Internal.Map<ResourceLocation, Internal.ICapabilityProvider>
        get listeners(): Internal.List<Internal.Runnable>
        get listenerList(): Internal.ListenerList
        get object(): T
    }
    type AttachCapabilitiesEvent_<T> = AttachCapabilitiesEvent<T>;
    abstract class PermissionCollection implements Internal.Serializable {
        constructor()
        toString(): string;
        setReadOnly(): void;
        elementsAsStream(): Internal.Stream<Internal.Permission>;
        elements(): Internal.Enumeration<Internal.Permission>;
        implies(arg0: Internal.Permission_): boolean;
        isReadOnly(): boolean;
        add(arg0: Internal.Permission_): void;
        get readOnly(): boolean
    }
    type PermissionCollection_ = PermissionCollection;
    interface Char2BooleanFunction extends it.unimi.dsi.fastutil.Function<string, boolean>, Internal.IntPredicate {
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2BooleanFunction;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2BooleanFunction;
        getOrDefault(arg0: any, arg1: any): any;
        or(arg0: Internal.IntPredicate_): Internal.IntPredicate;
        negate(): Internal.IntPredicate;
        composeChar(arg0: Internal.Char2CharFunction_): this;
        put(arg0: string, arg1: boolean): boolean;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2BooleanFunction;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Char2IntFunction;
        containsKey(arg0: string): boolean;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2BooleanFunction;
        containsKey(arg0: any): boolean;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Char2ShortFunction;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Char2ByteFunction;
        get(arg0: any): boolean;
        andThenObject(arg0: Internal.Boolean2ObjectFunction_<any>): Internal.Char2ObjectFunction<T>;
        put(arg0: any, arg1: any): any;
        composeReference(arg0: Internal.Reference2CharFunction_<any>): Internal.Reference2BooleanFunction<T>;
        defaultReturnValue(): boolean;
        and(arg0: Internal.IntPredicate_): Internal.IntPredicate;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Char2FloatFunction;
        apply(arg0: string): boolean;
        composeObject(arg0: Internal.Object2CharFunction_<any>): Internal.Object2BooleanFunction<T>;
        getOrDefault(arg0: any, arg1: boolean): boolean;
        put(arg0: string, arg1: boolean): boolean;
        test(arg0: number): boolean;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Char2CharFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, boolean>;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Char2LongFunction;
        size(): number;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2BooleanFunction;
        get(arg0: string): boolean;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2BooleanFunction;
        clear(): void;
        andThenReference(arg0: Internal.Boolean2ReferenceFunction_<any>): Internal.Char2ReferenceFunction<T>;
        remove(arg0: string): boolean;
        remove(arg0: any): any;
        defaultReturnValue(arg0: boolean): void;
        getOrDefault(arg0: string, arg1: boolean): boolean;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<string, T>;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Char2DoubleFunction;
    }
    type Char2BooleanFunction_ = ((arg0: string)=>boolean) | Char2BooleanFunction;
    interface LongStream$Builder extends Internal.LongConsumer {
        andThen(arg0: Internal.LongConsumer_): Internal.LongConsumer;
        build(): Internal.LongStream;
        add(arg0: number): this;
        accept(arg0: number): void;
    }
    type LongStream$Builder_ = LongStream$Builder;
    class Pufferfish extends Internal.AbstractFish {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getBucketItemStack(): Internal.ItemStack;
        playerTouch(arg0: Internal.Player_): void;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getDimensions(arg0: Internal.Pose_): Internal.EntityDimensions;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        tick(): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        setPuffState(arg0: number): void;
        alwaysAccepts(): boolean;
        getPuffState(): number;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get bucketItemStack(): Internal.ItemStack
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        set puffState(arg0: number)
        get puffState(): number
        readonly static "STATE_FULL": 2;
        readonly static "STATE_SMALL": 0;
        readonly static "STATE_MID": 1;
    }
    type Pufferfish_ = Pufferfish;
    interface BaseStream <T, S> extends Internal.AutoCloseable {
        onClose(arg0: Internal.Runnable_): S;
        unordered(): S;
        isParallel(): boolean;
        close(): void;
        parallel(): S;
        spliterator(): Internal.Spliterator<T>;
        sequential(): S;
        iterator(): Internal.Iterator<T>;
        get parallel(): boolean
    }
    type BaseStream_<T, S> = BaseStream<T, S>;
    interface Clearable {
        tryClear(arg0: any): void;
        clearContent(): void;
    }
    type Clearable_ = Clearable;
    class Climate$TargetPoint extends Internal.Record {
        constructor(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number)
        depth(): number;
        weirdness(): number;
        hashCode(): number;
        toString(): string;
        erosion(): number;
        temperature(): number;
        continentalness(): number;
        equals(arg0: any): boolean;
        humidity(): number;
    }
    type Climate$TargetPoint_ = Climate$TargetPoint;
    class Camera {
        constructor()
        setAnglesInternal(arg0: number, arg1: number): void;
        getLeftVector(): Internal.Vector3f;
        getPosition(): Vec3;
        getNearPlane(): Internal.Camera$NearPlane;
        getLookVector(): Internal.Vector3f;
        getXRot(): number;
        tick(): void;
        getFluidInCamera(): Internal.FogType;
        setup(arg0: Internal.BlockGetter_, arg1: Internal.Entity_, arg2: boolean, arg3: boolean, arg4: number): void;
        getBlockAtCamera(): Internal.BlockState;
        getEntity(): Internal.Entity;
        getYRot(): number;
        isInitialized(): boolean;
        isDetached(): boolean;
        rotation(): Internal.Quaternion;
        getUpVector(): Internal.Vector3f;
        reset(): void;
        getBlockPosition(): BlockPos;
        get leftVector(): Internal.Vector3f
        get position(): Vec3
        get nearPlane(): Internal.Camera$NearPlane
        get lookVector(): Internal.Vector3f
        get XRot(): number
        get fluidInCamera(): Internal.FogType
        get blockAtCamera(): Internal.BlockState
        get entity(): Internal.Entity
        get YRot(): number
        get initialized(): boolean
        get detached(): boolean
        get upVector(): Internal.Vector3f
        get blockPosition(): BlockPos
        readonly static "FOG_DISTANCE_SCALE": 0.083333336;
    }
    type Camera_ = Camera;
    abstract class AbstractDragonPhaseInstance implements Internal.DragonPhaseInstance {
        constructor(arg0: Internal.EnderDragon_)
        doClientTick(): void;
        onHurt(arg0: Internal.DamageSource_, arg1: number): number;
        isSitting(): boolean;
        getFlyTargetLocation(): Vec3;
        end(): void;
        getFlySpeed(): number;
        getTurnSpeed(): number;
        begin(): void;
        onCrystalDestroyed(arg0: Internal.EndCrystal_, arg1: BlockPos_, arg2: Internal.DamageSource_, arg3: Internal.Player_): void;
        doServerTick(): void;
        get sitting(): boolean
        get flyTargetLocation(): Vec3
        get flySpeed(): number
        get turnSpeed(): number
    }
    type AbstractDragonPhaseInstance_ = AbstractDragonPhaseInstance;
    interface Byte2FloatFunction extends Internal.IntToDoubleFunction, it.unimi.dsi.fastutil.Function<number, number> {
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2FloatFunction;
        applyAsDouble(arg0: number): number;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2FloatFunction;
        apply(arg0: number): number;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2FloatFunction;
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        composeObject(arg0: Internal.Object2ByteFunction_<any>): Internal.Object2FloatFunction<T>;
        andThenFloat(arg0: Internal.Float2FloatFunction_): this;
        defaultReturnValue(arg0: number): void;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Byte2IntFunction;
        composeReference(arg0: Internal.Reference2ByteFunction_<any>): Internal.Reference2FloatFunction<T>;
        containsKey(arg0: any): boolean;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Byte2CharFunction;
        andThenReference(arg0: Internal.Float2ReferenceFunction_<any>): Internal.Byte2ReferenceFunction<T>;
        put(arg0: any, arg1: any): any;
        containsKey(arg0: number): boolean;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2FloatFunction;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Byte2DoubleFunction;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Byte2LongFunction;
        get(arg0: number): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        defaultReturnValue(): number;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Byte2ByteFunction;
        andThenObject(arg0: Internal.Float2ObjectFunction_<any>): Internal.Byte2ObjectFunction<T>;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2FloatFunction;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        size(): number;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2FloatFunction;
        put(arg0: number, arg1: number): number;
        composeByte(arg0: Internal.Byte2ByteFunction_): this;
        clear(): void;
        remove(arg0: any): any;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Byte2ShortFunction;
    }
    type Byte2FloatFunction_ = ((arg0: number)=>number) | Byte2FloatFunction;
    class Blender$BlendingOutput extends Internal.Record {
        constructor(arg0: number, arg1: number)
        hashCode(): number;
        blendingOffset(): number;
        toString(): string;
        alpha(): number;
        equals(arg0: any): boolean;
    }
    type Blender$BlendingOutput_ = Blender$BlendingOutput;
    class LootNumberProviderType extends Internal.SerializerType<Internal.NumberProvider> {
        constructor(arg0: Internal.Serializer_<any>)
    }
    type LootNumberProviderType_ = Special.LootNumberProviderType | LootNumberProviderType;
    class ThreadGroup implements Internal.Thread$UncaughtExceptionHandler {
        constructor(arg0: Internal.ThreadGroup_, arg1: string)
        constructor(arg0: string)
        isDaemon(): boolean;
        suspend(): void;
        setMaxPriority(arg0: number): void;
        allowThreadSuspension(arg0: boolean): boolean;
        toString(): string;
        destroy(): void;
        activeGroupCount(): number;
        checkAccess(): void;
        uncaughtException(arg0: Internal.Thread_, arg1: Internal.Throwable_): void;
        enumerate(arg0: Internal.ThreadGroup_[], arg1: boolean): number;
        resume(): void;
        enumerate(arg0: Internal.ThreadGroup_[]): number;
        getParent(): this;
        list(): void;
        setDaemon(arg0: boolean): void;
        getMaxPriority(): number;
        interrupt(): void;
        enumerate(arg0: Internal.Thread_[], arg1: boolean): number;
        parentOf(arg0: Internal.ThreadGroup_): boolean;
        getName(): string;
        enumerate(arg0: Internal.Thread_[]): number;
        stop(): void;
        activeCount(): number;
        isDestroyed(): boolean;
        get daemon(): boolean
        set maxPriority(arg0: number)
        get parent(): Internal.ThreadGroup
        set daemon(arg0: boolean)
        get maxPriority(): number
        get name(): string
        get destroyed(): boolean
    }
    type ThreadGroup_ = ThreadGroup;
    class BannerBlockEntity extends Internal.BlockEntity implements Internal.Nameable {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_, arg2: Internal.DyeColor_)
        getDisplayName(): Internal.Component;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getUpdateTag(): Internal.CompoundTag;
        static removeLastPattern(arg0: Internal.ItemStack_): void;
        setCustomName(arg0: Internal.Component_): void;
        static createPatterns(arg0: Internal.DyeColor_, arg1: Internal.ListTag_): Internal.List<com.mojang.datafixers.util.Pair<Internal.BannerPattern, Internal.DyeColor>>;
        load(arg0: Internal.CompoundTag_): void;
        getUpdatePacket(): Internal.Packet<any>;
        onLoad(): void;
        fromItem(arg0: Internal.ItemStack_): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        static getPatternCount(arg0: Internal.ItemStack_): number;
        getName(): Internal.Component;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        getBaseColor(): Internal.DyeColor;
        getItem(): Internal.ItemStack;
        static getItemPatterns(arg0: Internal.ItemStack_): Internal.ListTag;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        fromItem(arg0: Internal.ItemStack_, arg1: Internal.DyeColor_): void;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getPatterns(): Internal.List<com.mojang.datafixers.util.Pair<Internal.BannerPattern, Internal.DyeColor>>;
        getRenderBoundingBox(): Internal.AABB;
        getCustomName(): Internal.Component;
        get displayName(): Internal.Component
        get updateTag(): Internal.CompoundTag
        set customName(arg0: Internal.Component_)
        get updatePacket(): Internal.Packet<any>
        get name(): Internal.Component
        get modelData(): Internal.IModelData
        get baseColor(): Internal.DyeColor
        get item(): Internal.ItemStack
        get patterns(): Internal.List<com.mojang.datafixers.util.Pair<Internal.BannerPattern, Internal.DyeColor>>
        get renderBoundingBox(): Internal.AABB
        get customName(): Internal.Component
        readonly static "TAG_PATTERNS": "Patterns";
        readonly static "MAX_PATTERNS": 6;
        readonly static "TAG_COLOR": "Color";
        readonly static "TAG_PATTERN": "Pattern";
    }
    type BannerBlockEntity_ = BannerBlockEntity;
    interface SpectatorMenuItem {
        getName(): Internal.Component;
        selectItem(arg0: Internal.SpectatorMenu_): void;
        renderIcon(arg0: Internal.PoseStack_, arg1: number, arg2: number): void;
        isEnabled(): boolean;
        get name(): Internal.Component
        get enabled(): boolean
    }
    type SpectatorMenuItem_ = SpectatorMenuItem;
    class ClientPlayerChangeGameTypeEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.PlayerInfo_, arg1: Internal.GameType_, arg2: Internal.GameType_)
        getCurrentGameType(): Internal.GameType;
        getNewGameType(): Internal.GameType;
        getListenerList(): Internal.ListenerList;
        getInfo(): Internal.PlayerInfo;
        get currentGameType(): Internal.GameType
        get newGameType(): Internal.GameType
        get listenerList(): Internal.ListenerList
        get info(): Internal.PlayerInfo
    }
    type ClientPlayerChangeGameTypeEvent_ = ClientPlayerChangeGameTypeEvent;
    class ValueRange implements Internal.Serializable {
        getMinimum(): number;
        toString(): string;
        getMaximum(): number;
        static of(arg0: number, arg1: number, arg2: number): Internal.ValueRange;
        static of(arg0: number, arg1: number, arg2: number, arg3: number): Internal.ValueRange;
        checkValidIntValue(arg0: number, arg1: Internal.TemporalField_): number;
        isIntValue(): boolean;
        getLargestMinimum(): number;
        isFixed(): boolean;
        static of(arg0: number, arg1: number): Internal.ValueRange;
        hashCode(): number;
        isValidIntValue(arg0: number): boolean;
        isValidValue(arg0: number): boolean;
        getSmallestMaximum(): number;
        equals(arg0: any): boolean;
        checkValidValue(arg0: number, arg1: Internal.TemporalField_): number;
        get minimum(): number
        get maximum(): number
        get intValue(): boolean
        get largestMinimum(): number
        get fixed(): boolean
        get smallestMaximum(): number
    }
    type ValueRange_ = ValueRange;
    class InputEvent$MouseScrollEvent extends Internal.InputEvent {
        constructor()
        constructor(arg0: number, arg1: boolean, arg2: boolean, arg3: boolean, arg4: number, arg5: number)
        isLeftDown(): boolean;
        isRightDown(): boolean;
        isCancelable(): boolean;
        getMouseX(): number;
        getListenerList(): Internal.ListenerList;
        getMouseY(): number;
        isMiddleDown(): boolean;
        getScrollDelta(): number;
        get leftDown(): boolean
        get rightDown(): boolean
        get cancelable(): boolean
        get mouseX(): number
        get listenerList(): Internal.ListenerList
        get mouseY(): number
        get middleDown(): boolean
        get scrollDelta(): number
    }
    type InputEvent$MouseScrollEvent_ = InputEvent$MouseScrollEvent;
    class RootSystemConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.Holder_<Internal.PlacedFeature_>, arg1: number, arg2: number, arg3: Internal.TagKey_<Internal.Block_>, arg4: Internal.BlockStateProvider_, arg5: number, arg6: number, arg7: number, arg8: number, arg9: Internal.BlockStateProvider_, arg10: number, arg11: number, arg12: net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate_)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "rootColumnMaxHeight": number;
        readonly static "CODEC": any;
        readonly "allowedTreePosition": net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate;
        readonly "requiredVerticalSpaceForTree": number;
        readonly "rootRadius": number;
        readonly "hangingRootStateProvider": Internal.BlockStateProvider;
        readonly "hangingRootsVerticalSpan": number;
        readonly "hangingRootPlacementAttempts": number;
        readonly "rootStateProvider": Internal.BlockStateProvider;
        readonly "rootReplaceable": Internal.TagKey<Internal.Block>;
        readonly "hangingRootRadius": number;
        readonly "rootPlacementAttempts": number;
        readonly "treeFeature": Internal.Holder<Internal.PlacedFeature>;
        readonly "allowedVerticalWaterForTree": number;
    }
    type RootSystemConfiguration_ = RootSystemConfiguration;
    class PerlinSimplexNoise {
        constructor(arg0: Internal.RandomSource_, arg1: Internal.List_<number>)
        getValue(arg0: number, arg1: number, arg2: boolean): number;
    }
    type PerlinSimplexNoise_ = PerlinSimplexNoise;
    class MultiPlayerGameMode {
        constructor(arg0: Internal.Minecraft_, arg1: Internal.ClientPacketListener_)
        adjustPlayer(arg0: Internal.Player_): void;
        stopDestroyBlock(): void;
        createPlayer(arg0: Internal.ClientLevel_, arg1: Internal.StatsCounter_, arg2: Internal.ClientRecipeBook_, arg3: boolean, arg4: boolean): Internal.LocalPlayer;
        interact(arg0: Internal.Player_, arg1: Internal.Entity_, arg2: Hand_): Internal.InteractionResult;
        createPlayer(arg0: Internal.ClientLevel_, arg1: Internal.StatsCounter_, arg2: Internal.ClientRecipeBook_): Internal.LocalPlayer;
        handlePickItem(arg0: number): void;
        hasExperience(): boolean;
        interactAt(arg0: Internal.Player_, arg1: Internal.Entity_, arg2: Internal.EntityHitResult_, arg3: Hand_): Internal.InteractionResult;
        hasFarPickRange(): boolean;
        useItemOn(arg0: Internal.LocalPlayer_, arg1: Internal.ClientLevel_, arg2: Hand_, arg3: Internal.BlockHitResult_): Internal.InteractionResult;
        handleCreativeModeItemDrop(arg0: Internal.ItemStack_): void;
        useItem(arg0: Internal.Player_, arg1: Internal.Level_, arg2: Hand_): Internal.InteractionResult;
        hasMissTime(): boolean;
        canHurtPlayer(): boolean;
        hasInfiniteItems(): boolean;
        isDestroying(): boolean;
        getPlayerMode(): Internal.GameType;
        handleInventoryButtonClick(arg0: number, arg1: number): void;
        attack(arg0: Internal.Player_, arg1: Internal.Entity_): void;
        getPreviousPlayerMode(): Internal.GameType;
        handlePlaceRecipe(arg0: number, arg1: Internal.Recipe_<any>, arg2: boolean): void;
        setLocalMode(arg0: Internal.GameType_, arg1: Internal.GameType_): void;
        tick(): void;
        getPickRange(): number;
        continueDestroyBlock(arg0: BlockPos_, arg1: Internal.Direction_): boolean;
        releaseUsingItem(arg0: Internal.Player_): void;
        handleInventoryMouseClick(arg0: number, arg1: number, arg2: number, arg3: Internal.ClickType_, arg4: Internal.Player_): void;
        isServerControlledInventory(): boolean;
        handleCreativeModeItemAdd(arg0: Internal.ItemStack_, arg1: number): void;
        destroyBlock(arg0: BlockPos_): boolean;
        startDestroyBlock(arg0: BlockPos_, arg1: Internal.Direction_): boolean;
        isAlwaysFlying(): boolean;
        handleBlockBreakAck(arg0: Internal.ClientLevel_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.ServerboundPlayerActionPacket$Action_, arg4: boolean): void;
        setLocalMode(arg0: Internal.GameType_): void;
        get destroying(): boolean
        get playerMode(): Internal.GameType
        get previousPlayerMode(): Internal.GameType
        get pickRange(): number
        get serverControlledInventory(): boolean
        get alwaysFlying(): boolean
        set localMode(arg0: Internal.GameType_)
    }
    type MultiPlayerGameMode_ = MultiPlayerGameMode;
    class PlayerEvent$PlayerChangeGameModeEvent extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.GameType_, arg2: Internal.GameType_)
        setNewGameMode(arg0: Internal.GameType_): void;
        isCancelable(): boolean;
        getCurrentGameMode(): Internal.GameType;
        getListenerList(): Internal.ListenerList;
        getNewGameMode(): Internal.GameType;
        set newGameMode(arg0: Internal.GameType_)
        get cancelable(): boolean
        get currentGameMode(): Internal.GameType
        get listenerList(): Internal.ListenerList
        get newGameMode(): Internal.GameType
    }
    type PlayerEvent$PlayerChangeGameModeEvent_ = PlayerEvent$PlayerChangeGameModeEvent;
    interface Long2IntFunction extends Internal.LongToIntFunction, it.unimi.dsi.fastutil.Function<number, number> {
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2IntFunction;
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        defaultReturnValue(): number;
        get(arg0: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Long2FloatFunction;
        containsKey(arg0: any): boolean;
        andThenInt(arg0: Internal.Int2IntFunction_): this;
        andThenObject(arg0: Internal.Int2ObjectFunction_<any>): Internal.Long2ObjectFunction<T>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        put(arg0: any, arg1: any): any;
        applyAsInt(arg0: number): number;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Long2ShortFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        andThenReference(arg0: Internal.Int2ReferenceFunction_<any>): Internal.Long2ReferenceFunction<T>;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Long2ByteFunction;
        getOrDefault(arg0: any, arg1: number): number;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Long2LongFunction;
        containsKey(arg0: number): boolean;
        put(arg0: number, arg1: number): number;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2IntFunction;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2IntFunction;
        composeReference(arg0: Internal.Reference2LongFunction_<any>): Internal.Reference2IntFunction<T>;
        remove(arg0: number): number;
        size(): number;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2IntFunction;
        defaultReturnValue(arg0: number): void;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2IntFunction;
        apply(arg0: number): number;
        clear(): void;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Long2CharFunction;
        put(arg0: number, arg1: number): number;
        composeObject(arg0: Internal.Object2LongFunction_<any>): Internal.Object2IntFunction<T>;
        remove(arg0: any): any;
        composeLong(arg0: Internal.Long2LongFunction_): this;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Long2DoubleFunction;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2IntFunction;
    }
    type Long2IntFunction_ = Long2IntFunction | ((arg0: number)=>number);
    interface Algebra {
        apply(arg0: number): Internal.RewriteResult<any, any>;
        toString(arg0: number): string;
    }
    type Algebra_ = Algebra;
    interface IForgeVertexConsumer {
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer_): number;
        applyBakedNormals(arg0: Internal.Vector3f_, arg1: Internal.ByteBuffer_, arg2: Internal.Matrix3f_): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void;
        getVertexFormat(): Internal.VertexFormat;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void;
        get vertexFormat(): Internal.VertexFormat
    }
    type IForgeVertexConsumer_ = IForgeVertexConsumer;
    class FlowingFluidBuilder extends Internal.BuilderBase<Internal.Fluid> {
        constructor(b: Internal.FluidBuilder_)
        createObject(): any;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Fluid>;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Fluid>
        readonly "fluidBuilder": Internal.FluidBuilder;
    }
    type FlowingFluidBuilder_ = FlowingFluidBuilder;
    class MobSpawnSettings$SpawnerData extends Internal.WeightedEntry$IntrusiveBase {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Weight_, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: number, arg2: number, arg3: number)
        toString(): string;
        readonly "minCount": number;
        readonly static "CODEC": any;
        readonly "type": Internal.EntityType<any>;
        readonly "maxCount": number;
    }
    type MobSpawnSettings$SpawnerData_ = MobSpawnSettings$SpawnerData;
    interface ObjDoubleConsumer <T> {
        accept(arg0: T, arg1: number): void;
    }
    type ObjDoubleConsumer_<T> = ObjDoubleConsumer<T> | ((arg0: T, arg1: number)=>void);
    class PlayerSensor extends Internal.Sensor<Internal.LivingEntity> {
        constructor()
        requires(): Internal.Set<Internal.MemoryModuleType<any>>;
    }
    type PlayerSensor_ = PlayerSensor;
    class ScreenEvent$MouseClickedEvent$Pre extends Internal.ScreenEvent$MouseClickedEvent {
        constructor()
        constructor(arg0: Internal.Screen_, arg1: number, arg2: number, arg3: number)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
    }
    type ScreenEvent$MouseClickedEvent$Pre_ = ScreenEvent$MouseClickedEvent$Pre;
    interface ComponentKJS extends Internal.Component, Internal.JsonSerializable, Internal.WrappedJS, Internal.Iterable<Internal.Component> {
        obfuscated(): Internal.MutableComponent;
        strikethrough(value: boolean): Internal.MutableComponent;
        insertion(s: string): Internal.MutableComponent;
        red(): Internal.MutableComponent;
        italic(): Internal.MutableComponent;
        darkRed(): Internal.MutableComponent;
        forEach(arg0: Internal.Consumer_<any>): void;
        visitSelf(arg0: Internal.FormattedText$StyledContentConsumer_<T>, arg1: Internal.Style_): Internal.Optional<T>;
        visit(arg0: Internal.FormattedText$ContentConsumer_<T>): Internal.Optional<T>;
        click(s: Internal.ClickEvent_): Internal.MutableComponent;
        underlined(value: boolean): Internal.MutableComponent;
        toJson(): Internal.JsonElement;
        self(): Internal.MutableComponent;
        visit(arg0: Internal.FormattedText$StyledContentConsumer_<T>, arg1: Internal.Style_): Internal.Optional<T>;
        visitSelf(arg0: Internal.FormattedText$ContentConsumer_<T>): Internal.Optional<T>;
        gray(): Internal.MutableComponent;
        darkBlue(): Internal.MutableComponent;
        obfuscated(value: boolean): Internal.MutableComponent;
        font(s: ResourceLocation_): Internal.MutableComponent;
        getString(arg0: number): string;
        darkAqua(): Internal.MutableComponent;
        iterator(): Internal.Iterator<Internal.Component>;
        darkGreen(): Internal.MutableComponent;
        bold(): Internal.MutableComponent;
        color(c: Internal.Color_): Internal.MutableComponent;
        underlined(): Internal.MutableComponent;
        getString(): string;
        yellow(): Internal.MutableComponent;
        darkGray(): Internal.MutableComponent;
        darkPurple(): Internal.MutableComponent;
        spliterator(): Internal.Spliterator<Internal.Component>;
        noColor(): Internal.MutableComponent;
        blue(): Internal.MutableComponent;
        hover(s: Internal.Component_): Internal.MutableComponent;
        strikethrough(): Internal.MutableComponent;
        gold(): Internal.MutableComponent;
        bold(value: boolean): Internal.MutableComponent;
        white(): Internal.MutableComponent;
        italic(value: boolean): Internal.MutableComponent;
        aqua(): Internal.MutableComponent;
        toFlatList(arg0: Internal.Style_): Internal.List<Internal.Component>;
        lightPurple(): Internal.MutableComponent;
        green(): Internal.MutableComponent;
        black(): Internal.MutableComponent;
        get string(): string
    }
    type ComponentKJS_ = ComponentKJS;
    interface Spliterator$OfInt extends Internal.Spliterator$OfPrimitive<number, Internal.IntConsumer, Internal.Spliterator$OfInt> {
        forEachRemaining(arg0: any): void;
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>;
        tryAdvance(arg0: Internal.IntConsumer_): boolean;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        getComparator(): Internal.Comparator<any>;
        getExactSizeIfKnown(): number;
        hasCharacteristics(arg0: number): boolean;
        tryAdvance(arg0: Internal.Consumer_<any>): boolean;
        forEachRemaining(arg0: Internal.IntConsumer_): void;
        tryAdvance(arg0: any): boolean;
        get comparator(): Internal.Comparator<any>
        get exactSizeIfKnown(): number
    }
    type Spliterator$OfInt_ = Spliterator$OfInt;
    class FurnaceBlockEntity extends Internal.AbstractFurnaceBlockEntity {
        constructor(arg0: BlockPos_, arg1: Internal.BlockState_)
        stopOpen(arg0: Internal.Player_): void;
        setRecipeUsed(arg0: Internal.Level_, arg1: Internal.ServerPlayer_, arg2: Internal.Recipe_<any>): boolean;
        getModelData(): Internal.IModelData;
        deserializeNBT(arg0: Internal.Tag_): void;
        requestModelDataUpdate(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        getMaxStackSize(): number;
        countItem(arg0: Internal.Item_): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        hasCustomName(): boolean;
        serializeNBT(): Internal.CompoundTag;
        startOpen(arg0: Internal.Player_): void;
        hasAnyOf(arg0: Internal.Set_<Internal.Item_>): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onLoad(): void;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        getRenderBoundingBox(): Internal.AABB;
        get modelData(): Internal.IModelData
        get maxStackSize(): number
        get renderBoundingBox(): Internal.AABB
    }
    type FurnaceBlockEntity_ = FurnaceBlockEntity;
    interface Object2ReferenceFunction <K, V> extends it.unimi.dsi.fastutil.Function<K, V> {
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Object2ShortFunction<K>;
        composeReference(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Reference2ReferenceFunction<T, V>;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2ReferenceFunction<V>;
        getOrDefault(arg0: any, arg1: V): V;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Object2CharFunction<K>;
        andThenObject(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Object2ObjectFunction<K, T>;
        containsKey(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2ReferenceFunction<V>;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2ReferenceFunction<V>;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Object2FloatFunction<K>;
        composeObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Object2ReferenceFunction<T, V>;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Object2IntFunction<K>;
        get(arg0: any): V;
        remove(arg0: any): V;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Object2ByteFunction<K>;
        andThenReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Object2ReferenceFunction<K, T>;
        apply(arg0: K): V;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, V>;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2ReferenceFunction<V>;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2ReferenceFunction<V>;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Object2LongFunction<K>;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2ReferenceFunction<V>;
        size(): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, V>;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2ReferenceFunction<V>;
        clear(): void;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Object2DoubleFunction<K>;
        defaultReturnValue(): V;
        defaultReturnValue(arg0: V): void;
    }
    type Object2ReferenceFunction_<K, V> = ((arg0: any)=>V) | Object2ReferenceFunction<K, V>;
    class BossHealthOverlay extends Internal.GuiComponent {
        constructor(arg0: Internal.Minecraft_)
        shouldCreateWorldFog(): boolean;
        shouldPlayMusic(): boolean;
        render(arg0: Internal.PoseStack_): void;
        reset(): void;
        update(arg0: Internal.ClientboundBossEventPacket_): void;
        shouldDarkenScreen(): boolean;
    }
    type BossHealthOverlay_ = BossHealthOverlay;
    class AirBlock extends Internal.Block {
        constructor(arg0: Internal.BlockBehaviour$Properties_)
        isFlammable(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getRespawnPosition(arg0: Internal.BlockState_, arg1: Internal.EntityType_<any>, arg2: Internal.LevelReader_, arg3: BlockPos_, arg4: number, arg5: Internal.LivingEntity_): Internal.Optional<Vec3>;
        supportsExternalFaceHiding(arg0: Internal.BlockState_): boolean;
        isFertile(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        collisionExtendsVertically(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        onBlockStateChange(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BlockState_): void;
        getWeakChanges(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): boolean;
        getBlockStatesKJS(): Internal.List<Internal.BlockState>;
        getExpDrop(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: number, arg4: number): number;
        getFriction(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): number;
        canConnectRedstone(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        isFireSource(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        isStickyBlock(arg0: Internal.BlockState_): boolean;
        shouldCheckWeakPower(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getBeaconColorMultiplier(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): number[];
        onBlockExploded(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Explosion_): void;
        isSlimeBlock(arg0: Internal.BlockState_): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockState_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_, arg3: Internal.FluidState_): boolean;
        canEntityDestroy(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        rotate(arg0: Internal.BlockState_, arg1: Internal.LevelAccessor_, arg2: BlockPos_, arg3: Internal.Rotation_): Internal.BlockState;
        canHarvestBlock(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        getRenderShape(arg0: Internal.BlockState_): Internal.RenderShape;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.UseOnContext_, arg2: Internal.ToolAction_, arg3: boolean): Internal.BlockState;
        isValidSpawn(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.SpawnPlacements$Type_, arg4: Internal.EntityType_<any>): boolean;
        getFlammability(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        arch$holder(): Internal.Holder<Internal.Block>;
        isLadder(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        getCloneItemStack(arg0: Internal.BlockState_, arg1: Internal.HitResult_, arg2: Internal.BlockGetter_, arg3: BlockPos_, arg4: Internal.Player_): Internal.ItemStack;
        getAiPathNodeType(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Mob_): Internal.BlockPathTypes;
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.BlockState_): boolean;
        onDestroyedByPlayer(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: boolean, arg5: Internal.FluidState_): boolean;
        onNeighborChange(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): void;
        isPortalFrame(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        onCaughtFire(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.LivingEntity_): void;
        isScaffolding(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        hidesNeighborFace(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: Internal.Direction_): boolean;
        getStateAtViewpoint(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Vec3_): Internal.BlockState;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: Internal.ItemStack_, arg5: Internal.ToolAction_): Internal.BlockState;
        isBed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        getExplosionResistance(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        getBedDirection(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): Internal.Direction;
        canStickTo(arg0: Internal.BlockState_, arg1: Internal.BlockState_): boolean;
        getFireSpreadSpeed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        getLightEmission(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): number;
        setBedOccupied(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.LivingEntity_, arg4: boolean): void;
        arch$registryName(): ResourceLocation;
        addLandingEffects(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: Internal.LivingEntity_, arg5: number): boolean;
        canDropFromExplosion(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): boolean;
        isConduitFrame(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): boolean;
        getEnchantPowerBonus(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): number;
        addRunningEffects(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        getShape(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.CollisionContext_): Internal.VoxelShape;
        getSoundType(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): Internal.SoundType;
        isBurning(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getMapColor(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.MaterialColor_): Internal.MaterialColor;
        get blockStatesKJS(): Internal.List<Internal.BlockState>
    }
    type AirBlock_ = AirBlock;
    class RuleProcessor extends Internal.StructureProcessor {
        constructor(arg0: Internal.List_<any>)
        processBlock(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.StructureTemplate$StructureBlockInfo_, arg4: Internal.StructureTemplate$StructureBlockInfo_, arg5: Internal.StructurePlaceSettings_): Internal.StructureTemplate$StructureBlockInfo;
        readonly static "CODEC": any;
    }
    type RuleProcessor_ = RuleProcessor;
    interface LongCollection extends Internal.LongIterable, Internal.Collection<number> {
        stream(): Internal.Stream<number>;
        forEach(arg0: Internal.Consumer_<any>): void;
        longIterator(): Internal.LongIterator;
        iterator(): Internal.LongIterator;
        add(arg0: number): boolean;
        removeIf(arg0: Internal.LongPredicate_): boolean;
        toLongArray(arg0: number[]): number[];
        toArray(arg0: number[]): number[];
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        retainAll(arg0: Internal.LongCollection_): boolean;
        parallelStream(): Internal.Stream<number>;
        forEach(arg0: Internal.LongConsumer_): void;
        contains(arg0: any): boolean;
        addAll(arg0: Internal.LongCollection_): boolean;
        contains(arg0: number): boolean;
        remove(arg0: any): boolean;
        rem(arg0: number): boolean;
        add(arg0: any): boolean;
        toLongArray(): number[];
        forEach(arg0: it.unimi.dsi.fastutil.longs.LongConsumer_): void;
        removeAll(arg0: Internal.LongCollection_): boolean;
        containsAll(arg0: Internal.LongCollection_): boolean;
        longParallelStream(): Internal.LongStream;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        spliterator(): Internal.Spliterator<any>;
        longStream(): Internal.LongStream;
        add(arg0: number): boolean;
        longSpliterator(): Internal.LongSpliterator;
        removeIf(arg0: it.unimi.dsi.fastutil.longs.LongPredicate_): boolean;
    }
    type LongCollection_ = LongCollection;
    class NativeJavaClass extends Internal.NativeJavaObject implements dev.latvian.mods.rhino.Function {
        constructor()
        constructor(scope: Internal.Scriptable_, cl: Internal.Class_<any>, isAdapter: boolean)
        constructor(scope: Internal.Scriptable_, cl: Internal.Class_<any>)
        call(cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        toString(): string;
        hasInstance(value: Internal.Scriptable_): boolean;
        getClassName(): string;
        getDefaultValue(hint: Internal.Class_<any>): any;
        has(name: string, start: Internal.Scriptable_): boolean;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getAllIds(): any[];
        get(name: string, start: Internal.Scriptable_): any;
        getIds(): any[];
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getClassObject(): Internal.Class<any>;
        getTypeOf(): Internal.MemberType;
        put(name: string, start: Internal.Scriptable_, value: any): void;
        construct(cx: Internal.Context_, scope: Internal.Scriptable_, args: any[]): Internal.Scriptable;
        get className(): string
        get allIds(): any[]
        get ids(): any[]
        get classObject(): Internal.Class<any>
        get typeOf(): Internal.MemberType
    }
    type NativeJavaClass_ = NativeJavaClass;
    interface CubicSpline <C> extends Internal.ToFloatFunction<C> {
        max(): number;
        builder(arg0: Internal.ToFloatFunction_<C>): Internal.CubicSpline$Builder<C>;
        codec(arg0: Internal.Codec_<Internal.ToFloatFunction_<C>>): Internal.Codec<Internal.CubicSpline<C>>;
        constant(arg0: number): this;
        min(): number;
        mapAll(arg0: Internal.CubicSpline$CoordinateVisitor_<C>): this;
        parityString(): string;
        builder(arg0: Internal.ToFloatFunction_<C>, arg1: Internal.ToFloatFunction_<number>): Internal.CubicSpline$Builder<C>;
    }
    type CubicSpline_<C> = CubicSpline<C>;
    class ClientboundContainerSetSlotPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: number, arg2: number, arg3: Internal.ItemStack_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        getStateId(): number;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getItem(): Internal.ItemStack;
        getContainerId(): number;
        getSlot(): number;
        isSkippable(): boolean;
        get stateId(): number
        get item(): Internal.ItemStack
        get containerId(): number
        get slot(): number
        get skippable(): boolean
        readonly static "CARRIED_ITEM": -1;
        readonly static "PLAYER_INVENTORY": -2;
    }
    type ClientboundContainerSetSlotPacket_ = ClientboundContainerSetSlotPacket;
    class CrashReportCategory {
        constructor(arg0: string)
        setDetail(arg0: string, arg1: Internal.CrashReportDetail_<string>): this;
        applyStackTrace(arg0: Internal.Throwable_): void;
        fillInStackTrace(arg0: number): number;
        getStacktrace(): Internal.StackTraceElement[];
        validateStackTrace(arg0: Internal.StackTraceElement_, arg1: Internal.StackTraceElement_): boolean;
        static formatLocation(arg0: Internal.LevelHeightAccessor_, arg1: number, arg2: number, arg3: number): string;
        getDetails(arg0: Internal.StringBuilder_): void;
        static formatLocation(arg0: Internal.LevelHeightAccessor_, arg1: number, arg2: number, arg3: number): string;
        setDetail(arg0: string, arg1: any): this;
        static formatLocation(arg0: Internal.LevelHeightAccessor_, arg1: BlockPos_): string;
        static populateBlockDetails(arg0: Internal.CrashReportCategory_, arg1: Internal.LevelHeightAccessor_, arg2: BlockPos_, arg3: Internal.BlockState_): void;
        setDetailError(arg0: string, arg1: Internal.Throwable_): void;
        trimStacktrace(arg0: number): void;
        get stacktrace(): Internal.StackTraceElement[]
    }
    type CrashReportCategory_ = CrashReportCategory;
    class Biome extends Internal.ForgeRegistryEntry$UncheckedRegistryEntry<Internal.Biome> {
        getWaterColor(): number;
        getPrecipitation(): Internal.Biome$Precipitation;
        getMobSettings(): Internal.MobSpawnSettings;
        shouldMeltFrozenOceanIcebergSlightly(arg0: BlockPos_): boolean;
        getAmbientLoop(): Internal.Optional<Internal.SoundEvent>;
        getSpecialEffects(): Internal.BiomeSpecialEffects;
        shouldFreeze(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: boolean): boolean;
        getDownfall(): number;
        coldEnoughToSnow(arg0: BlockPos_): boolean;
        shouldSnow(arg0: Internal.LevelReader_, arg1: BlockPos_): boolean;
        warmEnoughToRain(arg0: BlockPos_): boolean;
        getFogColor(): number;
        shouldFreeze(arg0: Internal.LevelReader_, arg1: BlockPos_): boolean;
        getSkyColor(): number;
        getFoliageColor(): number;
        static getBiomeCategory(arg0: Internal.Holder_<Internal.Biome_>): Internal.Biome$BiomeCategory;
        shouldSnowGolemBurn(arg0: BlockPos_): boolean;
        getAmbientAdditions(): Internal.Optional<Internal.AmbientAdditionsSettings>;
        getAmbientMood(): Internal.Optional<Internal.AmbientMoodSettings>;
        getBackgroundMusic(): Internal.Optional<Internal.Music>;
        getBaseTemperature(): number;
        getWaterFogColor(): number;
        getAmbientParticle(): Internal.Optional<Internal.AmbientParticleSettings>;
        isHumid(): boolean;
        getGrassColor(arg0: number, arg1: number): number;
        getGenerationSettings(): Internal.BiomeGenerationSettings;
        get waterColor(): number
        get precipitation(): Internal.Biome$Precipitation
        get mobSettings(): Internal.MobSpawnSettings
        get ambientLoop(): Internal.Optional<Internal.SoundEvent>
        get specialEffects(): Internal.BiomeSpecialEffects
        get downfall(): number
        get fogColor(): number
        get skyColor(): number
        get foliageColor(): number
        get ambientAdditions(): Internal.Optional<Internal.AmbientAdditionsSettings>
        get ambientMood(): Internal.Optional<Internal.AmbientMoodSettings>
        get backgroundMusic(): Internal.Optional<Internal.Music>
        get baseTemperature(): number
        get waterFogColor(): number
        get ambientParticle(): Internal.Optional<Internal.AmbientParticleSettings>
        get humid(): boolean
        get generationSettings(): Internal.BiomeGenerationSettings
        readonly "climateSettings": Internal.Biome$ClimateSettings;
        /**
         * @java.lang.Deprecated(forRemoval=true, since="")
        */
        readonly static "BIOME_INFO_NOISE": Internal.PerlinSimplexNoise;
        readonly static "CODEC": any;
        readonly static "DIRECT_CODEC": any;
        readonly static "NETWORK_CODEC": any;
        "biomeCategory": Internal.Biome$BiomeCategory;
        readonly static "LIST_CODEC": any;
    }
    type Biome_ = Special.Biome | Biome;
    class StructurePlaceSettings {
        constructor()
        setMirror(arg0: Internal.Mirror_): this;
        setKeepLiquids(arg0: boolean): this;
        setRotation(arg0: Internal.Rotation_): this;
        shouldFinalizeEntities(): boolean;
        isIgnoreEntities(): boolean;
        setFinalizeEntities(arg0: boolean): this;
        clearProcessors(): this;
        setIgnoreEntities(arg0: boolean): this;
        getRandomPalette(arg0: Internal.List_<Internal.StructureTemplate$Palette_>, arg1: BlockPos_): Internal.StructureTemplate$Palette;
        setRandom(arg0: Internal.Random_): this;
        getRandom(arg0: BlockPos_): Internal.Random;
        shouldKeepLiquids(): boolean;
        setKnownShape(arg0: boolean): this;
        getRotationPivot(): BlockPos;
        getBoundingBox(): Internal.BoundingBox;
        addProcessor(arg0: Internal.StructureProcessor_): this;
        setRotationPivot(arg0: BlockPos_): this;
        getRotation(): Internal.Rotation;
        copy(): this;
        getMirror(): Internal.Mirror;
        setBoundingBox(arg0: Internal.BoundingBox_): this;
        popProcessor(arg0: Internal.StructureProcessor_): this;
        getProcessors(): Internal.List<Internal.StructureProcessor>;
        getKnownShape(): boolean;
        set mirror(arg0: Internal.Mirror_)
        set keepLiquids(arg0: boolean)
        set rotation(arg0: Internal.Rotation_)
        get ignoreEntities(): boolean
        set finalizeEntities(arg0: boolean)
        set ignoreEntities(arg0: boolean)
        set random(arg0: Internal.Random_)
        set knownShape(arg0: boolean)
        get rotationPivot(): BlockPos
        get boundingBox(): Internal.BoundingBox
        set rotationPivot(arg0: BlockPos_)
        get rotation(): Internal.Rotation
        get mirror(): Internal.Mirror
        set boundingBox(arg0: Internal.BoundingBox_)
        get processors(): Internal.List<Internal.StructureProcessor>
        get knownShape(): boolean
    }
    type StructurePlaceSettings_ = StructurePlaceSettings;
    class ServerboundEditBookPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: number, arg1: Internal.List_<string>, arg2: Internal.Optional_<string>)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getTitle(): Internal.Optional<string>;
        getPages(): Internal.List<string>;
        getSlot(): number;
        isSkippable(): boolean;
        get title(): Internal.Optional<string>
        get pages(): Internal.List<string>
        get slot(): number
        get skippable(): boolean
        readonly static "MAX_BYTES_PER_CHAR": 4;
    }
    type ServerboundEditBookPacket_ = ServerboundEditBookPacket;
    interface PrimitiveIterator$OfLong extends Internal.PrimitiveIterator<number, Internal.LongConsumer> {
        forEachRemaining(arg0: any): void;
        remove(): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        next(): any;
        nextLong(): number;
        forEachRemaining(arg0: Internal.LongConsumer_): void;
    }
    type PrimitiveIterator$OfLong_ = PrimitiveIterator$OfLong;
    class ScoreboardSaveData extends Internal.SavedData {
        constructor(arg0: Internal.Scoreboard_)
        load(arg0: Internal.CompoundTag_): this;
        save(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        readonly static "FILE_ID": "scoreboard";
    }
    type ScoreboardSaveData_ = ScoreboardSaveData;
    interface TemporalAmount {
        subtractFrom(arg0: Internal.Temporal_): Internal.Temporal;
        addTo(arg0: Internal.Temporal_): Internal.Temporal;
        getUnits(): Internal.List<Internal.TemporalUnit>;
        get(arg0: Internal.TemporalUnit_): number;
        get units(): Internal.List<Internal.TemporalUnit>
    }
    type TemporalAmount_ = TemporalAmount;
    class RandomBlockStateMatchTest extends Internal.RuleTest {
        constructor(arg0: Internal.BlockState_, arg1: number)
        test(arg0: Internal.BlockState_, arg1: Internal.Random_): boolean;
        readonly static "CODEC": any;
    }
    type RandomBlockStateMatchTest_ = RandomBlockStateMatchTest;
    abstract class ImmutableMultimap <K, V> extends Internal.BaseImmutableMultimap<K, V> implements Internal.Serializable {
        putAll(arg0: Internal.Multimap_<any, any>): boolean;
        static of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): Internal.ImmutableMultimap<K, V>;
        putAll(arg0: K, arg1: Internal.Iterable_<any>): boolean;
        containsValue(arg0: any): boolean;
        static of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): Internal.ImmutableMultimap<K, V>;
        isEmpty(): boolean;
        keys(): Internal.ImmutableMultiset<K>;
        static of(arg0: K, arg1: V, arg2: K, arg3: V): Internal.ImmutableMultimap<K, V>;
        keySet(): Internal.Set<any>;
        containsKey(arg0: any): boolean;
        inverse(): Internal.ImmutableMultimap<V, K>;
        removeAll(arg0: any): Internal.ImmutableCollection<V>;
        values(): Internal.Collection<any>;
        replaceValues(arg0: K, arg1: Internal.Iterable_<any>): Internal.ImmutableCollection<V>;
        toString(): string;
        entries(): Internal.ImmutableCollection<Internal.Map$Entry<K, V>>;
        remove(arg0: any, arg1: any): boolean;
        containsEntry(arg0: any, arg1: any): boolean;
        asMap(): Internal.ImmutableMap<K, Internal.Collection<V>>;
        static builder(): Internal.ImmutableMultimap$Builder<K, V>;
        get(arg0: any): Internal.Collection<any>;
        hashCode(): number;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        size(): number;
        static copyOf(arg0: Internal.Iterable_<any>): Internal.ImmutableMultimap<K, V>;
        put(arg0: K, arg1: V): boolean;
        static of(arg0: K, arg1: V): Internal.ImmutableMultimap<K, V>;
        clear(): void;
        static of(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): Internal.ImmutableMultimap<K, V>;
        equals(arg0: any): boolean;
        static of(): Internal.ImmutableMultimap<K, V>;
        static copyOf(arg0: Internal.Multimap_<any, any>): Internal.ImmutableMultimap<K, V>;
        get empty(): boolean
    }
    type ImmutableMultimap_<K, V> = ImmutableMultimap<K, V>;
    class BrainDebugRenderer implements Internal.DebugRenderer$SimpleDebugRenderer {
        constructor(arg0: Internal.Minecraft_)
        removePoi(arg0: BlockPos_): void;
        setFreeTicketCount(arg0: BlockPos_, arg1: number): void;
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource_, arg2: number, arg3: number, arg4: number): void;
        removeBrainDump(arg0: number): void;
        clear(): void;
        addOrUpdateBrainDump(arg0: Internal.BrainDebugRenderer$BrainDump_): void;
        addPoi(arg0: Internal.BrainDebugRenderer$PoiInfo_): void;
    }
    type BrainDebugRenderer_ = BrainDebugRenderer;
    interface IntFunction <R> {
        apply(arg0: number): R;
    }
    type IntFunction_<R> = ((arg0: number)=>R) | IntFunction<R>;
    class AdvancementRewards {
        constructor(arg0: number, arg1: ResourceLocation_[], arg2: ResourceLocation_[], arg3: any_)
        serializeToJson(): Internal.JsonElement;
        getRecipes(): ResourceLocation[];
        toString(): string;
        grant(arg0: Internal.ServerPlayer_): void;
        static deserialize(arg0: Internal.JsonObject_): Internal.AdvancementRewards;
        get recipes(): ResourceLocation[]
        readonly static "EMPTY": Internal.AdvancementRewards;
    }
    type AdvancementRewards_ = AdvancementRewards;
    interface PrimitiveCodec <A> extends Internal.Codec<A> {
        parse(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<A>;
        optionalFieldOf(arg0: string, arg1: A): Internal.MapCodec<A>;
        orElseGet(arg0: Internal.UnaryOperator_<string>, arg1: Internal.Supplier_<any>): Internal.Codec<A>;
        fieldOf(arg0: string): Internal.MapCodec<A>;
        xmap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<S>;
        parse(arg0: Internal.Dynamic_<T>): Internal.DataResult<A>;
        orElseGet(arg0: Internal.Consumer_<string>, arg1: Internal.Supplier_<any>): Internal.Codec<A>;
        deprecated(arg0: number): Internal.Codec<A>;
        flatXmap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<S>;
        promotePartial(arg0: Internal.Consumer_<string>): Internal.Codec<A>;
        orElse(arg0: A): Internal.Codec<A>;
        simple(): Internal.Decoder$Simple<A>;
        flatMap(arg0: Internal.Function_<any, any>): Internal.Decoder<B>;
        stable(): Internal.Codec<A>;
        boxed(): Internal.Decoder$Boxed<A>;
        map(arg0: Internal.Function_<any, any>): Internal.Decoder<B>;
        dispatchMap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.MapCodec<E>;
        partialDispatch(arg0: string, arg1: Internal.Function_<any, any>, arg2: Internal.Function_<any, any>): Internal.Codec<E>;
        dispatch(arg0: string, arg1: Internal.Function_<any, any>, arg2: Internal.Function_<any, any>): Internal.Codec<E>;
        flatComapMap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<S>;
        dispatch(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<E>;
        dispatchMap(arg0: string, arg1: Internal.Function_<any, any>, arg2: Internal.Function_<any, any>): Internal.MapCodec<E>;
        comapFlatMap(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<S>;
        orElseGet(arg0: Internal.Supplier_<any>): Internal.Codec<A>;
        optionalFieldOf(arg0: string, arg1: A, arg2: Internal.Lifecycle_): Internal.MapCodec<A>;
        flatComap(arg0: Internal.Function_<any, any>): Internal.Encoder<B>;
        terminal(): Internal.Decoder$Terminal<A>;
        withLifecycle(arg0: Internal.Lifecycle_): Internal.Codec<A>;
        read(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<A>;
        decode(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>;
        orElse(arg0: Internal.Consumer_<string>, arg1: A): Internal.Codec<A>;
        encodeStart(arg0: Internal.DynamicOps_<T>, arg1: A): Internal.DataResult<T>;
        listOf(): Internal.Codec<Internal.List<A>>;
        orElse(arg0: Internal.UnaryOperator_<string>, arg1: A): Internal.Codec<A>;
        decode(arg0: Internal.Dynamic_<T>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>;
        comap(arg0: Internal.Function_<any, any>): Internal.Encoder<B>;
        mapResult(arg0: Internal.Codec$ResultFunction_<A>): Internal.Codec<A>;
        optionalFieldOf(arg0: string): Internal.MapCodec<Internal.Optional<A>>;
        dispatchStable(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Codec<E>;
        optionalFieldOf(arg0: string, arg1: Internal.Lifecycle_, arg2: A, arg3: Internal.Lifecycle_): Internal.MapCodec<A>;
        encode(arg0: A, arg1: Internal.DynamicOps_<T>, arg2: T): Internal.DataResult<T>;
        write(arg0: Internal.DynamicOps_<T>, arg1: A): T;
    }
    type PrimitiveCodec_<A> = PrimitiveCodec<A>;
    class HopperMenu extends Internal.AbstractContainerMenu {
        constructor(arg0: number, arg1: Internal.Inventory_)
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: Internal.Container_)
        stillValid(arg0: Internal.Player_): boolean;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        removed(arg0: Internal.Player_): void;
        readonly static "CONTAINER_SIZE": 5;
    }
    type HopperMenu_ = HopperMenu;
    abstract class WritableRegistry <T> extends Internal.Registry<T> {
        constructor(arg0: Internal.ResourceKey_<any>, arg1: Internal.Lifecycle_)
        registerOrOverride(arg0: Internal.OptionalInt_, arg1: Internal.ResourceKey_<T>, arg2: T, arg3: Internal.Lifecycle_): Internal.Holder<T>;
        register(arg0: Internal.ResourceKey_<T>, arg1: T, arg2: Internal.Lifecycle_): Internal.Holder<T>;
        forEach(arg0: Internal.Consumer_<any>): void;
        spliterator(): Internal.Spliterator<T>;
        isEmpty(): boolean;
        byIdOrThrow(arg0: number): T;
        registerMapping(arg0: number, arg1: Internal.ResourceKey_<T>, arg2: T, arg3: Internal.Lifecycle_): Internal.Holder<T>;
        get empty(): boolean
    }
    type WritableRegistry_<T> = WritableRegistry<T>;
    interface IForgeMobEffectInstance {
        setCurativeItems(arg0: Internal.List_<Internal.ItemStack_>): void;
        addCurativeItem(arg0: Internal.ItemStack_): void;
        getCurativeItems(): Internal.List<Internal.ItemStack>;
        writeCurativeItems(arg0: Internal.CompoundTag_): void;
        isCurativeItem(arg0: Internal.ItemStack_): boolean;
        set curativeItems(arg0: Internal.List_<Internal.ItemStack_>)
        get curativeItems(): Internal.List<Internal.ItemStack>
    }
    type IForgeMobEffectInstance_ = IForgeMobEffectInstance;
    interface Decoder <A> {
        parse(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<A>;
        error(arg0: string): this;
        withLifecycle(arg0: Internal.Lifecycle_): this;
        unit(arg0: A): Internal.MapDecoder<A>;
        ofBoxed(arg0: Internal.Decoder$Boxed_<any>): this;
        ofTerminal(arg0: Internal.Decoder$Terminal_<any>): this;
        parse(arg0: Internal.Dynamic_<T>): Internal.DataResult<A>;
        terminal(): Internal.Decoder$Terminal<A>;
        ofSimple(arg0: Internal.Decoder$Simple_<any>): this;
        fieldOf(arg0: string): Internal.MapDecoder<A>;
        simple(): Internal.Decoder$Simple<A>;
        decode(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>;
        flatMap(arg0: Internal.Function_<any, any>): Internal.Decoder<B>;
        decode(arg0: Internal.Dynamic_<T>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>;
        boxed(): Internal.Decoder$Boxed<A>;
        map(arg0: Internal.Function_<any, any>): Internal.Decoder<B>;
        unit(arg0: Internal.Supplier_<A>): Internal.MapDecoder<A>;
        promotePartial(arg0: Internal.Consumer_<string>): this;
    }
    type Decoder_<A> = Decoder<A>;
    interface Float2ShortFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleToIntFunction {
        andThenShort(arg0: Internal.Short2ShortFunction_): this;
        getOrDefault(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2ShortFunction;
        containsKey(arg0: any): boolean;
        andThenObject(arg0: Internal.Short2ObjectFunction_<any>): Internal.Float2ObjectFunction<T>;
        get(arg0: any): number;
        composeReference(arg0: Internal.Reference2FloatFunction_<any>): Internal.Reference2ShortFunction<T>;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Float2FloatFunction;
        defaultReturnValue(): number;
        andThenReference(arg0: Internal.Short2ReferenceFunction_<any>): Internal.Float2ReferenceFunction<T>;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Float2ByteFunction;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2ShortFunction;
        apply(arg0: number): number;
        put(arg0: any, arg1: any): any;
        containsKey(arg0: number): boolean;
        composeFloat(arg0: Internal.Float2FloatFunction_): this;
        get(arg0: number): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2ShortFunction;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2ShortFunction;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Float2CharFunction;
        put(arg0: number, arg1: number): number;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Float2LongFunction;
        composeObject(arg0: Internal.Object2FloatFunction_<any>): Internal.Object2ShortFunction<T>;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2ShortFunction;
        size(): number;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Float2DoubleFunction;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Float2IntFunction;
        defaultReturnValue(arg0: number): void;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2ShortFunction;
        clear(): void;
        getOrDefault(arg0: any, arg1: number): number;
        remove(arg0: any): any;
        applyAsInt(arg0: number): number;
    }
    type Float2ShortFunction_ = Float2ShortFunction | ((arg0: number)=>number);
    class LivingDeathEvent extends Internal.LivingEvent {
        constructor()
        constructor(arg0: Internal.LivingEntity_, arg1: Internal.DamageSource_)
        isCancelable(): boolean;
        getListenerList(): Internal.ListenerList;
        getSource(): Internal.DamageSource;
        get cancelable(): boolean
        get listenerList(): Internal.ListenerList
        get source(): Internal.DamageSource
    }
    type LivingDeathEvent_ = LivingDeathEvent;
    class VillagerData {
        constructor(arg0: Internal.VillagerType_, arg1: Internal.VillagerProfession_, arg2: number)
        static getMaxXpPerLevel(arg0: number): number;
        getLevel(): number;
        static getMinXpPerLevel(arg0: number): number;
        getProfession(): Internal.VillagerProfession;
        static canLevelUp(arg0: number): boolean;
        setProfession(arg0: Internal.VillagerProfession_): this;
        setLevel(arg0: number): this;
        setType(arg0: Internal.VillagerType_): this;
        getType(): Internal.VillagerType;
        get level(): number
        get profession(): Internal.VillagerProfession
        set profession(arg0: Internal.VillagerProfession_)
        set level(arg0: number)
        set type(arg0: Internal.VillagerType_)
        get type(): Internal.VillagerType
        readonly static "CODEC": any;
        readonly static "MAX_VILLAGER_LEVEL": 5;
        readonly static "MIN_VILLAGER_LEVEL": 1;
    }
    type VillagerData_ = VillagerData;
    interface ShortUnaryOperator extends Internal.IntUnaryOperator, Internal.UnaryOperator<number> {
        identity(): this;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
        apply(arg0: number): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        apply(arg0: number): number;
        apply(arg0: any): any;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        applyAsInt(arg0: number): number;
        negation(): this;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
    }
    type ShortUnaryOperator_ = ShortUnaryOperator | ((arg0: number)=>number);
    class GlowLichenConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: number, arg1: boolean, arg2: boolean, arg3: boolean, arg4: number, arg5: Internal.HolderSet_<Internal.Block_>)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "searchRange": number;
        readonly "canBePlacedOn": Internal.HolderSet<Internal.Block>;
        readonly "canPlaceOnCeiling": boolean;
        readonly "validDirections": Internal.List<Internal.Direction>;
        readonly static "CODEC": any;
        readonly "canPlaceOnFloor": boolean;
        readonly "canPlaceOnWall": boolean;
        readonly "chanceOfSpreading": number;
    }
    type GlowLichenConfiguration_ = GlowLichenConfiguration;
    abstract class DiscreteVoxelShape {
        forAllEdges(arg0: Internal.DiscreteVoxelShape$IntLineConsumer_, arg1: boolean): void;
        forAllBoxes(arg0: Internal.DiscreteVoxelShape$IntLineConsumer_, arg1: boolean): void;
        fill(arg0: number, arg1: number, arg2: number): void;
        isFullWide(arg0: number, arg1: number, arg2: number): boolean;
        lastFull(arg0: Internal.Direction$Axis_, arg1: number, arg2: number): number;
        isFull(arg0: Internal.AxisCycle_, arg1: number, arg2: number, arg3: number): boolean;
        firstFull(arg0: Internal.Direction$Axis_, arg1: number, arg2: number): number;
        isEmpty(): boolean;
        getSize(arg0: Internal.Direction$Axis_): number;
        forAllFaces(arg0: Internal.DiscreteVoxelShape$IntFaceConsumer_): void;
        firstFull(arg0: Internal.Direction$Axis_): number;
        isFull(arg0: number, arg1: number, arg2: number): boolean;
        getXSize(): number;
        getYSize(): number;
        isFullWide(arg0: Internal.AxisCycle_, arg1: number, arg2: number, arg3: number): boolean;
        getZSize(): number;
        lastFull(arg0: Internal.Direction$Axis_): number;
        get empty(): boolean
        get XSize(): number
        get YSize(): number
        get ZSize(): number
    }
    type DiscreteVoxelShape_ = DiscreteVoxelShape;
    interface LongSpliterator extends Internal.Spliterator$OfLong {
        forEachRemaining(arg0: any): void;
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        getComparator(): Internal.Comparator<any>;
        trySplit(): Internal.Spliterator<any>;
        tryAdvance(arg0: it.unimi.dsi.fastutil.longs.LongConsumer_): boolean;
        getExactSizeIfKnown(): number;
        hasCharacteristics(arg0: number): boolean;
        tryAdvance(arg0: Internal.Consumer_<any>): boolean;
        forEachRemaining(arg0: it.unimi.dsi.fastutil.longs.LongConsumer_): void;
        skip(arg0: number): number;
        tryAdvance(arg0: any): boolean;
        forEachRemaining(arg0: Internal.LongConsumer_): void;
        get comparator(): Internal.Comparator<any>
        get exactSizeIfKnown(): number
    }
    type LongSpliterator_ = LongSpliterator;
    class LongArrayTag extends Internal.CollectionTag<Internal.LongTag> {
        constructor(arg0: Internal.LongSet_)
        constructor(arg0: number[])
        constructor(arg0: Internal.List_<number>)
        spliterator(): Internal.Spliterator<Internal.LongTag>;
        remove(arg0: number): any;
        set(arg0: number, arg1: Internal.Tag_): Internal.Tag;
        forEach(arg0: Internal.Consumer_<any>): void;
        addTag(arg0: number, arg1: Internal.Tag_): boolean;
        set(arg0: number, arg1: Internal.LongTag_): Internal.LongTag;
        add(arg0: number, arg1: any): void;
        add(arg0: number, arg1: Internal.LongTag_): void;
        setTag(arg0: number, arg1: Internal.Tag_): boolean;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        write(arg0: Internal.DataOutput_): void;
        getAsLongArray(): number[];
        parallelStream(): Internal.Stream<Internal.LongTag>;
        getId(): number;
        getType(): Internal.TagType<Internal.LongArrayTag>;
        stream(): Internal.Stream<Internal.LongTag>;
        toString(): string;
        get(arg0: number): Internal.LongTag;
        accept(arg0: Internal.TagVisitor_): void;
        add(arg0: number, arg1: Internal.Tag_): void;
        sort(arg0: Internal.Comparator_<any>): void;
        getAsString(): string;
        size(): number;
        hashCode(): number;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        copy(): Internal.Tag;
        clear(): void;
        replaceAll(arg0: Internal.UnaryOperator_<Internal.LongTag_>): void;
        equals(arg0: any): boolean;
        accept(arg0: Internal.StreamTagVisitor_): Internal.StreamTagVisitor$ValueResult;
        set(arg0: number, arg1: any): any;
        getElementType(): number;
        get asLongArray(): number[]
        get id(): number
        get type(): Internal.TagType<Internal.LongArrayTag>
        get asString(): string
        get elementType(): number
        readonly static "TYPE": any;
    }
    type LongArrayTag_ = LongArrayTag;
    abstract class Either <L, R> implements Internal.App<Internal.Either$Mu<R>, L> {
        mapRight(arg0: Internal.Function_<any, any>): Internal.Either<L, T>;
        right(): Internal.Optional<R>;
        ifLeft(arg0: Internal.Consumer_<any>): this;
        flatMap(arg0: Internal.Function_<L, Internal.Either_<L2, R>>): Internal.Either<L2, R>;
        swap(): Internal.Either<R, L>;
        mapBoth(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): Internal.Either<C, D>;
        static right(arg0: R): Internal.Either<L, R>;
        ifRight(arg0: Internal.Consumer_<any>): this;
        static unbox(arg0: Internal.App_<Internal.Either$Mu_<R>, L>): Internal.Either<L, R>;
        orThrow(): L;
        map(arg0: Internal.Function_<any, any>, arg1: Internal.Function_<any, any>): T;
        static left(arg0: L): Internal.Either<L, R>;
        left(): Internal.Optional<L>;
        mapLeft(arg0: Internal.Function_<any, any>): Internal.Either<T, R>;
    }
    type Either_<L, R> = Either<L, R>;
    class ServerboundAcceptTeleportationPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: number)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        isSkippable(): boolean;
        getId(): number;
        get skippable(): boolean
        get id(): number
    }
    type ServerboundAcceptTeleportationPacket_ = ServerboundAcceptTeleportationPacket;
    class StructureProcessorList {
        constructor(arg0: Internal.List_<Internal.StructureProcessor_>)
        toString(): string;
        list(): Internal.List<Internal.StructureProcessor>;
    }
    type StructureProcessorList_ = Special.StructureProcessorList | StructureProcessorList;
    class AirItem extends Internal.Item {
        constructor(arg0: Internal.Block_, arg1: Internal.Item$Properties_)
        getMaxDamage(arg0: Internal.ItemStack_): number;
        elytraFlightTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getShareTag(arg0: Internal.ItemStack_): Internal.CompoundTag;
        isDamageable(arg0: Internal.ItemStack_): boolean;
        isEnderMask(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.EnderMan_): boolean;
        getBurnTime(arg0: Internal.ItemStack_, arg1: Internal.RecipeType_<any>): number;
        onItemUseFirst(arg0: Internal.ItemStack_, arg1: Internal.UseOnContext_): Internal.InteractionResult;
        onUsingTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack_): boolean;
        isCorrectToolForDrops(arg0: Internal.ItemStack_, arg1: Internal.BlockState_): boolean;
        getItemStackLimit(arg0: Internal.ItemStack_): number;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_, arg3: Internal.LivingEntity_): boolean;
        appendHoverText(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.List_<Internal.Component_>, arg3: Internal.TooltipFlag_): void;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_, arg1: Internal.Enchantment_): boolean;
        canWalkOnPowderedSnow(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        hasContainerItem(arg0: Internal.ItemStack_): boolean;
        getDescriptionId(): string;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        getXpRepairRatio(arg0: Internal.ItemStack_): number;
        isBookEnchantable(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        initCapabilities(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): Internal.ICapabilityProvider;
        onDroppedByPlayer(arg0: Internal.ItemStack_, arg1: Internal.Player_): boolean;
        isDamaged(arg0: Internal.ItemStack_): boolean;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack_): number;
        getCreatorModId(arg0: Internal.ItemStack_): string;
        canContinueUsing(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getFoodProperties(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): Internal.FoodProperties;
        getHighlightTip(arg0: Internal.ItemStack_, arg1: Internal.Component_): Internal.Component;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        onLeftClickEntity(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): boolean;
        canEquip(arg0: Internal.ItemStack_, arg1: EquipmentSlot_, arg2: Internal.Entity_): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        canPerformAction(arg0: Internal.ItemStack_, arg1: Internal.ToolAction_): boolean;
        getItemEnchantability(arg0: Internal.ItemStack_): number;
        hasCustomEntity(arg0: Internal.ItemStack_): boolean;
        onEntityItemUpdate(arg0: Internal.ItemStack_, arg1: Internal.ItemEntity_): boolean;
        getDamage(arg0: Internal.ItemStack_): number;
        onArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Player_): void;
        readShareTag(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): void;
        getEquipmentSlot(arg0: Internal.ItemStack_): EquipmentSlot;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        damageItem(arg0: Internal.ItemStack_, arg1: number, arg2: T, arg3: Internal.Consumer_<T>): number;
        arch$registryName(): ResourceLocation;
        getAttributeModifiers(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        arch$holder(): Internal.Holder<Internal.Item>;
        canElytraFly(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getArmorTexture(arg0: Internal.ItemStack_, arg1: Internal.Entity_, arg2: EquipmentSlot_, arg3: string): string;
        createEntity(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.ItemStack_): Internal.Entity;
        onEntitySwing(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getEntityLifespan(arg0: Internal.ItemStack_, arg1: Internal.Level_): number;
        setDamage(arg0: Internal.ItemStack_, arg1: number): void;
        getSweepHitBox(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): Internal.AABB;
        doesSneakBypassUse(arg0: Internal.ItemStack_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: boolean): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Mob_): void;
        getContainerItem(arg0: Internal.ItemStack_): Internal.ItemStack;
        onBlockStartBreak(arg0: Internal.ItemStack_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        get descriptionId(): string
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>
    }
    type AirItem_ = AirItem;
    abstract class StateHolder <O, S> {
        hasProperty(arg0: Internal.Property_<T>): boolean;
        getProperties(): Internal.Collection<Internal.Property<any>>;
        toString(): string;
        cycle(arg0: Internal.Property_<T>): S;
        getValues(): Internal.ImmutableMap<Internal.Property<any>, Internal.Comparable<any>>;
        setValue(arg0: Internal.Property_<T>, arg1: V): S;
        populateNeighbours(arg0: Internal.Map_<Internal.Map_<Internal.Property_<any>, Internal.Comparable_<any>>, S>): void;
        getValue(arg0: Internal.Property_<T>): T;
        getOptionalValue(arg0: Internal.Property_<T>): Internal.Optional<T>;
        get properties(): Internal.Collection<Internal.Property<any>>
        get values(): Internal.ImmutableMap<Internal.Property<any>, Internal.Comparable<any>>
        readonly static "PROPERTIES_TAG": "Properties";
        readonly static "NAME_TAG": "Name";
    }
    type StateHolder_<O, S> = StateHolder<O, S>;
    class BlockInWorld {
        constructor(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: boolean)
        getLevel(): Internal.LevelReader;
        static hasState(arg0: Internal.Predicate_<Internal.BlockState_>): Internal.Predicate<Internal.BlockInWorld>;
        getPos(): BlockPos;
        getEntity(): Internal.BlockEntity;
        getState(): Internal.BlockState;
        get level(): Internal.LevelReader
        get pos(): BlockPos
        get entity(): Internal.BlockEntity
        get state(): Internal.BlockState
    }
    type BlockInWorld_ = BlockInWorld;
    class PlayerNegotiationEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.Connection_, arg1: Internal.GameProfile_, arg2: Internal.List_<Internal.Future_<void>>)
        enqueueWork(arg0: Internal.Runnable_): void;
        getProfile(): Internal.GameProfile;
        getListenerList(): Internal.ListenerList;
        getConnection(): Internal.Connection;
        enqueueWork(arg0: Internal.Future_<void>): void;
        get profile(): Internal.GameProfile
        get listenerList(): Internal.ListenerList
        get connection(): Internal.Connection
    }
    type PlayerNegotiationEvent_ = PlayerNegotiationEvent;
    class StringReader implements Internal.ImmutableStringReader {
        constructor(arg0: Internal.StringReader_)
        constructor(arg0: string)
        getTotalLength(): number;
        peek(): string;
        skipWhitespace(): void;
        setCursor(arg0: number): void;
        static isAllowedInUnquotedString(arg0: string): boolean;
        getRemainingLength(): number;
        readDouble(): number;
        canRead(arg0: number): boolean;
        readFloat(): number;
        getRead(): string;
        static isQuotedStringStart(arg0: string): boolean;
        peek(arg0: number): string;
        getString(): string;
        readStringUntil(arg0: string): string;
        getCursor(): number;
        expect(arg0: string): void;
        readLong(): number;
        readQuotedString(): string;
        readInt(): number;
        static isAllowedNumber(arg0: string): boolean;
        readBoolean(): boolean;
        readString(): string;
        canRead(): boolean;
        readUnquotedString(): string;
        skip(): void;
        getRemaining(): string;
        read(): string;
        get totalLength(): number
        set cursor(arg0: number)
        get remainingLength(): number
        get read(): string
        get string(): string
        get cursor(): number
        get remaining(): string
    }
    type StringReader_ = StringReader;
    interface IntComparator extends Internal.Comparator<number> {
        thenComparing(arg0: Internal.IntComparator_): this;
        thenComparingDouble(arg0: Internal.ToDoubleFunction_<any>): Internal.Comparator<number>;
        thenComparingLong(arg0: Internal.ToLongFunction_<any>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.Function_<any, any>): Internal.Comparator<number>;
        compare(arg0: number, arg1: number): number;
        compare(arg0: any, arg1: any): number;
        thenComparingInt(arg0: Internal.ToIntFunction_<any>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.Function_<any, any>, arg1: Internal.Comparator_<any>): Internal.Comparator<number>;
        compare(arg0: number, arg1: number): number;
        thenComparing(arg0: Internal.Comparator_<any>): Internal.Comparator<number>;
        reversed(): this;
    }
    type IntComparator_ = IntComparator | ((arg0: number, arg1: number)=>number);
    interface WorldData {
        setCustomBossEvents(arg0: Internal.CompoundTag_): void;
        getLevelSettings(): Internal.LevelSettings;
        getKnownServerBrands(): Internal.Set<string>;
        getLevelName(): string;
        getGameRules(): Internal.GameRules;
        setEndDragonFightData(arg0: Internal.CompoundTag_): void;
        isHardcore(): boolean;
        worldGenSettingsLifecycle(): Internal.Lifecycle;
        fillCrashReportCategory(arg0: Internal.CrashReportCategory_): void;
        getLoadedPlayerTag(): Internal.CompoundTag;
        getAllowCommands(): boolean;
        getStorageVersionName(arg0: number): string;
        setModdedInfo(arg0: string, arg1: boolean): void;
        getDifficulty(): Internal.Difficulty;
        isDifficultyLocked(): boolean;
        endDragonFightData(): Internal.CompoundTag;
        wasModded(): boolean;
        setDifficulty(arg0: Internal.Difficulty_): void;
        getDataPackConfig(): Internal.DataPackConfig;
        createTag(arg0: Internal.RegistryAccess_, arg1: Internal.CompoundTag_): Internal.CompoundTag;
        getCustomBossEvents(): Internal.CompoundTag;
        setDifficultyLocked(arg0: boolean): void;
        overworldData(): Internal.ServerLevelData;
        setDataPackConfig(arg0: Internal.DataPackConfig_): void;
        setGameType(arg0: Internal.GameType_): void;
        worldGenSettings(): Internal.WorldGenSettings;
        getGameType(): Internal.GameType;
        getVersion(): number;
        set customBossEvents(arg0: Internal.CompoundTag_)
        get levelSettings(): Internal.LevelSettings
        get knownServerBrands(): Internal.Set<string>
        get levelName(): string
        get gameRules(): Internal.GameRules
        set endDragonFightData(arg0: Internal.CompoundTag_)
        get hardcore(): boolean
        get loadedPlayerTag(): Internal.CompoundTag
        get allowCommands(): boolean
        get difficulty(): Internal.Difficulty
        get difficultyLocked(): boolean
        set difficulty(arg0: Internal.Difficulty_)
        get dataPackConfig(): Internal.DataPackConfig
        get customBossEvents(): Internal.CompoundTag
        set difficultyLocked(arg0: boolean)
        set dataPackConfig(arg0: Internal.DataPackConfig_)
        set gameType(arg0: Internal.GameType_)
        get gameType(): Internal.GameType
        get version(): number
        readonly static "MCREGION_VERSION_ID": 19132;
        readonly static "ANVIL_VERSION_ID": 19133;
    }
    type WorldData_ = WorldData;
    class Pig extends Internal.Animal implements Internal.ItemSteerable, Internal.Saddleable {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        thunderHit(arg0: Internal.ServerLevel_, arg1: Internal.LightningBolt_): void;
        travel(arg0: Vec3_): void;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): this;
        getStepHeight(): number;
        getDismountLocationForPassenger(arg0: Internal.LivingEntity_): Vec3;
        getControllingPassenger(): Internal.Entity;
        asKJS(): Internal.EntityJS;
        travelWithInput(arg0: Vec3_): void;
        travel(arg0: Internal.Mob_, arg1: Internal.ItemBasedSteering_, arg2: Vec3_): boolean;
        isFood(arg0: Internal.ItemStack_): boolean;
        boost(): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        equipSaddle(arg0: Internal.SoundSource_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getSteeringSpeed(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        isSaddled(): boolean;
        canBeControlledByRider(): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        getLeashOffset(): Vec3;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        isSaddleable(): boolean;
        get stepHeight(): number
        get controllingPassenger(): Internal.Entity
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get steeringSpeed(): number
        get saddled(): boolean
        get leashOffset(): Vec3
        get saddleable(): boolean
    }
    type Pig_ = Pig;
    interface GameSession {
        getGameMode(): string;
        isRemoteServer(): boolean;
        getSessionId(): Internal.UUID;
        getDifficulty(): string;
        getPlayerCount(): number;
        get gameMode(): string
        get remoteServer(): boolean
        get sessionId(): Internal.UUID
        get difficulty(): string
        get playerCount(): number
    }
    type GameSession_ = GameSession;
    interface ObjectSpliterator <K> extends Internal.Spliterator<K> {
        forEachRemaining(arg0: Internal.Consumer_<any>): void;
        trySplit(): Internal.Spliterator<any>;
        getComparator(): Internal.Comparator<any>;
        getExactSizeIfKnown(): number;
        hasCharacteristics(arg0: number): boolean;
        skip(arg0: number): number;
        get comparator(): Internal.Comparator<any>
        get exactSizeIfKnown(): number
    }
    type ObjectSpliterator_<K> = ObjectSpliterator<K>;
    abstract class TimeZone implements Internal.Cloneable, Internal.Serializable {
        constructor()
        getDisplayName(arg0: boolean, arg1: number): string;
        clone(): any;
        static getDefault(): Internal.TimeZone;
        setID(arg0: string): void;
        getDisplayName(arg0: Internal.Locale_): string;
        static getTimeZone(arg0: Internal.ZoneId_): Internal.TimeZone;
        getDisplayName(arg0: boolean, arg1: number, arg2: Internal.Locale_): string;
        static getAvailableIDs(arg0: number): string[];
        useDaylightTime(): boolean;
        inDaylightTime(arg0: Internal.Date_): boolean;
        getID(): string;
        getOffset(arg0: number): number;
        getRawOffset(): number;
        toZoneId(): Internal.ZoneId;
        hasSameRules(arg0: Internal.TimeZone_): boolean;
        getOffset(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): number;
        getDSTSavings(): number;
        setRawOffset(arg0: number): void;
        getDisplayName(): string;
        static getAvailableIDs(): string[];
        observesDaylightTime(): boolean;
        static setDefault(arg0: Internal.TimeZone_): void;
        static getTimeZone(arg0: string): Internal.TimeZone;
        get default(): Internal.TimeZone
        set ID(arg0: string)
        get ID(): string
        get rawOffset(): number
        get DSTSavings(): number
        set rawOffset(arg0: number)
        get displayName(): string
        get availableIDs(): string[]
        set default(arg0: Internal.TimeZone_)
        readonly static "LONG": 1;
        readonly static "SHORT": 0;
    }
    type TimeZone_ = TimeZone;
    interface Collection <E> extends Internal.Iterable<E> {
        add(arg0: E): boolean;
        forEach(arg0: Internal.Consumer_<any>): void;
        toArray(arg0: T[]): T[];
        remove(arg0: any): boolean;
        parallelStream(): Internal.Stream<E>;
        isEmpty(): boolean;
        toArray(): any[];
        iterator(): Internal.Iterator<E>;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        size(): number;
        hashCode(): number;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        stream(): Internal.Stream<E>;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        removeAll(arg0: Internal.Collection_<any>): boolean;
        clear(): void;
        addAll(arg0: Internal.Collection_<any>): boolean;
        spliterator(): Internal.Spliterator<E>;
        equals(arg0: any): boolean;
        contains(arg0: any): boolean;
        get empty(): boolean
    }
    type Collection_<E> = Collection<E>;
    class ServerboundSetCommandBlockPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: BlockPos_, arg1: string, arg2: Internal.CommandBlockEntity$Mode_, arg3: boolean, arg4: boolean, arg5: boolean)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        isTrackOutput(): boolean;
        getCommand(): string;
        isConditional(): boolean;
        getPos(): BlockPos;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        isAutomatic(): boolean;
        getMode(): Internal.CommandBlockEntity$Mode;
        isSkippable(): boolean;
        get trackOutput(): boolean
        get command(): string
        get conditional(): boolean
        get pos(): BlockPos
        get automatic(): boolean
        get mode(): Internal.CommandBlockEntity$Mode
        get skippable(): boolean
    }
    type ServerboundSetCommandBlockPacket_ = ServerboundSetCommandBlockPacket;
    interface Long2DoubleFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.LongToDoubleFunction {
        composeObject(arg0: Internal.Object2LongFunction_<any>): Internal.Object2DoubleFunction<T>;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2DoubleFunction;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): this;
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: number, arg1: number): number;
        get(arg0: any): number;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Long2IntFunction;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Long2FloatFunction;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2DoubleFunction;
        andThenReference(arg0: Internal.Double2ReferenceFunction_<any>): Internal.Long2ReferenceFunction<T>;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2DoubleFunction;
        get(arg0: number): number;
        remove(arg0: number): number;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2DoubleFunction;
        composeReference(arg0: Internal.Reference2LongFunction_<any>): Internal.Reference2DoubleFunction<T>;
        put(arg0: any, arg1: any): any;
        defaultReturnValue(arg0: number): void;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Long2ByteFunction;
        composeLong(arg0: Internal.Long2LongFunction_): this;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Long2ShortFunction;
        put(arg0: number, arg1: number): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Long2LongFunction;
        containsKey(arg0: number): boolean;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        applyAsDouble(arg0: number): number;
        put(arg0: number, arg1: number): number;
        defaultReturnValue(): number;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2DoubleFunction;
        size(): number;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Long2CharFunction;
        clear(): void;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2DoubleFunction;
        remove(arg0: any): any;
        andThenObject(arg0: Internal.Double2ObjectFunction_<any>): Internal.Long2ObjectFunction<T>;
        apply(arg0: number): number;
    }
    type Long2DoubleFunction_ = Long2DoubleFunction | ((arg0: number)=>number);
    class InputEvent$KeyInputEvent extends Internal.InputEvent {
        constructor()
        constructor(arg0: number, arg1: number, arg2: number, arg3: number)
        getKey(): number;
        getModifiers(): number;
        getListenerList(): Internal.ListenerList;
        getScanCode(): number;
        getAction(): number;
        get key(): number
        get modifiers(): number
        get listenerList(): Internal.ListenerList
        get scanCode(): number
        get action(): number
    }
    type InputEvent$KeyInputEvent_ = InputEvent$KeyInputEvent;
    class NioEventLoopGroup extends Internal.MultithreadEventLoopGroup {
        constructor()
        constructor(arg0: number, arg1: any_, arg2: any_)
        constructor(arg0: number, arg1: Internal.Executor_, arg2: any_, arg3: any_, arg4: any_, arg5: any_, arg6: any_, arg7: any_)
        constructor(arg0: number, arg1: Internal.Executor_, arg2: any_, arg3: any_, arg4: any_, arg5: any_, arg6: any_)
        constructor(arg0: number)
        constructor(arg0: any_)
        constructor(arg0: number, arg1: Internal.Executor_, arg2: any_, arg3: any_, arg4: any_, arg5: any_)
        constructor(arg0: number, arg1: Internal.Executor_, arg2: any_, arg3: any_)
        constructor(arg0: number, arg1: Internal.Executor_, arg2: any_)
        constructor(arg0: number, arg1: any_, arg2: any_, arg3: any_)
        constructor(arg0: number, arg1: Internal.Executor_)
        constructor(arg0: number, arg1: any_)
        constructor(arg0: number, arg1: Internal.Executor_, arg2: any_, arg3: any_, arg4: any_)
        forEach(arg0: Internal.Consumer_<any>): void;
        rebuildSelectors(): void;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        setIoRatio(arg0: number): void;
        set ioRatio(arg0: number)
    }
    type NioEventLoopGroup_ = NioEventLoopGroup;
    interface BinaryOperator <T> extends Internal.BiFunction<T, T, T> {
        andThen(arg0: Internal.Function_<any, any>): Internal.BiFunction<T, T, V>;
        maxBy(arg0: Internal.Comparator_<any>): this;
        minBy(arg0: Internal.Comparator_<any>): this;
    }
    type BinaryOperator_<T> = BinaryOperator<T>;
    abstract class Player extends Internal.LivingEntity implements Internal.PlayerKJS, Internal.IForgePlayer {
        constructor(arg0: Internal.Level_, arg1: BlockPos_, arg2: number, arg3: Internal.GameProfile_)
        openCommandBlock(arg0: Internal.CommandBlockEntity_): void;
        getProjectile(arg0: Internal.ItemStack_): Internal.ItemStack;
        jumpFromGround(): void;
        playSound(arg0: Internal.SoundEvent_, arg1: number, arg2: number): void;
        mayUseItemAt(arg0: BlockPos_, arg1: Internal.Direction_, arg2: Internal.ItemStack_): boolean;
        remove(arg0: Internal.Entity$RemovalReason_): void;
        interactOn(arg0: Internal.Entity_, arg1: Hand_): Internal.InteractionResult;
        setAbsorptionAmount(arg0: number): void;
        isAffectedByFluids(): boolean;
        getScore(): number;
        isPushedByFluid(): boolean;
        canInteractWith(arg0: BlockPos_, arg1: number): boolean;
        giveExperiencePoints(arg0: number): void;
        onUpdateAbilities(): void;
        getFoodData(): Internal.FoodData;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getRopeHoldPosition(arg0: number): Vec3;
        sendMerchantOffers(arg0: number, arg1: Internal.MerchantOffers_, arg2: number, arg3: number, arg4: boolean, arg5: boolean): void;
        getForcedPose(): Internal.Pose;
        killed(arg0: Internal.ServerLevel_, arg1: Internal.LivingEntity_): void;
        resetRecipes(arg0: Internal.Collection_<Internal.Recipe_<any>>): number;
        getMyRidingOffset(): number;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        playNotifySound(arg0: Internal.SoundEvent_, arg1: Internal.SoundSource_, arg2: number, arg3: number): void;
        resetStat(arg0: Internal.Stat_<any>): void;
        getAbilities(): Internal.Abilities;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getEnchantmentSeed(): number;
        alwaysAccepts(): boolean;
        die(arg0: Internal.DamageSource_): void;
        addItem(arg0: Internal.ItemStack_): boolean;
        awardRecipesByKey(arg0: ResourceLocation_[]): void;
        openItemGui(arg0: Internal.ItemStack_, arg1: Hand_): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        getAbsorptionAmount(): number;
        startFallFlying(): void;
        crit(arg0: Internal.Entity_): void;
        getDisplayName(): Internal.Component;
        displayClientMessage(arg0: Internal.Component_, arg1: boolean): void;
        static createPlayerUUID(arg0: string): Internal.UUID;
        setReducedDebugInfo(arg0: boolean): void;
        getAttackRange(): number;
        sweepAttack(): void;
        awardStat(arg0: ResourceLocation_, arg1: number): void;
        travel(arg0: Vec3_): void;
        canEat(arg0: boolean): boolean;
        getSlot(arg0: number): Internal.SlotAccess;
        closeContainer(): void;
        asKJS(): Internal.EntityJS;
        awardStat(arg0: Internal.Stat_<any>, arg1: number): void;
        shouldBeSaved(): boolean;
        openTextEdit(arg0: Internal.SignBlockEntity_): void;
        tryToStartFallFlying(): boolean;
        drop(arg0: Internal.ItemStack_, arg1: boolean, arg2: boolean): Internal.ItemEntity;
        causeFoodExhaustion(arg0: number): void;
        canRiderInteract(): boolean;
        setEntityOnShoulder(arg0: Internal.CompoundTag_): boolean;
        isScoping(): boolean;
        getShoulderEntityLeft(): Internal.CompoundTag;
        isCreative(): boolean;
        isSpectator(): boolean;
        attack(arg0: Internal.Entity_): void;
        giveExperienceLevels(arg0: number): void;
        getDimensions(arg0: Internal.Pose_): Internal.EntityDimensions;
        stopFallFlying(): void;
        shouldRiderSit(): boolean;
        openJigsawBlock(arg0: Internal.JigsawBlockEntity_): void;
        isSwimming(): boolean;
        static createPlayerUUID(arg0: Internal.GameProfile_): Internal.UUID;
        getReachDistance(): number;
        canTakeItem(arg0: Internal.ItemStack_): boolean;
        setForcedPose(arg0: Internal.Pose_): void;
        aiStep(): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getShoulderEntityRight(): Internal.CompoundTag;
        canHarmPlayer(arg0: Internal.Player_): boolean;
        openMenu(arg0: Internal.MenuProvider_): Internal.OptionalInt;
        getPortalWaitTime(): number;
        getItemBySlot(arg0: EquipmentSlot_): Internal.ItemStack;
        startAutoSpinAttack(arg0: number): void;
        stopSleeping(): void;
        getFallSounds(): Internal.LivingEntity$Fallsounds;
        getDimensionChangingDelay(): number;
        static createAttributes(): Internal.AttributeSupplier$Builder;
        onEnchantmentPerformed(arg0: Internal.ItemStack_, arg1: number): void;
        getInventory(): Internal.Inventory;
        getStepHeight(): number;
        isLocalPlayer(): boolean;
        setMainArm(arg0: Internal.HumanoidArm_): void;
        awardStat(arg0: Internal.Stat_<any>): void;
        getSleepTimer(): number;
        awardRecipes(arg0: Internal.Collection_<Internal.Recipe_<any>>): number;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getSuffixes(): Internal.Collection<Internal.MutableComponent>;
        getMainArm(): Internal.HumanoidArm;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        canInteractWith(arg0: Internal.Entity_, arg1: number): boolean;
        isCloseEnough(arg0: Internal.Entity_, arg1: number): boolean;
        getStages(): Internal.Stages;
        getCurrentItemAttackStrengthDelay(): number;
        getName(): Internal.Component;
        getEnderChestInventory(): Internal.PlayerEnderChestContainer;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        updateSwimming(): void;
        getDismountPoses(): Internal.ImmutableList<Internal.Pose>;
        magicCrit(arg0: Internal.Entity_): void;
        getSpeed(): number;
        getDestroySpeed(arg0: Internal.BlockState_): number;
        tick(): void;
        isInvulnerableTo(arg0: Internal.DamageSource_): boolean;
        setRemainingFireTicks(arg0: number): void;
        makeStuckInBlock(arg0: Internal.BlockState_, arg1: Vec3_): void;
        canUseGameMasterBlocks(): boolean;
        stopSleepInBed(arg0: boolean, arg1: boolean): void;
        getLuck(): number;
        increaseScore(arg0: number): void;
        rideTick(): void;
        isSleepingLongEnough(): boolean;
        awardStat(arg0: ResourceLocation_): void;
        getDigSpeed(arg0: Internal.BlockState_, arg1: BlockPos_): number;
        isReducedDebugInfo(): boolean;
        getStandingEyeHeight(arg0: Internal.Pose_, arg1: Internal.EntityDimensions_): number;
        shouldShowName(): boolean;
        getCapability(arg0: Internal.Capability_<T>, arg1: Internal.Direction_): Internal.LazyOptional<T>;
        getGameProfile(): Internal.GameProfile;
        getHandSlots(): Internal.Iterable<Internal.ItemStack>;
        setScore(arg0: number): void;
        getArmorSlots(): Internal.Iterable<Internal.ItemStack>;
        canHit(arg0: Internal.Entity_, arg1: number): boolean;
        canBeSeenAsEnemy(): boolean;
        openMinecartCommandBlock(arg0: Internal.BaseCommandBlock_): void;
        openStructureBlock(arg0: Internal.StructureBlockEntity_): void;
        getScoreboardName(): string;
        updateTutorialInventoryAction(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.ClickAction_): void;
        drop(arg0: Internal.ItemStack_, arg1: boolean): Internal.ItemEntity;
        getStagesRawKJS(): Internal.Stages;
        getSoundSource(): Internal.SoundSource;
        isSecondaryUseActive(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        getPrefixes(): Internal.Collection<Internal.MutableComponent>;
        checkMovementStatistics(arg0: number, arg1: number, arg2: number): void;
        getCooldowns(): Internal.ItemCooldowns;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        hasCorrectToolForDrops(arg0: Internal.BlockState_): boolean;
        isAlwaysTicking(): boolean;
        static findRespawnPositionAndUseSpawnBlock(arg0: Internal.ServerLevel_, arg1: BlockPos_, arg2: number, arg3: boolean, arg4: boolean): Internal.Optional<Vec3>;
        getXpNeededForNextLevel(): number;
        deserializeNBT(arg0: Internal.Tag_): void;
        openHorseInventory(arg0: Internal.AbstractHorse_, arg1: Internal.Container_): void;
        isModelPartShown(arg0: Internal.PlayerModelPart_): boolean;
        removeVehicle(): void;
        resetAttackStrengthTicker(): void;
        blockActionRestricted(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.GameType_): boolean;
        refreshDisplayName(): void;
        getScoreboard(): Internal.Scoreboard;
        getAttackStrengthScale(arg0: number): number;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        eat(arg0: Internal.Level_, arg1: Internal.ItemStack_): Internal.ItemStack;
        mayBuild(): boolean;
        respawn(): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        isHurt(): boolean;
        setItemSlot(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): void;
        disableShield(arg0: boolean): void;
        startSleepInBed(arg0: BlockPos_): Internal.Either<Internal.Player$BedSleepingProblem, net.minecraft.util.Unit>;
        set absorptionAmount(arg0: number)
        get affectedByFluids(): boolean
        get score(): number
        get pushedByFluid(): boolean
        get foodData(): Internal.FoodData
        get forcedPose(): Internal.Pose
        get myRidingOffset(): number
        get abilities(): Internal.Abilities
        get enchantmentSeed(): number
        get absorptionAmount(): number
        get displayName(): Internal.Component
        set reducedDebugInfo(arg0: boolean)
        get attackRange(): number
        set entityOnShoulder(arg0: Internal.CompoundTag_)
        get scoping(): boolean
        get shoulderEntityLeft(): Internal.CompoundTag
        get creative(): boolean
        get spectator(): boolean
        get swimming(): boolean
        get reachDistance(): number
        set forcedPose(arg0: Internal.Pose_)
        get shoulderEntityRight(): Internal.CompoundTag
        get portalWaitTime(): number
        get fallSounds(): Internal.LivingEntity$Fallsounds
        get dimensionChangingDelay(): number
        get inventory(): Internal.Inventory
        get stepHeight(): number
        get localPlayer(): boolean
        set mainArm(arg0: Internal.HumanoidArm_)
        get sleepTimer(): number
        get suffixes(): Internal.Collection<Internal.MutableComponent>
        get mainArm(): Internal.HumanoidArm
        get stages(): Internal.Stages
        get currentItemAttackStrengthDelay(): number
        get name(): Internal.Component
        get enderChestInventory(): Internal.PlayerEnderChestContainer
        get dismountPoses(): Internal.ImmutableList<Internal.Pose>
        get speed(): number
        set remainingFireTicks(arg0: number)
        get luck(): number
        get sleepingLongEnough(): boolean
        get reducedDebugInfo(): boolean
        get gameProfile(): Internal.GameProfile
        get handSlots(): Internal.Iterable<Internal.ItemStack>
        set score(arg0: number)
        get armorSlots(): Internal.Iterable<Internal.ItemStack>
        get scoreboardName(): string
        get stagesRawKJS(): Internal.Stages
        get soundSource(): Internal.SoundSource
        get secondaryUseActive(): boolean
        get multipartEntity(): boolean
        get prefixes(): Internal.Collection<Internal.MutableComponent>
        get cooldowns(): Internal.ItemCooldowns
        get parts(): Internal.PartEntity<any>[]
        get alwaysTicking(): boolean
        get xpNeededForNextLevel(): number
        get scoreboard(): Internal.Scoreboard
        get hurt(): boolean
        readonly static "MAX_HEALTH": 20;
        "fishing": Internal.FishingHook;
        readonly static "PERSISTED_NBT_TAG": "PlayerPersisted";
        "zCloak": number;
        readonly static "MAX_NAME_LENGTH": 16;
        readonly static "WAKE_UP_DURATION": 10;
        "bob": number;
        "experienceLevel": number;
        readonly static "CROUCH_BB_HEIGHT": 1.5;
        readonly static "ENDER_SLOT_OFFSET": 200;
        readonly static "SWIMMING_BB_HEIGHT": 0.6;
        readonly static "SWIMMING_BB_WIDTH": 0.6;
        "xCloakO": number;
        "totalExperience": number;
        "xCloak": number;
        "yCloakO": number;
        "zCloakO": number;
        readonly static "DEFAULT_EYE_HEIGHT": 1.62;
        "containerMenu": Internal.AbstractContainerMenu;
        "takeXpDelay": number;
        readonly static "UUID_PREFIX_OFFLINE_PLAYER": "OfflinePlayer:";
        readonly "inventoryMenu": Internal.InventoryMenu;
        readonly static "SLEEP_DURATION": 100;
        "experienceProgress": number;
        "oBob": number;
        "yCloak": number;
        readonly static "STANDING_DIMENSIONS": Internal.EntityDimensions;
    }
    type Player_ = Player;
    interface Reference2ReferenceFunction <K, V> extends it.unimi.dsi.fastutil.Function<K, V> {
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Reference2ShortFunction<K>;
        getOrDefault(arg0: any, arg1: V): V;
        composeReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Reference2ReferenceFunction<T, V>;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2ReferenceFunction<V>;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Reference2LongFunction<K>;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2ReferenceFunction<V>;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2ReferenceFunction<V>;
        containsKey(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        andThenObject(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Reference2ObjectFunction<K, T>;
        get(arg0: any): V;
        remove(arg0: any): V;
        composeObject(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Object2ReferenceFunction<T, V>;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2ReferenceFunction<V>;
        apply(arg0: K): V;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Reference2CharFunction<K>;
        andThenReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Reference2ReferenceFunction<K, T>;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2ReferenceFunction<V>;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, V>;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Reference2DoubleFunction<K>;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2ReferenceFunction<V>;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Reference2IntFunction<K>;
        size(): number;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Reference2FloatFunction<K>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, V>;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2ReferenceFunction<V>;
        clear(): void;
        defaultReturnValue(): V;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Reference2ByteFunction<K>;
        defaultReturnValue(arg0: V): void;
    }
    type Reference2ReferenceFunction_<K, V> = Reference2ReferenceFunction<K, V> | ((arg0: any)=>V);
    class ClassMember {
        merge(member: Internal.ClassMember_): void;
        toString(): string;
        set(obj: any, value: any): Internal.Possible<any>;
        invoke(sig: Internal.MethodSignature_, obj: any, args: any[]): Internal.Possible<any>;
        get(obj: any): Internal.Possible<any>;
        readonly "name": string;
        "methods": Internal.Map<Internal.MethodSignature, Internal.MethodInfo>;
        readonly "classData": Internal.ClassData;
        "field": Internal.Field;
        "beanGet": Internal.MethodInfo;
        "beanSet": Internal.MethodInfo;
        "isFinal": boolean;
    }
    type ClassMember_ = ClassMember;
    interface Reference2DoubleFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToDoubleFunction<K> {
        put(arg0: K, arg1: number): number;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2DoubleFunction;
        getOrDefault(arg0: any, arg1: any): any;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2DoubleFunction;
        andThenObject(arg0: Internal.Double2ObjectFunction_<any>): Internal.Reference2ObjectFunction<K, T>;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Reference2LongFunction<K>;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Reference2CharFunction<K>;
        containsKey(arg0: any): boolean;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): this;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Reference2ByteFunction<K>;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2DoubleFunction;
        put(arg0: any, arg1: any): any;
        defaultReturnValue(arg0: number): void;
        applyAsDouble(arg0: K): number;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2DoubleFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        remove(arg0: any): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Reference2ShortFunction<K>;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2DoubleFunction;
        removeDouble(arg0: any): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        defaultReturnValue(): number;
        apply(arg0: K): number;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2DoubleFunction;
        composeReference(arg0: Internal.Reference2ReferenceFunction_<any, any>): Internal.Reference2DoubleFunction<T>;
        size(): number;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Reference2FloatFunction<K>;
        andThenReference(arg0: Internal.Double2ReferenceFunction_<any>): Internal.Reference2ReferenceFunction<K, T>;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2DoubleFunction;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Reference2IntFunction<K>;
        clear(): void;
        getOrDefault(arg0: any, arg1: number): number;
        getDouble(arg0: any): number;
        put(arg0: K, arg1: number): number;
        get(arg0: any): any;
        composeObject(arg0: Internal.Object2ReferenceFunction_<any, any>): Internal.Object2DoubleFunction<T>;
    }
    type Reference2DoubleFunction_<K> = Reference2DoubleFunction<K> | ((arg0: any)=>number);
    class Commands$CommandSelection extends Internal.Enum<Internal.Commands$CommandSelection> {
        static values(): Internal.Commands$CommandSelection[];
        static valueOf(arg0: string): Internal.Commands$CommandSelection;
        readonly static "DEDICATED": Internal.Commands$CommandSelection;
        readonly "includeDedicated": boolean;
        readonly static "INTEGRATED": Internal.Commands$CommandSelection;
        readonly static "ALL": Internal.Commands$CommandSelection;
        readonly "includeIntegrated": boolean;
    }
    type Commands$CommandSelection_ = "dedicated" | "integrated" | Commands$CommandSelection | "all";
    interface Temporal extends Internal.TemporalAccessor {
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        plus(arg0: Internal.TemporalAmount_): this;
        get(arg0: Internal.TemporalField_): number;
        with(arg0: Internal.TemporalAdjuster_): this;
        plus(arg0: number, arg1: Internal.TemporalUnit_): this;
        query(arg0: Internal.TemporalQuery_<R>): R;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        minus(arg0: Internal.TemporalAmount_): this;
        minus(arg0: number, arg1: Internal.TemporalUnit_): this;
        with(arg0: Internal.TemporalField_, arg1: number): this;
    }
    type Temporal_ = Temporal;
    interface Int2IntMap extends Internal.Int2IntFunction, Internal.Map<number, number> {
        containsValue(arg0: any): boolean;
        defaultReturnValue(): number;
        remove(arg0: number): number;
        putIfAbsent(arg0: number, arg1: number): number;
        containsKey(arg0: number): boolean;
        replace(arg0: number, arg1: number, arg2: number): boolean;
        remove(arg0: number, arg1: number): boolean;
        keySet(): Internal.Set<any>;
        putIfAbsent(arg0: number, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        replace(arg0: any, arg1: any, arg2: any): boolean;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        applyAsInt(arg0: number): number;
        put(arg0: any, arg1: any): any;
        values(): Internal.Collection<any>;
        computeIfAbsentNullable(arg0: number, arg1: Internal.IntFunction_<any>): number;
        getOrDefault(arg0: any, arg1: number): number;
        put(arg0: number, arg1: number): number;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<any, any, any>): number;
        computeIfAbsent(arg0: any, arg1: Internal.Function_<any, any>): any;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Int2LongFunction;
        andThenObject(arg0: Internal.Int2ObjectFunction_<any>): Internal.Int2ObjectFunction<T>;
        andThenReference(arg0: Internal.Int2ReferenceFunction_<any>): Internal.Int2ReferenceFunction<T>;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Int2ShortFunction;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        merge(arg0: number, arg1: number, arg2: Internal.BiFunction_<any, any, any>): number;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2IntFunction;
        remove(arg0: any): any;
        compute(arg0: any, arg1: Internal.BiFunction_<any, any, any>): any;
        putIfAbsent(arg0: any, arg1: any): any;
        computeIfAbsentPartial(arg0: number, arg1: Internal.Int2IntFunction_): number;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2IntFunction;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Int2FloatFunction;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2IntFunction;
        getOrDefault(arg0: any, arg1: any): any;
        compute(arg0: number, arg1: Internal.BiFunction_<any, any, any>): number;
        apply(arg0: number): number;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        replace(arg0: number, arg1: number): number;
        int2IntEntrySet(): Internal.ObjectSet<Internal.Int2IntMap$Entry>;
        computeIfAbsent(arg0: number, arg1: Internal.Int2IntFunction_): number;
        replace(arg0: number, arg1: number, arg2: number): boolean;
        containsKey(arg0: any): boolean;
        replaceAll(arg0: Internal.BiFunction_<any, any, any>): void;
        mergeInt(arg0: number, arg1: number, arg2: it.unimi.dsi.fastutil.ints.IntBinaryOperator_): number;
        containsValue(arg0: number): boolean;
        compute(arg0: number, arg1: Internal.BiFunction_<any, any, any>): number;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<any, any, any>): number;
        composeObject(arg0: Internal.Object2IntFunction_<any>): Internal.Object2IntFunction<T>;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Int2ByteFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2IntFunction;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Int2DoubleFunction;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, number>>;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2IntFunction;
        composeReference(arg0: Internal.Reference2IntFunction_<any>): Internal.Reference2IntFunction<T>;
        computeIfAbsent(arg0: number, arg1: Internal.Function_<any, any>): number;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2IntFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        andThenInt(arg0: Internal.Int2IntFunction_): Internal.Int2IntFunction;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Int2CharFunction;
        put(arg0: number, arg1: number): number;
        remove(arg0: any, arg1: any): boolean;
        replace(arg0: number, arg1: number): number;
        size(): number;
        computeIfAbsent(arg0: number, arg1: Internal.IntUnaryOperator_): number;
        defaultReturnValue(arg0: number): void;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2IntFunction;
        clear(): void;
        replace(arg0: any, arg1: any): any;
        merge(arg0: number, arg1: number, arg2: Internal.BiFunction_<any, any, any>): number;
        merge(arg0: any, arg1: any, arg2: Internal.BiFunction_<any, any, any>): any;
        mergeInt(arg0: number, arg1: number, arg2: Internal.IntBinaryOperator_): number;
        get(arg0: any): any;
        computeIfPresent(arg0: any, arg1: Internal.BiFunction_<any, any, any>): any;
    }
    type Int2IntMap_ = Int2IntMap;
    class BufferBuilder$SortState {
    }
    type BufferBuilder$SortState_ = BufferBuilder$SortState;
    interface EntityGetter {
        players(): Internal.List<any>;
        getEntities(arg0: Internal.Entity_, arg1: Internal.AABB_, arg2: Internal.Predicate_<any>): Internal.List<Internal.Entity>;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_): Internal.Player;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Predicate_<Internal.Entity_>): Internal.Player;
        getNearestEntity(arg0: Internal.Class_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number, arg6: Internal.AABB_): T;
        getEntities(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.Entity>;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_): Internal.List<T>;
        isUnobstructed(arg0: Internal.Entity_, arg1: Internal.VoxelShape_): boolean;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: number, arg2: number, arg3: number): Internal.Player;
        getNearbyEntities(arg0: Internal.Class_<T>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: Internal.AABB_): Internal.List<T>;
        getEntitiesOfClass(arg0: Internal.Class_<T>, arg1: Internal.AABB_, arg2: Internal.Predicate_<any>): Internal.List<T>;
        getNearestEntity(arg0: Internal.List_<any>, arg1: Internal.TargetingConditions_, arg2: Internal.LivingEntity_, arg3: number, arg4: number, arg5: number): T;
        getNearestPlayer(arg0: Internal.Entity_, arg1: number): Internal.Player;
        getPlayerByUUID(arg0: Internal.UUID_): Internal.Player;
        getEntities(arg0: Internal.EntityTypeTest_<Internal.Entity_, T>, arg1: Internal.AABB_, arg2: Internal.Predicate_<any>): Internal.List<T>;
        hasNearbyAlivePlayer(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getNearbyPlayers(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: Internal.AABB_): Internal.List<Internal.Player>;
        getEntityCollisions(arg0: Internal.Entity_, arg1: Internal.AABB_): Internal.List<Internal.VoxelShape>;
        getNearestPlayer(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): Internal.Player;
        getNearestPlayer(arg0: Internal.TargetingConditions_, arg1: Internal.LivingEntity_, arg2: number, arg3: number, arg4: number): Internal.Player;
    }
    type EntityGetter_ = EntityGetter;
    class ClientboundResourcePackPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: string, arg1: string, arg2: boolean, arg3: Internal.Component_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        getPrompt(): Internal.Component;
        write(arg0: Internal.FriendlyByteBuf_): void;
        isRequired(): boolean;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        getUrl(): string;
        getHash(): string;
        isSkippable(): boolean;
        get prompt(): Internal.Component
        get required(): boolean
        get url(): string
        get hash(): string
        get skippable(): boolean
        readonly static "MAX_HASH_LENGTH": 40;
    }
    type ClientboundResourcePackPacket_ = ClientboundResourcePackPacket;
    class PushReaction extends Internal.Enum<Internal.PushReaction> {
        static values(): Internal.PushReaction[];
        static valueOf(arg0: string): Internal.PushReaction;
        readonly static "BLOCK": Internal.PushReaction;
        readonly static "NORMAL": Internal.PushReaction;
        readonly static "PUSH_ONLY": Internal.PushReaction;
        readonly static "DESTROY": Internal.PushReaction;
        readonly static "IGNORE": Internal.PushReaction;
    }
    type PushReaction_ = "push_only" | "normal" | "block" | "ignore" | PushReaction | "destroy";
    class Team$CollisionRule extends Internal.Enum<Internal.Team$CollisionRule> {
        getDisplayName(): Internal.Component;
        static byName(arg0: string): Internal.Team$CollisionRule;
        static values(): Internal.Team$CollisionRule[];
        static valueOf(arg0: string): Internal.Team$CollisionRule;
        get displayName(): Internal.Component
        readonly static "PUSH_OTHER_TEAMS": Internal.Team$CollisionRule;
        readonly "name": string;
        readonly static "ALWAYS": Internal.Team$CollisionRule;
        readonly "id": number;
        readonly static "NEVER": Internal.Team$CollisionRule;
        readonly static "PUSH_OWN_TEAM": Internal.Team$CollisionRule;
    }
    type Team$CollisionRule_ = "push_own_team" | Team$CollisionRule | "push_other_teams" | "never" | "always";
    class ArmorStand extends Internal.LivingEntity {
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        setLeftLegPose(arg0: Internal.Rotations_): void;
        getFallSounds(): Internal.LivingEntity$Fallsounds;
        isMarker(): boolean;
        setRightArmPose(arg0: Internal.Rotations_): void;
        getHeadPose(): Internal.Rotations;
        attackable(): boolean;
        isAffectedByPotions(): boolean;
        getStepHeight(): number;
        isEffectiveAi(): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getMainArm(): Internal.HumanoidArm;
        setLeftArmPose(arg0: Internal.Rotations_): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getLightProbePosition(arg0: number): Vec3;
        shouldRenderAtSqrDistance(arg0: number): boolean;
        refreshDimensions(): void;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        setInvisible(arg0: boolean): void;
        getMyRidingOffset(): number;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        getLeftLegPose(): Internal.Rotations;
        isNoBasePlate(): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isPickable(): boolean;
        isBaby(): boolean;
        tick(): void;
        skipAttackInteraction(arg0: Internal.Entity_): boolean;
        setYHeadRot(arg0: number): void;
        getRightArmPose(): Internal.Rotations;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        setBodyPose(arg0: Internal.Rotations_): void;
        getPickResult(): Internal.ItemStack;
        foodEatenKJS(is: Internal.ItemStack_): void;
        getRightLegPose(): Internal.Rotations;
        isSmall(): boolean;
        getHandSlots(): Internal.Iterable<Internal.ItemStack>;
        getArmorSlots(): Internal.Iterable<Internal.ItemStack>;
        thunderHit(arg0: Internal.ServerLevel_, arg1: Internal.LightningBolt_): void;
        travel(arg0: Vec3_): void;
        kill(): void;
        getBodyPose(): Internal.Rotations;
        ignoreExplosion(): boolean;
        asKJS(): Internal.EntityJS;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        getDimensions(arg0: Internal.Pose_): Internal.EntityDimensions;
        getPistonPushReaction(): Internal.PushReaction;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        isShowArms(): boolean;
        canTakeItem(arg0: Internal.ItemStack_): boolean;
        interactAt(arg0: Internal.Player_, arg1: Vec3_, arg2: Hand_): Internal.InteractionResult;
        deserializeNBT(arg0: Internal.Tag_): void;
        setRightLegPose(arg0: Internal.Rotations_): void;
        getItemBySlot(arg0: EquipmentSlot_): Internal.ItemStack;
        getLeftArmPose(): Internal.Rotations;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        canBeSeenByAnyone(): boolean;
        setYBodyRot(arg0: number): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        isPushable(): boolean;
        setItemSlot(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): void;
        setHeadPose(arg0: Internal.Rotations_): void;
        set leftLegPose(arg0: Internal.Rotations_)
        get fallSounds(): Internal.LivingEntity$Fallsounds
        get marker(): boolean
        set rightArmPose(arg0: Internal.Rotations_)
        get headPose(): Internal.Rotations
        get affectedByPotions(): boolean
        get stepHeight(): number
        get effectiveAi(): boolean
        get mainArm(): Internal.HumanoidArm
        set leftArmPose(arg0: Internal.Rotations_)
        set invisible(arg0: boolean)
        get myRidingOffset(): number
        get leftLegPose(): Internal.Rotations
        get noBasePlate(): boolean
        get pickable(): boolean
        get baby(): boolean
        set YHeadRot(arg0: number)
        get rightArmPose(): Internal.Rotations
        set bodyPose(arg0: Internal.Rotations_)
        get pickResult(): Internal.ItemStack
        get rightLegPose(): Internal.Rotations
        get small(): boolean
        get handSlots(): Internal.Iterable<Internal.ItemStack>
        get armorSlots(): Internal.Iterable<Internal.ItemStack>
        get bodyPose(): Internal.Rotations
        get multipartEntity(): boolean
        get pistonPushReaction(): Internal.PushReaction
        get parts(): Internal.PartEntity<any>[]
        get showArms(): boolean
        set rightLegPose(arg0: Internal.Rotations_)
        get leftArmPose(): Internal.Rotations
        set YBodyRot(arg0: number)
        get pushable(): boolean
        set headPose(arg0: Internal.Rotations_)
        readonly static "CLIENT_FLAG_NO_BASEPLATE": 8;
        readonly static "DISABLE_PUTTING_OFFSET": 16;
        readonly static "DATA_RIGHT_ARM_POSE": Internal.EntityDataAccessor<any>;
        readonly static "CLIENT_FLAG_SMALL": 1;
        readonly static "DATA_LEFT_ARM_POSE": Internal.EntityDataAccessor<any>;
        "lastHit": number;
        readonly static "DATA_HEAD_POSE": Internal.EntityDataAccessor<any>;
        readonly static "DATA_RIGHT_LEG_POSE": Internal.EntityDataAccessor<any>;
        readonly static "CLIENT_FLAG_MARKER": 16;
        readonly static "DISABLE_TAKING_OFFSET": 8;
        readonly static "CLIENT_FLAG_SHOW_ARMS": 4;
        readonly static "DATA_CLIENT_FLAGS": Internal.EntityDataAccessor<any>;
        readonly static "WOBBLE_TIME": 5;
        readonly static "DATA_LEFT_LEG_POSE": Internal.EntityDataAccessor<any>;
        readonly static "DATA_BODY_POSE": Internal.EntityDataAccessor<any>;
    }
    type ArmorStand_ = ArmorStand;
    class LootContextParamSet {
        getAllowed(): Internal.Set<Internal.LootContextParam<any>>;
        getRequired(): Internal.Set<Internal.LootContextParam<any>>;
        toString(): string;
        static builder(): Internal.LootContextParamSet$Builder;
        isAllowed(arg0: Internal.LootContextParam_<any>): boolean;
        validateUser(arg0: Internal.ValidationContext_, arg1: Internal.LootContextUser_): void;
        get allowed(): Internal.Set<Internal.LootContextParam<any>>
        get required(): Internal.Set<Internal.LootContextParam<any>>
    }
    type LootContextParamSet_ = LootContextParamSet;
    class VillagerType {
        constructor(arg0: string)
        toString(): string;
        static byBiome(arg0: Internal.Holder_<Internal.Biome_>): Internal.VillagerType;
        readonly static "SNOW": Internal.VillagerType;
        readonly static "SAVANNA": Internal.VillagerType;
        readonly static "SWAMP": Internal.VillagerType;
        readonly static "JUNGLE": Internal.VillagerType;
        readonly static "TAIGA": Internal.VillagerType;
        readonly static "PLAINS": Internal.VillagerType;
        readonly static "DESERT": Internal.VillagerType;
    }
    type VillagerType_ = VillagerType | Special.VillagerType;
    abstract class LevelEventJS extends Internal.EventJS {
        constructor()
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        getLevel(): Internal.LevelJS;
        getServer(): Internal.ServerJS;
        get level(): Internal.LevelJS
        get server(): Internal.ServerJS
    }
    type LevelEventJS_ = LevelEventJS;
    interface ReadableByteChannel extends Internal.Channel {
        read(arg0: Internal.ByteBuffer_): number;
    }
    type ReadableByteChannel_ = ReadableByteChannel;
    class PlantType {
        getName(): string;
        static get(arg0: string): Internal.PlantType;
        get name(): string
        readonly static "NETHER": Internal.PlantType;
        readonly static "BEACH": Internal.PlantType;
        readonly static "CROP": Internal.PlantType;
        readonly static "WATER": Internal.PlantType;
        readonly static "PLAINS": Internal.PlantType;
        readonly static "CAVE": Internal.PlantType;
        readonly static "DESERT": Internal.PlantType;
    }
    type PlantType_ = PlantType;
    interface CraftingRecipe extends Internal.Recipe<Internal.CraftingContainer> {
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        isSpecial(): boolean;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        isIncomplete(): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get special(): boolean
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get incomplete(): boolean
    }
    type CraftingRecipe_ = CraftingRecipe;
    class DragonFireball extends Internal.AbstractHurtingProjectile {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        constructor(arg0: Internal.Level_, arg1: Internal.LivingEntity_, arg2: number, arg3: number, arg4: number)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        isPickable(): boolean;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        get pickable(): boolean
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        readonly static "SPLASH_RANGE": 4.0;
    }
    type DragonFireball_ = DragonFireball;
    abstract class DimensionSpecialEffects {
        constructor(arg0: number, arg1: boolean, arg2: Internal.DimensionSpecialEffects$SkyType_, arg3: boolean, arg4: boolean)
        forceBrightLightmap(): boolean;
        getWeatherRenderHandler(): Internal.IWeatherRenderHandler;
        isFoggyAt(arg0: number, arg1: number): boolean;
        setCloudRenderHandler(arg0: Internal.ICloudRenderHandler_): void;
        static forType(arg0: Internal.DimensionType_): Internal.DimensionSpecialEffects;
        getCloudHeight(): number;
        getWeatherParticleRenderHandler(): Internal.IWeatherParticleRenderHandler;
        skyType(): Internal.DimensionSpecialEffects$SkyType;
        setSkyRenderHandler(arg0: Internal.ISkyRenderHandler_): void;
        setWeatherParticleRenderHandler(arg0: Internal.IWeatherParticleRenderHandler_): void;
        getCloudRenderHandler(): Internal.ICloudRenderHandler;
        hasGround(): boolean;
        getSunriseColor(arg0: number, arg1: number): number[];
        constantAmbientLight(): boolean;
        setWeatherRenderHandler(arg0: Internal.IWeatherRenderHandler_): void;
        getBrightnessDependentFogColor(arg0: Vec3_, arg1: number): Vec3;
        getSkyRenderHandler(): Internal.ISkyRenderHandler;
        get weatherRenderHandler(): Internal.IWeatherRenderHandler
        set cloudRenderHandler(arg0: Internal.ICloudRenderHandler_)
        get cloudHeight(): number
        get weatherParticleRenderHandler(): Internal.IWeatherParticleRenderHandler
        set skyRenderHandler(arg0: Internal.ISkyRenderHandler_)
        set weatherParticleRenderHandler(arg0: Internal.IWeatherParticleRenderHandler_)
        get cloudRenderHandler(): Internal.ICloudRenderHandler
        set weatherRenderHandler(arg0: Internal.IWeatherRenderHandler_)
        get skyRenderHandler(): Internal.ISkyRenderHandler
    }
    type DimensionSpecialEffects_ = DimensionSpecialEffects;
    abstract class AbstractMap <K, V> implements Internal.Map<K, V> {
        replace(arg0: K, arg1: V): V;
        containsValue(arg0: any): boolean;
        getOrDefault(arg0: any, arg1: V): V;
        putAll(arg0: Internal.Map_<any, any>): void;
        isEmpty(): boolean;
        containsKey(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        replaceAll(arg0: Internal.BiFunction_<any, any, any>): void;
        get(arg0: any): V;
        remove(arg0: any): V;
        compute(arg0: K, arg1: Internal.BiFunction_<any, any, any>): V;
        merge(arg0: K, arg1: V, arg2: Internal.BiFunction_<any, any, any>): V;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<any, any, any>): V;
        keySet(): Internal.Set<K>;
        putIfAbsent(arg0: K, arg1: V): V;
        toString(): string;
        values(): Internal.Collection<V>;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        remove(arg0: any, arg1: any): boolean;
        computeIfAbsent(arg0: K, arg1: Internal.Function_<any, any>): V;
        hashCode(): number;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        size(): number;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        clear(): void;
        equals(arg0: any): boolean;
        get empty(): boolean
    }
    type AbstractMap_<K, V> = AbstractMap<K, V>;
    class ClientPlayerNetworkEvent extends Internal.Event {
        constructor()
        getMultiPlayerGameMode(): Internal.MultiPlayerGameMode;
        getListenerList(): Internal.ListenerList;
        getConnection(): Internal.Connection;
        getPlayer(): Internal.LocalPlayer;
        get multiPlayerGameMode(): Internal.MultiPlayerGameMode
        get listenerList(): Internal.ListenerList
        get connection(): Internal.Connection
        get player(): Internal.LocalPlayer
    }
    type ClientPlayerNetworkEvent_ = ClientPlayerNetworkEvent;
    interface ValueUnwrapper {
        unwrap(arg0: Internal.SharedContextData_, arg1: Internal.Scriptable_, arg2: any): any;
        readonly static "DEFAULT": any;
    }
    type ValueUnwrapper_ = ValueUnwrapper | ((arg0: Internal.SharedContextData, arg1: Internal.Scriptable, arg2: any)=>any);
    interface RecipeManagerAccessor {
        getContext(): Internal.ICondition$IContext;
        get context(): Internal.ICondition$IContext
    }
    type RecipeManagerAccessor_ = RecipeManagerAccessor;
    class MapRenderer implements Internal.AutoCloseable {
        constructor(arg0: Internal.TextureManager_)
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource_, arg2: number, arg3: Internal.MapItemSavedData_, arg4: boolean, arg5: number): void;
        close(): void;
        resetData(): void;
        update(arg0: number, arg1: Internal.MapItemSavedData_): void;
    }
    type MapRenderer_ = MapRenderer;
    interface Boolean2FloatFunction extends it.unimi.dsi.fastutil.Function<boolean, number> {
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2FloatFunction;
        apply(arg0: boolean): number;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2FloatFunction;
        get(arg0: any): number;
        getOrDefault(arg0: any, arg1: any): any;
        composeObject(arg0: Internal.Object2BooleanFunction_<any>): Internal.Object2FloatFunction<T>;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2FloatFunction;
        put(arg0: boolean, arg1: number): number;
        defaultReturnValue(arg0: number): void;
        andThenFloat(arg0: Internal.Float2FloatFunction_): this;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Boolean2DoubleFunction;
        containsKey(arg0: any): boolean;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2FloatFunction;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2FloatFunction;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Boolean2CharFunction;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2FloatFunction;
        put(arg0: any, arg1: any): any;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, number>;
        defaultReturnValue(): number;
        remove(arg0: any): number;
        composeReference(arg0: Internal.Reference2BooleanFunction_<any>): Internal.Reference2FloatFunction<T>;
        remove(arg0: boolean): number;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Boolean2ByteFunction;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2FloatFunction;
        andThenReference(arg0: Internal.Float2ReferenceFunction_<any>): Internal.Boolean2ReferenceFunction<T>;
        getOrDefault(arg0: any, arg1: number): number;
        containsKey(arg0: boolean): boolean;
        andThenObject(arg0: Internal.Float2ObjectFunction_<any>): Internal.Boolean2ObjectFunction<T>;
        size(): number;
        get(arg0: boolean): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<boolean, T>;
        clear(): void;
        getOrDefault(arg0: boolean, arg1: number): number;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Boolean2LongFunction;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Boolean2ShortFunction;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Boolean2IntFunction;
        put(arg0: boolean, arg1: number): number;
    }
    type Boolean2FloatFunction_ = Boolean2FloatFunction | ((arg0: boolean)=>number);
    interface FunctionFactory$Arg3 extends Internal.FunctionFactory$FuncSupplier {
        create(args: Internal.Unit_[]): Internal.Unit;
        createArg(arg0: Internal.Unit_, arg1: Internal.Unit_, arg2: Internal.Unit_): Internal.Unit;
    }
    type FunctionFactory$Arg3_ = FunctionFactory$Arg3 | ((arg0: Internal.Unit, arg1: Internal.Unit, arg2: Internal.Unit)=>Internal.Unit_);
    interface IngredientJS extends Internal.Copyable, Internal.JsonSerializable, Internal.WrappedJS {
        getVanillaItems(): Internal.Set<Internal.Item>;
        x(c: number): this;
        getCount(): number;
        isInvalidRecipeIngredient(): boolean;
        getStacks(): Internal.Set<Internal.ItemStackJS>;
        asIngredientStack(): Internal.IngredientStackJS;
        getItemIds(): Internal.Set<string>;
        copy(): Internal.Copyable;
        test(arg0: Internal.ItemStackJS_): boolean;
        isEmpty(): boolean;
        toJson(): Internal.JsonElement;
        testVanillaItem(item: Internal.Item_): boolean;
        filter(filter: Internal.IngredientJS_): this;
        not(): this;
        of(o: any): this;
        anyStackMatches(ingredient: Internal.IngredientJS_): boolean;
        createVanillaIngredient(): Internal.Ingredient;
        ingredientFromRecipeJson(json: Internal.JsonElement_): this;
        getVanillaPredicate(): Internal.Predicate<Internal.ItemStack>;
        getFirst(): Internal.ItemStackJS;
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>;
        withCount(count: number): this;
        testVanilla(stack: Internal.ItemStack_): boolean;
        get vanillaItems(): Internal.Set<Internal.Item>
        get count(): number
        get invalidRecipeIngredient(): boolean
        get stacks(): Internal.Set<Internal.ItemStackJS>
        get itemIds(): Internal.Set<string>
        get empty(): boolean
        get vanillaPredicate(): Internal.Predicate<Internal.ItemStack>
        get first(): Internal.ItemStackJS
    }
    type IngredientJS_ = IngredientJS | ((arg0: Internal.ItemStackJS)=>boolean);
    class ClientAdvancements {
        constructor(arg0: Internal.Minecraft_)
        setSelectedTab(arg0: Internal.Advancement_, arg1: boolean): void;
        setListener(arg0: Internal.ClientAdvancements$Listener_): void;
        getAdvancements(): Internal.AdvancementList;
        update(arg0: Internal.ClientboundUpdateAdvancementsPacket_): void;
        set listener(arg0: Internal.ClientAdvancements$Listener_)
        get advancements(): Internal.AdvancementList
    }
    type ClientAdvancements_ = ClientAdvancements;
    interface ParticleOptions {
        getType(): Internal.ParticleType<any>;
        writeToString(): string;
        writeToNetwork(arg0: Internal.FriendlyByteBuf_): void;
        get type(): Internal.ParticleType<any>
    }
    type ParticleOptions_ = ParticleOptions;
    class RandomOffsetPlacement extends Internal.PlacementModifier {
        static vertical(arg0: Internal.IntProvider_): Internal.RandomOffsetPlacement;
        static of(arg0: Internal.IntProvider_, arg1: Internal.IntProvider_): Internal.RandomOffsetPlacement;
        type(): Internal.PlacementModifierType<any>;
        getPositions(arg0: Internal.PlacementContext_, arg1: Internal.Random_, arg2: BlockPos_): Internal.Stream<BlockPos>;
        static horizontal(arg0: Internal.IntProvider_): Internal.RandomOffsetPlacement;
        readonly static "CODEC": any;
    }
    type RandomOffsetPlacement_ = RandomOffsetPlacement;
    class InetAddress implements Internal.Serializable {
        isSiteLocalAddress(): boolean;
        isLinkLocalAddress(): boolean;
        static getLocalHost(): Internal.InetAddress;
        isAnyLocalAddress(): boolean;
        static getByAddress(arg0: string, arg1: number[]): Internal.InetAddress;
        getHostAddress(): string;
        isMCNodeLocal(): boolean;
        isMCGlobal(): boolean;
        getCanonicalHostName(): string;
        static getAllByName(arg0: string): Internal.InetAddress[];
        getHostName(): string;
        isMCOrgLocal(): boolean;
        static getByName(arg0: string): Internal.InetAddress;
        static getLoopbackAddress(): Internal.InetAddress;
        isMulticastAddress(): boolean;
        toString(): string;
        isReachable(arg0: number): boolean;
        isMCLinkLocal(): boolean;
        isReachable(arg0: Internal.NetworkInterface_, arg1: number, arg2: number): boolean;
        isLoopbackAddress(): boolean;
        isMCSiteLocal(): boolean;
        hashCode(): number;
        static getByAddress(arg0: number[]): Internal.InetAddress;
        equals(arg0: any): boolean;
        getAddress(): number[];
        get siteLocalAddress(): boolean
        get linkLocalAddress(): boolean
        get localHost(): Internal.InetAddress
        get anyLocalAddress(): boolean
        get hostAddress(): string
        get MCNodeLocal(): boolean
        get MCGlobal(): boolean
        get canonicalHostName(): string
        get hostName(): string
        get MCOrgLocal(): boolean
        get loopbackAddress(): Internal.InetAddress
        get multicastAddress(): boolean
        get MCLinkLocal(): boolean
        get loopbackAddress(): boolean
        get MCSiteLocal(): boolean
        get address(): number[]
    }
    type InetAddress_ = InetAddress;
    interface Short2BooleanFunction extends it.unimi.dsi.fastutil.Function<number, boolean>, Internal.IntPredicate {
        apply(arg0: number): boolean;
        getOrDefault(arg0: number, arg1: boolean): boolean;
        remove(arg0: number): boolean;
        getOrDefault(arg0: any, arg1: any): any;
        or(arg0: Internal.IntPredicate_): Internal.IntPredicate;
        negate(): Internal.IntPredicate;
        andThenReference(arg0: Internal.Boolean2ReferenceFunction_<any>): Internal.Short2ReferenceFunction<T>;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Short2ByteFunction;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2BooleanFunction;
        containsKey(arg0: any): boolean;
        composeReference(arg0: Internal.Reference2ShortFunction_<any>): Internal.Reference2BooleanFunction<T>;
        get(arg0: any): boolean;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2BooleanFunction;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2BooleanFunction;
        put(arg0: any, arg1: any): any;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Short2LongFunction;
        defaultReturnValue(): boolean;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Short2DoubleFunction;
        get(arg0: number): boolean;
        and(arg0: Internal.IntPredicate_): Internal.IntPredicate;
        composeObject(arg0: Internal.Object2ShortFunction_<any>): Internal.Object2BooleanFunction<T>;
        andThenObject(arg0: Internal.Boolean2ObjectFunction_<any>): Internal.Short2ObjectFunction<T>;
        put(arg0: number, arg1: boolean): boolean;
        getOrDefault(arg0: any, arg1: boolean): boolean;
        containsKey(arg0: number): boolean;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2BooleanFunction;
        test(arg0: number): boolean;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Short2ShortFunction;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2BooleanFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, boolean>;
        put(arg0: number, arg1: boolean): boolean;
        size(): number;
        clear(): void;
        remove(arg0: any): any;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Short2FloatFunction;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2BooleanFunction;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Short2IntFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, T>;
        composeShort(arg0: Internal.Short2ShortFunction_): this;
        defaultReturnValue(arg0: boolean): void;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Short2CharFunction;
    }
    type Short2BooleanFunction_ = Short2BooleanFunction | ((arg0: number)=>boolean);
    class ServerboundPlayerCommandPacket$Action extends Internal.Enum<Internal.ServerboundPlayerCommandPacket$Action> {
        static values(): Internal.ServerboundPlayerCommandPacket$Action[];
        static valueOf(arg0: string): Internal.ServerboundPlayerCommandPacket$Action;
        readonly static "START_SPRINTING": Internal.ServerboundPlayerCommandPacket$Action;
        readonly static "STOP_SPRINTING": Internal.ServerboundPlayerCommandPacket$Action;
        readonly static "START_RIDING_JUMP": Internal.ServerboundPlayerCommandPacket$Action;
        readonly static "PRESS_SHIFT_KEY": Internal.ServerboundPlayerCommandPacket$Action;
        readonly static "STOP_SLEEPING": Internal.ServerboundPlayerCommandPacket$Action;
        readonly static "STOP_RIDING_JUMP": Internal.ServerboundPlayerCommandPacket$Action;
        readonly static "OPEN_INVENTORY": Internal.ServerboundPlayerCommandPacket$Action;
        readonly static "START_FALL_FLYING": Internal.ServerboundPlayerCommandPacket$Action;
        readonly static "RELEASE_SHIFT_KEY": Internal.ServerboundPlayerCommandPacket$Action;
    }
    type ServerboundPlayerCommandPacket$Action_ = "press_shift_key" | "stop_sprinting" | "start_sprinting" | "start_fall_flying" | ServerboundPlayerCommandPacket$Action | "open_inventory" | "release_shift_key" | "start_riding_jump" | "stop_sleeping" | "stop_riding_jump";
    class MerchantOffer {
        constructor(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.ItemStack_, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number)
        constructor(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.ItemStack_, arg3: number, arg4: number, arg5: number, arg6: number)
        constructor(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.ItemStack_, arg3: number, arg4: number, arg5: number)
        constructor(arg0: Internal.CompoundTag_)
        constructor(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: number, arg3: number, arg4: number)
        getSpecialPriceDiff(): number;
        shouldRewardExp(): boolean;
        needsRestock(): boolean;
        increaseUses(): void;
        resetSpecialPriceDiff(): void;
        getMaxUses(): number;
        isOutOfStock(): boolean;
        getBaseCostA(): Internal.ItemStack;
        getPriceMultiplier(): number;
        createTag(): Internal.CompoundTag;
        getUses(): number;
        resetUses(): void;
        assemble(): Internal.ItemStack;
        updateDemand(): void;
        take(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        addToSpecialPriceDiff(arg0: number): void;
        getResult(): Internal.ItemStack;
        setToOutOfStock(): void;
        getXp(): number;
        setSpecialPriceDiff(arg0: number): void;
        getCostB(): Internal.ItemStack;
        getDemand(): number;
        satisfiedBy(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getCostA(): Internal.ItemStack;
        get specialPriceDiff(): number
        get maxUses(): number
        get outOfStock(): boolean
        get baseCostA(): Internal.ItemStack
        get priceMultiplier(): number
        get uses(): number
        get result(): Internal.ItemStack
        get xp(): number
        set specialPriceDiff(arg0: number)
        get costB(): Internal.ItemStack
        get demand(): number
        get costA(): Internal.ItemStack
    }
    type MerchantOffer_ = MerchantOffer;
    class TutorialToast implements Internal.Toast {
        constructor(arg0: any_, arg1: Internal.Component_, arg2: Internal.Component_, arg3: boolean)
        getToken(): any;
        hide(): void;
        width(): number;
        height(): number;
        updateProgress(arg0: number): void;
        render(arg0: Internal.PoseStack_, arg1: Internal.ToastComponent_, arg2: number): Internal.Toast$Visibility;
        get token(): any
        readonly static "PROGRESS_BAR_WIDTH": 154;
        readonly static "PROGRESS_BAR_HEIGHT": 1;
        readonly static "PROGRESS_BAR_Y": 28;
        readonly static "PROGRESS_BAR_X": 3;
    }
    type TutorialToast_ = TutorialToast;
    interface FunctionFactory$Arg1 extends Internal.FunctionFactory$FuncSupplier {
        createArg(arg0: Internal.Unit_): Internal.Unit;
        create(args: Internal.Unit_[]): Internal.Unit;
    }
    type FunctionFactory$Arg1_ = FunctionFactory$Arg1 | ((arg0: Internal.Unit)=>Internal.Unit_);
    interface FunctionFactory$Arg2 extends Internal.FunctionFactory$FuncSupplier {
        create(args: Internal.Unit_[]): Internal.Unit;
        createArg(arg0: Internal.Unit_, arg1: Internal.Unit_): Internal.Unit;
    }
    type FunctionFactory$Arg2_ = FunctionFactory$Arg2 | ((arg0: Internal.Unit, arg1: Internal.Unit)=>Internal.Unit_);
    class BeaconMenu extends Internal.AbstractContainerMenu {
        constructor(arg0: number, arg1: Internal.Container_, arg2: any_, arg3: any_)
        constructor(arg0: number, arg1: Internal.Container_)
        stillValid(arg0: Internal.Player_): boolean;
        hasPayment(): boolean;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        updateEffects(arg0: number, arg1: number): void;
        getPrimaryEffect(): Internal.MobEffect;
        setData(arg0: number, arg1: number): void;
        removed(arg0: Internal.Player_): void;
        getLevels(): number;
        getSecondaryEffect(): Internal.MobEffect;
        get primaryEffect(): Internal.MobEffect
        get levels(): number
        get secondaryEffect(): Internal.MobEffect
    }
    type BeaconMenu_ = BeaconMenu;
    abstract class MobEffectBuilder extends Internal.BuilderBase<Internal.MobEffect> {
        constructor(i: ResourceLocation_)
        beneficial(): this;
        category(c: Internal.MobEffectCategory_): this;
        modifyAttribute(attribute: ResourceLocation_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): this;
        harmful(): this;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.MobEffect>;
        getTranslationKeyGroup(): string;
        effectTick(effectTick: Internal.MobEffectBuilder$EffectTickCallback_): this;
        color(col: Internal.Color_): this;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.MobEffect>
        get translationKeyGroup(): string
    }
    type MobEffectBuilder_ = MobEffectBuilder;
    class FilterOutputStream extends Internal.OutputStream {
        constructor(arg0: Internal.OutputStream_)
        flush(): void;
        write(arg0: number): void;
        close(): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        write(arg0: number[]): void;
    }
    type FilterOutputStream_ = FilterOutputStream;
    class LiteralArgumentBuilder <S> extends Internal.ArgumentBuilder<S, Internal.LiteralArgumentBuilder<S>> {
        build(): Internal.LiteralCommandNode<S>;
        static literal(arg0: string): Internal.LiteralArgumentBuilder<S>;
        getLiteral(): string;
        get literal(): string
    }
    type LiteralArgumentBuilder_<S> = LiteralArgumentBuilder<S>;
    class VertexFormat {
        constructor(arg0: Internal.ImmutableMap_<string, Internal.VertexFormatElement_>)
        getIntegerSize(): number;
        hasUV(arg0: number): boolean;
        toString(): string;
        getOrCreateIndexBufferObject(): number;
        getVertexSize(): number;
        hasPosition(): boolean;
        getElementMapping(): Internal.ImmutableMap<string, Internal.VertexFormatElement>;
        getOrCreateVertexBufferObject(): number;
        clearBufferState(): void;
        hashCode(): number;
        getOffset(arg0: number): number;
        hasColor(): boolean;
        getElementAttributeNames(): Internal.ImmutableList<string>;
        setupBufferState(): void;
        getOrCreateVertexArrayObject(): number;
        getElements(): Internal.ImmutableList<Internal.VertexFormatElement>;
        equals(arg0: any): boolean;
        hasNormal(): boolean;
        get integerSize(): number
        get orCreateIndexBufferObject(): number
        get vertexSize(): number
        get elementMapping(): Internal.ImmutableMap<string, Internal.VertexFormatElement>
        get orCreateVertexBufferObject(): number
        get elementAttributeNames(): Internal.ImmutableList<string>
        get orCreateVertexArrayObject(): number
        get elements(): Internal.ImmutableList<Internal.VertexFormatElement>
    }
    type VertexFormat_ = VertexFormat;
    class SpectatorMenu {
        constructor(arg0: Internal.SpectatorMenuListener_)
        getSelectedCategory(): Internal.SpectatorMenuCategory;
        exit(): void;
        getItems(): Internal.List<Internal.SpectatorMenuItem>;
        getSelectedItem(): Internal.SpectatorMenuItem;
        getCurrentPage(): Internal.SpectatorPage;
        selectCategory(arg0: Internal.SpectatorMenuCategory_): void;
        getSelectedSlot(): number;
        selectSlot(arg0: number): void;
        getItem(arg0: number): Internal.SpectatorMenuItem;
        get selectedCategory(): Internal.SpectatorMenuCategory
        get items(): Internal.List<Internal.SpectatorMenuItem>
        get selectedItem(): Internal.SpectatorMenuItem
        get currentPage(): Internal.SpectatorPage
        get selectedSlot(): number
        readonly static "EMPTY_SLOT": any;
    }
    type SpectatorMenu_ = SpectatorMenu;
    class MobSpawnSettings$Builder {
        constructor()
        addSpawn(arg0: Internal.MobCategory_, arg1: Internal.MobSpawnSettings$SpawnerData_): this;
        build(): Internal.MobSpawnSettings;
        creatureGenerationProbability(arg0: number): this;
        addMobCharge(arg0: Internal.EntityType_<any>, arg1: number, arg2: number): this;
        readonly "mobSpawnCosts": Internal.Map<Internal.EntityType<any>, Internal.MobSpawnSettings$MobSpawnCost>;
        "creatureGenerationProbability": number;
        readonly "spawners": Internal.Map<Internal.MobCategory, Internal.List<Internal.MobSpawnSettings$SpawnerData>>;
    }
    type MobSpawnSettings$Builder_ = MobSpawnSettings$Builder;
    class BannerDuplicateRecipe extends Internal.CustomRecipe {
        constructor(arg0: ResourceLocation_)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        matches(arg0: Internal.CraftingContainer_, arg1: Internal.Level_): boolean;
        getRemainingItems(arg0: Internal.Container_): Internal.NonNullList<any>;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        getSerializer(): Internal.RecipeSerializer<any>;
        isIncomplete(): boolean;
        assemble(arg0: Internal.CraftingContainer_): Internal.ItemStack;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get serializer(): Internal.RecipeSerializer<any>
        get incomplete(): boolean
    }
    type BannerDuplicateRecipe_ = BannerDuplicateRecipe;
    class TerrainShaper$Point extends Internal.Record {
        constructor(arg0: number, arg1: number, arg2: number, arg3: number)
        hashCode(): number;
        erosion(): number;
        toString(): string;
        ridges(): number;
        weirdness(): number;
        continents(): number;
        equals(arg0: any): boolean;
    }
    type TerrainShaper$Point_ = TerrainShaper$Point;
    class CountOnEveryLayerPlacement extends Internal.PlacementModifier {
        static of(arg0: number): Internal.CountOnEveryLayerPlacement;
        static of(arg0: Internal.IntProvider_): Internal.CountOnEveryLayerPlacement;
        type(): Internal.PlacementModifierType<any>;
        getPositions(arg0: Internal.PlacementContext_, arg1: Internal.Random_, arg2: BlockPos_): Internal.Stream<BlockPos>;
        readonly static "CODEC": any;
    }
    type CountOnEveryLayerPlacement_ = CountOnEveryLayerPlacement;
    interface BiomeResolver {
        getNoiseBiome(arg0: number, arg1: number, arg2: number, arg3: Internal.Climate$Sampler_): Internal.Holder<Internal.Biome>;
    }
    type BiomeResolver_ = BiomeResolver;
    class ItemEntityJS extends Internal.EntityJS {
        constructor(e: Internal.ItemEntity_)
        getTicksUntilDespawn(): number;
        setDefaultPickupDelay(): void;
        setNoDespawn(): void;
        setOwner(owner: Internal.UUID_): void;
        getItem(): Internal.ItemStackJS;
        getOwner(): Internal.UUID;
        setNoPickupDelay(): void;
        setTicksUntilDespawn(ticks: number): void;
        setLifespan(lifespan: number): void;
        setStatusMessage(message: Internal.Component_): void;
        getThrower(): Internal.UUID;
        getAge(): number;
        setInfinitePickupDelay(): void;
        setPickupDelay(ticks: number): void;
        getLifespan(): number;
        setThrower(thrower: Internal.UUID_): void;
        setAge(age: number): void;
        setItem(item: any): void;
        get ticksUntilDespawn(): number
        set owner(owner: Internal.UUID_)
        get item(): Internal.ItemStackJS
        get owner(): Internal.UUID
        set ticksUntilDespawn(ticks: number)
        set lifespan(lifespan: number)
        set statusMessage(message: Internal.Component_)
        get thrower(): Internal.UUID
        get age(): number
        set pickupDelay(ticks: number)
        get lifespan(): number
        set thrower(thrower: Internal.UUID_)
        set age(age: number)
        set item(item: any)
    }
    type ItemEntityJS_ = ItemEntityJS;
    class ImmutableSet$Builder <E> extends Internal.ImmutableCollection$Builder<E> {
        constructor()
        addAll(arg0: Internal.Iterator_<any>): Internal.ImmutableCollection$Builder<any>;
        add(arg0: E): this;
        add(...arg0: E[]): this;
        addAll(arg0: Internal.Iterable_<any>): Internal.ImmutableCollection$Builder<any>;
        build(): Internal.ImmutableCollection<any>;
    }
    type ImmutableSet$Builder_<E> = ImmutableSet$Builder<E>;
    interface ProgressiveFuture <V> extends io.netty.util.concurrent.Future<V> {
        removeListener(arg0: Internal.GenericFutureListener_<any>): this;
        syncUninterruptibly(): this;
        addListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        await(): this;
        sync(): this;
        addListener(arg0: Internal.GenericFutureListener_<any>): this;
        removeListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        awaitUninterruptibly(): this;
    }
    type ProgressiveFuture_<V> = ProgressiveFuture<V>;
    abstract class LootPoolEntryContainer implements Internal.ComposableEntryContainer {
        and(arg0: Internal.ComposableEntryContainer_): Internal.ComposableEntryContainer;
        or(arg0: Internal.ComposableEntryContainer_): Internal.ComposableEntryContainer;
        getType(): Internal.LootPoolEntryType;
        validate(arg0: Internal.ValidationContext_): void;
        get type(): Internal.LootPoolEntryType
    }
    type LootPoolEntryContainer_ = LootPoolEntryContainer;
    class ItemRightClickEmptyEventJS extends Internal.PlayerEventJS {
        constructor(player: Internal.Player_, hand: Hand_)
        getEntity(): Internal.EntityJS;
        getHand(): Hand;
        getItem(): Internal.ItemStackJS;
        get entity(): Internal.EntityJS
        get hand(): Hand
        get item(): Internal.ItemStackJS
    }
    type ItemRightClickEmptyEventJS_ = ItemRightClickEmptyEventJS;
    class LecternMenu extends Internal.AbstractContainerMenu {
        constructor(arg0: number, arg1: Internal.Container_, arg2: any_)
        constructor(arg0: number)
        stillValid(arg0: Internal.Player_): boolean;
        getBook(): Internal.ItemStack;
        clickMenuButton(arg0: Internal.Player_, arg1: number): boolean;
        getPage(): number;
        setData(arg0: number, arg1: number): void;
        get book(): Internal.ItemStack
        get page(): number
        readonly static "BUTTON_NEXT_PAGE": 2;
        readonly static "BUTTON_PREV_PAGE": 1;
        readonly static "BUTTON_TAKE_BOOK": 3;
        readonly static "BUTTON_PAGE_JUMP_RANGE_START": 100;
    }
    type LecternMenu_ = LecternMenu;
    interface Boolean2CharFunction extends it.unimi.dsi.fastutil.Function<boolean, string> {
        andThenReference(arg0: Internal.Char2ReferenceFunction_<any>): Internal.Boolean2ReferenceFunction<T>;
        getOrDefault(arg0: any, arg1: string): string;
        remove(arg0: boolean): string;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Boolean2FloatFunction;
        getOrDefault(arg0: any, arg1: any): any;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2CharFunction;
        defaultReturnValue(): string;
        getOrDefault(arg0: boolean, arg1: string): string;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Boolean2DoubleFunction;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Boolean2ByteFunction;
        remove(arg0: any): string;
        containsKey(arg0: any): boolean;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2CharFunction;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Boolean2LongFunction;
        get(arg0: boolean): string;
        defaultReturnValue(arg0: string): void;
        get(arg0: any): string;
        put(arg0: any, arg1: any): any;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2CharFunction;
        andThenChar(arg0: Internal.Char2CharFunction_): this;
        put(arg0: boolean, arg1: string): string;
        apply(arg0: boolean): string;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2CharFunction;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2CharFunction;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Boolean2IntFunction;
        containsKey(arg0: boolean): boolean;
        composeObject(arg0: Internal.Object2BooleanFunction_<any>): Internal.Object2CharFunction<T>;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2CharFunction;
        put(arg0: boolean, arg1: string): string;
        size(): number;
        andThenObject(arg0: Internal.Char2ObjectFunction_<any>): Internal.Boolean2ObjectFunction<T>;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Boolean2ShortFunction;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<boolean, T>;
        clear(): void;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2CharFunction;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<T, string>;
        composeReference(arg0: Internal.Reference2BooleanFunction_<any>): Internal.Reference2CharFunction<T>;
    }
    type Boolean2CharFunction_ = ((arg0: boolean)=>string) | Boolean2CharFunction;
    class ClientboundPlayerCombatEndPacket implements Internal.Packet<Internal.ClientGamePacketListener> {
        constructor(arg0: number, arg1: number)
        constructor(arg0: Internal.CombatTracker_)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ClientGamePacketListener_): void;
        isSkippable(): boolean;
        get skippable(): boolean
    }
    type ClientboundPlayerCombatEndPacket_ = ClientboundPlayerCombatEndPacket;
    class TypeToken$TypeSet extends Internal.ForwardingSet<Internal.TypeToken<any>> implements Internal.Serializable {
        interfaces(): this;
        toArray(arg0: Internal.IntFunction_<T[]>): T[];
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        classes(): this;
        stream(): Internal.Stream<Internal.TypeToken<any>>;
        forEach(arg0: Internal.Consumer_<any>): void;
        parallelStream(): Internal.Stream<Internal.TypeToken<any>>;
        rawTypes(): Internal.Set<Internal.Class<any>>;
        spliterator(): Internal.Spliterator<Internal.TypeToken<any>>;
    }
    type TypeToken$TypeSet_ = TypeToken$TypeSet;
    class VillagerHostilesSensor extends Internal.NearestVisibleLivingEntitySensor {
        constructor()
    }
    type VillagerHostilesSensor_ = VillagerHostilesSensor;
    interface DataOutput {
        writeBoolean(arg0: boolean): void;
        writeUTF(arg0: string): void;
        writeLong(arg0: number): void;
        writeChars(arg0: string): void;
        writeChar(arg0: number): void;
        write(arg0: number[]): void;
        writeFloat(arg0: number): void;
        writeInt(arg0: number): void;
        writeBytes(arg0: string): void;
        write(arg0: number): void;
        writeByte(arg0: number): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        writeDouble(arg0: number): void;
        writeShort(arg0: number): void;
    }
    type DataOutput_ = DataOutput;
    class PlayerTeam extends Internal.Team {
        constructor(arg0: Internal.Scoreboard_, arg1: string)
        getDisplayName(): Internal.Component;
        setPlayerPrefix(arg0: Internal.Component_): void;
        isAllowFriendlyFire(): boolean;
        setSeeFriendlyInvisibles(arg0: boolean): void;
        getCollisionRule(): Internal.Team$CollisionRule;
        canSeeFriendlyInvisibles(): boolean;
        getDeathMessageVisibility(): Internal.Team$Visibility;
        getName(): string;
        setNameTagVisibility(arg0: Internal.Team$Visibility_): void;
        getColor(): Internal.ChatFormatting;
        unpackOptions(arg0: number): void;
        setDeathMessageVisibility(arg0: Internal.Team$Visibility_): void;
        getFormattedDisplayName(): Internal.MutableComponent;
        packOptions(): number;
        getPlayerSuffix(): Internal.Component;
        getNameTagVisibility(): Internal.Team$Visibility;
        getPlayers(): Internal.Collection<string>;
        getScoreboard(): Internal.Scoreboard;
        setColor(arg0: Internal.ChatFormatting_): void;
        setPlayerSuffix(arg0: Internal.Component_): void;
        setDisplayName(arg0: Internal.Component_): void;
        getPlayerPrefix(): Internal.Component;
        getFormattedName(arg0: Internal.Component_): Internal.MutableComponent;
        setAllowFriendlyFire(arg0: boolean): void;
        setCollisionRule(arg0: Internal.Team$CollisionRule_): void;
        static formatNameForTeam(arg0: Internal.Team_, arg1: Internal.Component_): Internal.MutableComponent;
        get displayName(): Internal.Component
        set playerPrefix(arg0: Internal.Component_)
        get allowFriendlyFire(): boolean
        set seeFriendlyInvisibles(arg0: boolean)
        get collisionRule(): Internal.Team$CollisionRule
        get deathMessageVisibility(): Internal.Team$Visibility
        get name(): string
        set nameTagVisibility(arg0: Internal.Team$Visibility_)
        get color(): Internal.ChatFormatting
        set deathMessageVisibility(arg0: Internal.Team$Visibility_)
        get formattedDisplayName(): Internal.MutableComponent
        get playerSuffix(): Internal.Component
        get nameTagVisibility(): Internal.Team$Visibility
        get players(): Internal.Collection<string>
        get scoreboard(): Internal.Scoreboard
        set color(arg0: Internal.ChatFormatting_)
        set playerSuffix(arg0: Internal.Component_)
        set displayName(arg0: Internal.Component_)
        get playerPrefix(): Internal.Component
        set allowFriendlyFire(arg0: boolean)
        set collisionRule(arg0: Internal.Team$CollisionRule_)
    }
    type PlayerTeam_ = PlayerTeam;
    class Illusioner extends Internal.SpellcasterIllager implements Internal.RangedAttackMob {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        performRangedAttack(arg0: Internal.LivingEntity_, arg1: number): void;
        isAlliedTo(arg0: Internal.Entity_): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getCelebrateSound(): Internal.SoundEvent;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getBoundingBoxForCulling(): Internal.AABB;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getIllusionOffsets(arg0: number): Vec3[];
        finalizeSpawn(arg0: Internal.ServerLevelAccessor_, arg1: Internal.DifficultyInstance_, arg2: Internal.MobSpawnType_, arg3: Internal.SpawnGroupData_, arg4: Internal.CompoundTag_): Internal.SpawnGroupData;
        getArmPose(): Internal.AbstractIllager$IllagerArmPose;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        applyRaidBuffs(arg0: number, arg1: boolean): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get multipartEntity(): boolean
        get celebrateSound(): Internal.SoundEvent
        get parts(): Internal.PartEntity<any>[]
        get boundingBoxForCulling(): Internal.AABB
        get armPose(): Internal.AbstractIllager$IllagerArmPose
    }
    type Illusioner_ = Illusioner;
    interface ITeleporter {
        isVanilla(): boolean;
        playTeleportSound(arg0: Internal.ServerPlayer_, arg1: Internal.ServerLevel_, arg2: Internal.ServerLevel_): boolean;
        getPortalInfo(arg0: Internal.Entity_, arg1: Internal.ServerLevel_, arg2: Internal.Function_<Internal.ServerLevel_, Internal.PortalInfo_>): Internal.PortalInfo;
        placeEntity(arg0: Internal.Entity_, arg1: Internal.ServerLevel_, arg2: Internal.ServerLevel_, arg3: number, arg4: Internal.Function_<boolean, Internal.Entity_>): Internal.Entity;
        get vanilla(): boolean
    }
    type ITeleporter_ = ITeleporter;
    interface FunctionContainer {
        enchantWithLevels(levels: Internal.NumberProvider_, treasure: boolean): this;
        addFunction(arg0: Internal.JsonObject_): this;
        enchantRandomly(enchantments: ResourceLocation_[]): this;
        furnaceSmelt(): this;
        lootingEnchant(count: Internal.NumberProvider_, limit: number): this;
        addConditionalFunction(func: Internal.Consumer_<Internal.ConditionalFunction_>): this;
        name(name: Internal.Component_, entity: Internal.LootContext$EntityTarget_): this;
        damage(damage: Internal.NumberProvider_): this;
        nbt(tag: Internal.CompoundTag_): this;
        count(count: Internal.NumberProvider_): this;
        copyName(source: Internal.CopyNameFunction$NameSource_): this;
        lootTable(table: ResourceLocation_, seed: number): this;
        name(name: Internal.Component_): this;
    }
    type FunctionContainer_ = FunctionContainer;
    class BlockAgeProcessor extends Internal.StructureProcessor {
        constructor(arg0: number)
        processBlock(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_, arg3: Internal.StructureTemplate$StructureBlockInfo_, arg4: Internal.StructureTemplate$StructureBlockInfo_, arg5: Internal.StructurePlaceSettings_): Internal.StructureTemplate$StructureBlockInfo;
        readonly static "CODEC": any;
    }
    type BlockAgeProcessor_ = BlockAgeProcessor;
    class Snowball extends Internal.ThrowableItemProjectile {
        constructor(arg0: Internal.Level_, arg1: Internal.LivingEntity_)
        constructor(arg0: Internal.Level_, arg1: number, arg2: number, arg3: number)
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        shouldRiderSit(): boolean;
        handleEntityEvent(arg0: number): void;
        getParts(): Internal.PartEntity<any>[];
        get stepHeight(): number
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
    }
    type Snowball_ = Snowball;
    class PoiManager$Occupancy extends Internal.Enum<Internal.PoiManager$Occupancy> {
        static valueOf(arg0: string): Internal.PoiManager$Occupancy;
        static values(): Internal.PoiManager$Occupancy[];
        getTest(): Internal.Predicate<any>;
        get test(): Internal.Predicate<any>
        readonly static "IS_OCCUPIED": Internal.PoiManager$Occupancy;
        readonly static "HAS_SPACE": Internal.PoiManager$Occupancy;
        readonly static "ANY": Internal.PoiManager$Occupancy;
    }
    type PoiManager$Occupancy_ = "has_space" | "any" | PoiManager$Occupancy | "is_occupied";
    interface SpawnProperties {
        getMobSpawnCosts(): Internal.Map<Internal.EntityType<any>, Internal.MobSpawnSettings$MobSpawnCost>;
        getCreatureProbability(): number;
        getSpawners(): Internal.Map<Internal.MobCategory, Internal.List<Internal.MobSpawnSettings$SpawnerData>>;
        get mobSpawnCosts(): Internal.Map<Internal.EntityType<any>, Internal.MobSpawnSettings$MobSpawnCost>
        get creatureProbability(): number
        get spawners(): Internal.Map<Internal.MobCategory, Internal.List<Internal.MobSpawnSettings$SpawnerData>>
    }
    type SpawnProperties_ = SpawnProperties;
    interface Constable {
        describeConstable(): Internal.Optional<any>;
    }
    type Constable_ = Constable;
    class Zoglin extends Internal.Monster implements Internal.Enemy, Internal.HoglinBase {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getMobType(): Internal.MobType;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        setBaby(arg0: boolean): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        handleEntityEvent(arg0: number): void;
        getAttackAnimationRemainingTicks(): number;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        doHurtTarget(arg0: Internal.Entity_): boolean;
        isAdult(): boolean;
        deserializeNBT(arg0: Internal.Tag_): void;
        hurt(arg0: Internal.DamageSource_, arg1: number): boolean;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canBeLeashed(arg0: Internal.Player_): boolean;
        aiStep(): void;
        getPassengersRidingOffset(): number;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        isBaby(): boolean;
        getBrain(): Internal.Brain<Internal.Zoglin>;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        onSyncedDataUpdated(arg0: Internal.EntityDataAccessor_<any>): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get mobType(): Internal.MobType
        get stepHeight(): number
        set baby(arg0: boolean)
        get multipartEntity(): boolean
        get parts(): Internal.PartEntity<any>[]
        get attackAnimationRemainingTicks(): number
        get adult(): boolean
        get passengersRidingOffset(): number
        get baby(): boolean
        get brain(): Internal.Brain<Internal.Zoglin>
    }
    type Zoglin_ = Zoglin;
    interface SymbolScriptable {
        put(arg0: Internal.Symbol_, arg1: Internal.Scriptable_, arg2: any): void;
        has(arg0: Internal.Symbol_, arg1: Internal.Scriptable_): boolean;
        get(arg0: Internal.Symbol_, arg1: Internal.Scriptable_): any;
        delete(arg0: Internal.Symbol_): void;
    }
    type SymbolScriptable_ = SymbolScriptable;
    class ServerLevelJS extends Internal.LevelJS {
        constructor(s: Internal.ServerJS_, w: Internal.ServerLevel_)
        toString(): string;
        getEntities(): Internal.EntityArrayList;
        getSeed(): number;
        setLocalTime(time: number): void;
        getMinecraftLevel(): Internal.Level;
        getEntities(filter: string): Internal.EntityArrayList;
        getSide(): Internal.ScriptType;
        getServer(): Internal.ServerJS;
        getPlayerData(arg0: Internal.Player_): Internal.PlayerDataJS<any, any>;
        setTime(time: number): void;
        get entities(): Internal.EntityArrayList
        get seed(): number
        set localTime(time: number)
        get minecraftLevel(): Internal.Level
        get side(): Internal.ScriptType
        get server(): Internal.ServerJS
        set time(time: number)
        readonly "persistentData": Internal.CompoundTag;
    }
    type ServerLevelJS_ = ServerLevelJS;
    interface ModifyRecipeResultCallback {
        modify(arg0: Internal.ModifyRecipeCraftingGrid_, arg1: Internal.ItemStackJS_): Internal.ItemStackJS;
    }
    type ModifyRecipeResultCallback_ = ModifyRecipeResultCallback | ((arg0: Internal.ModifyRecipeCraftingGrid, arg1: Internal.ItemStackJS)=>Internal.ItemStackJS_);
    class ServerboundChatPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: Internal.FriendlyByteBuf_)
        constructor(arg0: string)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getMessage(): string;
        isSkippable(): boolean;
        get message(): string
        get skippable(): boolean
    }
    type ServerboundChatPacket_ = ServerboundChatPacket;
    class CraftingMenu extends Internal.RecipeBookMenu<Internal.CraftingContainer> {
        constructor(arg0: number, arg1: Internal.Inventory_, arg2: any_)
        constructor(arg0: number, arg1: Internal.Inventory_)
        getRecipeBookType(): Internal.RecipeBookType;
        canTakeItemForPickAll(arg0: Internal.ItemStack_, arg1: Internal.Slot_): boolean;
        slotsChanged(arg0: Internal.Container_): void;
        clearCraftingContent(): void;
        quickMoveStack(arg0: Internal.Player_, arg1: number): Internal.ItemStack;
        getGridWidth(): number;
        stillValid(arg0: Internal.Player_): boolean;
        getResultSlotIndex(): number;
        getSize(): number;
        recipeMatches(arg0: Internal.Recipe_<any>): boolean;
        getGridHeight(): number;
        fillCraftSlotsStackedContents(arg0: Internal.StackedContents_): void;
        removed(arg0: Internal.Player_): void;
        shouldMoveToInventory(arg0: number): boolean;
        get recipeBookType(): Internal.RecipeBookType
        get gridWidth(): number
        get resultSlotIndex(): number
        get size(): number
        get gridHeight(): number
        readonly "player": Internal.Player;
        readonly static "RESULT_SLOT": 0;
    }
    type CraftingMenu_ = CraftingMenu;
    class CountConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: Internal.IntProvider_)
        constructor(arg0: number)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        count(): Internal.IntProvider;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly static "CODEC": any;
    }
    type CountConfiguration_ = CountConfiguration;
    class WeightedEntry$IntrusiveBase implements Internal.WeightedEntry {
        constructor(arg0: number)
        constructor(arg0: Internal.Weight_)
        getWeight(): Internal.Weight;
        get weight(): Internal.Weight
    }
    type WeightedEntry$IntrusiveBase_ = WeightedEntry$IntrusiveBase;
    class StringTag implements Internal.Tag, Internal.SpecialEquality {
        toString(): string;
        specialEquals(o: any, shallow: boolean): boolean;
        static skipString(arg0: Internal.DataInput_): void;
        accept(arg0: Internal.TagVisitor_): void;
        getAsString(): string;
        hashCode(): number;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        getType(): Internal.TagType<Internal.StringTag>;
        copy(): Internal.Tag;
        write(arg0: Internal.DataOutput_): void;
        static quoteAndEscape(arg0: string): string;
        getId(): number;
        equals(arg0: any): boolean;
        accept(arg0: Internal.StreamTagVisitor_): Internal.StreamTagVisitor$ValueResult;
        static valueOf(arg0: string): Internal.StringTag;
        get asString(): string
        get type(): Internal.TagType<Internal.StringTag>
        get id(): number
        readonly static "TYPE": any;
    }
    type StringTag_ = StringTag;
    abstract class AbstractContainerEventHandler extends Internal.GuiComponent implements Internal.ContainerEventHandler {
        constructor()
        charTyped(arg0: string, arg1: number): boolean;
        magicalSpecialHackyFocus(arg0: Internal.GuiEventListener_): void;
        mouseReleased(arg0: number, arg1: number, arg2: number): boolean;
        changeFocus(arg0: boolean): boolean;
        mouseClicked(arg0: number, arg1: number, arg2: number): boolean;
        mouseScrolled(arg0: number, arg1: number, arg2: number): boolean;
        keyReleased(arg0: number, arg1: number, arg2: number): boolean;
        setFocused(arg0: Internal.GuiEventListener_): void;
        keyPressed(arg0: number, arg1: number, arg2: number): boolean;
        setInitialFocus(arg0: Internal.GuiEventListener_): void;
        setDragging(arg0: boolean): void;
        mouseDragged(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): boolean;
        getChildAt(arg0: number, arg1: number): Internal.Optional<Internal.GuiEventListener>;
        isDragging(): boolean;
        mouseMoved(arg0: number, arg1: number): void;
        getFocused(): Internal.GuiEventListener;
        isMouseOver(arg0: number, arg1: number): boolean;
        set focused(arg0: Internal.GuiEventListener_)
        set initialFocus(arg0: Internal.GuiEventListener_)
        set dragging(arg0: boolean)
        get dragging(): boolean
        get focused(): Internal.GuiEventListener
    }
    type AbstractContainerEventHandler_ = AbstractContainerEventHandler;
    class MovementInputUpdateEvent extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.Input_)
        getInput(): Internal.Input;
        getListenerList(): Internal.ListenerList;
        get input(): Internal.Input
        get listenerList(): Internal.ListenerList
    }
    type MovementInputUpdateEvent_ = MovementInputUpdateEvent;
    class Products$P13 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> {
        constructor(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>)
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function13_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>): Internal.App<F, R>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function13_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>): Internal.App<F, R>;
    }
    type Products$P13_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> = Products$P13<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>;
    class Products$P14 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> {
        constructor(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>, arg13: Internal.App_<F, T14>)
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function14_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>): Internal.App<F, R>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function14_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>): Internal.App<F, R>;
    }
    type Products$P14_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> = Products$P14<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>;
    class Products$P11 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
        constructor(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>)
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function11_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>): Internal.App<F, R>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function11_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>>): Internal.App<F, R>;
    }
    type Products$P11_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> = Products$P11<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>;
    class Products$P12 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> {
        constructor(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>)
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function12_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>): Internal.App<F, R>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function12_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>): Internal.App<F, R>;
    }
    type Products$P12_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> = Products$P12<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>;
    interface LidBlockEntity {
        getOpenNess(arg0: number): number;
    }
    type LidBlockEntity_ = LidBlockEntity;
    interface BiomeModifications$BiomeContext {
        getProperties(): Internal.BiomeProperties;
        hasTag(arg0: Internal.TagKey_<Internal.Biome_>): boolean;
        getKey(): ResourceLocation;
        get properties(): Internal.BiomeProperties
        get key(): ResourceLocation
    }
    type BiomeModifications$BiomeContext_ = BiomeModifications$BiomeContext;
    class RenderLevelStageEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.RenderLevelStageEvent$Stage_, arg1: Internal.LevelRenderer_, arg2: Internal.PoseStack_, arg3: Internal.Matrix4f_, arg4: number, arg5: number, arg6: Internal.Camera_, arg7: Internal.Frustum_)
        getStage(): Internal.RenderLevelStageEvent$Stage;
        getPartialTick(): number;
        getPoseStack(): Internal.PoseStack;
        getProjectionMatrix(): Internal.Matrix4f;
        getFrustum(): Internal.Frustum;
        getListenerList(): Internal.ListenerList;
        getCamera(): Internal.Camera;
        getRenderTick(): number;
        getLevelRenderer(): Internal.LevelRenderer;
        get stage(): Internal.RenderLevelStageEvent$Stage
        get partialTick(): number
        get poseStack(): Internal.PoseStack
        get projectionMatrix(): Internal.Matrix4f
        get frustum(): Internal.Frustum
        get listenerList(): Internal.ListenerList
        get camera(): Internal.Camera
        get renderTick(): number
        get levelRenderer(): Internal.LevelRenderer
    }
    type RenderLevelStageEvent_ = RenderLevelStageEvent;
    class Products$P10 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> {
        constructor(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>)
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function10_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>>): Internal.App<F, R>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function10_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>): Internal.App<F, R>;
    }
    type Products$P10_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> = Products$P10<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>;
    class FireworkStarFadeRecipe extends Internal.CustomRecipe {
        constructor(arg0: ResourceLocation_)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        getSerializer(): Internal.RecipeSerializer<any>;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        matches(arg0: Internal.CraftingContainer_, arg1: Internal.Level_): boolean;
        isIncomplete(): boolean;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        assemble(arg0: Internal.CraftingContainer_): Internal.ItemStack;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get serializer(): Internal.RecipeSerializer<any>
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get incomplete(): boolean
    }
    type FireworkStarFadeRecipe_ = FireworkStarFadeRecipe;
    class DebugQueryHandler {
        constructor(arg0: Internal.ClientPacketListener_)
        queryBlockEntityTag(arg0: BlockPos_, arg1: Internal.Consumer_<Internal.CompoundTag_>): void;
        queryEntityTag(arg0: number, arg1: Internal.Consumer_<Internal.CompoundTag_>): void;
        handleResponse(arg0: number, arg1: Internal.CompoundTag_): boolean;
    }
    type DebugQueryHandler_ = DebugQueryHandler;
    class Pack$Position extends Internal.Enum<Internal.Pack$Position> {
        insert(arg0: Internal.List_<T>, arg1: T, arg2: Internal.Function_<T, Internal.Pack_>, arg3: boolean): number;
        opposite(): this;
        static values(): Internal.Pack$Position[];
        static valueOf(arg0: string): Internal.Pack$Position;
        readonly static "TOP": Internal.Pack$Position;
        readonly static "BOTTOM": Internal.Pack$Position;
    }
    type Pack$Position_ = Pack$Position | "bottom" | "top";
    class SuspiciousStewRecipe extends Internal.CustomRecipe {
        constructor(arg0: ResourceLocation_)
        getIngredients(): Internal.NonNullList<Internal.Ingredient>;
        getSerializer(): Internal.RecipeSerializer<any>;
        assemble(arg0: Internal.Container_): Internal.ItemStack;
        getGroup(): string;
        getType(): Internal.RecipeType<any>;
        getToastSymbol(): Internal.ItemStack;
        matches(arg0: Internal.CraftingContainer_, arg1: Internal.Level_): boolean;
        isIncomplete(): boolean;
        canCraftInDimensions(arg0: number, arg1: number): boolean;
        assemble(arg0: Internal.CraftingContainer_): Internal.ItemStack;
        matches(arg0: Internal.Container_, arg1: Internal.Level_): boolean;
        getRemainingItems(arg0: Internal.CraftingContainer_): Internal.NonNullList<Internal.ItemStack>;
        get ingredients(): Internal.NonNullList<Internal.Ingredient>
        get serializer(): Internal.RecipeSerializer<any>
        get group(): string
        get type(): Internal.RecipeType<any>
        get toastSymbol(): Internal.ItemStack
        get incomplete(): boolean
    }
    type SuspiciousStewRecipe_ = SuspiciousStewRecipe;
    class Products$P15 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> {
        constructor(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>, arg13: Internal.App_<F, T14>, arg14: Internal.App_<F, T15>)
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function15_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>): Internal.App<F, R>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function15_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>): Internal.App<F, R>;
    }
    type Products$P15_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> = Products$P15<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>;
    interface SurfaceRules$Condition {
        test(): boolean;
    }
    type SurfaceRules$Condition_ = SurfaceRules$Condition;
    class Products$P16 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> {
        constructor(arg0: Internal.App_<F, T1>, arg1: Internal.App_<F, T2>, arg2: Internal.App_<F, T3>, arg3: Internal.App_<F, T4>, arg4: Internal.App_<F, T5>, arg5: Internal.App_<F, T6>, arg6: Internal.App_<F, T7>, arg7: Internal.App_<F, T8>, arg8: Internal.App_<F, T9>, arg9: Internal.App_<F, T10>, arg10: Internal.App_<F, T11>, arg11: Internal.App_<F, T12>, arg12: Internal.App_<F, T13>, arg13: Internal.App_<F, T14>, arg14: Internal.App_<F, T15>, arg15: Internal.App_<F, T16>)
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function16_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>): Internal.App<F, R>;
        apply(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function16_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>): Internal.App<F, R>;
    }
    type Products$P16_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> = Products$P16<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>;
    class PointedDripstoneConfiguration implements Internal.FeatureConfiguration {
        constructor(arg0: number, arg1: number, arg2: number, arg3: number)
        getFeatures(): Internal.Stream<Internal.ConfiguredFeature<any, any>>;
        get features(): Internal.Stream<Internal.ConfiguredFeature<any, any>>
        readonly "chanceOfTallerDripstone": number;
        readonly static "CODEC": any;
        readonly "chanceOfSpreadRadius2": number;
        readonly "chanceOfSpreadRadius3": number;
        readonly "chanceOfDirectionalSpread": number;
    }
    type PointedDripstoneConfiguration_ = PointedDripstoneConfiguration;
    abstract class BlockStateProvider {
        constructor()
        static simple(arg0: Internal.BlockState_): Internal.SimpleStateProvider;
        getState(arg0: Internal.Random_, arg1: BlockPos_): Internal.BlockState;
        static simple(arg0: Internal.Block_): Internal.SimpleStateProvider;
        readonly static "CODEC": any;
    }
    type BlockStateProvider_ = BlockStateProvider;
    class MoveControl implements Internal.Control {
        constructor(arg0: Internal.Mob_)
        setWantedPosition(arg0: number, arg1: number, arg2: number, arg3: number): void;
        getWantedX(): number;
        getWantedY(): number;
        getWantedZ(): number;
        strafe(arg0: number, arg1: number): void;
        getSpeedModifier(): number;
        hasWanted(): boolean;
        tick(): void;
        get wantedX(): number
        get wantedY(): number
        get wantedZ(): number
        get speedModifier(): number
        readonly static "MIN_SPEED": 5.0E-4;
        readonly static "MIN_SPEED_SQR": 2.5000003E-7;
    }
    type MoveControl_ = MoveControl;
    class Chicken extends Internal.Animal {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        static createAttributes(): Internal.AttributeSupplier$Builder;
        getStepHeight(): number;
        asKJS(): Internal.EntityJS;
        isFood(arg0: Internal.ItemStack_): boolean;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        isChickenJockey(): boolean;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        aiStep(): void;
        causeFallDamage(arg0: number, arg1: number, arg2: Internal.DamageSource_): boolean;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        setChickenJockey(arg0: boolean): void;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        positionRider(arg0: Internal.Entity_): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        removeWhenFarAway(arg0: number): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get stepHeight(): number
        get multipartEntity(): boolean
        get chickenJockey(): boolean
        get parts(): Internal.PartEntity<any>[]
        set chickenJockey(arg0: boolean)
        "flapSpeed": number;
        "eggTime": number;
        "flap": number;
        "isChickenJockey": boolean;
        "oFlapSpeed": number;
        "oFlap": number;
        "flapping": number;
    }
    type Chicken_ = Chicken;
    class CompoundTag implements Internal.Tag {
        constructor()
        getLong(arg0: string): number;
        getLongArray(arg0: string): number[];
        merge(arg0: Internal.CompoundTag_): this;
        getFloat(arg0: string): number;
        putShort(arg0: string, arg1: number): void;
        putLongArray(arg0: string, arg1: number[]): void;
        getTagType(arg0: string): number;
        contains(arg0: string): boolean;
        putLongArray(arg0: string, arg1: Internal.List_<number>): void;
        getBoolean(arg0: string): boolean;
        write(arg0: Internal.DataOutput_): void;
        getShort(arg0: string): number;
        getCompound(arg0: string): this;
        accept(arg0: Internal.TagVisitor_): void;
        getUUID(arg0: string): Internal.UUID;
        getAllKeys(): Internal.Set<string>;
        putByteArray(arg0: string, arg1: number[]): void;
        getDouble(arg0: string): number;
        putFloat(arg0: string, arg1: number): void;
        copy(): Internal.Tag;
        getString(arg0: string): string;
        remove(arg0: string): void;
        getType(): Internal.TagType<Internal.CompoundTag>;
        accept(arg0: Internal.StreamTagVisitor_): Internal.StreamTagVisitor$ValueResult;
        put(arg0: string, arg1: Internal.Tag_): Internal.Tag;
        putUUID(arg0: string, arg1: Internal.UUID_): void;
        getByteArray(arg0: string): number[];
        getInt(arg0: string): number;
        putByte(arg0: string, arg1: number): void;
        isEmpty(): boolean;
        putIntArray(arg0: string, arg1: number[]): void;
        get(arg0: string): Internal.Tag;
        acceptAsRoot(arg0: Internal.StreamTagVisitor_): void;
        putLong(arg0: string, arg1: number): void;
        putByteArray(arg0: string, arg1: Internal.List_<number>): void;
        putString(arg0: string, arg1: string): void;
        getId(): number;
        putDouble(arg0: string, arg1: number): void;
        putIntArray(arg0: string, arg1: Internal.List_<number>): void;
        getList(arg0: string, arg1: number): Internal.ListTag;
        toString(): string;
        getIntArray(arg0: string): number[];
        getByte(arg0: string): number;
        getAsString(): string;
        size(): number;
        hashCode(): number;
        hasUUID(arg0: string): boolean;
        putBoolean(arg0: string, arg1: boolean): void;
        contains(arg0: string, arg1: number): boolean;
        putInt(arg0: string, arg1: number): void;
        equals(arg0: any): boolean;
        get allKeys(): Internal.Set<string>
        get type(): Internal.TagType<Internal.CompoundTag>
        get empty(): boolean
        get id(): number
        get asString(): string
        readonly static "CODEC": any;
        readonly static "TYPE": any;
        readonly "tags": Internal.Map<string, Internal.Tag>;
    }
    type CompoundTag_ = CompoundTag;
    class RenderGameOverlayEvent$PreLayer extends Internal.RenderGameOverlayEvent$Pre {
        constructor()
        constructor(arg0: Internal.PoseStack_, arg1: Internal.RenderGameOverlayEvent_, arg2: Internal.IIngameOverlay_)
        getOverlay(): Internal.IIngameOverlay;
        getListenerList(): Internal.ListenerList;
        get overlay(): Internal.IIngameOverlay
        get listenerList(): Internal.ListenerList
    }
    type RenderGameOverlayEvent$PreLayer_ = RenderGameOverlayEvent$PreLayer;
    class PathComputationType extends Internal.Enum<Internal.PathComputationType> {
        static values(): Internal.PathComputationType[];
        static valueOf(arg0: string): Internal.PathComputationType;
        readonly static "AIR": Internal.PathComputationType;
        readonly static "LAND": Internal.PathComputationType;
        readonly static "WATER": Internal.PathComputationType;
    }
    type PathComputationType_ = "land" | PathComputationType | "air" | "water";
    interface IForgeBlock {
        isFlammable(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getRespawnPosition(arg0: Internal.BlockState_, arg1: Internal.EntityType_<any>, arg2: Internal.LevelReader_, arg3: BlockPos_, arg4: number, arg5: Internal.LivingEntity_): Internal.Optional<Vec3>;
        supportsExternalFaceHiding(arg0: Internal.BlockState_): boolean;
        isFertile(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        collisionExtendsVertically(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        getWeakChanges(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): boolean;
        onBlockStateChange(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BlockState_): void;
        getExpDrop(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: number, arg4: number): number;
        getFriction(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): number;
        canConnectRedstone(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        isFireSource(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        isStickyBlock(arg0: Internal.BlockState_): boolean;
        shouldCheckWeakPower(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getBeaconColorMultiplier(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): number[];
        onBlockExploded(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Explosion_): void;
        isSlimeBlock(arg0: Internal.BlockState_): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockState_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_, arg3: Internal.FluidState_): boolean;
        canEntityDestroy(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        rotate(arg0: Internal.BlockState_, arg1: Internal.LevelAccessor_, arg2: BlockPos_, arg3: Internal.Rotation_): Internal.BlockState;
        canHarvestBlock(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        isValidSpawn(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.SpawnPlacements$Type_, arg4: Internal.EntityType_<any>): boolean;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.UseOnContext_, arg2: Internal.ToolAction_, arg3: boolean): Internal.BlockState;
        getFlammability(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        isLadder(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        getCloneItemStack(arg0: Internal.BlockState_, arg1: Internal.HitResult_, arg2: Internal.BlockGetter_, arg3: BlockPos_, arg4: Internal.Player_): Internal.ItemStack;
        getAiPathNodeType(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Mob_): Internal.BlockPathTypes;
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.BlockState_): boolean;
        onDestroyedByPlayer(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: boolean, arg5: Internal.FluidState_): boolean;
        onNeighborChange(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): void;
        isPortalFrame(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        onCaughtFire(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.LivingEntity_): void;
        isScaffolding(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        hidesNeighborFace(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: Internal.Direction_): boolean;
        getStateAtViewpoint(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Vec3_): Internal.BlockState;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: Internal.ItemStack_, arg5: Internal.ToolAction_): Internal.BlockState;
        isBed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        getExplosionResistance(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        getBedDirection(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): Internal.Direction;
        canStickTo(arg0: Internal.BlockState_, arg1: Internal.BlockState_): boolean;
        getFireSpreadSpeed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        getLightEmission(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): number;
        setBedOccupied(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.LivingEntity_, arg4: boolean): void;
        addLandingEffects(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: Internal.LivingEntity_, arg5: number): boolean;
        canDropFromExplosion(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): boolean;
        isConduitFrame(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): boolean;
        addRunningEffects(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        getEnchantPowerBonus(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): number;
        canSustainPlant(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.IPlantable_): boolean;
        getSoundType(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): Internal.SoundType;
        isBurning(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getMapColor(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.MaterialColor_): Internal.MaterialColor;
    }
    type IForgeBlock_ = IForgeBlock;
    class AbstractIllager$IllagerArmPose extends Internal.Enum<Internal.AbstractIllager$IllagerArmPose> {
        static valueOf(arg0: string): Internal.AbstractIllager$IllagerArmPose;
        static values(): Internal.AbstractIllager$IllagerArmPose[];
        readonly static "BOW_AND_ARROW": Internal.AbstractIllager$IllagerArmPose;
        readonly static "CROSSBOW_CHARGE": Internal.AbstractIllager$IllagerArmPose;
        readonly static "CROSSED": Internal.AbstractIllager$IllagerArmPose;
        readonly static "CELEBRATING": Internal.AbstractIllager$IllagerArmPose;
        readonly static "NEUTRAL": Internal.AbstractIllager$IllagerArmPose;
        readonly static "SPELLCASTING": Internal.AbstractIllager$IllagerArmPose;
        readonly static "CROSSBOW_HOLD": Internal.AbstractIllager$IllagerArmPose;
        readonly static "ATTACKING": Internal.AbstractIllager$IllagerArmPose;
    }
    type AbstractIllager$IllagerArmPose_ = "crossed" | "neutral" | "celebrating" | "spellcasting" | "attacking" | "crossbow_hold" | "bow_and_arrow" | "crossbow_charge" | AbstractIllager$IllagerArmPose;
    class BlockEntityRenderDispatcher implements Internal.ResourceManagerReloadListener {
        constructor(arg0: Internal.Font_, arg1: Internal.EntityModelSet_, arg2: Internal.Supplier_<Internal.BlockRenderDispatcher_>)
        getRenderer(arg0: E): Internal.BlockEntityRenderer<E>;
        prepare(arg0: Internal.Level_, arg1: Internal.Camera_, arg2: Internal.HitResult_): void;
        getName(): string;
        render(arg0: E, arg1: number, arg2: Internal.PoseStack_, arg3: Internal.MultiBufferSource_): void;
        onResourceManagerReload(arg0: Internal.ResourceManager_): void;
        renderItem(arg0: E, arg1: Internal.PoseStack_, arg2: Internal.MultiBufferSource_, arg3: number, arg4: number): boolean;
        setLevel(arg0: Internal.Level_): void;
        reload(arg0: Internal.PreparableReloadListener$PreparationBarrier_, arg1: Internal.ResourceManager_, arg2: Internal.ProfilerFiller_, arg3: Internal.ProfilerFiller_, arg4: Internal.Executor_, arg5: Internal.Executor_): Internal.CompletableFuture<void>;
        get name(): string
        set level(arg0: Internal.Level_)
        "camera": Internal.Camera;
        readonly "font": Internal.Font;
        "level": Internal.Level;
        "cameraHitResult": Internal.HitResult;
    }
    type BlockEntityRenderDispatcher_ = BlockEntityRenderDispatcher;
    abstract class MultithreadEventExecutorGroup extends Internal.AbstractEventExecutorGroup {
        shutdown(): void;
        terminationFuture(): io.netty.util.concurrent.Future<any>;
        iterator(): Internal.Iterator<Internal.EventExecutor>;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit_): boolean;
        isShutdown(): boolean;
        executorCount(): number;
        next(): Internal.EventExecutor;
        forEach(arg0: Internal.Consumer_<any>): void;
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.Future<any>;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        isShuttingDown(): boolean;
        isTerminated(): boolean;
        get shutdown(): boolean
        get shuttingDown(): boolean
        get terminated(): boolean
    }
    type MultithreadEventExecutorGroup_ = MultithreadEventExecutorGroup;
    class WanderingTrader extends Internal.AbstractVillager {
        constructor(arg0: Internal.EntityType_<any>, arg1: Internal.Level_)
        getDespawnDelay(): number;
        getStepHeight(): number;
        getNotifyTradeSound(): Internal.SoundEvent;
        asKJS(): Internal.EntityJS;
        addAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRiderInteract(): boolean;
        isMultipartEntity(): boolean;
        serializeNBT(): Internal.Tag;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        showProgressBar(): boolean;
        setWanderTarget(arg0: BlockPos_): void;
        shouldRiderSit(): boolean;
        getParts(): Internal.PartEntity<any>[];
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        deserializeNBT(arg0: Internal.Tag_): void;
        readAdditionalSaveData(arg0: Internal.CompoundTag_): void;
        canRestock(): boolean;
        aiStep(): void;
        getCapability(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
        openTradingScreen(arg0: Internal.Player_, arg1: Internal.Component_, arg2: number): void;
        getBreedOffspring(arg0: Internal.ServerLevel_, arg1: Internal.AgeableMob_): Internal.AgeableMob;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        alwaysAccepts(): boolean;
        mobInteract(arg0: Internal.Player_, arg1: Hand_): Internal.InteractionResult;
        getClassification(arg0: boolean): Internal.MobCategory;
        removeWhenFarAway(arg0: number): boolean;
        setDespawnDelay(arg0: number): void;
        foodEatenKJS(is: Internal.ItemStack_): void;
        get despawnDelay(): number
        get stepHeight(): number
        get notifyTradeSound(): Internal.SoundEvent
        get multipartEntity(): boolean
        set wanderTarget(arg0: BlockPos_)
        get parts(): Internal.PartEntity<any>[]
        set despawnDelay(arg0: number)
    }
    type WanderingTrader_ = WanderingTrader;
    class BeaconBlockEntity$BeaconBeamSection {
        constructor(arg0: number[])
        getColor(): number[];
        getHeight(): number;
        get color(): number[]
        get height(): number
    }
    type BeaconBlockEntity$BeaconBeamSection_ = BeaconBlockEntity$BeaconBeamSection;
    interface IForgeItem {
        elytraFlightTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getMaxDamage(arg0: Internal.ItemStack_): number;
        getShareTag(arg0: Internal.ItemStack_): Internal.CompoundTag;
        isRepairable(arg0: Internal.ItemStack_): boolean;
        isDamageable(arg0: Internal.ItemStack_): boolean;
        isEnderMask(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.EnderMan_): boolean;
        getBurnTime(arg0: Internal.ItemStack_, arg1: Internal.RecipeType_<any>): number;
        onUsingTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): void;
        onItemUseFirst(arg0: Internal.ItemStack_, arg1: Internal.UseOnContext_): Internal.InteractionResult;
        isPiglinCurrency(arg0: Internal.ItemStack_): boolean;
        isCorrectToolForDrops(arg0: Internal.ItemStack_, arg1: Internal.BlockState_): boolean;
        getItemStackLimit(arg0: Internal.ItemStack_): number;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_, arg3: Internal.LivingEntity_): boolean;
        canWalkOnPowderedSnow(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_, arg1: Internal.Enchantment_): boolean;
        hasContainerItem(arg0: Internal.ItemStack_): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        getXpRepairRatio(arg0: Internal.ItemStack_): number;
        isBookEnchantable(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        initCapabilities(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): Internal.ICapabilityProvider;
        onDroppedByPlayer(arg0: Internal.ItemStack_, arg1: Internal.Player_): boolean;
        isDamaged(arg0: Internal.ItemStack_): boolean;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack_): number;
        getCreatorModId(arg0: Internal.ItemStack_): string;
        canContinueUsing(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getFoodProperties(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): Internal.FoodProperties;
        getHighlightTip(arg0: Internal.ItemStack_, arg1: Internal.Component_): Internal.Component;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        onLeftClickEntity(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): boolean;
        canEquip(arg0: Internal.ItemStack_, arg1: EquipmentSlot_, arg2: Internal.Entity_): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        canPerformAction(arg0: Internal.ItemStack_, arg1: Internal.ToolAction_): boolean;
        getItemEnchantability(arg0: Internal.ItemStack_): number;
        hasCustomEntity(arg0: Internal.ItemStack_): boolean;
        onEntityItemUpdate(arg0: Internal.ItemStack_, arg1: Internal.ItemEntity_): boolean;
        getDamage(arg0: Internal.ItemStack_): number;
        readShareTag(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): void;
        onArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Player_): void;
        getEquipmentSlot(arg0: Internal.ItemStack_): EquipmentSlot;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        damageItem(arg0: Internal.ItemStack_, arg1: number, arg2: T, arg3: Internal.Consumer_<T>): number;
        getAttributeModifiers(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        canElytraFly(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        createEntity(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.ItemStack_): Internal.Entity;
        getArmorTexture(arg0: Internal.ItemStack_, arg1: Internal.Entity_, arg2: EquipmentSlot_, arg3: string): string;
        onEntitySwing(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getEntityLifespan(arg0: Internal.ItemStack_, arg1: Internal.Level_): number;
        setDamage(arg0: Internal.ItemStack_, arg1: number): void;
        getSweepHitBox(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): Internal.AABB;
        doesSneakBypassUse(arg0: Internal.ItemStack_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: boolean): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Mob_): void;
        getContainerItem(arg0: Internal.ItemStack_): Internal.ItemStack;
        onBlockStartBreak(arg0: Internal.ItemStack_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>
    }
    type IForgeItem_ = IForgeItem;
    class StairsShape extends Internal.Enum<Internal.StairsShape> implements Internal.StringRepresentable {
        static values(): Internal.StairsShape[];
        toString(): string;
        static valueOf(arg0: string): Internal.StairsShape;
        getSerializedName(): string;
        get serializedName(): string
        readonly static "OUTER_LEFT": Internal.StairsShape;
        readonly static "INNER_RIGHT": Internal.StairsShape;
        readonly static "STRAIGHT": Internal.StairsShape;
        readonly static "OUTER_RIGHT": Internal.StairsShape;
        readonly static "INNER_LEFT": Internal.StairsShape;
    }
    type StairsShape_ = "inner_left" | "outer_left" | StairsShape | "outer_right" | "inner_right" | "straight";
    interface LightChunkGetter {
        getLevel(): Internal.BlockGetter;
        getChunkForLighting(arg0: number, arg1: number): Internal.BlockGetter;
        onLightUpdate(arg0: Internal.LightLayer_, arg1: Internal.SectionPos_): void;
        get level(): Internal.BlockGetter
    }
    type LightChunkGetter_ = LightChunkGetter;
    class SpecialRecipeSerializerManager extends Internal.EventJS {
        constructor()
        isSpecial(recipe: Internal.Recipe_<any>): boolean;
        ignoreSpecialMod(modid: string): void;
        ignoreSpecialFlag(id: ResourceLocation_): void;
        addSpecialMod(modid: string): void;
        reset(): void;
        addSpecialFlag(id: ResourceLocation_): void;
        readonly static "INSTANCE": Internal.SpecialRecipeSerializerManager;
        readonly static "EVENT": any;
    }
    type SpecialRecipeSerializerManager_ = SpecialRecipeSerializerManager;
    class RenderStateShard$TexturingStateShard extends Internal.RenderStateShard {
        constructor(arg0: string, arg1: Internal.Runnable_, arg2: Internal.Runnable_)
    }
    type RenderStateShard$TexturingStateShard_ = RenderStateShard$TexturingStateShard;
    class ServerboundSetBeaconPacket implements Internal.Packet<Internal.ServerGamePacketListener> {
        constructor(arg0: number, arg1: number)
        constructor(arg0: Internal.FriendlyByteBuf_)
        handle(arg0: Internal.PacketListener_): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        handle(arg0: Internal.ServerGamePacketListener_): void;
        getPrimary(): number;
        getSecondary(): number;
        isSkippable(): boolean;
        get primary(): number
        get secondary(): number
        get skippable(): boolean
    }
    type ServerboundSetBeaconPacket_ = ServerboundSetBeaconPacket;
    interface ArmorMaterial {
        getRepairIngredient(): Internal.Ingredient;
        getDefenseForSlot(arg0: EquipmentSlot_): number;
        getToughness(): number;
        getName(): string;
        getKnockbackResistance(): number;
        getEnchantmentValue(): number;
        getDurabilityForSlot(arg0: EquipmentSlot_): number;
        getEquipSound(): Internal.SoundEvent;
        get repairIngredient(): Internal.Ingredient
        get toughness(): number
        get name(): string
        get knockbackResistance(): number
        get enchantmentValue(): number
        get equipSound(): Internal.SoundEvent
    }
    type ArmorMaterial_ = ArmorMaterial;
    class Minecraft extends Internal.ReentrantBlockableEventLoop<Internal.Runnable> implements Internal.WindowEventHandler, Internal.IForgeMinecraft {
        constructor(arg0: any_)
        debugFpsMeterKeyPress(arg0: number): void;
        renderOnThread(): boolean;
        destroy(): void;
        showOnlyReducedInfo(): boolean;
        clearLevel(arg0: Internal.Screen_): void;
        getCurrentServer(): Internal.ServerData;
        getResourceManager(): Internal.ResourceManager;
        getProxy(): Internal.Proxy;
        getOverlay(): Internal.Overlay;
        shouldEntityAppearGlowing(arg0: Internal.Entity_): boolean;
        getToasts(): Internal.ToastComponent;
        pushGuiLayer(arg0: Internal.Screen_): void;
        loadLevel(arg0: string): void;
        askEither(arg0: Internal.Function_<any, any>): Internal.CompletableFuture<Source>;
        getSoundManager(): Internal.SoundManager;
        static useShaderTransparency(): boolean;
        getSplashManager(): Internal.SplashManager;
        setConnectedToRealms(arg0: boolean): void;
        getFrameTimer(): Internal.FrameTimer;
        getResourcePackRepository(): Internal.PackRepository;
        getBlockEntityRenderDispatcher(): Internal.BlockEntityRenderDispatcher;
        getLevelSource(): Internal.LevelStorageSource;
        getMainRenderTarget(): Internal.RenderTarget;
        getBlockRenderer(): Internal.BlockRenderDispatcher;
        grabPanoramixScreenshot(arg0: Internal.File_, arg1: number, arg2: number): Internal.Component;
        makeWorldStem(arg0: Internal.PackRepository_, arg1: boolean, arg2: Internal.WorldStem$DataPackConfigSupplier_, arg3: Internal.WorldStem$WorldDataSupplier_): Internal.WorldStem;
        getSkinManager(): Internal.SkinManager;
        allowsRealms(): boolean;
        getGpuWarnlistManager(): Internal.GpuWarnlistManager;
        getVersionType(): string;
        forceSetScreen(arg0: Internal.Screen_): void;
        is64Bit(): boolean;
        getTextureManager(): Internal.TextureManager;
        ask(arg0: Internal.Function_<any, any>): Internal.CompletableFuture<Source>;
        getHotbarManager(): Internal.HotbarManager;
        run(): void;
        static fillReport(arg0: Internal.Minecraft_, arg1: Internal.LanguageManager_, arg2: string, arg3: Internal.Options_, arg4: Internal.CrashReport_): void;
        resizeDisplay(): void;
        setOverlay(arg0: Internal.Overlay_): void;
        static useAmbientOcclusion(): boolean;
        delayCrash(arg0: Internal.Supplier_<Internal.CrashReport_>): void;
        hasSingleplayerServer(): boolean;
        isLocalServer(): boolean;
        getTutorial(): Internal.Tutorial;
        getEntityModels(): Internal.EntityModelSet;
        getClientPackSource(): Internal.ClientPackSource;
        getDeltaFrameTime(): number;
        makeWorldStem(arg0: Internal.LevelStorageSource$LevelStorageAccess_, arg1: boolean): Internal.WorldStem;
        setCurrentServer(arg0: Internal.ServerData_): void;
        clearLevel(): void;
        setWindowActive(arg0: boolean): void;
        static useFancyGraphics(): boolean;
        clearResourcePacksOnError(arg0: Internal.Throwable_, arg1: Internal.Component_): void;
        getMusicManager(): Internal.MusicManager;
        delayTextureReload(): Internal.CompletableFuture<void>;
        getTextureAtlas(arg0: ResourceLocation_): Internal.Function<ResourceLocation, Internal.TextureAtlasSprite>;
        addCustomNbtData(arg0: Internal.ItemStack_, arg1: Internal.BlockEntity_): Internal.ItemStack;
        static crash(arg0: Internal.CrashReport_): void;
        getMobEffectTextures(): Internal.MobEffectTextureManager;
        getMinecraftSessionService(): Internal.MinecraftSessionService;
        getFrameTime(): number;
        getItemInHandRenderer(): Internal.ItemInHandRenderer;
        getPaintingTextures(): Internal.PaintingTextureManager;
        reloadResourcePacks(): Internal.CompletableFuture<void>;
        getLanguageManager(): Internal.LanguageManager;
        getItemColors(): Internal.ItemColors;
        getSearchTree(arg0: Internal.SearchRegistry$Key_<T>): Internal.MutableSearchTree<T>;
        allowsMultiplayer(): boolean;
        getWindow(): Internal.Window;
        debugClientMetricsStart(arg0: Internal.Consumer_<Internal.TranslatableComponent_>): boolean;
        prepareForMultiplayer(): void;
        setCameraEntity(arg0: Internal.Entity_): void;
        getChatStatus(): Internal.Minecraft$ChatStatus;
        createLevel(arg0: string, arg1: Internal.LevelSettings_, arg2: Internal.RegistryAccess_, arg3: Internal.WorldGenSettings_): void;
        getProfileProperties(): Internal.PropertyMap;
        pauseGame(arg0: boolean): void;
        getEntityRenderDispatcher(): Internal.EntityRenderDispatcher;
        isEnforceUnicode(): boolean;
        setLevel(arg0: Internal.ClientLevel_): void;
        getResourcePackDirectory(): Internal.File;
        updateTitle(): void;
        isRunning(): boolean;
        getSituationalMusic(): Internal.Music;
        getSearchTreeManager(): Internal.SearchRegistry;
        tick(): void;
        getProgressListener(): Internal.StoringChunkProgressListener;
        updateMaxMipLevel(arg0: number): void;
        isTextFilteringEnabled(): boolean;
        stop(): void;
        isPaused(): boolean;
        getItemRenderer(): Internal.ItemRenderer;
        getUser(): Internal.User;
        createTelemetryManager(): Internal.ClientTelemetryManager;
        static getInstance(): Internal.Minecraft;
        getSingleplayerServer(): Internal.IntegratedServer;
        getProfiler(): Internal.ProfilerFiller;
        static checkModStatus(): Internal.ModCheck;
        getGame(): Internal.Game;
        isConnectedToRealms(): boolean;
        fillReport(arg0: Internal.CrashReport_): Internal.CrashReport;
        createSearchTrees(): void;
        isDemo(): boolean;
        emergencySave(): void;
        popGuiLayer(): void;
        setScreen(arg0: Internal.Screen_): void;
        getPlayerSocialManager(): Internal.PlayerSocialManager;
        isBlocked(arg0: Internal.UUID_): boolean;
        getModelManager(): Internal.ModelManager;
        renderBuffers(): Internal.RenderBuffers;
        getConnection(): Internal.ClientPacketListener;
        isWindowActive(): boolean;
        static renderNames(): boolean;
        close(): void;
        getFixerUpper(): Internal.DataFixer;
        getLaunchedVersion(): string;
        cursorEntered(): void;
        getCameraEntity(): Internal.Entity;
        getBlockColors(): Internal.BlockColors;
        get currentServer(): Internal.ServerData
        get resourceManager(): Internal.ResourceManager
        get proxy(): Internal.Proxy
        get overlay(): Internal.Overlay
        get toasts(): Internal.ToastComponent
        get soundManager(): Internal.SoundManager
        get splashManager(): Internal.SplashManager
        set connectedToRealms(arg0: boolean)
        get frameTimer(): Internal.FrameTimer
        get resourcePackRepository(): Internal.PackRepository
        get blockEntityRenderDispatcher(): Internal.BlockEntityRenderDispatcher
        get levelSource(): Internal.LevelStorageSource
        get mainRenderTarget(): Internal.RenderTarget
        get blockRenderer(): Internal.BlockRenderDispatcher
        get skinManager(): Internal.SkinManager
        get gpuWarnlistManager(): Internal.GpuWarnlistManager
        get versionType(): string
        get textureManager(): Internal.TextureManager
        get hotbarManager(): Internal.HotbarManager
        set overlay(arg0: Internal.Overlay_)
        get localServer(): boolean
        get tutorial(): Internal.Tutorial
        get entityModels(): Internal.EntityModelSet
        get clientPackSource(): Internal.ClientPackSource
        get deltaFrameTime(): number
        set currentServer(arg0: Internal.ServerData_)
        set windowActive(arg0: boolean)
        get musicManager(): Internal.MusicManager
        get mobEffectTextures(): Internal.MobEffectTextureManager
        get minecraftSessionService(): Internal.MinecraftSessionService
        get frameTime(): number
        get itemInHandRenderer(): Internal.ItemInHandRenderer
        get paintingTextures(): Internal.PaintingTextureManager
        get languageManager(): Internal.LanguageManager
        get itemColors(): Internal.ItemColors
        get window(): Internal.Window
        set cameraEntity(arg0: Internal.Entity_)
        get chatStatus(): Internal.Minecraft$ChatStatus
        get profileProperties(): Internal.PropertyMap
        get entityRenderDispatcher(): Internal.EntityRenderDispatcher
        get enforceUnicode(): boolean
        set level(arg0: Internal.ClientLevel_)
        get resourcePackDirectory(): Internal.File
        get running(): boolean
        get situationalMusic(): Internal.Music
        get searchTreeManager(): Internal.SearchRegistry
        get progressListener(): Internal.StoringChunkProgressListener
        get textFilteringEnabled(): boolean
        get paused(): boolean
        get itemRenderer(): Internal.ItemRenderer
        get user(): Internal.User
        get instance(): Internal.Minecraft
        get singleplayerServer(): Internal.IntegratedServer
        get profiler(): Internal.ProfilerFiller
        get game(): Internal.Game
        get connectedToRealms(): boolean
        get demo(): boolean
        set screen(arg0: Internal.Screen_)
        get playerSocialManager(): Internal.PlayerSocialManager
        get modelManager(): Internal.ModelManager
        get connection(): Internal.ClientPacketListener
        get windowActive(): boolean
        get fixerUpper(): Internal.DataFixer
        get launchedVersion(): string
        get cameraEntity(): Internal.Entity
        get blockColors(): Internal.BlockColors
        "level": Internal.ClientLevel;
        readonly static "UNIFORM_FONT": ResourceLocation;
        readonly "frameTimer": Internal.FrameTimer;
        "fpsString": string;
        readonly static "DEFAULT_FONT": ResourceLocation;
        readonly "options": Internal.Options;
        "chunkPath": boolean;
        "noRender": boolean;
        "cameraEntity": Internal.Entity;
        "hitResult": Internal.HitResult;
        readonly static "ON_OSX": false;
        readonly "textureManager": Internal.TextureManager;
        readonly "debugRenderer": Internal.DebugRenderer;
        readonly "gameDirectory": Internal.File;
        "chunkVisibility": boolean;
        readonly "particleEngine": Internal.ParticleEngine;
        "screen": Internal.Screen;
        "gameMode": Internal.MultiPlayerGameMode;
        readonly "gameRenderer": Internal.GameRenderer;
        readonly static "UPDATE_DRIVERS_ADVICE": "Please make sure you have up-to-date drivers (see aka.ms/mcdriver for instructions).";
        readonly "mouseHandler": Internal.MouseHandler;
        "smartCull": boolean;
        readonly "font": Internal.Font;
        readonly static "ALT_FONT": ResourceLocation;
        readonly "gui": Internal.Gui;
        "wireframe": boolean;
        "crosshairPickEntity": Internal.Entity;
        readonly "keyboardHandler": Internal.KeyboardHandler;
        readonly "levelRenderer": Internal.LevelRenderer;
        "player": Internal.LocalPlayer;
    }
    type Minecraft_ = Minecraft;
    class DataResult$PartialResult <R> {
        constructor(arg0: string, arg1: Internal.Optional_<R>)
        message(): string;
        hashCode(): number;
        toString(): string;
        flatMap(arg0: Internal.Function_<R, Internal.DataResult$PartialResult_<R2>>): Internal.DataResult$PartialResult<R2>;
        equals(arg0: any): boolean;
        map(arg0: Internal.Function_<any, any>): Internal.DataResult$PartialResult<R2>;
    }
    type DataResult$PartialResult_<R> = DataResult$PartialResult<R>;
    interface ICondition$IContext {
        getTag(arg0: Internal.TagKey_<T>): net.minecraft.tags.Tag<Internal.Holder<T>>;
        getAllTags(arg0: Internal.ResourceKey_<any>): Internal.Map<ResourceLocation, net.minecraft.tags.Tag<Internal.Holder<T>>>;
        readonly static "EMPTY": any;
    }
    type ICondition$IContext_ = ICondition$IContext;
    class Painter implements Internal.UnitVariables {
        getObject(key: string): Internal.PainterObject;
        inGameScreenDraw(matrices: Internal.PoseStack_, delta: number): void;
        guiScreenDraw(screen: Internal.Screen_, matrices: Internal.PoseStack_, mouseX: number, mouseY: number, delta: number): void;
        clear(): void;
        make(type: string): Internal.PainterObject;
        getVariables(): Internal.VariableSet;
        paint(root: Internal.CompoundTag_): void;
        unitOf(o: any): Internal.Unit;
        setVariable(key: string, variable: Internal.Unit_): void;
        get variables(): Internal.VariableSet
        readonly static "RIGHT": 1;
        readonly static "CENTER": 0;
        readonly "screenWidthUnit": Internal.MutableNumberUnit;
        readonly "mouseYUnit": Internal.MutableNumberUnit;
        readonly static "DRAW_INGAME": 1;
        readonly "mouseXUnit": Internal.MutableNumberUnit;
        readonly static "TOP": -1;
        readonly "screenHeightUnit": Internal.MutableNumberUnit;
        readonly static "BOTTOM": 1;
        readonly static "INSTANCE": Internal.Painter;
        readonly static "DRAW_GUI": 2;
        readonly static "LEFT": -1;
        readonly "deltaUnit": Internal.MutableNumberUnit;
        readonly static "DRAW_ALWAYS": 0;
        readonly "unitContext": Internal.UnitContext;
    }
    type Painter_ = Painter;
    class WeightedListInt extends Internal.IntProvider {
        constructor(arg0: Internal.SimpleWeightedRandomList_<Internal.IntProvider_>)
        getMinValue(): number;
        getType(): Internal.IntProviderType<any>;
        getMaxValue(): number;
        sample(arg0: Internal.Random_): number;
        get minValue(): number
        get type(): Internal.IntProviderType<any>
        get maxValue(): number
        readonly static "CODEC": any;
    }
    type WeightedListInt_ = WeightedListInt;
    class LivingEntityDeathEventJS extends Internal.LivingEntityEventJS {
        constructor(entity: Internal.LivingEntity_, source: Internal.DamageSource_)
        getEntity(): Internal.EntityJS;
        canCancel(): boolean;
        getSource(): Internal.DamageSource;
        get entity(): Internal.EntityJS
        get source(): Internal.DamageSource
    }
    type LivingEntityDeathEventJS_ = LivingEntityDeathEventJS;
    class Tutorial {
        constructor(arg0: Internal.Minecraft_, arg1: Internal.Options_)
        onMouse(arg0: number, arg1: number): void;
        setStep(arg0: Internal.TutorialSteps_): void;
        getMinecraft(): Internal.Minecraft;
        isSurvival(): boolean;
        onInventoryAction(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.ClickAction_): void;
        addTimedToast(arg0: Internal.TutorialToast_, arg1: number): void;
        onOpenInventory(): void;
        tick(): void;
        static key(arg0: string): Internal.Component;
        removeTimedToast(arg0: Internal.TutorialToast_): void;
        start(): void;
        onDestroyBlock(arg0: Internal.ClientLevel_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: number): void;
        onLookAt(arg0: Internal.ClientLevel_, arg1: Internal.HitResult_): void;
        onInput(arg0: Internal.Input_): void;
        stop(): void;
        onGetItem(arg0: Internal.ItemStack_): void;
        set step(arg0: Internal.TutorialSteps_)
        get minecraft(): Internal.Minecraft
        get survival(): boolean
    }
    type Tutorial_ = Tutorial;
    class ScriptManager {
        constructor(t: Internal.ScriptType_, p: Internal.Path_, e: string)
        unload(): void;
        isClassAllowed(name: string): boolean;
        handler$zbd000$loadJavaClass(event: Internal.BindingsEvent_, args: any[], cir: Internal.CallbackInfoReturnable_<any>): void;
        loadJavaClass(event: Internal.BindingsEvent_, args: any[]): Internal.NativeJavaClass;
        load(): void;
        loadFromDirectory(): void;
        "firstLoad": boolean;
        readonly "directory": Internal.Path;
        readonly "packs": Internal.Map<string, Internal.ScriptPack>;
        readonly "events": Internal.EventsJS;
        readonly "exampleScript": string;
        readonly "type": Internal.ScriptType;
    }
    type ScriptManager_ = ScriptManager;
    class PlayerEvent$SaveToFile extends Internal.PlayerEvent {
        constructor()
        constructor(arg0: Internal.Player_, arg1: Internal.File_, arg2: string)
        getListenerList(): Internal.ListenerList;
        getPlayerFile(arg0: string): Internal.File;
        getPlayerDirectory(): Internal.File;
        getPlayerUUID(): string;
        get listenerList(): Internal.ListenerList
        get playerDirectory(): Internal.File
        get playerUUID(): string
    }
    type PlayerEvent$SaveToFile_ = PlayerEvent$SaveToFile;
    class InventoryEventJS extends Internal.PlayerEventJS {
        constructor(player: Internal.Player_, menu: Internal.AbstractContainerMenu_)
        getEntity(): Internal.EntityJS;
        getInventoryContainer(): Internal.AbstractContainerMenu;
        get entity(): Internal.EntityJS
        get inventoryContainer(): Internal.AbstractContainerMenu
    }
    type InventoryEventJS_ = InventoryEventJS;
    interface Object2CharFunction <K> extends it.unimi.dsi.fastutil.Function<K, string>, Internal.ToIntFunction<K> {
        put(arg0: K, arg1: string): string;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2CharFunction;
        getOrDefault(arg0: any, arg1: string): string;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Object2ShortFunction<K>;
        removeChar(arg0: any): string;
        composeReference(arg0: Internal.Reference2ObjectFunction_<any, any>): Internal.Reference2CharFunction<T>;
        getOrDefault(arg0: any, arg1: any): any;
        defaultReturnValue(): string;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Object2IntFunction<K>;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2CharFunction;
        composeObject(arg0: Internal.Object2ObjectFunction_<any, any>): Internal.Object2CharFunction<T>;
        containsKey(arg0: any): boolean;
        getChar(arg0: any): string;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2CharFunction;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2CharFunction;
        put(arg0: K, arg1: string): string;
        defaultReturnValue(arg0: string): void;
        get(arg0: any): string;
        put(arg0: any, arg1: any): any;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, T>;
        apply(arg0: K): string;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Object2ByteFunction<K>;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Object2LongFunction<K>;
        applyAsInt(arg0: K): number;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2CharFunction;
        size(): number;
        andThenReference(arg0: Internal.Char2ReferenceFunction_<any>): Internal.Object2ReferenceFunction<K, T>;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2CharFunction;
        andThenChar(arg0: Internal.Char2CharFunction_): this;
        andThenObject(arg0: Internal.Char2ObjectFunction_<any>): Internal.Object2ObjectFunction<K, T>;
        clear(): void;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Object2FloatFunction<K>;
        getOrDefault(arg0: any, arg1: string): string;
        remove(arg0: any): any;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, string>;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2CharFunction;
    }
    type Object2CharFunction_<K> = ((arg0: any)=>string) | Object2CharFunction<K>;
}
declare namespace com.mojang.authlib.properties {
    class Property {
        constructor(arg0: string, arg1: string, arg2: string)
        constructor(arg0: string, arg1: string)
        isSignatureValid(arg0: Internal.PublicKey_): boolean;
        getValue(): string;
        getName(): string;
        getSignature(): string;
        hasSignature(): boolean;
        get value(): string
        get name(): string
        get signature(): string
    }
    type Property_ = Property;
}
declare namespace com.mojang.blaze3d.audio {
    class Channel {
        destroy(): void;
        setSelfPosition(arg0: Vec3_): void;
        unpause(): void;
        disableAttenuation(): void;
        attachBufferStream(arg0: Internal.AudioStream_): void;
        playing(): boolean;
        updateStream(): void;
        attachStaticBuffer(arg0: Internal.SoundBuffer_): void;
        linearAttenuation(arg0: number): void;
        setLooping(arg0: boolean): void;
        play(): void;
        setRelative(arg0: boolean): void;
        setPitch(arg0: number): void;
        stop(): void;
        pause(): void;
        setVolume(arg0: number): void;
        stopped(): boolean;
        set selfPosition(arg0: Vec3_)
        set looping(arg0: boolean)
        set relative(arg0: boolean)
        set pitch(arg0: number)
        set volume(arg0: number)
        readonly static "BUFFER_DURATION_SECONDS": 1;
    }
    type Channel_ = Channel;
}
declare namespace io.netty.util.concurrent {
    interface ScheduledFuture <V> extends io.netty.util.concurrent.Future<V>, Internal.ScheduledFuture<V> {
    }
    type ScheduledFuture_<V> = ScheduledFuture<V>;
    interface Future <V> extends Internal.Future<V> {
        isSuccess(): boolean;
        removeListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        cancel(arg0: boolean): boolean;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit_): boolean;
        cause(): Internal.Throwable;
        getNow(): V;
        awaitUninterruptibly(): this;
        await(arg0: number, arg1: Internal.TimeUnit_): boolean;
        addListeners(...arg0: Internal.GenericFutureListener_<any>[]): this;
        syncUninterruptibly(): this;
        await(arg0: number): boolean;
        await(): this;
        removeListener(arg0: Internal.GenericFutureListener_<any>): this;
        isCancellable(): boolean;
        addListener(arg0: Internal.GenericFutureListener_<any>): this;
        awaitUninterruptibly(arg0: number): boolean;
        sync(): this;
        get success(): boolean
        get now(): V
        get cancellable(): boolean
    }
    type Future_<V> = Future<V>;
}
declare namespace net.minecraft.world.inventory {
    interface ContainerListener {
        dataChanged(arg0: Internal.AbstractContainerMenu_, arg1: number, arg2: number): void;
        slotChanged(arg0: Internal.AbstractContainerMenu_, arg1: number, arg2: Internal.ItemStack_): void;
    }
    type ContainerListener_ = ContainerListener;
}
declare namespace Special {
    type Mod = "minecraft" | "rhino" | "forge" | "architectury" | "kubejs" | "probejs"
    type Ingredient = "kubejs:custom_predicate" | "kubejs:ignore_nbt" | "forge:compound" | "forge:nbt" | "forge:partial_nbt" | "forge:difference" | "forge:intersection" | "minecraft:item";
    type RecipeId = "minecraft:yellow_dye_from_dandelion" | "minecraft:charcoal" | "minecraft:dark_oak_button" | "minecraft:emerald_from_smelting_deepslate_emerald_ore" | "minecraft:diorite_wall_from_diorite_stonecutting" | "minecraft:polished_blackstone_brick_slab" | "minecraft:chiseled_deepslate" | "minecraft:gray_candle" | "minecraft:rabbit_stew_from_brown_mushroom" | "minecraft:red_wool" | "minecraft:stripped_dark_oak_wood" | "minecraft:stonecutter" | "minecraft:soul_torch" | "minecraft:bone_block" | "minecraft:raw_iron" | "minecraft:iron_nugget" | "minecraft:melon" | "minecraft:birch_fence" | "minecraft:cracked_deepslate_tiles" | "minecraft:deepslate_brick_stairs_from_cobbled_deepslate_stonecutting" | "minecraft:red_nether_brick_slab" | "minecraft:waxed_oxidized_cut_copper_from_honeycomb" | "minecraft:cooked_rabbit" | "minecraft:gold_nugget_from_blasting" | "minecraft:warped_fence_gate" | "minecraft:cooked_salmon_from_campfire_cooking" | "minecraft:nether_wart_block" | "minecraft:polished_blackstone_brick_slab_from_blackstone_stonecutting" | "minecraft:magenta_banner" | "minecraft:weathered_cut_copper_from_weathered_copper_stonecutting" | "minecraft:polished_blackstone_brick_wall_from_polished_blackstone_stonecutting" | "minecraft:red_bed_from_white_bed" | "minecraft:cobblestone_wall" | "minecraft:gray_dye" | "minecraft:lime_stained_glass_pane" | "minecraft:magenta_wool" | "minecraft:warped_pressure_plate" | "minecraft:cut_sandstone_slab_from_cut_sandstone_stonecutting" | "minecraft:waxed_cut_copper_slab" | "minecraft:coal_block" | "minecraft:raw_copper" | "minecraft:sugar_from_honey_bottle" | "minecraft:cyan_bed_from_white_bed" | "minecraft:black_wool" | "minecraft:slime_ball" | "minecraft:spruce_fence_gate" | "minecraft:leather_chestplate" | "minecraft:yellow_bed" | "minecraft:iron_block" | "minecraft:beehive" | "minecraft:map_extending" | "minecraft:nether_brick_slab_from_nether_bricks_stonecutting" | "minecraft:spruce_sign" | "minecraft:white_stained_glass_pane_from_glass_pane" | "minecraft:dark_oak_door" | "minecraft:cooked_porkchop" | "minecraft:waxed_cut_copper_slab_from_waxed_cut_copper_stonecutting" | "minecraft:cut_copper_slab_from_copper_block_stonecutting" | "minecraft:cooked_salmon_from_smoking" | "minecraft:writable_book" | "minecraft:birch_wood" | "minecraft:glow_item_frame" | "minecraft:leather_helmet" | "minecraft:light_blue_bed" | "minecraft:oak_wood" | "minecraft:scaffolding" | "minecraft:emerald_block" | "minecraft:golden_apple" | "minecraft:chiseled_nether_bricks" | "minecraft:diamond_pickaxe" | "minecraft:flower_pot" | "minecraft:acacia_button" | "minecraft:light_gray_dye_from_oxeye_daisy" | "minecraft:polished_granite_from_granite_stonecutting" | "minecraft:magenta_stained_glass_pane" | "minecraft:copper_block" | "minecraft:nether_brick_stairs" | "minecraft:purple_candle" | "minecraft:purple_wool" | "minecraft:chiseled_stone_bricks_from_stone_bricks_stonecutting" | "minecraft:lapis_lazuli_from_smelting_deepslate_lapis_ore" | "minecraft:polished_blackstone_bricks_from_blackstone_stonecutting" | "minecraft:magenta_bed" | "minecraft:oxidized_cut_copper_stairs_from_oxidized_copper_stonecutting" | "minecraft:end_stone_brick_slab_from_end_stone_brick_stonecutting" | "minecraft:iron_sword" | "minecraft:spruce_wood" | "minecraft:green_stained_glass" | "minecraft:magenta_dye_from_blue_red_white_dye" | "minecraft:spruce_fence" | "minecraft:mossy_stone_brick_slab" | "minecraft:andesite_slab" | "minecraft:dark_prismarine_slab" | "minecraft:polished_blackstone_wall_from_polished_blackstone_stonecutting" | "minecraft:sandstone_slab_from_sandstone_stonecutting" | "minecraft:honey_block" | "minecraft:green_dye" | "minecraft:pink_glazed_terracotta" | "minecraft:pink_terracotta" | "minecraft:dried_kelp_from_smoking" | "minecraft:chiseled_sandstone_from_sandstone_stonecutting" | "minecraft:waxed_exposed_cut_copper_stairs" | "minecraft:orange_stained_glass" | "minecraft:exposed_cut_copper_slab" | "minecraft:polished_blackstone_wall" | "minecraft:cobblestone_stairs" | "minecraft:copper_ingot_from_blasting_deepslate_copper_ore" | "minecraft:redstone_from_smelting_redstone_ore" | "minecraft:cut_sandstone_slab" | "minecraft:smooth_red_sandstone_slab" | "minecraft:stone_brick_stairs_from_stone_bricks_stonecutting" | "minecraft:cut_copper_stairs_from_cut_copper_stonecutting" | "minecraft:suspicious_stew" | "minecraft:birch_trapdoor" | "minecraft:weathered_cut_copper_slab" | "minecraft:prismarine_brick_stairs_from_prismarine_stonecutting" | "minecraft:deepslate_brick_wall_from_deepslate_bricks_stonecutting" | "minecraft:waxed_weathered_copper_from_honeycomb" | "minecraft:yellow_bed_from_white_bed" | "minecraft:golden_boots" | "minecraft:pink_dye_from_red_white_dye" | "minecraft:netherite_shovel_smithing" | "minecraft:coal_from_blasting_coal_ore" | "minecraft:andesite_wall_from_andesite_stonecutting" | "minecraft:acacia_door" | "minecraft:polished_basalt" | "minecraft:prismarine_stairs" | "minecraft:cyan_concrete_powder" | "minecraft:conduit" | "minecraft:mojang_banner_pattern" | "minecraft:polished_granite_slab" | "minecraft:fire_charge" | "minecraft:golden_hoe" | "minecraft:sticky_piston" | "minecraft:white_dye" | "minecraft:redstone" | "minecraft:blue_glazed_terracotta" | "minecraft:emerald" | "minecraft:polished_andesite_slab" | "minecraft:wooden_pickaxe" | "minecraft:powered_rail" | "minecraft:exposed_cut_copper_slab_from_exposed_copper_stonecutting" | "minecraft:firework_star" | "minecraft:green_concrete_powder" | "minecraft:nether_brick_wall_from_nether_bricks_stonecutting" | "minecraft:oxidized_cut_copper_slab_from_oxidized_cut_copper_stonecutting" | "minecraft:oak_stairs" | "minecraft:smooth_red_sandstone_slab_from_smooth_red_sandstone_stonecutting" | "minecraft:cracked_deepslate_bricks" | "minecraft:stone_button" | "minecraft:polished_blackstone_brick_stairs" | "minecraft:brown_stained_glass" | "minecraft:stick_from_bamboo_item" | "minecraft:tinted_glass" | "minecraft:blue_terracotta" | "minecraft:yellow_candle" | "minecraft:stripped_oak_wood" | "minecraft:sandstone" | "minecraft:yellow_concrete_powder" | "minecraft:gray_terracotta" | "minecraft:jungle_fence_gate" | "minecraft:diamond_from_blasting_diamond_ore" | "minecraft:comparator" | "minecraft:lodestone" | "minecraft:repeater" | "minecraft:red_concrete_powder" | "minecraft:netherite_boots_smithing" | "minecraft:purpur_block" | "minecraft:cut_copper_stairs_from_copper_block_stonecutting" | "minecraft:glass" | "minecraft:polished_blackstone_slab" | "minecraft:stone_stairs" | "minecraft:fishing_rod" | "minecraft:cooked_beef_from_smoking" | "minecraft:dried_kelp_block" | "minecraft:end_stone_brick_stairs" | "minecraft:iron_leggings" | "minecraft:terracotta" | "minecraft:stripped_crimson_hyphae" | "minecraft:quartz" | "minecraft:cyan_carpet" | "minecraft:magenta_carpet_from_white_carpet" | "minecraft:polished_deepslate_stairs_from_polished_deepslate_stonecutting" | "minecraft:nether_brick_wall" | "minecraft:book_cloning" | "minecraft:polished_basalt_from_basalt_stonecutting" | "minecraft:gray_concrete_powder" | "minecraft:light_blue_concrete_powder" | "minecraft:smooth_sandstone_stairs_from_smooth_sandstone_stonecutting" | "minecraft:granite_wall_from_granite_stonecutting" | "minecraft:redstone_from_blasting_redstone_ore" | "minecraft:gray_bed_from_white_bed" | "minecraft:granite_stairs" | "minecraft:cyan_terracotta" | "minecraft:polished_granite_slab_from_polished_granite_stonecutting" | "minecraft:cut_red_sandstone" | "minecraft:mushroom_stew" | "minecraft:polished_deepslate_from_cobbled_deepslate_stonecutting" | "minecraft:red_dye_from_tulip" | "minecraft:warped_planks" | "minecraft:lime_candle" | "minecraft:red_nether_brick_wall_from_red_nether_bricks_stonecutting" | "minecraft:red_dye_from_beetroot" | "minecraft:beacon" | "minecraft:tnt" | "minecraft:mossy_stone_bricks_from_vine" | "minecraft:waxed_weathered_cut_copper_stairs_from_waxed_weathered_cut_copper_stonecutting" | "minecraft:andesite_slab_from_andesite_stonecutting" | "minecraft:light_gray_bed" | "minecraft:flint_and_steel" | "minecraft:red_candle" | "minecraft:orange_dye_from_orange_tulip" | "minecraft:pink_bed_from_white_bed" | "minecraft:brown_carpet" | "minecraft:jungle_door" | "minecraft:black_dye" | "minecraft:black_stained_glass_pane" | "minecraft:prismarine_brick_slab" | "minecraft:prismarine_bricks" | "minecraft:nether_bricks" | "minecraft:blue_carpet" | "minecraft:deepslate_brick_stairs_from_polished_deepslate_stonecutting" | "minecraft:iron_chestplate" | "minecraft:crimson_fence" | "minecraft:stone_bricks" | "minecraft:oxidized_cut_copper_slab" | "minecraft:lapis_lazuli_from_blasting_deepslate_lapis_ore" | "minecraft:birch_stairs" | "minecraft:exposed_cut_copper_slab_from_exposed_cut_copper_stonecutting" | "minecraft:light_gray_stained_glass" | "minecraft:white_wool_from_string" | "minecraft:cobblestone_wall_from_cobblestone_stonecutting" | "minecraft:polished_andesite_from_andesite_stonecutting" | "minecraft:white_stained_glass_pane" | "minecraft:golden_axe" | "minecraft:crimson_stairs" | "minecraft:light_blue_stained_glass_pane" | "minecraft:brown_concrete_powder" | "minecraft:cooked_chicken_from_smoking" | "minecraft:cyan_glazed_terracotta" | "minecraft:cyan_stained_glass" | "minecraft:oak_pressure_plate" | "minecraft:stone_brick_stairs" | "minecraft:stone_sword" | "minecraft:yellow_dye_from_sunflower" | "minecraft:cut_red_sandstone_from_red_sandstone_stonecutting" | "minecraft:diorite" | "minecraft:acacia_fence" | "minecraft:crimson_hyphae" | "minecraft:waxed_weathered_cut_copper_slab_from_waxed_weathered_copper_stonecutting" | "minecraft:coal_from_smelting_coal_ore" | "minecraft:oak_slab" | "minecraft:orange_bed_from_white_bed" | "minecraft:cyan_banner" | "minecraft:polished_blackstone_wall_from_blackstone_stonecutting" | "minecraft:dripstone_block" | "minecraft:glistering_melon_slice" | "minecraft:smooth_stone_slab_from_smooth_stone_stonecutting" | "minecraft:crimson_button" | "minecraft:warped_door" | "minecraft:iron_hoe" | "minecraft:iron_ingot_from_iron_block" | "minecraft:jungle_planks" | "minecraft:netherite_axe_smithing" | "minecraft:snow" | "minecraft:acacia_fence_gate" | "minecraft:clock" | "minecraft:magenta_carpet" | "minecraft:orange_stained_glass_pane_from_glass_pane" | "minecraft:yellow_wool" | "minecraft:blackstone_wall_from_blackstone_stonecutting" | "minecraft:jungle_trapdoor" | "minecraft:grindstone" | "minecraft:blue_ice" | "minecraft:polished_deepslate_slab_from_polished_deepslate_stonecutting" | "minecraft:red_nether_bricks" | "minecraft:banner_duplicate" | "minecraft:granite_slab_from_granite_stonecutting" | "minecraft:glass_pane" | "minecraft:diamond_leggings" | "minecraft:granite_stairs_from_granite_stonecutting" | "minecraft:emerald_from_smelting_emerald_ore" | "minecraft:warped_slab" | "minecraft:lectern" | "minecraft:prismarine" | "minecraft:golden_sword" | "minecraft:purple_stained_glass" | "minecraft:iron_ingot_from_nuggets" | "minecraft:chiseled_sandstone" | "minecraft:clay" | "minecraft:golden_pickaxe" | "minecraft:cut_copper_stairs" | "minecraft:magenta_dye_from_allium" | "minecraft:smooth_stone_slab" | "minecraft:ladder" | "minecraft:polished_blackstone_slab_from_polished_blackstone_stonecutting" | "minecraft:redstone_torch" | "minecraft:moss_carpet" | "minecraft:oxidized_cut_copper_stairs_from_oxidized_cut_copper_stonecutting" | "minecraft:mossy_cobblestone_slab" | "minecraft:polished_andesite_slab_from_andesite_stonecutting" | "minecraft:furnace_minecart" | "minecraft:mossy_cobblestone_from_vine" | "minecraft:target" | "minecraft:polished_diorite_slab_from_diorite_stonecutting" | "minecraft:gray_wool" | "minecraft:white_concrete_powder" | "minecraft:yellow_terracotta" | "minecraft:orange_carpet" | "minecraft:mossy_stone_bricks_from_moss_block" | "minecraft:waxed_weathered_cut_copper" | "minecraft:cake" | "minecraft:gray_bed" | "minecraft:orange_banner" | "minecraft:dark_oak_sign" | "minecraft:granite_slab" | "minecraft:chiseled_nether_bricks_from_nether_bricks_stonecutting" | "minecraft:white_terracotta" | "minecraft:leather_boots" | "minecraft:diamond_from_blasting_deepslate_diamond_ore" | "minecraft:black_carpet_from_white_carpet" | "minecraft:netherite_ingot_from_netherite_block" | "minecraft:armor_stand" | "minecraft:pink_stained_glass_pane" | "minecraft:lime_concrete_powder" | "minecraft:leather_leggings" | "minecraft:sandstone_wall_from_sandstone_stonecutting" | "minecraft:blue_dye_from_cornflower" | "minecraft:brick_slab_from_bricks_stonecutting" | "minecraft:polished_blackstone_bricks_from_polished_blackstone_stonecutting" | "minecraft:quartz_slab_from_stonecutting" | "minecraft:brown_banner" | "minecraft:barrel" | "minecraft:polished_blackstone_button" | "minecraft:polished_blackstone_slab_from_blackstone_stonecutting" | "minecraft:warped_hyphae" | "minecraft:redstone_from_blasting_deepslate_redstone_ore" | "minecraft:netherite_scrap_from_blasting" | "minecraft:red_nether_brick_slab_from_red_nether_bricks_stonecutting" | "minecraft:dark_prismarine_slab_from_dark_prismarine_stonecutting" | "minecraft:lime_stained_glass_pane_from_glass_pane" | "minecraft:baked_potato_from_smoking" | "minecraft:magenta_glazed_terracotta" | "minecraft:deepslate_brick_slab_from_polished_deepslate_stonecutting" | "minecraft:brown_carpet_from_white_carpet" | "minecraft:chiseled_stone_bricks_stone_from_stonecutting" | "minecraft:book" | "minecraft:chiseled_stone_bricks" | "minecraft:netherite_sword_smithing" | "minecraft:polished_blackstone_brick_wall_from_blackstone_stonecutting" | "minecraft:wooden_shovel" | "minecraft:end_stone_brick_slab" | "minecraft:smithing_table" | "minecraft:green_bed" | "minecraft:deepslate_tile_slab_from_polished_deepslate_stonecutting" | "minecraft:magma_block" | "minecraft:polished_granite_stairs_from_granite_stonecutting" | "minecraft:red_sandstone_slab_from_red_sandstone_stonecutting" | "minecraft:spruce_pressure_plate" | "minecraft:polished_blackstone_brick_stairs_from_polished_blackstone_stonecutting" | "minecraft:purple_terracotta" | "minecraft:cauldron" | "minecraft:pink_concrete_powder" | "minecraft:red_nether_brick_stairs_from_red_nether_bricks_stonecutting" | "minecraft:waxed_copper_block_from_honeycomb" | "minecraft:magenta_concrete_powder" | "minecraft:red_dye_from_poppy" | "minecraft:redstone_from_smelting_deepslate_redstone_ore" | "minecraft:deepslate_tiles_from_deepslate_bricks_stonecutting" | "minecraft:diamond_shovel" | "minecraft:warped_fungus_on_a_stick" | "minecraft:waxed_weathered_cut_copper_slab_from_honeycomb" | "minecraft:deepslate_tile_slab_from_deepslate_tiles_stonecutting" | "minecraft:prismarine_brick_slab_from_prismarine_stonecutting" | "minecraft:andesite_wall" | "minecraft:sandstone_slab" | "minecraft:hay_block" | "minecraft:light_blue_candle" | "minecraft:waxed_oxidized_cut_copper_stairs_from_waxed_oxidized_cut_copper_stonecutting" | "minecraft:cobblestone_slab" | "minecraft:gold_ingot_from_smelting_raw_gold" | "minecraft:iron_ingot_from_blasting_deepslate_iron_ore" | "minecraft:gray_banner" | "minecraft:warped_stairs" | "minecraft:gold_ingot_from_smelting_gold_ore" | "minecraft:cracked_polished_blackstone_bricks" | "minecraft:deepslate_brick_slab_from_cobbled_deepslate_stonecutting" | "minecraft:deepslate_tile_wall_from_deepslate_tiles_stonecutting" | "minecraft:end_stone_bricks_from_end_stone_stonecutting" | "minecraft:mossy_stone_brick_slab_from_mossy_stone_brick_stonecutting" | "minecraft:popped_chorus_fruit" | "minecraft:cooked_cod_from_smoking" | "minecraft:minecart" | "minecraft:stone_bricks_from_stone_stonecutting" | "minecraft:smooth_sandstone_slab" | "minecraft:smooth_quartz_slab_from_smooth_quartz_stonecutting" | "minecraft:chest" | "minecraft:gray_stained_glass" | "minecraft:rail" | "minecraft:pink_candle" | "minecraft:diamond_sword" | "minecraft:red_terracotta" | "minecraft:yellow_banner" | "minecraft:creeper_banner_pattern" | "minecraft:waxed_exposed_cut_copper_slab" | "minecraft:red_bed" | "minecraft:dark_oak_fence" | "minecraft:golden_shovel" | "minecraft:cut_copper" | "minecraft:deepslate_tile_stairs" | "minecraft:purpur_stairs_from_purpur_block_stonecutting" | "minecraft:soul_lantern" | "minecraft:copper_ingot" | "minecraft:deepslate_bricks_from_cobbled_deepslate_stonecutting" | "minecraft:waxed_weathered_cut_copper_slab" | "minecraft:white_dye_from_lily_of_the_valley" | "minecraft:crimson_trapdoor" | "minecraft:waxed_oxidized_cut_copper_slab_from_waxed_oxidized_copper_stonecutting" | "minecraft:oxidized_cut_copper_slab_from_oxidized_copper_stonecutting" | "minecraft:brick_wall_from_bricks_stonecutting" | "minecraft:end_stone_brick_wall" | "minecraft:firework_star_fade" | "minecraft:polished_diorite_slab" | "minecraft:brown_glazed_terracotta" | "minecraft:smooth_sandstone_stairs" | "minecraft:blaze_powder" | "minecraft:end_stone_brick_slab_from_end_stone_stonecutting" | "minecraft:waxed_exposed_cut_copper_slab_from_waxed_exposed_cut_copper_stonecutting" | "minecraft:copper_ingot_from_blasting_copper_ore" | "minecraft:smooth_basalt" | "minecraft:chain" | "minecraft:orange_carpet_from_white_carpet" | "minecraft:polished_blackstone_from_blackstone_stonecutting" | "minecraft:blue_concrete_powder" | "minecraft:blue_stained_glass" | "minecraft:iron_ingot_from_smelting_deepslate_iron_ore" | "minecraft:oak_fence" | "minecraft:warped_trapdoor" | "minecraft:chiseled_deepslate_from_cobbled_deepslate_stonecutting" | "minecraft:rabbit_stew_from_red_mushroom" | "minecraft:iron_boots" | "minecraft:netherite_hoe_smithing" | "minecraft:polished_blackstone_brick_stairs_from_polished_blackstone_bricks_stonecutting" | "minecraft:prismarine_brick_stairs" | "minecraft:diamond_chestplate" | "minecraft:waxed_oxidized_cut_copper_stairs_from_honeycomb" | "minecraft:golden_chestplate" | "minecraft:netherite_chestplate_smithing" | "minecraft:copper_ingot_from_smelting_raw_copper" | "minecraft:prismarine_stairs_from_prismarine_stonecutting" | "minecraft:crimson_planks" | "minecraft:oak_sign" | "minecraft:smooth_red_sandstone" | "minecraft:quartz_stairs_from_quartz_block_stonecutting" | "minecraft:blue_candle" | "minecraft:netherite_ingot" | "minecraft:birch_sign" | "minecraft:magenta_bed_from_white_bed" | "minecraft:exposed_cut_copper_stairs_from_exposed_copper_stonecutting" | "minecraft:diamond_from_smelting_deepslate_diamond_ore" | "minecraft:birch_pressure_plate" | "minecraft:flower_banner_pattern" | "minecraft:netherite_block" | "minecraft:cyan_carpet_from_white_carpet" | "minecraft:deepslate" | "minecraft:light_blue_terracotta" | "minecraft:orange_dye_from_red_yellow" | "minecraft:red_sandstone_stairs_from_red_sandstone_stonecutting" | "minecraft:purple_carpet_from_white_carpet" | "minecraft:spruce_stairs" | "minecraft:emerald_from_blasting_deepslate_emerald_ore" | "minecraft:polished_blackstone_brick_slab_from_polished_blackstone_bricks_stonecutting" | "minecraft:smooth_sandstone_slab_from_smooth_sandstone_stonecutting" | "minecraft:black_bed" | "minecraft:gold_ingot_from_blasting_raw_gold" | "minecraft:jungle_sign" | "minecraft:cyan_candle" | "minecraft:iron_nugget_from_blasting" | "minecraft:cut_red_sandstone_slab_from_red_sandstone_stonecutting" | "minecraft:diamond_from_smelting_diamond_ore" | "minecraft:gold_ingot_from_blasting_gold_ore" | "minecraft:crossbow" | "minecraft:light_gray_dye_from_azure_bluet" | "minecraft:light_gray_dye_from_white_tulip" | "minecraft:shield_decoration" | "minecraft:deepslate_tile_wall_from_cobbled_deepslate_stonecutting" | "minecraft:bowl" | "minecraft:diamond" | "minecraft:magenta_candle" | "minecraft:green_stained_glass_pane" | "minecraft:crimson_slab" | "minecraft:green_bed_from_white_bed" | "minecraft:magenta_dye_from_blue_red_pink" | "minecraft:black_concrete_powder" | "minecraft:prismarine_slab_from_prismarine_stonecutting" | "minecraft:lime_carpet" | "minecraft:purple_banner" | "minecraft:purple_concrete_powder" | "minecraft:sugar_from_sugar_cane" | "minecraft:birch_planks" | "minecraft:polished_deepslate_slab_from_cobbled_deepslate_stonecutting" | "minecraft:light_gray_dye_from_black_white_dye" | "minecraft:deepslate_tile_wall_from_deepslate_bricks_stonecutting" | "minecraft:light_gray_stained_glass_pane" | "minecraft:spectral_arrow" | "minecraft:green_terracotta" | "minecraft:tnt_minecart" | "minecraft:red_carpet" | "minecraft:white_stained_glass" | "minecraft:acacia_planks" | "minecraft:slime_block" | "minecraft:cooked_beef_from_campfire_cooking" | "minecraft:wooden_hoe" | "minecraft:quartz_pillar" | "minecraft:cooked_rabbit_from_campfire_cooking" | "minecraft:waxed_cut_copper_from_honeycomb" | "minecraft:light_gray_bed_from_white_bed" | "minecraft:waxed_oxidized_cut_copper_from_waxed_oxidized_copper_stonecutting" | "minecraft:purpur_stairs" | "minecraft:brown_terracotta" | "minecraft:waxed_oxidized_cut_copper_stairs" | "minecraft:blue_wool" | "minecraft:mossy_cobblestone_stairs" | "minecraft:note_block" | "minecraft:weathered_cut_copper_stairs_from_weathered_cut_copper_stonecutting" | "minecraft:blue_dye" | "minecraft:polished_diorite_slab_from_polished_diorite_stonecutting" | "minecraft:waxed_weathered_cut_copper_stairs_from_waxed_weathered_copper_stonecutting" | "minecraft:blackstone_stairs_from_blackstone_stonecutting" | "minecraft:piston" | "minecraft:waxed_weathered_cut_copper_from_waxed_weathered_copper_stonecutting" | "minecraft:brown_bed" | "minecraft:blue_bed" | "minecraft:light_gray_carpet" | "minecraft:weathered_cut_copper_slab_from_weathered_copper_stonecutting" | "minecraft:white_banner" | "minecraft:smooth_quartz" | "minecraft:end_crystal" | "minecraft:magenta_stained_glass_pane_from_glass_pane" | "minecraft:smooth_red_sandstone_stairs" | "minecraft:smooth_sandstone" | "minecraft:light_gray_banner" | "minecraft:stone_pickaxe" | "minecraft:light_blue_glazed_terracotta" | "minecraft:shulker_box" | "minecraft:cut_red_sandstone_slab_from_cut_red_sandstone_stonecutting" | "minecraft:dispenser" | "minecraft:wooden_axe" | "minecraft:cyan_stained_glass_pane" | "minecraft:daylight_detector" | "minecraft:sponge" | "minecraft:quartz_stairs" | "minecraft:diorite_wall" | "minecraft:quartz_from_blasting" | "minecraft:purple_glazed_terracotta" | "minecraft:white_carpet" | "minecraft:spruce_planks" | "minecraft:mossy_cobblestone_stairs_from_mossy_cobblestone_stonecutting" | "minecraft:red_stained_glass" | "minecraft:light_gray_stained_glass_pane_from_glass_pane" | "minecraft:green_carpet" | "minecraft:polished_blackstone_bricks" | "minecraft:purpur_slab" | "minecraft:waxed_exposed_cut_copper_from_honeycomb" | "minecraft:mossy_cobblestone_from_moss_block" | "minecraft:cracked_stone_bricks" | "minecraft:jack_o_lantern" | "minecraft:tripwire_hook" | "minecraft:chiseled_polished_blackstone_from_blackstone_stonecutting" | "minecraft:diorite_stairs_from_diorite_stonecutting" | "minecraft:trapped_chest" | "minecraft:hopper" | "minecraft:cut_sandstone_from_sandstone_stonecutting" | "minecraft:stone_stairs_from_stone_stonecutting" | "minecraft:lantern" | "minecraft:raw_gold" | "minecraft:waxed_cut_copper_slab_from_waxed_copper_block_stonecutting" | "minecraft:green_banner" | "minecraft:dried_kelp" | "minecraft:ender_chest" | "minecraft:magenta_stained_glass" | "minecraft:gold_nugget" | "minecraft:polished_andesite_stairs_from_andesite_stonecutting" | "minecraft:iron_bars" | "minecraft:beetroot_soup" | "minecraft:iron_trapdoor" | "minecraft:brown_candle" | "minecraft:deepslate_brick_wall" | "minecraft:green_glazed_terracotta" | "minecraft:lime_terracotta" | "minecraft:cooked_cod" | "minecraft:diamond_axe" | "minecraft:iron_helmet" | "minecraft:blackstone_slab_from_blackstone_stonecutting" | "minecraft:jungle_wood" | "minecraft:waxed_oxidized_cut_copper" | "minecraft:lime_bed_from_white_bed" | "minecraft:cartography_table" | "minecraft:gray_stained_glass_pane_from_glass_pane" | "minecraft:polished_diorite" | "minecraft:stone_slab" | "minecraft:acacia_pressure_plate" | "minecraft:lime_bed" | "minecraft:dark_oak_pressure_plate" | "minecraft:acacia_slab" | "minecraft:brick_stairs_from_bricks_stonecutting" | "minecraft:jungle_stairs" | "minecraft:cooked_porkchop_from_smoking" | "minecraft:blast_furnace" | "minecraft:polished_andesite_stairs" | "minecraft:deepslate_brick_stairs_from_deepslate_bricks_stonecutting" | "minecraft:light_blue_stained_glass_pane_from_glass_pane" | "minecraft:magenta_dye_from_lilac" | "minecraft:waxed_weathered_cut_copper_from_honeycomb" | "minecraft:lime_carpet_from_white_carpet" | "minecraft:lime_wool" | "minecraft:purple_bed_from_white_bed" | "minecraft:light_gray_wool" | "minecraft:tipped_arrow" | "minecraft:waxed_cut_copper" | "minecraft:blue_stained_glass_pane_from_glass_pane" | "minecraft:light_blue_carpet" | "minecraft:chiseled_polished_blackstone" | "minecraft:firework_rocket" | "minecraft:turtle_helmet" | "minecraft:polished_andesite_slab_from_polished_andesite_stonecutting" | "minecraft:red_sandstone_wall_from_red_sandstone_stonecutting" | "minecraft:gold_ingot_from_smelting_deepslate_gold_ore" | "minecraft:cobbled_deepslate_stairs" | "minecraft:baked_potato" | "minecraft:fletching_table" | "minecraft:light_blue_banner" | "minecraft:waxed_exposed_cut_copper_stairs_from_waxed_exposed_copper_stonecutting" | "minecraft:cooked_salmon" | "minecraft:light_gray_dye_from_gray_white_dye" | "minecraft:mossy_cobblestone_wall" | "minecraft:spyglass" | "minecraft:magenta_dye_from_purple_and_pink" | "minecraft:red_banner" | "minecraft:purpur_pillar" | "minecraft:heavy_weighted_pressure_plate" | "minecraft:deepslate_tile_slab" | "minecraft:pink_stained_glass" | "minecraft:stone_shovel" | "minecraft:golden_leggings" | "minecraft:stripped_birch_wood" | "minecraft:deepslate_tiles_from_polished_deepslate_stonecutting" | "minecraft:waxed_oxidized_cut_copper_slab" | "minecraft:end_stone_brick_wall_from_end_stone_brick_stonecutting" | "minecraft:polished_blackstone_stairs" | "minecraft:lime_banner" | "minecraft:netherite_pickaxe_smithing" | "minecraft:deepslate_brick_stairs" | "minecraft:stone_pressure_plate" | "minecraft:dropper" | "minecraft:redstone_lamp" | "minecraft:yellow_stained_glass_pane" | "minecraft:black_carpet" | "minecraft:deepslate_brick_wall_from_cobbled_deepslate_stonecutting" | "minecraft:end_rod" | "minecraft:cut_copper_from_copper_block_stonecutting" | "minecraft:diorite_slab_from_diorite_stonecutting" | "minecraft:iron_ingot_from_blasting_iron_ore" | "minecraft:lime_dye_from_smelting" | "minecraft:polished_andesite_stairs_from_polished_andesite_stonecutting" | "minecraft:deepslate_tile_stairs_from_deepslate_tiles_stonecutting" | "minecraft:golden_helmet" | "minecraft:light_blue_dye_from_blue_orchid" | "minecraft:weathered_cut_copper_stairs" | "minecraft:mossy_stone_brick_wall_from_mossy_stone_brick_stonecutting" | "minecraft:warped_button" | "minecraft:waxed_oxidized_cut_copper_slab_from_honeycomb" | "minecraft:polished_deepslate" | "minecraft:oxidized_cut_copper_from_oxidized_copper_stonecutting" | "minecraft:bone_meal_from_bone_block" | "minecraft:bread" | "minecraft:torch" | "minecraft:polished_granite_stairs" | "minecraft:acacia_boat" | "minecraft:armor_dye" | "minecraft:lever" | "minecraft:end_stone_brick_wall_from_end_stone_stonecutting" | "minecraft:cobbled_deepslate_slab_from_cobbled_deepslate_stonecutting" | "minecraft:map" | "minecraft:detector_rail" | "minecraft:pink_bed" | "minecraft:shield" | "minecraft:blackstone_slab" | "minecraft:cooked_porkchop_from_campfire_cooking" | "minecraft:crimson_sign" | "minecraft:cyan_stained_glass_pane_from_glass_pane" | "minecraft:dark_oak_trapdoor" | "minecraft:waxed_exposed_cut_copper_slab_from_waxed_exposed_copper_stonecutting" | "minecraft:black_banner" | "minecraft:green_carpet_from_white_carpet" | "minecraft:painting" | "minecraft:iron_shovel" | "minecraft:stone_brick_slab" | "minecraft:cooked_rabbit_from_smoking" | "minecraft:polished_blackstone_pressure_plate" | "minecraft:quartz_bricks" | "minecraft:crafting_table" | "minecraft:map_cloning" | "minecraft:sandstone_wall" | "minecraft:green_stained_glass_pane_from_glass_pane" | "minecraft:polished_deepslate_slab" | "minecraft:red_sandstone_wall" | "minecraft:cut_copper_slab" | "minecraft:dark_oak_wood" | "minecraft:stone_slab_from_stone_stonecutting" | "minecraft:light_blue_wool" | "minecraft:orange_wool" | "minecraft:black_bed_from_white_bed" | "minecraft:orange_glazed_terracotta" | "minecraft:pink_carpet" | "minecraft:gray_glazed_terracotta" | "minecraft:acacia_stairs" | "minecraft:stone_brick_slab_from_stone_stonecutting" | "minecraft:deepslate_bricks" | "minecraft:iron_nugget_from_smelting" | "minecraft:raw_gold_block" | "minecraft:birch_door" | "minecraft:waxed_exposed_copper_from_honeycomb" | "minecraft:anvil" | "minecraft:stripped_acacia_wood" | "minecraft:waxed_weathered_cut_copper_stairs" | "minecraft:gold_ingot_from_nuggets" | "minecraft:mossy_stone_brick_stairs" | "minecraft:cooked_chicken" | "minecraft:smooth_quartz_stairs_from_smooth_quartz_stonecutting" | "minecraft:oak_trapdoor" | "minecraft:amethyst_block" | "minecraft:chiseled_polished_blackstone_from_polished_blackstone_stonecutting" | "minecraft:oak_door" | "minecraft:netherite_leggings_smithing" | "minecraft:waxed_cut_copper_slab_from_honeycomb" | "minecraft:orange_bed" | "minecraft:birch_button" | "minecraft:nether_brick" | "minecraft:wooden_sword" | "minecraft:birch_fence_gate" | "minecraft:bone_meal" | "minecraft:stone_brick_stairs_from_stone_stonecutting" | "minecraft:gold_ingot_from_blasting_nether_gold_ore" | "minecraft:black_glazed_terracotta" | "minecraft:polished_diorite_stairs_from_diorite_stonecutting" | "minecraft:weathered_cut_copper_stairs_from_weathered_copper_stonecutting" | "minecraft:honey_bottle" | "minecraft:cyan_bed" | "minecraft:smooth_quartz_slab" | "minecraft:spruce_door" | "minecraft:carrot_on_a_stick" | "minecraft:red_stained_glass_pane" | "minecraft:brown_wool" | "minecraft:brick_wall" | "minecraft:lapis_lazuli_from_smelting_lapis_ore" | "minecraft:raw_copper_block" | "minecraft:polished_diorite_from_diorite_stonecutting" | "minecraft:purple_bed" | "minecraft:yellow_carpet_from_white_carpet" | "minecraft:waxed_exposed_cut_copper_stairs_from_waxed_exposed_cut_copper_stonecutting" | "minecraft:dark_prismarine" | "minecraft:prismarine_wall_from_prismarine_stonecutting" | "minecraft:purple_stained_glass_pane_from_glass_pane" | "minecraft:leather_horse_armor" | "minecraft:cookie" | "minecraft:raw_iron_block" | "minecraft:dark_oak_planks" | "minecraft:lapis_lazuli" | "minecraft:candle" | "minecraft:lightning_rod" | "minecraft:brown_stained_glass_pane_from_glass_pane" | "minecraft:oak_button" | "minecraft:granite_wall" | "minecraft:orange_concrete_powder" | "minecraft:polished_blackstone_brick_slab_from_polished_blackstone_stonecutting" | "minecraft:redstone_block" | "minecraft:shears" | "minecraft:waxed_oxidized_cut_copper_slab_from_waxed_oxidized_cut_copper_stonecutting" | "minecraft:wheat" | "minecraft:polished_deepslate_wall_from_cobbled_deepslate_stonecutting" | "minecraft:honeycomb_block" | "minecraft:orange_stained_glass_pane" | "minecraft:quartz_block" | "minecraft:brick" | "minecraft:yellow_stained_glass_pane_from_glass_pane" | "minecraft:deepslate_tile_slab_from_cobbled_deepslate_stonecutting" | "minecraft:exposed_cut_copper_from_exposed_copper_stonecutting" | "minecraft:mossy_cobblestone_slab_from_mossy_cobblestone_stonecutting" | "minecraft:diamond_helmet" | "minecraft:warped_fence" | "minecraft:light_blue_bed_from_white_bed" | "minecraft:bow" | "minecraft:andesite_stairs_from_andesite_stonecutting" | "minecraft:stone_brick_slab_from_stone_bricks_stonecutting" | "minecraft:dark_oak_fence_gate" | "minecraft:waxed_exposed_cut_copper" | "minecraft:coal" | "minecraft:compass" | "minecraft:gold_ingot_from_blasting_deepslate_gold_ore" | "minecraft:andesite_stairs" | "minecraft:item_frame" | "minecraft:waxed_weathered_cut_copper_slab_from_waxed_weathered_cut_copper_stonecutting" | "minecraft:iron_ingot_from_smelting_iron_ore" | "minecraft:light_blue_carpet_from_white_carpet" | "minecraft:jungle_slab" | "minecraft:loom" | "minecraft:light_gray_carpet_from_white_carpet" | "minecraft:polished_granite_stairs_from_polished_granite_stonecutting" | "minecraft:smoker" | "minecraft:skull_banner_pattern" | "minecraft:dark_oak_boat" | "minecraft:pink_dye_from_pink_tulip" | "minecraft:arrow" | "minecraft:oak_fence_gate" | "minecraft:copper_ingot_from_smelting_deepslate_copper_ore" | "minecraft:mossy_stone_brick_wall" | "minecraft:brown_dye" | "minecraft:granite" | "minecraft:melon_seeds" | "minecraft:polished_blackstone_stairs_from_blackstone_stonecutting" | "minecraft:waxed_exposed_cut_copper_stairs_from_honeycomb" | "minecraft:brick_slab" | "minecraft:firework_rocket_simple" | "minecraft:black_dye_from_wither_rose" | "minecraft:red_sandstone_stairs" | "minecraft:sandstone_stairs_from_sandstone_stonecutting" | "minecraft:bricks" | "minecraft:red_sandstone_slab" | "minecraft:gray_stained_glass_pane" | "minecraft:gray_carpet" | "minecraft:oxidized_cut_copper_stairs" | "minecraft:green_wool" | "minecraft:yellow_glazed_terracotta" | "minecraft:andesite" | "minecraft:diamond_boots" | "minecraft:deepslate_tile_wall" | "minecraft:polished_deepslate_stairs" | "minecraft:exposed_cut_copper" | "minecraft:polished_blackstone" | "minecraft:waxed_exposed_cut_copper_slab_from_honeycomb" | "minecraft:stick" | "minecraft:red_nether_brick_stairs" | "minecraft:dark_oak_stairs" | "minecraft:jungle_pressure_plate" | "minecraft:brewing_stand" | "minecraft:white_candle" | "minecraft:polished_blackstone_brick_wall_from_polished_blackstone_bricks_stonecutting" | "minecraft:emerald_from_blasting_emerald_ore" | "minecraft:smooth_red_sandstone_stairs_from_smooth_red_sandstone_stonecutting" | "minecraft:cobbled_deepslate_wall_from_cobbled_deepslate_stonecutting" | "minecraft:polished_blackstone_brick_wall" | "minecraft:stone_axe" | "minecraft:jungle_button" | "minecraft:packed_ice" | "minecraft:golden_carrot" | "minecraft:stone" | "minecraft:blackstone_stairs" | "minecraft:dried_kelp_from_campfire_cooking" | "minecraft:blue_banner" | "minecraft:prismarine_wall" | "minecraft:diamond_block" | "minecraft:deepslate_tile_slab_from_deepslate_bricks_stonecutting" | "minecraft:deepslate_tile_stairs_from_deepslate_bricks_stonecutting" | "minecraft:waxed_oxidized_copper_from_honeycomb" | "minecraft:diorite_slab" | "minecraft:spruce_trapdoor" | "minecraft:yellow_stained_glass" | "minecraft:light_blue_stained_glass" | "minecraft:waxed_oxidized_cut_copper_stairs_from_waxed_oxidized_copper_stonecutting" | "minecraft:glowstone" | "minecraft:respawn_anchor" | "minecraft:pumpkin_seeds" | "minecraft:cobbled_deepslate_wall" | "minecraft:deepslate_brick_slab" | "minecraft:purpur_slab_from_purpur_block_stonecutting" | "minecraft:red_nether_brick_wall" | "minecraft:chiseled_red_sandstone" | "minecraft:nether_brick_fence" | "minecraft:polished_blackstone_brick_stairs_from_blackstone_stonecutting" | "minecraft:magma_cream" | "minecraft:blackstone_wall" | "minecraft:smooth_stone" | "minecraft:cooked_mutton" | "minecraft:bookshelf" | "minecraft:dark_prismarine_stairs" | "minecraft:iron_ingot_from_blasting_raw_iron" | "minecraft:light_gray_candle" | "minecraft:lapis_block" | "minecraft:cobbled_deepslate_stairs_from_cobbled_deepslate_stonecutting" | "minecraft:purple_carpet" | "minecraft:brown_bed_from_white_bed" | "minecraft:brown_stained_glass_pane" | "minecraft:dried_kelp_from_smelting" | "minecraft:polished_deepslate_stairs_from_cobbled_deepslate_stonecutting" | "minecraft:black_terracotta" | "minecraft:polished_granite_slab_from_granite_stonecutting" | "minecraft:snow_block" | "minecraft:iron_axe" | "minecraft:cyan_wool" | "minecraft:composter" | "minecraft:ender_eye" | "minecraft:sandstone_stairs" | "minecraft:jukebox" | "minecraft:polished_deepslate_wall_from_polished_deepslate_stonecutting" | "minecraft:light_gray_terracotta" | "minecraft:white_bed" | "minecraft:birch_slab" | "minecraft:spruce_slab" | "minecraft:deepslate_tile_stairs_from_cobbled_deepslate_stonecutting" | "minecraft:acacia_sign" | "minecraft:coarse_dirt" | "minecraft:red_carpet_from_white_carpet" | "minecraft:chest_minecart" | "minecraft:cobblestone_slab_from_cobblestone_stonecutting" | "minecraft:oak_boat" | "minecraft:mossy_stone_brick_stairs_from_mossy_stone_brick_stonecutting" | "minecraft:waxed_cut_copper_stairs" | "minecraft:quartz_bricks_from_quartz_block_stonecutting" | "minecraft:sea_lantern" | "minecraft:yellow_carpet" | "minecraft:green_candle" | "minecraft:waxed_weathered_cut_copper_stairs_from_honeycomb" | "minecraft:pink_stained_glass_pane_from_glass_pane" | "minecraft:prismarine_slab" | "minecraft:red_dye_from_rose_bush" | "minecraft:exposed_cut_copper_stairs" | "minecraft:fermented_spider_eye" | "minecraft:light_gray_glazed_terracotta" | "minecraft:magenta_terracotta" | "minecraft:baked_potato_from_campfire_cooking" | "minecraft:stone_hoe" | "minecraft:diamond_hoe" | "minecraft:jungle_boat" | "minecraft:coal_from_smelting_deepslate_coal_ore" | "minecraft:pumpkin_pie" | "minecraft:exposed_cut_copper_stairs_from_exposed_cut_copper_stonecutting" | "minecraft:deepslate_bricks_from_polished_deepslate_stonecutting" | "minecraft:gold_ingot_from_gold_block" | "minecraft:jungle_fence" | "minecraft:light_weighted_pressure_plate" | "minecraft:cobbled_deepslate_slab" | "minecraft:cooked_mutton_from_campfire_cooking" | "minecraft:glass_bottle" | "minecraft:weathered_cut_copper" | "minecraft:iron_ingot_from_smelting_raw_iron" | "minecraft:deepslate_brick_slab_from_deepslate_bricks_stonecutting" | "minecraft:iron_door" | "minecraft:purple_stained_glass_pane" | "minecraft:polished_granite" | "minecraft:cooked_beef" | "minecraft:cooked_mutton_from_smoking" | "minecraft:hopper_minecart" | "minecraft:blue_stained_glass_pane" | "minecraft:black_stained_glass_pane_from_glass_pane" | "minecraft:oxidized_cut_copper" | "minecraft:pink_banner" | "minecraft:blue_bed_from_white_bed" | "minecraft:chiseled_quartz_block" | "minecraft:soul_campfire" | "minecraft:cobblestone_stairs_from_cobblestone_stonecutting" | "minecraft:stripped_warped_hyphae" | "minecraft:crimson_door" | "minecraft:copper_ingot_from_waxed_copper_block" | "minecraft:end_stone_brick_stairs_from_end_stone_brick_stonecutting" | "minecraft:pink_wool" | "minecraft:gold_ingot_from_smelting_nether_gold_ore" | "minecraft:leather" | "minecraft:gold_nugget_from_smelting" | "minecraft:chiseled_quartz_block_from_quartz_block_stonecutting" | "minecraft:end_stone_bricks" | "minecraft:waxed_cut_copper_stairs_from_honeycomb" | "minecraft:red_stained_glass_pane_from_glass_pane" | "minecraft:acacia_trapdoor" | "minecraft:stone_brick_wall_from_stone_bricks_stonecutting" | "minecraft:waxed_cut_copper_stairs_from_waxed_copper_block_stonecutting" | "minecraft:black_candle" | "minecraft:cut_copper_slab_from_cut_copper_stonecutting" | "minecraft:light_gray_concrete_powder" | "minecraft:smooth_quartz_stairs" | "minecraft:furnace" | "minecraft:diorite_stairs" | "minecraft:cracked_nether_bricks" | "minecraft:dark_prismarine_stairs_from_dark_prismarine_stonecutting" | "minecraft:crimson_fence_gate" | "minecraft:purpur_pillar_from_purpur_block_stonecutting" | "minecraft:activator_rail" | "minecraft:lime_dye" | "minecraft:polished_diorite_stairs_from_polished_diorite_stonecutting" | "minecraft:crimson_pressure_plate" | "minecraft:oak_planks" | "minecraft:orange_candle" | "minecraft:deepslate_brick_wall_from_polished_deepslate_stonecutting" | "minecraft:weathered_cut_copper_slab_from_weathered_cut_copper_stonecutting" | "minecraft:waxed_exposed_cut_copper_from_waxed_exposed_copper_stonecutting" | "minecraft:end_stone_brick_stairs_from_end_stone_stonecutting" | "minecraft:warped_sign" | "minecraft:lapis_lazuli_from_blasting_lapis_ore" | "minecraft:copper_ingot_from_smelting_copper_ore" | "minecraft:cooked_chicken_from_campfire_cooking" | "minecraft:deepslate_tile_wall_from_polished_deepslate_stonecutting" | "minecraft:purple_dye" | "minecraft:red_sandstone" | "minecraft:netherite_scrap" | "minecraft:stone_brick_wall" | "minecraft:iron_pickaxe" | "minecraft:quartz_slab" | "minecraft:cut_sandstone" | "minecraft:spruce_button" | "minecraft:repair_item" | "minecraft:light_blue_dye_from_blue_white_dye" | "minecraft:shulker_box_coloring" | "minecraft:nether_brick_slab" | "minecraft:cyan_dye" | "minecraft:quartz_pillar_from_quartz_block_stonecutting" | "minecraft:waxed_cut_copper_stairs_from_waxed_cut_copper_stonecutting" | "minecraft:deepslate_tiles" | "minecraft:orange_terracotta" | "minecraft:deepslate_tile_stairs_from_polished_deepslate_stonecutting" | "minecraft:enchanting_table" | "minecraft:red_glazed_terracotta" | "minecraft:white_glazed_terracotta" | "minecraft:blue_carpet_from_white_carpet" | "minecraft:deepslate_tiles_from_cobbled_deepslate_stonecutting" | "minecraft:lead" | "minecraft:birch_boat" | "minecraft:gold_block" | "minecraft:spruce_boat" | "minecraft:polished_diorite_stairs" | "minecraft:mossy_cobblestone_wall_from_mossy_cobblestone_stonecutting" | "minecraft:nether_brick_stairs_from_nether_bricks_stonecutting" | "minecraft:observer" | "minecraft:campfire" | "minecraft:paper" | "minecraft:polished_deepslate_wall" | "minecraft:dark_oak_slab" | "minecraft:lime_glazed_terracotta" | "minecraft:cooked_cod_from_campfire_cooking" | "minecraft:gray_carpet_from_white_carpet" | "minecraft:brick_stairs" | "minecraft:pink_carpet_from_white_carpet" | "minecraft:lime_stained_glass" | "minecraft:cut_sandstone_slab_from_sandstone_stonecutting" | "minecraft:stripped_spruce_wood" | "minecraft:acacia_wood" | "minecraft:netherite_helmet_smithing" | "minecraft:polished_blackstone_stairs_from_polished_blackstone_stonecutting" | "minecraft:stripped_jungle_wood" | "minecraft:pink_dye_from_peony" | "minecraft:copper_ingot_from_blasting_raw_copper" | "minecraft:stone_brick_walls_from_stone_stonecutting" | "minecraft:bucket" | "minecraft:waxed_cut_copper_from_waxed_copper_block_stonecutting" | "minecraft:cut_red_sandstone_slab" | "minecraft:coal_from_blasting_deepslate_coal_ore" | "minecraft:black_stained_glass" | "minecraft:chiseled_red_sandstone_from_red_sandstone_stonecutting" | "minecraft:polished_andesite";
    type LangKey = "block.minecraft.brown_terracotta" | "entity.minecraft.area_effect_cloud" | "block.minecraft.lapis_ore" | "item.minecraft.gray_dye" | "subtitles.entity.fishing_bobber.splash" | "block.minecraft.banner.base.yellow" | "multiplayer.disconnect.flying" | "block.minecraft.terracotta" | "item.minecraft.stray_spawn_egg" | "key.categories.creative" | "block.minecraft.banner.base.pink" | "item.minecraft.potion.effect.weakness" | "selectWorld.backupWarning.experimental" | "forge.configgui.zoomInMissingModelTextInGui" | "block.minecraft.dark_prismarine_slab" | "commands.debug.function.success.multiple" | "subtitles.entity.mooshroom.milk" | "item.minecraft.splash_potion.effect.thick" | "item.minecraft.cooked_cod" | "clear.failed.single" | "block.minecraft.red_nether_brick_slab" | "block.minecraft.yellow_terracotta" | "block.minecraft.observer" | "entity.minecraft.creeper" | "block.minecraft.banner.stripe_bottom.cyan" | "key.keyboard.world.1" | "key.keyboard.world.2" | "block.minecraft.banner.creeper.purple" | "block.minecraft.banner.straight_cross.cyan" | "commands.schedule.created.function" | "subtitles.entity.silverfish.ambient" | "block.minecraft.banner.half_horizontal_bottom.brown" | "deathScreen.quit.confirm" | "commands.team.option.friendlyfire.alreadyDisabled" | "item.minecraft.firework_star.shape.large_ball" | "block.minecraft.prismarine_brick_slab" | "death.fell.accident.twisting_vines" | "block.minecraft.jungle_trapdoor" | "commands.bossbar.remove.success" | "block.minecraft.sculk_sensor" | "gamerule.disableElytraMovementCheck" | "connect.aborted" | "block.minecraft.banner.triangles_top.lime" | "block.minecraft.banner.creeper.orange" | "advancements.nether.create_full_beacon.description" | "addServer.enterIp" | "item.minecraft.charcoal" | "stat.minecraft.clean_shulker_box" | "item.minecraft.tipped_arrow.effect.night_vision" | "commands.team.list.teams.success" | "options.narrator.all" | "block.minecraft.stone_brick_slab" | "key.keyboard.left" | "subtitles.entity.donkey.angry" | "block.minecraft.banner.mojang.cyan" | "multiplayer.status.cannot_resolve" | "subtitles.entity.iron_golem.hurt" | "attribute.name.generic.movement_speed" | "block.minecraft.white_stained_glass" | "narrator.position.list" | "item.minecraft.bowl" | "commands.item.target.no_such_slot" | "block.minecraft.banner.square_top_right.light_gray" | "block.minecraft.banner.diagonal_up_left.magenta" | "block.minecraft.dead_brain_coral_fan" | "block.minecraft.banner.flower.white" | "item.minecraft.bone_meal" | "stat.minecraft.sneak_time" | "argument.nbt.trailing" | "mco.selectServer.note" | "options.fov.min" | "subtitles.entity.zombie.destroy_egg" | "mco.minigame.world.restore.question.line2" | "entity.minecraft.wither_skull" | "biome.minecraft.lukewarm_ocean" | "mco.minigame.world.restore.question.line1" | "entity.minecraft.eye_of_ender" | "mco.configure.world.subscription.timeleft" | "block.minecraft.banner.triangle_bottom.red" | "multiplayer.status.no_connection" | "subtitles.block.respawn_anchor.deplete" | "block.minecraft.cyan_carpet" | "createWorld.customize.custom.useOceanRuins" | "argument.double.big" | "color.minecraft.red" | "block.minecraft.oak_door" | "arguments.objective.readonly" | "commands.forge.tracking.entity.enabled" | "commands.team.leave.success.single" | "commands.locate.invalid" | "advancements.end.elytra.title" | "entity.minecraft.piglin_brute" | "block.minecraft.flowering_azalea_leaves" | "item.minecraft.prismarine_crystals" | "subtitles.entity.wandering_trader.hurt" | "menu.disconnect" | "block.minecraft.banner.diagonal_left.cyan" | "commands.scoreboard.players.enable.success.multiple" | "menu.preparingSpawn" | "block.minecraft.banner.stripe_bottom.light_blue" | "generator.amplified" | "createWorld.customize.custom.biomeScaleWeight" | "item.minecraft.tipped_arrow.effect.slow_falling" | "stat_type.minecraft.killed_by" | "options.online" | "block.minecraft.end_stone" | "subtitles.entity.horse.armor" | "commands.banip.invalid" | "block.minecraft.potted_white_tulip" | "block.minecraft.warped_door" | "chat.cannotSend" | "mco.download.title" | "block.minecraft.banner.square_top_left.light_gray" | "item.minecraft.splash_potion.effect.fire_resistance" | "subtitles.entity.elder_guardian.death" | "multiplayer.disconnect.authservers_down" | "color.minecraft.gray" | "fml.language.missingversion" | "item.minecraft.furnace_minecart" | "block.minecraft.banner.half_vertical_right.pink" | "mco.selectServer.expiredList" | "selectWorld.edit.export_worldgen_settings.success" | "block.minecraft.banner.triangles_bottom.light_gray" | "stat.minecraft.damage_dealt" | "createWorld.customize.presets.list" | "forge.configgui.disableStairSlabCulling.tooltip" | "item.minecraft.shield.red" | "fml.menu.multiplayer.compatible" | "multiplayer.disconnect.idling" | "soundCategory.record" | "block.minecraft.quartz_pillar" | "commands.bossbar.get.visible.hidden" | "title.32bit.deprecation.realms.check" | "block.minecraft.prismarine_slab" | "argument.pos3d.incomplete" | "block.minecraft.nether_portal" | "item.minecraft.diamond_sword" | "debug.cycle_renderdistance.help" | "subtitles.entity.ender_dragon.flap" | "advancements.story.obtain_armor.title" | "block.minecraft.oak_planks" | "item.minecraft.amethyst_shard" | "entity.minecraft.spider" | "block.minecraft.purple_banner" | "fml.menu.mods.info.idstate" | "subtitles.entity.piglin.celebrate" | "block.minecraft.structure_void" | "subtitles.entity.endermite.death" | "tutorial.socialInteractions.title" | "block.minecraft.purple_shulker_box" | "jigsaw_block.pool" | "commands.item.source.not_a_container" | "block.minecraft.potatoes" | "datapackFailure.safeMode" | "container.isLocked" | "block.minecraft.light_blue_bed" | "commands.time.set" | "block.minecraft.yellow_banner" | "item.modifiers.head" | "item.minecraft.potion.effect.swiftness" | "options.on.composed" | "advancements.adventure.honey_block_slide.title" | "subtitles.entity.player.levelup" | "commands.worldborder.damage.buffer.success" | "container.grindstone_title" | "mco.configure.world.opening" | "block.minecraft.glass_pane" | "block.minecraft.clay" | "container.barrel" | "block.minecraft.banner.diagonal_right.cyan" | "fml.messages.version.restriction.upper.exclusive" | "commands.title.times.single" | "key.keyboard.period" | "key.mouse.right" | "death.attack.fireball" | "block.minecraft.cut_copper_slab" | "itemGroup.search" | "block.minecraft.polished_diorite_slab" | "argument.entity.notfound.entity" | "block.minecraft.banner.piglin.green" | "gui.socialInteractions.blocking_hint" | "item.minecraft.splash_potion.effect.slow_falling" | "resourcepack.requesting" | "biome.minecraft.warped_forest" | "item.minecraft.book" | "block.minecraft.banner.gradient.brown" | "block.minecraft.cobblestone_slab" | "entity.minecraft.magma_cube" | "block.minecraft.banner.cross.magenta" | "block.minecraft.banner.diagonal_right.purple" | "block.minecraft.banner.curly_border.gray" | "options.particles.all" | "block.minecraft.big_dripleaf" | "block.minecraft.black_shulker_box" | "subtitles.block.amethyst_block.chime" | "advancements.nether.root.description" | "commands.bossbar.list.bars.none" | "advancements.nether.find_fortress.title" | "block.minecraft.banner.straight_cross.purple" | "multiplayer.texturePrompt.serverPrompt" | "key.forward" | "block.minecraft.blackstone_stairs" | "mco.template.trailer.tooltip" | "effect.none" | "block.minecraft.banner.triangles_top.blue" | "block.minecraft.deepslate_tile_slab" | "gamerule.showDeathMessages" | "commands.enchant.success.single" | "advancements.end.find_end_city.title" | "block.minecraft.banner.square_top_left.blue" | "block.minecraft.banner.stripe_center.yellow" | "item.minecraft.piglin_banner_pattern.desc" | "subtitles.entity.blaze.hurt" | "gamerule.doEntityDrops" | "mco.configure.world.invite.profile.name" | "entity.minecraft.evoker" | "item.minecraft.firework_star.cyan" | "selectWorld.create" | "block.minecraft.exposed_cut_copper_slab" | "commands.forge.tracking.no_data" | "block.minecraft.brick_slab" | "death.attack.fireworks" | "block.minecraft.banner.triangle_top.lime" | "subtitles.entity.slime.hurt" | "block.minecraft.deepslate_emerald_ore" | "advancements.adventure.throw_trident.title" | "commands.jfr.stopped" | "block.minecraft.potted_dead_bush" | "block.minecraft.crimson_wall_sign" | "subtitles.entity.ender_dragon.growl" | "item.minecraft.apple" | "block.minecraft.banner.half_horizontal.brown" | "gamerule.reducedDebugInfo.description" | "commands.advancement.revoke.one.to.many.success" | "block.minecraft.brown_wool" | "subtitles.entity.ghast.ambient" | "subtitles.entity.ravager.stunned" | "arguments.function.tag.unknown" | "entity.minecraft.turtle" | "item.minecraft.splash_potion.effect.water" | "fml.menu.accessdenied.message" | "mco.configure.world.subscription.months" | "createWorld.customize.custom.preset.waterWorld" | "subtitles.entity.bee.loop" | "block.minecraft.banner.diagonal_right.red" | "entity.minecraft.experience_orb" | "commands.datapack.list.available.success" | "death.attack.inWall" | "commands.function.success.multiple" | "item.minecraft.bone" | "advancements.story.cure_zombie_villager.title" | "advancements.husbandry.plant_seed.title" | "chat.type.announcement" | "advancements.end.dragon_breath.title" | "selectWorld.edit.save" | "advancements.husbandry.netherite_hoe.description" | "mco.errorMessage.6003" | "mco.errorMessage.6002" | "commands.attribute.base_value.set.success" | "argument.angle.incomplete" | "mco.errorMessage.6001" | "effect.minecraft.speed" | "key.keyboard.page.up" | "commands.title.cleared.multiple" | "mco.errorMessage.6004" | "block.minecraft.banner.piglin.light_blue" | "block.minecraft.polished_andesite" | "event.minecraft.raid.defeat" | "forge.configgui.removeErroringBlockEntities" | "options.rawMouseInput" | "subtitles.block.sweet_berry_bush.pick_berries" | "gui.yes" | "soundCategory.ambient" | "chat.editBox" | "fml.messages.version.restriction.any" | "block.minecraft.medium_amethyst_bud" | "item.minecraft.lapis_lazuli" | "block.minecraft.banner.straight_cross.orange" | "subtitles.entity.piglin.ambient" | "block.minecraft.banner.diagonal_right.orange" | "mco.configure.world.buttons.switchminigame" | "entity.minecraft.stray" | "options.gamma.default" | "commands.bossbar.get.players.some" | "block.minecraft.banner.base.green" | "biome.minecraft.small_end_islands" | "fml.menu.mods.info.updateavailable" | "subtitles.entity.axolotl.splash" | "subtitles.entity.guardian.attack" | "commands.experience.add.levels.success.single" | "commands.effect.clear.specific.success.single" | "block.minecraft.potted_crimson_fungus" | "fml.modmismatchscreen.table.serverhas" | "commands.teleport.success.entity.single" | "advancements.adventure.bullseye.description" | "block.minecraft.banner.square_top_left.lime" | "chat.type.team.text" | "block.minecraft.pink_terracotta" | "connect.connecting" | "death.attack.flyIntoWall" | "stat.minecraft.walk_one_cm" | "item.minecraft.orange_dye" | "block.minecraft.warped_fence_gate" | "block.minecraft.magenta_stained_glass_pane" | "subtitles.entity.generic.death" | "block.minecraft.banner.square_bottom_left.gray" | "commands.scoreboard.objectives.display.set" | "subtitles.event.raid.horn" | "advancements.nether.explore_nether.description" | "itemGroup.tools" | "commands.bossbar.set.visibility.unchanged.visible" | "biome.minecraft.soul_sand_valley" | "pack.source.builtin" | "block.minecraft.flower_pot" | "item.minecraft.fishing_rod" | "commands.perf.reportFailed" | "forge.configgui.fixVanillaCascading" | "block.minecraft.cyan_stained_glass" | "narrator.joining" | "item.minecraft.bee_spawn_egg" | "enchantment.minecraft.luck_of_the_sea" | "argument.player.toomany" | "block.minecraft.light_gray_stained_glass_pane" | "mco.configure.world.buttons.done" | "item.minecraft.fox_spawn_egg" | "block.minecraft.banner.triangle_top.blue" | "commands.reload.success" | "mco.connect.connecting" | "selectWorld.allowCommands.info" | "block.minecraft.mossy_stone_brick_stairs" | "block.minecraft.brown_mushroom_block" | "subtitles.block.barrel.close" | "subtitles.block.growing_plant.crop" | "block.minecraft.spruce_slab" | "subtitles.entity.rabbit.death" | "key.pickItem" | "block.minecraft.polished_andesite_stairs" | "block.minecraft.banner.half_vertical_right.brown" | "createWorld.customize.preset.overworld" | "commands.bossbar.set.color.unchanged" | "subtitles.entity.boat.paddle_land" | "block.minecraft.banner.bricks.red" | "argument.block.property.unclosed" | "pack.dropConfirm" | "subtitles.entity.panda.step" | "block.minecraft.banner.border.magenta" | "createWorld.customize.custom.page1" | "item.minecraft.enderman_spawn_egg" | "createWorld.customize.custom.page2" | "createWorld.customize.custom.page3" | "block.minecraft.pink_concrete_powder" | "subtitles.entity.enderman.death" | "advancements.adventure.voluntary_exile.description" | "createWorld.customize.custom.page0" | "subtitles.entity.axolotl.swim" | "block.minecraft.banner.creeper.red" | "options.autoJump" | "entity.minecraft.tropical_fish" | "key.mouse.middle" | "event.minecraft.raid.raiders_remaining" | "subtitles.entity.piglin.admiring_item" | "block.minecraft.spruce_fence" | "block.minecraft.oak_trapdoor" | "death.attack.starve" | "block.minecraft.polished_granite" | "options.framerate" | "forge.configgui.forceSystemNanoTime" | "subtitles.entity.cat.eat" | "block.minecraft.glass" | "subtitles.entity.elder_guardian.hurt" | "debug.reload_chunks.help" | "forge.nameTagDistance" | "container.hopper" | "block.minecraft.tnt" | "commands.experience.set.levels.success.multiple" | "forge.controlsgui.control" | "subtitles.entity.witch.hurt" | "entity.minecraft.bee" | "block.minecraft.budding_amethyst" | "block.minecraft.white_bed" | "arguments.item.tag.unknown" | "createWorld.customize.custom.presets.title" | "selectWorld.gameMode.hardcore" | "subtitles.entity.item_frame.remove_item" | "subtitles.entity.zoglin.ambient" | "commands.debug.function.success.single" | "subtitles.entity.pillager.ambient" | "item.minecraft.turtle_spawn_egg" | "block.minecraft.banner.rhombus.red" | "narration.cycle_button.usage.hovered" | "block.minecraft.banner.half_vertical.light_gray" | "stat.minecraft.damage_dealt_resisted" | "createWorld.customize.custom.defaults" | "entity.minecraft.item_frame" | "block.minecraft.brain_coral_block" | "item.minecraft.tropical_fish" | "stat.minecraft.mob_kills" | "entity.minecraft.leash_knot" | "key.categories.multiplayer" | "death.attack.fall.player" | "advancements.adventure.shoot_arrow.description" | "soundCategory.block" | "gui.socialInteractions.status_blocked_offline" | "subtitles.entity.mule.hurt" | "createWorld.customize.flat.layer" | "entity.minecraft.ocelot" | "block.minecraft.cyan_candle" | "block.minecraft.banner.stripe_right.cyan" | "block.minecraft.banner.piglin.pink" | "fml.menu.mods.openmodsfolder" | "stat.minecraft.interact_with_lectern" | "structure_block.mode.save" | "subtitles.entity.villager.work_toolsmith" | "block.minecraft.chest" | "stat_type.minecraft.dropped" | "block.minecraft.furnace" | "commands.attribute.failed.modifier_already_present" | "gamerule.naturalRegeneration" | "item.minecraft.tipped_arrow.effect.harming" | "stat.minecraft.animals_bred" | "block.minecraft.banner.border.white" | "createWorld.customize.custom.riverSize" | "block.minecraft.dark_oak_slab" | "subtitles.block.respawn_anchor.ambient" | "block.minecraft.banner.triangle_bottom.light_blue" | "mco.configure.world.switch.slot" | "block.minecraft.cartography_table" | "subtitles.entity.chicken.death" | "item.minecraft.phantom_membrane" | "block.minecraft.banner.border.red" | "permissions.requires.entity" | "subtitles.entity.evoker.prepare_wololo" | "subtitles.block.bubble_column.whirlpool_ambient" | "selectWorld.tooltip.fromNewerVersion2" | "subtitles.entity.dolphin.ambient" | "subtitles.entity.guardian.death" | "selectWorld.tooltip.fromNewerVersion1" | "item.minecraft.cat_spawn_egg" | "block.minecraft.cut_red_sandstone" | "entity.minecraft.bat" | "block.minecraft.oxidized_copper" | "options.realmsNotifications" | "commands.ban.success" | "block.minecraft.stripped_birch_log" | "subtitles.entity.dolphin.death" | "block.minecraft.jungle_sign" | "death.attack.thrown.item" | "commands.enchant.success.multiple" | "subtitles.entity.firework_rocket.twinkle" | "block.minecraft.banner.circle.white" | "commands.advancement.grant.many.to.one.failure" | "biome.minecraft.jagged_peaks" | "subtitles.entity.llama.spit" | "options.viewBobbing" | "commands.difficulty.failure" | "multiplayer.disconnect.generic" | "gui.cancel" | "block.minecraft.redstone_wall_torch" | "enchantment.minecraft.flame" | "commands.data.storage.get" | "demo.help.movementShort" | "block.minecraft.white_carpet" | "commands.advancement.revoke.many.to.many.failure" | "advancements.adventure.hero_of_the_village.title" | "advancements.story.deflect_arrow.description" | "block.minecraft.pink_bed" | "death.attack.cramming" | "subtitles.entity.vex.hurt" | "block.minecraft.red_sandstone" | "subtitles.item.bottle.empty" | "debug.creative_spectator.help" | "commands.difficulty.success" | "commands.team.option.friendlyfire.alreadyEnabled" | "block.minecraft.glow_lichen" | "options.difficulty.hard" | "menu.options" | "item.minecraft.ocelot_spawn_egg" | "mco.configure.world.reset.question.line1" | "mco.configure.world.reset.question.line2" | "item.minecraft.potion.effect.invisibility" | "stat_type.minecraft.killed.none" | "commands.clear.success.single" | "entity.minecraft.villager.butcher" | "subtitles.entity.panda.death" | "block.minecraft.banner.bricks.black" | "createWorld.customize.custom.useCaves" | "block.minecraft.banner.half_horizontal_bottom.light_gray" | "advancements.adventure.ol_betsy.description" | "block.minecraft.raw_copper_block" | "mco.configure.world.subscription.recurring.daysleft" | "entity.minecraft.mule" | "item.minecraft.music_disc_wait.desc" | "gamerule.doMobSpawning.description" | "block.minecraft.banner.stripe_downright.light_gray" | "block.minecraft.gray_shulker_box" | "block.minecraft.skeleton_skull" | "subtitles.block.shulker_box.close" | "team.visibility.hideForOwnTeam" | "options.customizeTitle" | "addServer.add" | "attribute.name.generic.attack_knockback" | "mco.configure.world.uninvite.question" | "selectWorld.data_read" | "gui.stats" | "block.minecraft.light_gray_stained_glass" | "subtitles.entity.villager.work_librarian" | "item.minecraft.golden_pickaxe" | "commands.forge.tags.error.unknown_registry" | "filled_map.mansion" | "item.minecraft.gold_nugget" | "entity.minecraft.chicken" | "block.minecraft.banner.stripe_left.pink" | "block.minecraft.banner.stripe_downright.yellow" | "subtitles.entity.zombie_horse.death" | "permissions.requires.player" | "subtitles.entity.wolf.death" | "block.minecraft.banner.diagonal_up_right.brown" | "potion.withDuration" | "block.minecraft.lilac" | "argument.literal.incorrect" | "block.minecraft.black_candle" | "gamerule.doLimitedCrafting" | "mco.upload.done" | "block.minecraft.dripstone_block" | "block.minecraft.banner.base.black" | "mco.configure.world.switch.slot.subtitle" | "jigsaw_block.final_state" | "item.minecraft.tipped_arrow.effect.leaping" | "item.minecraft.shield.light_blue" | "mco.connect.success" | "block.minecraft.banner.triangles_top.purple" | "commands.bossbar.get.visible.visible" | "block.minecraft.oxidized_cut_copper_slab" | "commands.data.entity.query" | "block.minecraft.bricks" | "fml.menu.mods.info.signature.unsigned" | "block.minecraft.banner.stripe_bottom.white" | "block.minecraft.warped_nylium" | "block.minecraft.daylight_detector" | "stats.tooltip.type.statistic" | "block.minecraft.diorite_slab" | "entity.minecraft.illusioner" | "block.minecraft.banner.border.black" | "block.minecraft.banner.square_bottom_right.brown" | "block.minecraft.banner.triangles_bottom.brown" | "menu.respawning" | "generator.default" | "mco.account.privacy.info" | "pack.incompatible" | "container.crafting" | "debug.pause_focus.on" | "tutorial.open_inventory.description" | "block.minecraft.dark_oak_planks" | "subtitles.entity.cat.beg_for_food" | "argument.pos.missing.int" | "options.visible" | "item.minecraft.pig_spawn_egg" | "enchantment.unknown" | "block.minecraft.green_candle" | "block.minecraft.melon_stem" | "advancements.end.root.description" | "argument.long.low" | "color.minecraft.yellow" | "block.minecraft.banner.half_horizontal.light_gray" | "multiplayer.status.unknown" | "commands.scoreboard.objectives.display.cleared" | "subtitles.block.piston.move" | "item.minecraft.iron_pickaxe" | "block.minecraft.mossy_cobblestone_stairs" | "forge.experimentalsettings.tooltip" | "block.minecraft.cobbled_deepslate_wall" | "enchantment.minecraft.fire_aspect" | "block.minecraft.orange_carpet" | "commands.whitelist.alreadyOn" | "options.chat.width" | "subtitles.entity.iron_golem.attack" | "forge.configgui.forgeLightPipelineEnabled.tooltip" | "commands.bossbar.create.failed" | "mco.configure.world.buttons.activity" | "options.graphics.fast" | "debug.show_hitboxes.on" | "selectWorld.gameMode.spectator" | "attribute.name.generic.max_health" | "entity.minecraft.tropical_fish.type.blockfish" | "container.chest" | "item.minecraft.gunpowder" | "mco.configure.world.spawnMonsters" | "disconnect.loginFailedInfo" | "subtitles.entity.villager.work_armorer" | "multiplayer.requiredTexturePrompt.disconnect" | "block.minecraft.potted_orange_tulip" | "subtitles.entity.shulker_bullet.hurt" | "block.minecraft.banner.stripe_right.yellow" | "block.minecraft.polished_diorite_stairs" | "block.minecraft.bubble_coral_fan" | "mco.download.extracting" | "block.minecraft.deepslate_coal_ore" | "block.minecraft.dead_fire_coral" | "block.minecraft.banner.gradient.light_gray" | "block.minecraft.banner.piglin.white" | "tutorial.socialInteractions.description" | "block.minecraft.banner.diagonal_left.magenta" | "block.minecraft.brain_coral_fan" | "block.minecraft.dark_oak_trapdoor" | "subtitles.entity.parrot.hurts" | "mco.configure.world.title" | "commands.scoreboard.players.set.success.multiple" | "argument.entity.notfound.player" | "sleep.skipping_night" | "mco.selectServer.expires.soon" | "forge.configgui.zombieBaseSummonChance" | "entity.minecraft.zombie_villager" | "commands.team.list.members.success" | "container.enchant.lapis.many" | "item.minecraft.wandering_trader_spawn_egg" | "subtitles.entity.parrot.imitate.witch" | "multiplayer.disconnect.missing_tags" | "options.chat.height.unfocused" | "subtitles.entity.stray.ambient" | "options.chat.links" | "block.minecraft.bed.not_safe" | "commands.kill.success.single" | "argument.block.property.novalue" | "block.minecraft.powder_snow_cauldron" | "block.minecraft.potted_wither_rose" | "block.minecraft.banner.straight_cross.light_blue" | "item.minecraft.leather_helmet" | "block.minecraft.banner.diagonal_up_right.gray" | "block.minecraft.spruce_wood" | "commands.bossbar.set.visibility.unchanged.hidden" | "block.minecraft.smooth_red_sandstone_stairs" | "fml.modloading.failedtoprocesswork" | "options.fov.max" | "commands.advancement.grant.one.to.many.failure" | "fml.modmismatchscreen.additional" | "commands.advancement.grant.one.to.many.success" | "advancements.end.find_end_city.description" | "narrator.select" | "item.minecraft.cooked_salmon" | "commands.drop.success.multiple" | "block.minecraft.banner.globe.brown" | "biome.minecraft.end_barrens" | "options.fullscreen.resolution" | "entity.minecraft.silverfish" | "multiplayer.status.cannot_connect" | "subtitles.block.anvil.land" | "item.minecraft.iron_axe" | "block.minecraft.banner.diagonal_up_left.pink" | "enchantment.minecraft.binding_curse" | "block.minecraft.banner.border.green" | "mco.selectServer.openserver" | "block.minecraft.birch_fence_gate" | "block.minecraft.iron_door" | "commands.pardonip.success" | "commands.team.option.collisionRule.unchanged" | "options.vsync" | "block.minecraft.banner.mojang.light_gray" | "options.chat.color" | "block.minecraft.piston" | "debug.chunk_boundaries.on" | "subtitles.entity.strider.happy" | "fml.menu.mods.z_to_a" | "generator.debug_all_block_states" | "subtitles.entity.zombie_villager.death" | "block.minecraft.red_stained_glass" | "commands.team.empty.unchanged" | "narration.button.usage.hovered" | "selectWorld.import_worldgen_settings.failure" | "item.minecraft.firework_rocket.flight" | "container.enchant.level.requirement" | "advancements.end.dragon_egg.title" | "subtitles.entity.piglin_brute.angry" | "gamerule.forgiveDeadPlayers.description" | "commands.attribute.failed.no_modifier" | "gamerule.doTileDrops" | "entity.minecraft.llama_spit" | "createWorld.customize.preset.desert" | "options.ao.off" | "structure_block.show_air" | "item.minecraft.lingering_potion.effect.weakness" | "subtitles.block.iron_trapdoor.open" | "forge.configgui.forgeCloudsEnabled" | "block.minecraft.potted_lily_of_the_valley" | "options.accessibility.text_background.chat" | "block.minecraft.banner.diagonal_up_right.purple" | "subtitles.item.honey_bottle.drink" | "item.minecraft.lime_dye" | "chat.type.text.narrate" | "fml.menu.mods.info.securejardisabled" | "block.minecraft.grass_block" | "mco.configure.world.buttons.moreoptions" | "block.minecraft.spruce_trapdoor" | "commands.enchant.failed.level" | "options.graphics.fabulous" | "chat.link.confirmTrusted" | "block.minecraft.brown_bed" | "subtitles.entity.dolphin.ambient_water" | "translation.test.complex" | "entity.minecraft.fishing_bobber" | "block.minecraft.banner.square_top_right.red" | "subtitles.entity.llama.eat" | "block.minecraft.acacia_fence_gate" | "commands.setidletimeout.success" | "commands.team.option.friendlyfire.enabled" | "item.minecraft.lodestone_compass" | "gui.recipebook.toggleRecipes.all" | "block.minecraft.deepslate_lapis_ore" | "options.sounds.title" | "block.minecraft.banner.gradient_up.white" | "biome.minecraft.badlands" | "block.minecraft.banner.small_stripes.yellow" | "subtitles.entity.witch.drink" | "block.minecraft.dark_oak_wood" | "block.minecraft.dark_prismarine_stairs" | "commands.banip.failed" | "command.exception" | "key.right" | "block.minecraft.banner.bricks.green" | "subtitles.entity.villager.yes" | "block.minecraft.blue_bed" | "block.minecraft.oak_leaves" | "item.kubejs.dummy_fluid_item" | "subtitles.entity.silverfish.death" | "block.minecraft.infested_chiseled_stone_bricks" | "advancements.adventure.totem_of_undying.description" | "block.minecraft.moss_carpet" | "block.minecraft.cracked_polished_blackstone_bricks" | "death.attack.lava" | "item.minecraft.wolf_spawn_egg" | "structure_block.save_success" | "entity.minecraft.slime" | "advancements.story.form_obsidian.description" | "gamerule.drowningDamage" | "commands.scoreboard.objectives.list.success" | "item.minecraft.witch_spawn_egg" | "block.minecraft.banner.stripe_middle.purple" | "block.minecraft.banner.triangle_top.cyan" | "subtitles.entity.zombie.infect" | "advancements.husbandry.netherite_hoe.title" | "commands.worldborder.set.shrink" | "effect.effectNotFound" | "block.minecraft.banner.flower.green" | "subtitles.entity.generic.splash" | "subtitles.entity.guardian.hurt" | "event.minecraft.raid.victory" | "item.minecraft.shield.gray" | "item.minecraft.firework_star.red" | "mco.template.info.tooltip" | "key.keyboard.keypad.equal" | "death.attack.fireball.item" | "subtitles.block.pressure_plate.click" | "commands.perf.started" | "subtitles.entity.husk.ambient" | "options.difficulty" | "key.keyboard.comma" | "argument.uuid.invalid" | "selectWorld.backupQuestion.customized" | "death.attack.inFire" | "options.mainHand.left" | "commands.scoreboard.players.set.success.single" | "structure_block.hover.data" | "entity.minecraft.skeleton" | "item.minecraft.blaze_spawn_egg" | "block.minecraft.cyan_concrete" | "multiplayerWarning.message" | "block.minecraft.banner.diagonal_up_left.orange" | "fml.dependencyloading.conflictingdependencies" | "subtitles.entity.villager.no" | "block.minecraft.banner.triangle_bottom.black" | "commands.advancement.grant.criterion.to.one.success" | "menu.resetdemo" | "block.minecraft.warped_slab" | "item.modifiers.offhand" | "multiplayer.status.incompatible" | "block.minecraft.sweet_berry_bush" | "block.minecraft.acacia_pressure_plate" | "block.minecraft.weathered_copper" | "enchantment.minecraft.depth_strider" | "entity.minecraft.experience_bottle" | "block.minecraft.banner.triangle_bottom.light_gray" | "subtitles.entity.generic.swim" | "subtitles.entity.villager.celebrate" | "item.dyed" | "subtitles.entity.wandering_trader.yes" | "commands.drop.no_loot_table" | "block.minecraft.turtle_egg" | "entity.minecraft.tnt_minecart" | "key.mouse.left" | "subtitles.entity.llama.angry" | "subtitles.entity.spider.ambient" | "debug.profiling.start" | "subtitles.block.anvil.use" | "options.difficulty.hardcore" | "block.minecraft.banner.stripe_middle.orange" | "mco.configure.world.spawnAnimals" | "attribute.unknown" | "block.minecraft.magma_block" | "block.minecraft.lime_candle_cake" | "item.minecraft.phantom_spawn_egg" | "block.minecraft.end_stone_brick_stairs" | "death.attack.cactus.player" | "commands.forge.gen.complete" | "fml.modloading.missinglicense" | "item.minecraft.splash_potion.effect.awkward" | "block.minecraft.spruce_door" | "block.minecraft.warped_button" | "tutorial.find_tree.title" | "block.minecraft.pumpkin" | "subtitles.entity.mule.death" | "subtitles.block.candle.crackle" | "block.minecraft.banner.circle.pink" | "subtitles.entity.chicken.egg" | "chat.type.emote" | "key.keyboard.keypad.enter" | "block.minecraft.dark_oak_log" | "commands.pardon.failed" | "block.minecraft.sponge" | "argument.entity.options.x_rotation.description" | "commands.advancement.revoke.one.to.many.failure" | "options.online.title" | "subtitles.entity.zoglin.death" | "block.minecraft.light_gray_candle" | "options.clouds.fast" | "mco.errorMessage.connectionFailure" | "options.attack.crosshair" | "biome.minecraft.snowy_taiga" | "advancements.nether.create_beacon.description" | "forge.configgui.logCascadingWorldGeneration" | "jigsaw_block.joint.aligned" | "record.nowPlaying" | "options.sounds" | "stat.minecraft.player_kills" | "item.minecraft.golden_boots" | "advancements.husbandry.axolotl_in_a_bucket.description" | "block.minecraft.black_carpet" | "block.minecraft.bubble_coral_block" | "commands.spreadplayers.failed.invalid.height" | "block.minecraft.brown_candle_cake" | "key.keyboard.delete" | "commands.advancement.revoke.many.to.many.success" | "commands.locatebiome.success" | "block.minecraft.banner.skull.purple" | "commands.trigger.set.success" | "advancements.nether.all_effects.title" | "commands.forge.entity.list.multiple.header" | "item.minecraft.netherite_chestplate" | "item.minecraft.mojang_banner_pattern.desc" | "block.minecraft.magenta_candle" | "subtitles.entity.evoker.prepare_summon" | "mco.configure.world.settings.title" | "block.minecraft.banner.stripe_downright.light_blue" | "menu.working" | "narrator.controls.reset" | "advMode.mode.auto" | "fml.modloading.missingdependency.optional" | "death.attack.magic" | "mco.template.title.minigame" | "commands.fill.success" | "dataPack.validation.working" | "item.minecraft.music_disc_mellohi" | "argument.entity.options.y.description" | "block.minecraft.cocoa" | "advancements.adventure.sleep_in_bed.description" | "block.minecraft.jungle_button" | "stat.minecraft.open_shulker_box" | "block.minecraft.banner.cross.purple" | "block.minecraft.andesite_stairs" | "item.minecraft.carrot" | "block.minecraft.red_sand" | "block.minecraft.banner.skull.orange" | "createWorld.customize.custom.useMineShafts" | "item.minecraft.lead" | "subtitles.entity.turtle.egg_break" | "block.minecraft.banner.half_horizontal.gray" | "subtitles.block.lever.click" | "item.minecraft.golden_apple" | "item.minecraft.iron_ingot" | "advancements.nether.return_to_sender.description" | "block.minecraft.banner.stripe_downright.gray" | "block.minecraft.hopper" | "commands.save.alreadyOn" | "subtitles.entity.cat.death" | "subtitles.entity.cod.death" | "gui.socialInteractions.status_blocked" | "item.minecraft.snowball" | "block.minecraft.banner.curly_border.yellow" | "subtitles.entity.illusioner.prepare_blindness" | "subtitles.entity.dolphin.swim" | "advancements.nether.fast_travel.title" | "disconnect.endOfStream" | "jigsaw_block.levels" | "advancements.nether.ride_strider.description" | "block.minecraft.cracked_stone_bricks" | "fml.menu.mods.info.version" | "block.minecraft.wet_sponge" | "stat.minecraft.open_chest" | "container.repair.cost" | "block.minecraft.banner.half_horizontal.light_blue" | "block.minecraft.slime_block" | "subtitles.entity.witch.death" | "block.minecraft.banner.bricks.cyan" | "createWorld.customize.custom.baseSize" | "item.minecraft.music_disc_mall" | "block.minecraft.banner.triangles_top.light_blue" | "block.minecraft.quartz_stairs" | "commands.effect.clear.specific.failed" | "commands.advancement.grant.many.to.one.success" | "connect.joining" | "block.minecraft.pink_carpet" | "block.minecraft.end_rod" | "pack.selected.title" | "item.minecraft.enchanted_book" | "block.minecraft.banner.square_top_left.purple" | "commands.team.option.name.success" | "selectWorld.gameMode.adventure.line2" | "item.minecraft.tipped_arrow.effect.strength" | "selectWorld.gameMode.adventure.line1" | "item.minecraft.oak_boat" | "biome.minecraft.eroded_badlands" | "block.minecraft.polished_granite_stairs" | "clear.failed.multiple" | "key.left" | "block.minecraft.smooth_quartz" | "entity.minecraft.spawner_minecart" | "block.minecraft.banner.triangles_top.magenta" | "subtitles.entity.tnt.primed" | "item.minecraft.stone_sword" | "block.minecraft.banner.curly_border.light_gray" | "block.minecraft.white_shulker_box" | "options.off.composed" | "advancements.husbandry.breed_all_animals.title" | "block.minecraft.banner.half_horizontal.yellow" | "block.minecraft.flowering_azalea" | "subtitles.block.brewing_stand.brew" | "selectWorld.deleteButton" | "block.minecraft.chiseled_nether_bricks" | "block.minecraft.melon" | "commands.forceload.removed.failure" | "item.minecraft.splash_potion.effect.turtle_master" | "gui.socialInteractions.hide" | "block.minecraft.acacia_planks" | "selectWorld.title" | "block.minecraft.banner.gradient.light_blue" | "item.minecraft.music_disc_stal" | "entity.minecraft.villager.mason" | "block.minecraft.banner.globe.light_gray" | "subtitles.entity.armor_stand.fall" | "block.minecraft.acacia_fence" | "item.minecraft.flower_banner_pattern" | "entity.minecraft.tropical_fish.type.dasher" | "mco.configure.world.subscription.extend" | "container.repair" | "block.minecraft.warped_wall_sign" | "block.minecraft.white_candle" | "connect.negotiating" | "narration.button.usage.focused" | "filled_map.monument" | "entity.minecraft.enderman" | "subtitles.block.portal.travel" | "block.minecraft.chipped_anvil" | "block.minecraft.stripped_acacia_wood" | "block.minecraft.orange_candle" | "block.minecraft.gray_terracotta" | "block.minecraft.light_blue_concrete_powder" | "subtitles.entity.item_frame.add_item" | "argument.entity.options.type.invalid" | "options.chat.scale" | "block.minecraft.infested_deepslate" | "biome.minecraft.end_midlands" | "mco.reset.world.experience" | "optimizeWorld.stage.finished" | "effect.minecraft.bad_omen" | "forge.configgui.showLoadWarnings" | "advancements.nether.root.title" | "subtitles.entity.experience_orb.pickup" | "subtitles.entity.ender_pearl.throw" | "commands.experience.query.levels" | "debug.inspect.client.entity" | "key.keyboard.semicolon" | "block.minecraft.banner.diagonal_up_right.blue" | "mco.brokenworld.minigame.title" | "subtitles.entity.turtle.hurt_baby" | "block.minecraft.banner.triangles_top.orange" | "block.minecraft.banner.straight_cross.light_gray" | "editGamerule.default" | "block.minecraft.banner.triangle_bottom.green" | "block.minecraft.banner.circle.yellow" | "biome.minecraft.deep_ocean" | "item.minecraft.firework_star.fade_to" | "item.minecraft.music_disc_cat" | "block.minecraft.black_stained_glass_pane" | "block.minecraft.banner.gradient_up.orange" | "subtitles.entity.ghast.death" | "effect.minecraft.glowing" | "subtitles.entity.cow.ambient" | "block.minecraft.oak_wood" | "block.minecraft.banner.small_stripes.light_gray" | "block.minecraft.powered_rail" | "options.mouse_settings" | "fml.menu.multiplayer.extraservermods" | "advancements.nether.all_effects.description" | "argument.dimension.invalid" | "subtitles.entity.generic.burn" | "commands.item.target.no_changed.known_item" | "block.minecraft.spruce_stairs" | "argument.entity.selector.self" | "block.minecraft.banner.small_stripes.pink" | "debug.profiling.stop" | "item.minecraft.drowned_spawn_egg" | "item.minecraft.glow_item_frame" | "commands.team.option.prefix.success" | "fml.menu.mods.a_to_z" | "entity.minecraft.husk" | "fml.menu.mods.title" | "commands.worldborder.center.success" | "block.minecraft.banner.half_vertical_right.yellow" | "block.minecraft.banner.mojang.light_blue" | "advancements.husbandry.fishy_business.title" | "multiplayer.requiredTexturePrompt.line2" | "title.multiplayer.disabled" | "multiplayer.requiredTexturePrompt.line1" | "item.minecraft.splash_potion.effect.empty" | "block.minecraft.green_shulker_box" | "biome.minecraft.windswept_gravelly_hills" | "entity.minecraft.wither_skeleton" | "selectWorld.seedInfo" | "subtitles.entity.generic.extinguish_fire" | "spectatorMenu.root.prompt" | "options.accessibility.link" | "translation.test.world" | "commands.bossbar.set.name.success" | "block.minecraft.polished_deepslate_slab" | "argument.integer.big" | "commands.reload.failure" | "options.graphics" | "commands.trigger.add.success" | "subtitles.block.pointed_dripstone.drip_water" | "block.minecraft.petrified_oak_slab" | "block.minecraft.banner.square_bottom_left.light_gray" | "block.minecraft.blue_banner" | "selectWorld.gameMode.adventure" | "effect.minecraft.levitation" | "block.minecraft.banner.rhombus.brown" | "chat.type.admin" | "subtitles.item.honeycomb.wax_on" | "advancements.adventure.arbalistic.description" | "subtitles.entity.item.break" | "item.minecraft.chest_minecart" | "deathScreen.respawn" | "subtitles.block.beacon.activate" | "commands.defaultgamemode.success" | "createWorld.customize.custom.preset.isleLand" | "block.minecraft.banner.half_vertical.pink" | "argument.component.invalid" | "block.minecraft.zombie_head" | "mount.onboard" | "subtitles.entity.cat.hiss" | "block.minecraft.nether_gold_ore" | "commands.tag.remove.success.multiple" | "block.minecraft.warped_roots" | "multiplayer.disconnect.outdated_server" | "block.minecraft.banner.flower.gray" | "commands.recipe.take.success.single" | "block.minecraft.nether_wart" | "block.minecraft.banner.diagonal_up_right.lime" | "biome.minecraft.ocean" | "commands.ban.failed" | "options.attack.hotbar" | "stat.minecraft.interact_with_stonecutter" | "block.minecraft.banner.bricks.white" | "effect.minecraft.weakness" | "commands.message.display.outgoing" | "menu.multiplayer" | "arguments.swizzle.invalid" | "subtitles.block.lava.ambient" | "block.minecraft.scaffolding" | "mco.news" | "subtitles.entity.fox.bite" | "item.minecraft.potion.effect.levitation" | "subtitles.entity.arrow.hit" | "mco.client.outdated.msg.line1" | "mco.upload.select.world.none" | "options.prioritizeChunkUpdates.nearby" | "mco.client.outdated.msg.line2" | "createWorld.customize.custom.center" | "createWorld.customize.custom.confirmTitle" | "advancements.adventure.fall_from_world_height.title" | "enchantment.minecraft.soul_speed" | "block.minecraft.banner.gradient.yellow" | "item.minecraft.pufferfish_spawn_egg" | "item.minecraft.elytra" | "commands.team.option.nametagVisibility.success" | "block.minecraft.sand" | "item.minecraft.zombified_piglin_spawn_egg" | "biome.minecraft.deep_frozen_ocean" | "block.minecraft.banner.creeper.pink" | "commands.scoreboard.players.remove.success.multiple" | "selectWorld.versionUnknown" | "structure_block.integrity" | "biome.minecraft.bamboo_jungle" | "selectWorld.import_worldgen_settings.select_file" | "block.minecraft.stripped_oak_log" | "debug.show_hitboxes.off" | "block.minecraft.smooth_quartz_stairs" | "block.minecraft.ender_chest" | "block.minecraft.banner.diagonal_right.blue" | "options.mouseWheelSensitivity" | "commands.data.get.invalid" | "key.inventory" | "structure_block.mode_info.data" | "argument.double.low" | "gui.socialInteractions.server_label.multiple" | "subtitles.block.end_portal_frame.fill" | "subtitles.entity.puffer_fish.flop" | "gamerule.doImmediateRespawn" | "advancements.adventure.voluntary_exile.title" | "mco.backup.nobackups" | "block.minecraft.azalea_leaves" | "structure_block.size_success" | "item.minecraft.potion.effect.poison" | "block.minecraft.banner.bricks.blue" | "argument.entity.options.unknown" | "advancements.husbandry.safely_harvest_honey.title" | "subtitles.entity.turtle.egg_hatch" | "mco.configure.world.restore.download.question.line2" | "mco.configure.world.restore.download.question.line1" | "item.minecraft.mutton" | "options.multiplayer.title" | "fml.menu.multiplayer.vanilla.incompatible" | "mco.create.world.wait" | "key.keyboard.right.alt" | "stat.minecraft.damage_absorbed" | "translation.test.none" | "block.minecraft.banner.curly_border.brown" | "entity.minecraft.cave_spider" | "disconnect.unknownHost" | "gamerule.doMobSpawning" | "controls.keybinds.title" | "commands.op.failed" | "forge.configgui.alwaysSetupTerrainOffThread.tooltip" | "selectWorld.gameMode.hardcore.line2" | "selectWorld.gameMode.hardcore.line1" | "block.minecraft.banner.half_vertical_right.magenta" | "block.minecraft.acacia_slab" | "item.minecraft.tipped_arrow.effect.slowness" | "subtitles.entity.dolphin.jump" | "commands.attribute.modifier.remove.success" | "item.minecraft.ender_pearl" | "subtitles.item.bundle.remove_one" | "commands.data.entity.get" | "subtitles.entity.piglin_brute.hurt" | "commands.advancement.revoke.criterion.to.one.failure" | "block.minecraft.skeleton_wall_skull" | "block.minecraft.banner.triangles_bottom.yellow" | "gameMode.survival" | "item.minecraft.sign" | "block.minecraft.purpur_stairs" | "subtitles.item.bucket.fill_fish" | "item.minecraft.music_disc_otherside.desc" | "commands.scoreboard.objectives.display.alreadySet" | "entity.minecraft.llama" | "block.minecraft.banner.base.light_blue" | "block.minecraft.banner.circle.green" | "subtitles.entity.iron_golem.death" | "mco.configure.world.buttons.delete" | "commands.forge.tags.page_info" | "subtitles.entity.parrot.imitate.stray" | "item.minecraft.lingering_potion.effect.healing" | "mco.configure.world.location" | "subtitles.entity.fox.sniff" | "selectWorld.incompatible_series" | "soundCategory.voice" | "attribute.name.generic.knockback_resistance" | "subtitles.entity.rabbit.attack" | "forge.controlsgui.shift" | "createWorld.customize.custom.lowerLimitScale" | "block.minecraft.banner.half_vertical.brown" | "argument.float.low" | "subtitles.entity.wolf.shake" | "block.minecraft.hay_block" | "createWorld.customize.flat.removeLayer" | "mco.configure.world.players.error" | "block.minecraft.crimson_fungus" | "block.minecraft.banner.stripe_bottom.light_gray" | "advancements.story.root.description" | "commands.stop.stopping" | "selectWorld.versionJoinButton" | "gameMode.adventure" | "multiplayer.texturePrompt.failure.line1" | "biome.minecraft.old_growth_spruce_taiga" | "multiplayer.texturePrompt.failure.line2" | "advancements.adventure.trade_at_world_height.title" | "subtitles.entity.bee.pollinate" | "block.minecraft.note_block" | "block.minecraft.light_gray_concrete_powder" | "item.minecraft.golden_leggings" | "item.minecraft.splash_potion.effect.mundane" | "item.minecraft.pumpkin_pie" | "block.minecraft.banner.gradient.pink" | "block.minecraft.activator_rail" | "subtitles.item.crop.plant" | "createWorld.customize.custom.biomeDepthWeight" | "commands.list.players" | "commands.bossbar.create.success" | "block.minecraft.red_sandstone_wall" | "item.minecraft.diamond_axe" | "block.minecraft.banner.curly_border.lime" | "mco.brokenworld.downloaded" | "advancements.story.mine_diamond.description" | "block.minecraft.red_shulker_box" | "subtitles.entity.turtle.swim" | "argument.pos.unloaded" | "block.minecraft.banner.flower.light_blue" | "commands.scoreboard.players.list.success" | "stat_type.minecraft.broken" | "options.percent_value" | "book.byAuthor" | "subtitles.entity.fishing_bobber.retrieve" | "item.minecraft.diamond_helmet" | "advancements.nether.all_potions.description" | "block.minecraft.wall_torch" | "entity.minecraft.horse" | "options.audioDevice" | "item.minecraft.fire_charge" | "subtitles.entity.parrot.imitate.illusioner" | "key.spectatorOutlines" | "block.minecraft.diorite_stairs" | "block.minecraft.light_gray_terracotta" | "block.minecraft.banner.piglin.black" | "attribute.name.generic.armor_toughness" | "block.minecraft.banner.stripe_bottom.green" | "block.minecraft.banner.square_top_left.red" | "subtitles.item.book.put" | "death.attack.indirectMagic.item" | "subtitles.entity.zombified_piglin.angry" | "gamerule.doMobLoot" | "item.minecraft.music_disc_otherside" | "forge.configgui.clumpingThreshold" | "block.minecraft.player_head" | "block.minecraft.banner.small_stripes.brown" | "advancements.end.enter_end_gateway.description" | "block.minecraft.birch_leaves" | "item.minecraft.diamond_pickaxe" | "block.minecraft.banner.square_bottom_right.pink" | "block.minecraft.sea_pickle" | "entity.minecraft.sheep" | "block.minecraft.dark_oak_door" | "subtitles.entity.player.hurt_drown" | "dataPack.validation.back" | "block.minecraft.light_gray_carpet" | "fml.loadingerrorscreen.errorheader" | "selectWorld.delete" | "subtitles.entity.item.pickup" | "item.minecraft.netherite_scrap" | "mco.terms.buttons.disagree" | "argument.item.tag.disallowed" | "options.key.hold" | "biome.minecraft.snowy_plains" | "selectWorld.recreate.error.title" | "resourcepack.progress" | "block.minecraft.light_blue_wool" | "gui.socialInteractions.tooltip.show" | "filled_map.id" | "subtitles.entity.phantom.flap" | "generator.single_biome_caves" | "item.minecraft.netherite_hoe" | "subtitles.entity.rabbit.hurt" | "subtitles.entity.player.hurt_on_fire" | "subtitles.entity.ravager.roar" | "block.minecraft.banner.mojang.blue" | "options.modelPart.cape" | "fml.menu.accessdenied.title" | "fml.menu.mods.info.childmods" | "commands.whitelist.disabled" | "options.generic_value" | "subtitles.entity.panda.bite" | "mco.upload.preparing" | "block.minecraft.banner.square_bottom_right.yellow" | "block.minecraft.banner.stripe_left.brown" | "subtitles.block.portal.ambient" | "enchantment.minecraft.loyalty" | "subtitles.entity.parrot.death" | "block.minecraft.trapped_chest" | "block.minecraft.banner.triangles_top.gray" | "subtitles.entity.illusioner.ambient" | "block.minecraft.banner.circle.black" | "menu.loadingForcedChunks" | "commands.whitelist.reloaded" | "subtitles.entity.illusioner.hurt" | "commands.data.merge.failed" | "subtitles.entity.axolotl.attack" | "subtitles.entity.silverfish.hurt" | "block.minecraft.potted_warped_fungus" | "block.minecraft.banner.square_top_right.pink" | "createWorld.customize.custom.stretchY" | "block.minecraft.banner.curly_border.blue" | "biome.minecraft.river" | "subtitles.block.conduit.ambient" | "block.minecraft.banner.square_top_left.gray" | "subtitles.item.axe.strip" | "selectWorld.enterSeed" | "subtitles.block.pointed_dripstone.land" | "subtitles.block.beehive.drip" | "subtitles.entity.bat.ambient" | "entity.minecraft.spectral_arrow" | "commands.tag.add.success.multiple" | "commands.publish.failed" | "forge.configgui.clumpingThreshold.tooltip" | "gui.proceed" | "selectWorld.deleteQuestion" | "selectWorld.edit.export_worldgen_settings.failure" | "createWorld.customize.custom.depthNoiseScaleZ" | "item.minecraft.netherite_pickaxe" | "block.minecraft.banner.rhombus.pink" | "item.minecraft.blaze_rod" | "item.minecraft.husk_spawn_egg" | "structure_block.position" | "commands.recipe.give.success.single" | "item.minecraft.tipped_arrow.effect.turtle_master" | "subtitles.block.generic.footsteps" | "fml.menu.mods.info.nochildmods" | "item.minecraft.iron_sword" | "commands.attribute.modifier.add.success" | "block.minecraft.orange_tulip" | "subtitles.entity.mooshroom.suspicious_milk" | "death.fell.accident.vines" | "commands.title.show.actionbar.multiple" | "block.minecraft.netherite_block" | "block.minecraft.banner.stripe_bottom.red" | "commands.debug.started" | "block.minecraft.infested_cracked_stone_bricks" | "filled_map.unknown" | "block.minecraft.banner.stripe_downleft.cyan" | "item.minecraft.tipped_arrow.effect.thick" | "block.minecraft.banner.bricks.magenta" | "gui.socialInteractions.show" | "subtitles.entity.guardian.ambient" | "container.creative" | "itemGroup.materials" | "entity.minecraft.armor_stand" | "block.minecraft.banner.mojang.lime" | "block.minecraft.banner.stripe_center.gray" | "entity.minecraft.zoglin" | "commands.team.list.teams.empty" | "block.minecraft.candle_cake" | "item.minecraft.goat_spawn_egg" | "debug.cycle_renderdistance.message" | "fml.modloading.brokenfile.invalidzip" | "block.minecraft.banner.piglin.light_gray" | "subtitles.block.dispenser.dispense" | "subtitles.block.sculk_sensor.clicking_stop" | "stat.itemsButton" | "block.minecraft.banner.gradient_up.brown" | "block.minecraft.banner.stripe_downleft.brown" | "subtitles.entity.cow.death" | "subtitles.entity.panda.ambient" | "item.minecraft.lingering_potion.effect.fire_resistance" | "effect.minecraft.invisibility" | "block.minecraft.repeater" | "block.minecraft.acacia_leaves" | "block.minecraft.tuff" | "block.minecraft.banner.stripe_bottom.black" | "commands.effect.clear.everything.failed" | "block.minecraft.banner.gradient.red" | "options.graphics.warning.accept" | "createWorld.customize.custom.depthNoiseScaleX" | "subtitles.block.chorus_flower.grow" | "debug.chunk_boundaries.help" | "container.dispenser" | "block.minecraft.banner.diagonal_right.lime" | "block.minecraft.banner.flower.black" | "options.chat.visibility" | "block.minecraft.warped_stem" | "block.minecraft.potted_flowering_azalea_bush" | "itemGroup.food" | "subtitles.entity.turtle.ambient_land" | "container.chestDouble" | "advancements.husbandry.wax_on.title" | "block.minecraft.soul_wall_torch" | "death.attack.witherSkull" | "mco.brokenworld.reset" | "block.minecraft.banner.triangle_bottom.cyan" | "multiplayer.disconnect.illegal_characters" | "item.minecraft.splash_potion.effect.weakness" | "potion.potency.5" | "tutorial.craft_planks.description" | "subtitles.entity.bee.hurt" | "key.keyboard.keypad.multiply" | "commands.placefeature.failed" | "item.minecraft.ghast_tear" | "commands.scoreboard.players.add.success.single" | "item.minecraft.lingering_potion.effect.luck" | "commands.worldborder.set.failed.big" | "block.minecraft.banner.stripe_right.magenta" | "block.minecraft.red_sandstone_stairs" | "subtitles.entity.cow.hurt" | "subtitles.item.hoe.till" | "gamerule.universalAnger" | "stat.minecraft.walk_on_water_one_cm" | "commands.debug.notRunning" | "block.minecraft.banner.bricks.light_blue" | "commands.save.saving" | "block.minecraft.cobbled_deepslate" | "argument.id.unknown" | "selectWorld.moreWorldOptions" | "block.minecraft.dead_fire_coral_block" | "block.minecraft.birch_planks" | "block.minecraft.stone_slab" | "gamerule.spectatorsGenerateChunks" | "entity.minecraft.guardian" | "potion.potency.0" | "subtitles.entity.stray.hurt" | "advancements.story.enter_the_end.title" | "block.minecraft.frosted_ice" | "block.minecraft.lime_banner" | "selectWorld.edit.backupFailed" | "potion.potency.4" | "block.minecraft.oak_slab" | "potion.potency.3" | "commands.whitelist.alreadyOff" | "potion.potency.2" | "potion.potency.1" | "selectWorld.futureworld.error.text" | "translation.test.args" | "mco.selectServer.minigameNotSupportedInVersion" | "entity.minecraft.painting" | "forge.configgui.disableVersionCheck" | "fml.modloading.cycle" | "container.smoker" | "block.minecraft.banner.half_vertical.light_blue" | "block.minecraft.brown_carpet" | "entity.minecraft.villager.librarian" | "argument.entity.options.y_rotation.description" | "advancements.story.enter_the_nether.title" | "narration.checkbox" | "advancements.story.lava_bucket.title" | "commands.forge.tags.registry_key" | "selectWorld.bonusItems" | "item.minecraft.vex_spawn_egg" | "block.minecraft.brain_coral_wall_fan" | "stat.minecraft.boat_one_cm" | "selectWorld.edit.openFolder" | "generator.single_biome_surface" | "subtitles.block.big_dripleaf.tilt_up" | "biome.minecraft.dripstone_caves" | "mco.minigame.world.stopButton" | "block.minecraft.cake" | "advancements.adventure.spyglass_at_parrot.title" | "block.minecraft.banner.circle.red" | "debug.gamemodes.press_f4" | "commands.worldborder.warning.distance.failed" | "mco.selectServer.popup" | "block.minecraft.end_stone_bricks" | "mco.create.world.reset.title" | "event.minecraft.raid" | "options.prioritizeChunkUpdates.none" | "enchantment.minecraft.power" | "subtitles.entity.ravager.hurt" | "block.minecraft.warped_pressure_plate" | "stat_type.minecraft.killed" | "block.minecraft.horn_coral_fan" | "advancements.toast.challenge" | "block.minecraft.banner.diagonal_right.gray" | "item.minecraft.splash_potion" | "block.minecraft.jungle_log" | "commands.experience.add.points.success.single" | "item.minecraft.zoglin_spawn_egg" | "argument.float.big" | "itemGroup.decorations" | "block.minecraft.gray_glazed_terracotta" | "subtitles.block.bubble_column.upwards_inside" | "gui.all" | "death.attack.stalagmite" | "item.minecraft.lingering_potion.effect.water" | "subtitles.entity.witch.celebrate" | "block.minecraft.chiseled_polished_blackstone" | "container.dropper" | "commands.team.empty.success" | "commands.particle.success" | "death.fell.accident.weeping_vines" | "advancements.story.deflect_arrow.title" | "mco.configure.world.slot.empty" | "enchantment.minecraft.lure" | "block.minecraft.black_terracotta" | "subtitles.entity.axolotl.idle_air" | "commands.team.option.color.unchanged" | "argument.nbt.expected.value" | "block.minecraft.lily_pad" | "commands.data.block.invalid" | "subtitles.entity.chicken.ambient" | "soundCategory.neutral" | "block.minecraft.pointed_dripstone" | "generator.amplified.info" | "subtitles.block.generic.place" | "commands.forceload.added.none" | "advancements.nether.summon_wither.title" | "mco.configure.world.edit.subscreen.adventuremap" | "subtitles.block.bubble_column.bubble_pop" | "advancements.husbandry.balanced_diet.description" | "key.saveToolbarActivator" | "block.minecraft.banner.small_stripes.magenta" | "block.minecraft.banner.diagonal_left.white" | "subtitles.entity.blaze.ambient" | "item.minecraft.netherite_boots" | "gamerule.fireDamage" | "argument.entity.options.nbt.description" | "block.minecraft.warped_trapdoor" | "block.minecraft.banner.square_bottom_left.pink" | "commands.pardonip.failed" | "block.minecraft.banner.diagonal_up_right.white" | "stat.minecraft.talked_to_villager" | "fml.messages.version.restriction.upper.inclusive" | "key.keyboard.right.shift" | "advMode.triggering" | "subtitles.entity.villager.work_fletcher" | "title.multiplayer.lan" | "enchantment.minecraft.vanishing_curse" | "options.mainHand" | "item.minecraft.pumpkin_seeds" | "subtitles.entity.zombified_piglin.hurt" | "commands.effect.give.failed" | "fml.modmismatchscreen.table.youneed" | "block.minecraft.nether_brick_wall" | "item.minecraft.firework_star.trail" | "demo.help.buy" | "block.minecraft.banner.creeper.magenta" | "advMode.allEntities" | "subtitles.entity.zombified_piglin.ambient" | "subtitles.entity.lightning_bolt.thunder" | "mco.error.invalid.session.title" | "disconnect.loginFailedInfo.serversUnavailable" | "item.minecraft.armor_stand" | "mco.configure.world.closing" | "death.attack.fall" | "block.minecraft.yellow_concrete" | "entity.minecraft.villager.armorer" | "disconnect.spam" | "mco.backup.button.restore" | "key.keyboard.insert" | "gui.socialInteractions.title" | "item.minecraft.ravager_spawn_egg" | "block.minecraft.banner.creeper.green" | "block.minecraft.dragon_wall_head" | "block.minecraft.twisting_vines_plant" | "block.minecraft.banner.half_vertical.white" | "advancements.husbandry.breed_an_animal.title" | "block.minecraft.cyan_glazed_terracotta" | "effect.minecraft.hero_of_the_village" | "createWorld.customize.flat.layer.top" | "block.minecraft.potted_spruce_sapling" | "item.minecraft.cave_spider_spawn_egg" | "mco.reset.world.warning" | "subtitles.entity.parrot.imitate.hoglin" | "block.minecraft.deepslate_tile_wall" | "death.attack.arrow" | "block.minecraft.banner.gradient.magenta" | "multiplayer.status.request_handled" | "block.minecraft.void_air" | "item.minecraft.ghast_spawn_egg" | "item.minecraft.splash_potion.effect.swiftness" | "subtitles.entity.pig.saddle" | "block.minecraft.banner.circle.magenta" | "block.minecraft.gray_concrete_powder" | "multiplayer.disconnect.ip_banned" | "item.minecraft.trader_llama_spawn_egg" | "mco.download.cancelled" | "commands.worldborder.warning.distance.success" | "block.minecraft.cut_sandstone_slab" | "block.minecraft.banner.stripe_bottom.yellow" | "options.percent_add_value" | "item.minecraft.firework_star.light_gray" | "fml.modmismatchscreen.missingmods.client" | "block.minecraft.dark_oak_sapling" | "entity.minecraft.zombie_horse" | "block.minecraft.banner.cross.cyan" | "selectServer.delete" | "subtitles.entity.turtle.shamble" | "argument.entity.options.valueless" | "addServer.resourcePack" | "key.screenshot" | "commands.worldborder.get" | "commands.forge.dimensions.list" | "commands.spreadplayers.success.entities" | "biome.minecraft.deep_lukewarm_ocean" | "createWorld.customize.custom.preset.goodLuck" | "block.minecraft.banner.triangles_bottom.cyan" | "mco.download.downloading" | "block.minecraft.white_concrete" | "commands.execute.conditional.pass_count" | "block.minecraft.potted_poppy" | "block.minecraft.birch_wall_sign" | "advancements.husbandry.ride_a_boat_with_a_goat.title" | "advancements.nether.find_fortress.description" | "mco.selectServer.expires.day" | "subtitles.entity.mooshroom.convert" | "subtitles.entity.sheep.hurt" | "subtitles.item.bottle.fill" | "block.minecraft.dead_tube_coral_block" | "block.minecraft.banner.stripe_downright.magenta" | "block.minecraft.spruce_sapling" | "block.minecraft.sticky_piston" | "block.minecraft.banner.base.gray" | "item.minecraft.birch_boat" | "item.minecraft.experience_bottle" | "subtitles.entity.bat.death" | "subtitles.block.generic.break" | "block.minecraft.banner.skull.pink" | "item.minecraft.wooden_sword" | "jigsaw_block.generate" | "commands.banlist.entry" | "gui.socialInteractions.search_empty" | "subtitles.entity.llama.chest" | "commands.whitelist.add.success" | "commands.clone.success" | "block.minecraft.magenta_concrete_powder" | "screenshot.success" | "entity.minecraft.glow_squid" | "death.attack.explosion" | "pack.dropInfo" | "block.minecraft.crimson_hyphae" | "block.minecraft.black_wool" | "commands.effect.give.success.multiple" | "block.minecraft.magenta_bed" | "block.minecraft.black_concrete" | "advMode.mode.redstone" | "subtitles.entity.snow_golem.death" | "block.minecraft.banner.globe.yellow" | "commands.spectate.self" | "item.minecraft.lingering_potion.effect.regeneration" | "selectServer.title" | "block.minecraft.banner.cross.red" | "selectWorld.import_worldgen_settings.experimental.question" | "block.minecraft.red_mushroom_block" | "entity.minecraft.fireball" | "mirror.none" | "fml.menu.multiplayer.clientoutdated" | "block.minecraft.prismarine_wall" | "subtitles.entity.evoker.prepare_attack" | "subtitles.entity.zombie.converted_to_drowned" | "subtitles.entity.wandering_trader.no" | "block.minecraft.banner.diagonal_left.gray" | "block.minecraft.banner.gradient_up.black" | "block.minecraft.spruce_button" | "stat.minecraft.leave_game" | "block.minecraft.banner.gradient_up.blue" | "item.minecraft.mooshroom_spawn_egg" | "advancements.nether.ride_strider_in_overworld_lava.title" | "commands.bossbar.set.players.success.none" | "stat.minecraft.damage_blocked_by_shield" | "commands.attribute.modifier.value.get.success" | "options.fullscreen.unavailable" | "commands.forge.tags.copy_element_names" | "argument.long.big" | "argument.scoreboardDisplaySlot.invalid" | "item.unbreakable" | "subtitles.entity.goat.death" | "forge.configgui.alwaysSetupTerrainOffThread" | "block.minecraft.tinted_glass" | "block.minecraft.banner.triangle_bottom.pink" | "fml.menu.multiplayer.serveroutdated" | "item.minecraft.netherite_helmet" | "key.swapOffhand" | "commands.team.join.success.multiple" | "subtitles.item.armor.equip_chain" | "key.jump" | "spectatorMenu.next_page" | "multiplayer.disconnect.invalid_entity_attacked" | "block.minecraft.banner.skull.black" | "demo.help.jump" | "block.minecraft.blue_ice" | "subtitles.entity.ender_eye.death" | "selectWorld.delete_failure" | "lanServer.scanning" | "parsing.double.expected" | "block.minecraft.banner.bricks.orange" | "selectWorld.futureworld.error.title" | "commands.gamemode.success.self" | "mco.configure.world.slot.tooltip.minigame" | "block.minecraft.banner.triangle_top.yellow" | "menu.sendFeedback" | "entity.minecraft.parrot" | "soundCategory.master" | "jigsaw_block.keep_jigsaws" | "argument.entity.options.sort.irreversible" | "block.minecraft.acacia_log" | "subtitles.item.ink_sac.use" | "subtitles.entity.slime.squish" | "subtitles.entity.villager.trade" | "subtitles.entity.donkey.death" | "forge.configgui.removeErroringEntities" | "subtitles.entity.wolf.hurt" | "block.minecraft.orange_glazed_terracotta" | "argument.entity.options.team.description" | "item.minecraft.shield.lime" | "parsing.quote.expected.start" | "entity.minecraft.phantom" | "item.minecraft.egg" | "commands.worldborder.set.failed.far" | "item.minecraft.music_disc_blocks.desc" | "commands.team.option.nametagVisibility.unchanged" | "commands.forge.tags.error.unknown_element" | "entity.minecraft.dolphin" | "block.minecraft.oak_pressure_plate" | "biome.minecraft.plains" | "item.minecraft.honey_bottle" | "gui.entity_tooltip.type" | "mco.backup.button.download" | "block.minecraft.banner.creeper.black" | "advancements.adventure.spyglass_at_dragon.title" | "commands.title.show.actionbar.single" | "commands.advancement.grant.criterion.to.one.failure" | "block.minecraft.banner.bricks.lime" | "lectern.take_book" | "forge.configgui.removeErroringBlockEntities.tooltip" | "subtitles.entity.painting.break" | "subtitles.entity.wandering_trader.drink_potion" | "block.minecraft.birch_wood" | "createWorld.customize.custom.randomize" | "block.minecraft.banner.gradient_up.lime" | "enchantment.minecraft.thorns" | "commands.scoreboard.objectives.list.empty" | "commands.bossbar.set.name.unchanged" | "argument.criteria.invalid" | "forge.update.newversion" | "connect.authorizing" | "death.attack.flyIntoWall.player" | "item.minecraft.glow_berries" | "commands.tag.list.multiple.empty" | "key.socialInteractions" | "key.keyboard.space" | "fml.menu.multiplayer.missingdatapackregistries" | "block.minecraft.bed.occupied" | "structure_block.hover.load" | "fml.menu.mods.search" | "item.minecraft.dragon_breath" | "subtitles.block.bubble_column.whirlpool_inside" | "block.minecraft.banner.stripe_left.gray" | "subtitles.entity.parrot.imitate.drowned" | "block.minecraft.banner.rhombus.cyan" | "color.minecraft.lime" | "gamerule.category.updates" | "block.minecraft.yellow_stained_glass_pane" | "commands.team.option.deathMessageVisibility.success" | "block.minecraft.banner.stripe_downleft.light_gray" | "attribute.modifier.equals.2" | "block.minecraft.amethyst_block" | "attribute.modifier.equals.1" | "block.minecraft.polished_blackstone_bricks" | "attribute.modifier.equals.0" | "item.minecraft.red_dye" | "subtitles.entity.painting.place" | "mco.minigame.world.noSelection" | "attribute.name.zombie.spawn_reinforcements" | "subtitles.entity.panda.sneeze" | "block.minecraft.banner.small_stripes.orange" | "subtitles.entity.iron_golem.damage" | "block.minecraft.banner.gradient_up.green" | "block.minecraft.banner.globe.lime" | "pack.openFolder" | "subtitles.entity.villager.work_fisherman" | "enchantment.minecraft.fire_protection" | "addServer.resourcePack.enabled" | "title.32bit.deprecation.realms.header" | "block.minecraft.air" | "chat.type.advancement.goal" | "subtitles.entity.parrot.imitate.slime" | "multiplayer.disconnect.server_shutdown" | "commands.debug.alreadyRunning" | "argument.range.empty" | "block.minecraft.banner.curly_border.orange" | "multiplayer.disconnect.banned_ip.reason" | "forge.configgui.fullBoundingBoxLadders" | "key.use" | "block.minecraft.poppy" | "item.minecraft.firework_rocket" | "advancements.nether.create_full_beacon.title" | "block.minecraft.crimson_pressure_plate" | "resourcepack.downloading" | "generator.single_biome_floating_islands" | "item.canPlace" | "subtitles.entity.illusioner.prepare_mirror" | "commands.enchant.failed.itemless" | "createWorld.customize.presets.share" | "sleep.not_possible" | "createWorld.customize.preset.tunnelers_dream" | "item.minecraft.shield.brown" | "subtitles.entity.wither.shoot" | "gamerule.doEntityDrops.description" | "block.minecraft.brown_candle" | "structure_block.show_boundingbox" | "mco.selectServer.configure" | "commands.debug.function.traceFailed" | "forge.configgui.treatEmptyTagsAsAir.tooltip" | "options.sensitivity.max" | "gui.up" | "stat.minecraft.clean_banner" | "block.minecraft.banner.straight_cross.black" | "commands.fill.failed" | "key.keyboard.backspace" | "item.minecraft.firework_star.purple" | "item.minecraft.shield.yellow" | "block.minecraft.stripped_birch_wood" | "item.minecraft.firework_star.flicker" | "block.minecraft.banner.stripe_middle.red" | "item.minecraft.creeper_banner_pattern.desc" | "options.prioritizeChunkUpdates.byPlayer.tooltip" | "commands.scoreboard.objectives.modify.rendertype" | "commands.advancement.revoke.criterion.to.many.success" | "block.minecraft.deepslate_brick_slab" | "commands.team.option.suffix.success" | "gameMode.spectator" | "mco.selectServer.leave" | "block.minecraft.purpur_block" | "subtitles.entity.shulker.shoot" | "menu.modded" | "item.minecraft.cooked_chicken" | "block.minecraft.banner.curly_border.cyan" | "subtitles.item.shears.shear" | "options.attackIndicator" | "stat.generalButton" | "structure_block.custom_data" | "block.minecraft.banner.square_top_right.light_blue" | "structure_block.hover.save" | "argument.angle.invalid" | "fml.menu.multiplayer.truncated" | "selectWorld.newWorld" | "block.minecraft.oak_sign" | "item.minecraft.nether_star" | "block.minecraft.stonecutter" | "subtitles.entity.pillager.celebrate" | "block.minecraft.structure_block" | "item.minecraft.splash_potion.effect.harming" | "block.minecraft.jukebox" | "entity.minecraft.command_block_minecart" | "effect.minecraft.nausea" | "block.minecraft.gold_block" | "chat.link.confirm" | "block.minecraft.lime_concrete_powder" | "advancements.adventure.lightning_rod_with_villager_no_fire.title" | "block.minecraft.banner.square_top_left.magenta" | "demo.help.title" | "subtitles.entity.zoglin.attack" | "subtitles.entity.parrot.imitate.spider" | "subtitles.item.nether_wart.plant" | "mco.reset.world.seed" | "block.minecraft.bone_block" | "key.chat" | "enchantment.minecraft.looting" | "block.minecraft.ancient_debris" | "block.minecraft.banner.stripe_right.black" | "disconnect.kicked" | "options.ao.min" | "fml.messages.version.restriction.bounded.lowerexclusive" | "block.minecraft.banner.skull.green" | "block.minecraft.banner.square_top_right.magenta" | "fml.modmismatchscreen.homepage" | "block.minecraft.banner.half_vertical.magenta" | "advancements.nether.ride_strider_in_overworld_lava.description" | "gui.none" | "subtitles.entity.phantom.hurt" | "block.minecraft.azalea" | "commands.schedule.cleared.failure" | "key.command" | "block.minecraft.banner.rhombus.orange" | "subtitles.entity.piglin_brute.ambient" | "block.minecraft.banner.diagonal_up_right.cyan" | "color.minecraft.blue" | "sign.edit" | "enchantment.minecraft.efficiency" | "block.minecraft.banner.gradient_up.light_blue" | "narration.checkbox.usage.focused" | "demo.help.later" | "block.minecraft.spruce_pressure_plate" | "block.minecraft.set_spawn" | "block.minecraft.exposed_copper" | "gameMode.changed" | "subtitles.entity.parrot.imitate.zoglin" | "selectWorld.edit.backupCreated" | "commands.data.entity.invalid" | "multiplayer.disconnect.invalid_packet" | "options.hideMatchedNames" | "debug.reload_resourcepacks.message" | "biome.minecraft.windswept_forest" | "argument.nbt.list.mixed" | "compliance.playtime.message" | "advancements.sad_label" | "block.minecraft.banner.square_bottom_left.green" | "item.minecraft.music_disc_strad" | "entity.minecraft.boat" | "effect.minecraft.unluck" | "advancements.adventure.summon_iron_golem.description" | "commands.data.storage.modified" | "forge.configgui.dimensionUnloadQueueDelay.tooltip" | "block.minecraft.dead_horn_coral_fan" | "mco.configure.world.subscription.days" | "subtitles.entity.vindicator.hurt" | "block.minecraft.banner.globe.blue" | "subtitles.entity.villager.hurt" | "createWorld.customize.custom.preset.drought" | "block.minecraft.birch_fence" | "block.minecraft.iron_trapdoor" | "fml.modloading.brokenfile.optifine" | "item.minecraft.music_disc_11.desc" | "item.minecraft.polar_bear_spawn_egg" | "debug.crash.message" | "death.attack.fallingBlock" | "block.minecraft.banner.diagonal_right.brown" | "subtitles.entity.illusioner.death" | "arguments.item.overstacked" | "block.minecraft.black_glazed_terracotta" | "block.minecraft.banner.flower.magenta" | "mco.invites.title" | "mco.account.update" | "commands.datapack.list.enabled.success" | "block.minecraft.light_blue_candle" | "block.minecraft.banner.half_vertical.green" | "item.minecraft.firework_star" | "gamerule.spawnRadius" | "createWorld.customize.custom.mainNoiseScaleX" | "createWorld.customize.custom.mainNoiseScaleY" | "createWorld.customize.custom.mainNoiseScaleZ" | "key.categories.ui" | "block.minecraft.banner.triangles_top.light_gray" | "options.gamma.min" | "mco.configure.world.subscription.unknown" | "createWorld.customize.custom.coordinateScale" | "effect.minecraft.conduit_power" | "block.minecraft.banner.square_top_left.black" | "commands.forge.tracking.timing_entry" | "subtitles.entity.blaze.burn" | "advancements.end.elytra.description" | "block.minecraft.banner.half_vertical.orange" | "advancements.end.dragon_breath.description" | "multiplayer.disconnect.name_taken" | "mco.minigame.world.startButton" | "disconnect.loginFailedInfo.insufficientPrivileges" | "block.minecraft.dead_horn_coral_block" | "commands.data.modify.invalid_index" | "entity.minecraft.firework_rocket" | "block.minecraft.banner.square_bottom_left.black" | "block.minecraft.banner.rhombus.black" | "biome.minecraft.wooded_badlands" | "block.minecraft.cornflower" | "commands.forge.setdim.invalid.entity" | "options.discrete_mouse_scroll" | "subtitles.entity.elder_guardian.ambient_land" | "chat_screen.title" | "structure_block.mode_info.corner" | "debug.inspect.client.block" | "dataPack.validation.failed" | "mco.activity.noactivity" | "fml.messages.version.restriction.lower.inclusive" | "entity.minecraft.villager.weaponsmith" | "menu.paused" | "block.minecraft.purple_glazed_terracotta" | "mco.selectServer.play" | "block.minecraft.waxed_exposed_cut_copper_stairs" | "fml.menu.modoptions" | "options.sensitivity.min" | "death.attack.outOfWorld" | "mco.connect.authorizing" | "subtitles.entity.magma_cube.hurt" | "menu.quit" | "stat.minecraft.interact_with_cartography_table" | "advancements.story.cure_zombie_villager.description" | "forge.configgui.zombieBabyChance" | "block.minecraft.banner.stripe_left.white" | "commands.trigger.failed.unprimed" | "chat.queue" | "advancements.husbandry.complete_catalogue.title" | "commands.scoreboard.players.operation.success.single" | "selectWorld.unable_to_load" | "subtitles.entity.goat.screaming.ambient" | "block.minecraft.deepslate_gold_ore" | "block.minecraft.end_stone_brick_wall" | "subtitles.entity.puffer_fish.blow_up" | "options.language" | "block.minecraft.vine" | "enchantment.minecraft.aqua_affinity" | "commands.scoreboard.players.reset.specific.multiple" | "block.minecraft.orange_concrete" | "entity.minecraft.ender_pearl" | "block.minecraft.banner.diagonal_left.yellow" | "block.minecraft.blue_stained_glass_pane" | "subtitles.entity.illusioner.mirror_move" | "block.minecraft.smoker" | "gui.socialInteractions.hidden_in_chat" | "commands.bossbar.list.bars.some" | "effect.minecraft.instant_damage" | "block.minecraft.infested_stone_bricks" | "commands.playsound.failed" | "item.canBreak" | "death.attack.trident" | "block.minecraft.blue_stained_glass" | "enchantment.minecraft.protection" | "options.guiScale.auto" | "block.minecraft.banner.flower.lime" | "commands.whitelist.enabled" | "subtitles.entity.sheep.ambient" | "block.minecraft.magenta_wool" | "block.minecraft.blue_candle" | "entity.minecraft.villager.fletcher" | "debug.gamemodes.select_next" | "block.minecraft.weeping_vines" | "subtitles.entity.fox.teleport" | "subtitles.entity.goat.hurt" | "subtitles.entity.snowball.throw" | "block.minecraft.brown_concrete_powder" | "subtitles.entity.wither_skeleton.ambient" | "subtitles.block.note_block.note" | "block.minecraft.acacia_trapdoor" | "block.minecraft.banner.triangles_top.white" | "commands.spectate.success.stopped" | "fml.menu.mods.info.trust" | "enchantment.level.10" | "subtitles.entity.vex.charge" | "createWorld.customize.custom.depthNoiseScaleExponent" | "tutorial.move.description" | "block.minecraft.amethyst_cluster" | "item.minecraft.black_dye" | "block.minecraft.banner.straight_cross.green" | "commands.bossbar.set.style.unchanged" | "block.minecraft.polished_blackstone_brick_wall" | "commands.time.query" | "advancements.end.enter_end_gateway.title" | "structure_block.button.detect_size" | "advancements.husbandry.make_a_sign_glow.title" | "container.loom" | "entity.minecraft.ender_dragon" | "forge.configgui.treatEmptyTagsAsAir" | "subtitles.block.fire.extinguish" | "block.minecraft.banner.half_horizontal_bottom.white" | "selectServer.edit" | "block.minecraft.anvil" | "mco.configure.world.slot" | "block.minecraft.waxed_cut_copper" | "fml.modloading.brokenfile.liteloader" | "block.minecraft.birch_slab" | "subtitles.enchant.thorns.hit" | "options.ao.max" | "block.minecraft.cyan_candle_cake" | "mco.upload.failed" | "block.minecraft.banner.half_horizontal_bottom.pink" | "biome.minecraft.cold_ocean" | "options.framerateLimit" | "narrator.button.difficulty_lock.unlocked" | "commands.datapack.list.available.none" | "block.minecraft.oak_wall_sign" | "enchantment.minecraft.riptide" | "argument.nbt.array.mixed" | "block.minecraft.brewing_stand" | "block.minecraft.banner.triangle_top.gray" | "commands.kill.success.multiple" | "block.minecraft.brown_concrete" | "block.minecraft.pink_candle" | "options.key.toggle" | "death.attack.lightningBolt.player" | "block.minecraft.banner.square_top_left.green" | "block.minecraft.potted_bamboo" | "block.minecraft.deepslate_bricks" | "block.minecraft.blackstone_wall" | "item.minecraft.villager_spawn_egg" | "advMode.command" | "options.chat.line_spacing" | "effect.minecraft.absorption" | "block.minecraft.light_gray_concrete" | "block.minecraft.banner.flower.blue" | "datapackFailure.title" | "biome.minecraft.frozen_peaks" | "block.minecraft.dead_brain_coral" | "key.keyboard.keypad.divide" | "compliance.playtime.hours" | "block.minecraft.sugar_cane" | "item.color" | "item.minecraft.saddle" | "block.minecraft.banner.rhombus.green" | "menu.loadingLevel" | "structure_block.size" | "lanServer.otherPlayers" | "block.minecraft.green_concrete_powder" | "subtitles.entity.goat.long_jump" | "block.minecraft.red_mushroom" | "block.minecraft.end_gateway" | "structure_block.integrity.integrity" | "advancements.nether.summon_wither.description" | "block.minecraft.deepslate_copper_ore" | "subtitles.item.crossbow.load" | "subtitles.entity.phantom.swoop" | "advancements.story.shiny_gear.description" | "block.minecraft.banner.stripe_downleft.light_blue" | "block.minecraft.banner.cross.lime" | "resourcePack.server.name" | "book.finalizeWarning" | "demo.day.2" | "demo.day.1" | "demo.day.4" | "block.minecraft.cracked_deepslate_bricks" | "demo.day.3" | "item.minecraft.slime_ball" | "enchantment.minecraft.sharpness" | "subtitles.block.door.toggle" | "commands.data.block.get" | "demo.day.6" | "demo.day.5" | "item.minecraft.magenta_dye" | "item.minecraft.glistering_melon_slice" | "subtitles.entity.slime.attack" | "commands.forge.tracking.be.reset" | "multiplayer.disconnect.outdated_client" | "subtitles.entity.enderman.ambient" | "block.minecraft.horn_coral_wall_fan" | "block.minecraft.potted_red_tulip" | "mco.selectServer.mapOnlySupportedForVersion" | "commands.forge.tps.summary.all" | "subtitles.entity.turtle.egg_crack" | "gamerule.playersSleepingPercentage.description" | "item.minecraft.golden_axe" | "gamerule.doLimitedCrafting.description" | "block.minecraft.deepslate_tiles" | "commands.execute.conditional.pass" | "block.minecraft.banner.stripe_downright.cyan" | "fml.messages.version.restriction.lower.exclusive" | "item.minecraft.skull_banner_pattern.desc" | "block.minecraft.banner.cross.orange" | "disconnect.closed" | "block.minecraft.banner.gradient_up.cyan" | "commands.experience.set.levels.success.single" | "container.spectatorCantOpen" | "subtitles.entity.turtle.shamble_baby" | "block.minecraft.banner.diagonal_left.lime" | "resourcePack.vanilla.description" | "block.minecraft.infested_mossy_stone_bricks" | "biome.minecraft.snowy_slopes" | "death.attack.fallingStalactite" | "block.minecraft.blue_concrete" | "block.minecraft.banner.creeper.white" | "selectWorld.import_worldgen_settings" | "death.attack.anvil" | "block.minecraft.banner.triangles_bottom.lime" | "subtitles.entity.wandering_trader.drink_milk" | "mco.terms.title" | "item.minecraft.light_gray_dye" | "block.minecraft.banner.border.brown" | "gui.toTitle" | "selectServer.refresh" | "block.minecraft.fire_coral_wall_fan" | "block.minecraft.packed_ice" | "block.minecraft.dispenser" | "block.minecraft.banner.bricks.gray" | "fml.modloading.brokenfile.fabric" | "narrator.controls.unbound" | "subtitles.item.armor.equip" | "commands.effect.give.success.single" | "spectatorMenu.close" | "advMode.mode.unconditional" | "subtitles.entity.parrot.imitate.skeleton" | "biome.minecraft.meadow" | "argument.entity.toomany" | "commands.playsound.success.single" | "subtitles.entity.ravager.celebrate" | "item.minecraft.brick" | "block.minecraft.banner.gradient.purple" | "lanServer.start" | "block.minecraft.mossy_cobblestone_slab" | "fml.modloading.failedtoloadmodclass" | "subtitles.ambient.cave" | "subtitles.block.pointed_dripstone.drip_lava" | "pack.available.title" | "entity.minecraft.shulker" | "subtitles.entity.player.attack.sweep" | "block.minecraft.banner.square_top_right.orange" | "commands.save.success" | "block.minecraft.emerald_ore" | "subtitles.item.armor.equip_diamond" | "subtitles.item.armor.equip_netherite" | "createWorld.customize.custom.useTemples" | "mco.template.select.narrate.version" | "block.minecraft.dark_oak_stairs" | "subtitles.entity.elder_guardian.ambient" | "advancements.nether.uneasy_alliance.title" | "chat.disabled.launcher" | "block.minecraft.andesite" | "advancements.nether.brew_potion.description" | "subtitles.entity.magma_cube.squish" | "subtitles.entity.skeleton.death" | "block.minecraft.dead_tube_coral_wall_fan" | "block.minecraft.banner.stripe_middle.brown" | "subtitles.block.beehive.exit" | "block.minecraft.banner.diagonal_left.green" | "options.gamma.max" | "block.minecraft.polished_blackstone_pressure_plate" | "stat.minecraft.pig_one_cm" | "subtitles.entity.zoglin.angry" | "commands.enchant.failed.entity" | "block.minecraft.gray_carpet" | "argument.entity.selector.not_allowed" | "item.nbt_tags" | "subtitles.block.chest.open" | "subtitles.item.armor.equip_gold" | "potion.withAmplifier" | "item.minecraft.diamond_leggings" | "block.minecraft.banner.border.orange" | "argument.player.entities" | "subtitles.entity.ravager.attack" | "subtitles.entity.husk.converted_to_zombie" | "subtitles.entity.pig.death" | "block.minecraft.cobbled_deepslate_slab" | "block.minecraft.banner.base.light_gray" | "argument.id.invalid" | "block.minecraft.purple_bed" | "block.minecraft.chain_command_block" | "block.minecraft.iron_ore" | "forge.configgui.forgeCloudsEnabled.tooltip" | "block.minecraft.banner.square_top_left.orange" | "mco.selectServer.info" | "mco.create.world.subtitle" | "options.screenEffectScale" | "options.narrator.off" | "block.minecraft.banner.flower.purple" | "multiplayer.disconnect.banned.reason" | "block.minecraft.purpur_pillar" | "block.minecraft.banner.triangle_top.brown" | "entity.minecraft.iron_golem" | "subtitles.block.pointed_dripstone.drip_water_into_cauldron" | "mco.configure.world.edit.subscreen.inspiration" | "entity.minecraft.small_fireball" | "subtitles.entity.goat.prepare_ram" | "advancements.adventure.walk_on_powder_snow_with_leather_boots.title" | "commands.save.failed" | "translation.test.escape" | "item.minecraft.stick" | "advancements.toast.goal" | "block.minecraft.banner.circle.light_blue" | "item.minecraft.bundle" | "itemGroup.buildingBlocks" | "block.minecraft.banner.stripe_top.red" | "mco.brokenworld.title" | "createWorld.customize.flat.height" | "command.unknown.argument" | "key.categories.movement" | "block.minecraft.magenta_glazed_terracotta" | "subtitles.entity.puffer_fish.hurt" | "block.minecraft.deepslate_tile_stairs" | "advancements.adventure.lightning_rod_with_villager_no_fire.description" | "commands.bossbar.set.players.unchanged" | "fml.modloading.uncaughterror" | "block.minecraft.moving_piston" | "block.minecraft.polished_blackstone_slab" | "subtitles.entity.squid.ambient" | "biome.minecraft.the_void" | "block.minecraft.fire" | "advancements.adventure.ol_betsy.title" | "block.minecraft.banner.stripe_downleft.yellow" | "block.minecraft.birch_door" | "block.minecraft.cyan_shulker_box" | "block.minecraft.light" | "advancements.adventure.throw_trident.description" | "advancements.nether.obtain_blaze_rod.description" | "commands.scoreboard.players.get.success" | "options.chat.visibility.system" | "block.minecraft.smooth_sandstone_stairs" | "subtitles.entity.spider.death" | "subtitles.entity.shulker.ambient" | "block.minecraft.redstone_torch" | "block.minecraft.lime_glazed_terracotta" | "subtitles.entity.ender_dragon.death" | "key.keyboard.down" | "stat.minecraft.open_barrel" | "debug.creative_spectator.error" | "mco.brokenworld.nonowner.title" | "block.minecraft.banner.triangles_bottom.magenta" | "entity.minecraft.ghast" | "advancements.adventure.play_jukebox_in_meadows.title" | "team.collision.never" | "block.minecraft.banner.cross.white" | "block.minecraft.light_gray_candle_cake" | "block.minecraft.heavy_weighted_pressure_plate" | "multiplayer.status.cancelled" | "block.minecraft.waxed_oxidized_copper" | "createWorld.customize.custom.useWaterLakes" | "commands.forge.setdim.deprecated" | "block.minecraft.banner.half_vertical.gray" | "subtitles.entity.player.burp" | "gui.socialInteractions.search_hint" | "gui.ok" | "entity.minecraft.cod" | "block.minecraft.stripped_spruce_wood" | "argument.entity.options.sort.description" | "entity.minecraft.hoglin" | "commands.banlist.list" | "biome.minecraft.basalt_deltas" | "block.minecraft.banner.stripe_right.green" | "block.minecraft.banner.half_horizontal.white" | "subtitles.entity.bee.ambient" | "argument.block.tag.disallowed" | "options.videoTitle" | "subtitles.entity.pillager.death" | "entity.minecraft.cow" | "effect.minecraft.health_boost" | "block.minecraft.stripped_dark_oak_log" | "commands.give.success.multiple" | "block.minecraft.pink_glazed_terracotta" | "death.attack.generic.player" | "block.minecraft.red_banner" | "selectWorld.dataPacks" | "block.minecraft.banner.flower.orange" | "subtitles.entity.hoglin.retreat" | "item.minecraft.cod_bucket" | "block.minecraft.banner.diagonal_left.black" | "block.minecraft.banner.diagonal_up_left.brown" | "biome.minecraft.savanna_plateau" | "gui.no" | "commands.forceload.removed.single" | "commands.bossbar.get.max" | "block.minecraft.light_blue_carpet" | "subtitles.entity.axolotl.death" | "block.minecraft.banner.stripe_middle.blue" | "createWorld.customize.preset.redstone_ready" | "block.minecraft.warped_fence" | "mco.invites.button.reject" | "enchantment.minecraft.piercing" | "item.minecraft.water_bucket" | "entity.minecraft.ravager" | "mco.configure.world.invited" | "entity.notFound" | "death.attack.thrown" | "block.minecraft.banner.cross.light_gray" | "entity.minecraft.tnt" | "item.minecraft.potion.effect.slowness" | "subtitles.block.conduit.activate" | "death.attack.drown" | "createWorld.customize.custom.useLavaOceans" | "block.minecraft.mossy_stone_brick_slab" | "jigsaw_block.name" | "biome.minecraft.stony_peaks" | "color.minecraft.light_gray" | "subtitles.entity.slime.death" | "subtitles.entity.firework_rocket.blast" | "addServer.title" | "block.minecraft.bell" | "item.minecraft.shield.cyan" | "subtitles.block.composter.fill" | "block.minecraft.banner.gradient_up.purple" | "createWorld.customize.buffet.title" | "block.minecraft.exposed_cut_copper" | "key.keyboard.grave.accent" | "subtitles.block.beehive.shear" | "selectServer.direct" | "block.minecraft.lime_candle" | "commands.advancement.revoke.criterion.to.many.failure" | "subtitles.particle.soul_escape" | "mco.selectServer.expired" | "color.minecraft.white" | "commands.datapack.enable.failed" | "block.minecraft.enchanting_table" | "block.minecraft.barrel" | "structure_block.position.z" | "structure_block.position.y" | "structure_block.position.x" | "narrator.button.language" | "gui.recipebook.toggleRecipes.blastable" | "mco.configure.world.leave.question.line2" | "mco.configure.world.leave.question.line1" | "forge.configgui.fixVanillaCascading.tooltip" | "block.minecraft.dandelion" | "block.minecraft.banner.mojang.brown" | "subtitles.item.crossbow.charge" | "block.minecraft.chain" | "item.minecraft.potion.effect.regeneration" | "item.minecraft.tropical_fish_spawn_egg" | "subtitles.entity.villager.death" | "generator.flat" | "subtitles.entity.phantom.bite" | "block.minecraft.banner.triangle_top.red" | "biome.minecraft.beach" | "stat.minecraft.interact_with_smithing_table" | "commands.team.join.success.single" | "item.minecraft.tipped_arrow.effect.fire_resistance" | "block.minecraft.cave_vines_plant" | "subtitles.entity.bee.death" | "subtitles.entity.glow_item_frame.remove_item" | "subtitles.entity.evoker.celebrate" | "block.minecraft.quartz_block" | "subtitles.block.shulker_box.open" | "advancements.story.mine_diamond.title" | "item.minecraft.cod_spawn_egg" | "commands.bossbar.set.max.unchanged" | "entity.minecraft.villager.leatherworker" | "item.minecraft.writable_book" | "key.mouse" | "block.minecraft.banner.gradient.gray" | "block.minecraft.cut_copper_stairs" | "block.minecraft.banner.triangles_bottom.blue" | "block.minecraft.stripped_dark_oak_wood" | "block.minecraft.rooted_dirt" | "commands.worldborder.warning.time.success" | "subtitles.entity.parrot.imitate.vex" | "block.minecraft.banner.border.pink" | "subtitles.entity.strider.idle" | "mco.configure.world.restore.question.line2" | "mco.configure.world.restore.question.line1" | "selectWorld.edit.resetIcon" | "subtitles.entity.dolphin.eat" | "disconnect.genericReason" | "subtitles.block.fire.ambient" | "subtitles.entity.panda.eat" | "biome.minecraft.flower_forest" | "block.minecraft.banner.cross.blue" | "narration.recipe.usage" | "stat.minecraft.bell_ring" | "block.minecraft.banner.half_horizontal_bottom.green" | "subtitles.entity.bat.hurt" | "subtitles.entity.squid.death" | "menu.playdemo" | "block.minecraft.banner.square_top_right.black" | "block.minecraft.raw_gold_block" | "block.minecraft.big_dripleaf_stem" | "block.minecraft.banner.triangles_top.green" | "item.minecraft.potion.effect.turtle_master" | "options.allowServerListing.tooltip" | "block.minecraft.gray_stained_glass_pane" | "enchantment.minecraft.quick_charge" | "block.minecraft.stone_pressure_plate" | "block.minecraft.grindstone" | "subtitles.block.smoker.smoke" | "block.minecraft.banner.straight_cross.white" | "advancements.nether.obtain_ancient_debris.title" | "advancements.husbandry.breed_an_animal.description" | "block.minecraft.banner.mojang.yellow" | "subtitles.entity.zombified_piglin.death" | "narrator.loading" | "block.minecraft.campfire" | "advancements.nether.create_beacon.title" | "block.minecraft.banner.rhombus.white" | "block.minecraft.banner.bricks.light_gray" | "commands.item.block.set.success" | "argument.entity.options.distance.negative" | "demo.help.inventory" | "team.collision.pushOtherTeams" | "item.minecraft.spider_spawn_egg" | "deathScreen.title.hardcore" | "subtitles.entity.skeleton_horse.death" | "debug.pause_focus.off" | "block.minecraft.spawner" | "mco.configure.world.subscription.less_than_a_day" | "commands.enchant.failed" | "commands.tag.remove.success.single" | "parsing.long.invalid" | "block.minecraft.green_bed" | "mco.selectServer.buy" | "block.minecraft.spruce_wall_sign" | "block.minecraft.banner.gradient_up.red" | "advancements.story.follow_ender_eye.title" | "biome.minecraft.swamp" | "mco.selectServer.open" | "item.minecraft.music_disc_pigstep.desc" | "subtitles.entity.zombie_horse.hurt" | "gamerule.category.drops" | "death.attack.cactus" | "mco.reset.world.inspiration" | "block.minecraft.crimson_trapdoor" | "subtitles.entity.dolphin.hurt" | "subtitles.entity.glow_squid.squirt" | "advancements.adventure.arbalistic.title" | "item.minecraft.splash_potion.effect.slowness" | "attribute.name.forge.swim_speed" | "item.minecraft.music_disc_mall.desc" | "commands.enchant.failed.incompatible" | "item.minecraft.shield.blue" | "merchant.current_level" | "block.minecraft.red_bed" | "death.attack.player" | "createWorld.customize.custom.confirm2" | "block.minecraft.dead_horn_coral_wall_fan" | "createWorld.customize.custom.confirm1" | "advMode.mode" | "item.minecraft.firework_star.orange" | "block.minecraft.andesite_wall" | "block.minecraft.banner.square_top_right.gray" | "death.fell.assist" | "entity.minecraft.player" | "options.gamma" | "multiplayer.disconnect.server_full" | "block.minecraft.smooth_basalt" | "entity.minecraft.donkey" | "subtitles.item.bucket.empty" | "advancements.adventure.fall_from_world_height.description" | "parsing.int.invalid" | "item.minecraft.turtle_helmet" | "block.minecraft.stripped_acacia_log" | "commands.data.get.unknown" | "subtitles.entity.panda.hurt" | "subtitles.entity.panda.pre_sneeze" | "block.minecraft.magenta_concrete" | "entity.minecraft.arrow" | "item.minecraft.netherite_axe" | "block.minecraft.birch_trapdoor" | "advancements.story.follow_ender_eye.description" | "block.minecraft.birch_stairs" | "gamerule.logAdminCommands" | "mco.selectServer.expires.days" | "item.minecraft.blue_dye" | "block.minecraft.moss_block" | "lanServer.title" | "block.minecraft.banner.stripe_top.pink" | "fml.modloading.missingmetadata" | "subtitles.entity.polar_bear.ambient" | "commands.title.reset.single" | "block.minecraft.torch" | "block.minecraft.banner.half_vertical_right.light_blue" | "item.minecraft.lingering_potion.effect.slow_falling" | "entity.minecraft.lightning_bolt" | "advancements.story.smelt_iron.title" | "block.minecraft.light_gray_shulker_box" | "block.minecraft.orange_candle_cake" | "color.minecraft.green" | "item.minecraft.firework_star.black" | "advancements.story.enchant_item.title" | "commands.banip.info" | "mco.upload.select.world.subtitle" | "recipe.notFound" | "commands.scoreboard.objectives.add.duplicate" | "options.difficulty.easy" | "advMode.mode.redstoneTriggered" | "subtitles.entity.parrot.imitate.silverfish" | "language.code" | "commands.teammsg.failed.noteam" | "block.minecraft.banner.stripe_middle.cyan" | "stat.minecraft.raid_trigger" | "block.minecraft.dark_oak_button" | "options.video" | "block.minecraft.large_amethyst_bud" | "block.minecraft.banner.half_horizontal_bottom.magenta" | "mco.configure.world.buttons.open" | "block.minecraft.banner.square_top_right.green" | "block.minecraft.banner.stripe_center.pink" | "item.minecraft.golden_helmet" | "block.minecraft.soul_lantern" | "itemGroup.inventory" | "fml.modloading.missingdependency" | "block.minecraft.banner.triangles_top.black" | "options.chunks" | "block.minecraft.banner.stripe_bottom.pink" | "commands.team.option.seeFriendlyInvisibles.alreadyDisabled" | "block.minecraft.chiseled_stone_bricks" | "item.minecraft.salmon" | "block.minecraft.comparator" | "block.minecraft.banner.small_stripes.purple" | "item.minecraft.tipped_arrow.effect.healing" | "gamerule.category.chat" | "block.minecraft.banner.stripe_right.white" | "block.minecraft.potted_warped_roots" | "item.minecraft.beetroot_seeds" | "item.minecraft.totem_of_undying" | "entity.minecraft.cat" | "item.minecraft.lingering_potion.effect.night_vision" | "subtitles.entity.tropical_fish.flop" | "block.minecraft.banner.curly_border.magenta" | "argument.entity.selector.randomPlayer" | "commands.bossbar.set.players.success.some" | "gamerule.playersSleepingPercentage" | "item.minecraft.cauldron" | "commands.clear.success.multiple" | "advancements.nether.obtain_crying_obsidian.description" | "block.minecraft.warped_sign" | "block.minecraft.banner.stripe_top.brown" | "block.minecraft.bamboo" | "item.minecraft.cooked_porkchop" | "death.attack.thorns.item" | "subtitles.entity.llama.ambient" | "commands.experience.set.points.success.single" | "block.minecraft.banner.flower.cyan" | "commands.team.option.seeFriendlyInvisibles.enabled" | "block.minecraft.banner.square_bottom_left.red" | "commands.effect.clear.everything.success.multiple" | "demo.reminder" | "block.minecraft.banner.square_top_right.white" | "block.minecraft.dead_fire_coral_wall_fan" | "block.minecraft.magenta_banner" | "selectWorld.gameMode.creative.line1" | "selectWorld.select" | "block.minecraft.wither_rose" | "block.minecraft.potted_dandelion" | "options.chat.visibility.full" | "stat.minecraft.strider_one_cm" | "debug.gamemodes.help" | "advancements.adventure.shoot_arrow.title" | "subtitles.entity.parrot.imitate.creeper" | "mco.configure.world.buttons.subscription" | "advancements.adventure.adventuring_time.title" | "advancements.nether.get_wither_skull.description" | "structure_block.mode.load" | "commands.advancement.grant.many.to.many.failure" | "selectWorld.mapFeatures.info" | "debug.advanced_tooltips.off" | "item.minecraft.firework_star.shape.small_ball" | "entity.minecraft.tropical_fish.type.snooper" | "item.minecraft.firework_star.green" | "item.minecraft.firework_star.light_blue" | "forge.stepHeight" | "effect.minecraft.strength" | "block.minecraft.banner.half_horizontal_bottom.black" | "block.minecraft.brick_wall" | "block.minecraft.banner.stripe_downright.blue" | "item.minecraft.tipped_arrow.effect.water_breathing" | "block.minecraft.lectern" | "subtitles.entity.skeleton_horse.hurt" | "selectWorld.gameMode.creative.line2" | "item.minecraft.lingering_potion.effect.thick" | "commands.locatebiome.invalid" | "selectWorld.allowCommands" | "block.minecraft.bee_nest" | "advancements.nether.all_potions.title" | "mco.activity.title" | "block.minecraft.dead_fire_coral_fan" | "block.minecraft.cut_copper" | "subtitles.entity.pillager.hurt" | "item.minecraft.firework_star.pink" | "block.minecraft.spruce_planks" | "item.minecraft.map" | "parsing.long.expected" | "block.minecraft.lapis_block" | "item.minecraft.honeycomb" | "options.mipmapLevels" | "item.minecraft.magma_cream" | "debug.show_hitboxes.help" | "block.minecraft.banner.rhombus.purple" | "commands.team.option.name.unchanged" | "item.minecraft.lingering_potion.effect.empty" | "createWorld.customize.custom.useStrongholds" | "options.accessibility.title" | "subtitles.entity.dolphin.play" | "block.minecraft.red_stained_glass_pane" | "commands.data.block.modified" | "commands.bossbar.unknown" | "item.minecraft.music_disc_11" | "block.minecraft.smooth_sandstone_slab" | "entity.minecraft.tropical_fish.predefined.0" | "item.minecraft.music_disc_13" | "item.minecraft.firework_star.shape" | "block.minecraft.green_banner" | "entity.minecraft.killer_bunny" | "commands.data.entity.modified" | "block.minecraft.red_sandstone_slab" | "commands.advancement.grant.many.to.many.success" | "argument.pos.mixed" | "subtitles.entity.fox.hurt" | "advancements.adventure.trade.title" | "block.minecraft.orange_banner" | "item.minecraft.golden_horse_armor" | "entity.minecraft.tropical_fish.predefined.9" | "commands.config.getwithtype" | "block.minecraft.stripped_oak_wood" | "entity.minecraft.salmon" | "stat.minecraft.interact_with_crafting_table" | "entity.minecraft.tropical_fish.predefined.3" | "entity.minecraft.tropical_fish.predefined.4" | "entity.minecraft.tropical_fish.predefined.1" | "entity.minecraft.tropical_fish.predefined.2" | "stat.minecraft.crouch_one_cm" | "biome.minecraft.nether_wastes" | "entity.minecraft.tropical_fish.predefined.7" | "entity.minecraft.tropical_fish.predefined.8" | "entity.minecraft.tropical_fish.predefined.5" | "team.collision.pushOwnTeam" | "entity.minecraft.tropical_fish.predefined.6" | "subtitles.entity.chicken.hurt" | "fml.menu.loadingmods" | "multiplayer.disconnect.slow_login" | "block.minecraft.banner.stripe_top.yellow" | "subtitles.block.dispenser.fail" | "block.minecraft.redstone_ore" | "forge.configgui.logCascadingWorldGeneration.tooltip" | "subtitles.item.shovel.flatten" | "commands.bossbar.set.value.success" | "filled_map.scale" | "death.attack.mob.item" | "argument.time.invalid_unit" | "subtitles.entity.horse.angry" | "block.minecraft.banner.stripe_left.red" | "block.minecraft.end_portal_frame" | "item.minecraft.tipped_arrow.effect.poison" | "commands.scoreboard.players.enable.failed" | "block.minecraft.banner.stripe_downright.lime" | "subtitles.entity.wolf.growl" | "connect.failed" | "block.minecraft.waxed_exposed_copper" | "item.minecraft.potion.effect.mundane" | "advancements.end.kill_dragon.title" | "disconnect.disconnected" | "block.minecraft.warped_hyphae" | "stat.minecraft.eat_cake_slice" | "block.minecraft.shroomlight" | "enchantment.minecraft.knockback" | "subtitles.entity.elder_guardian.flop" | "selectWorld.edit.optimize" | "item.minecraft.skull_banner_pattern" | "block.minecraft.banner.skull.magenta" | "commands.bossbar.get.players.none" | "block.minecraft.dark_oak_fence_gate" | "entity.minecraft.strider" | "subtitles.entity.parrot.imitate.vindicator" | "argument.block.property.duplicate" | "item.minecraft.splash_potion.effect.healing" | "subtitles.entity.parrot.imitate.zombie_villager" | "subtitles.entity.piglin.retreat" | "debug.reload_chunks.message" | "mco.selectServer.minigame" | "createWorld.customize.custom.next" | "stat.minecraft.open_enderchest" | "subtitles.entity.ravager.death" | "subtitles.item.firecharge.use" | "subtitles.entity.parrot.fly" | "block.minecraft.warped_stairs" | "item.minecraft.minecart" | "optimizeWorld.stage.upgrading" | "advancements.adventure.kill_all_mobs.title" | "mco.configure.world.invites.remove.tooltip" | "optimizeWorld.confirm.description" | "commands.forge.tags.tag_key" | "block.minecraft.orange_wool" | "item.minecraft.diamond" | "mco.backup.generate.world" | "chat.disabled.profile" | "item.minecraft.jungle_boat" | "block.minecraft.waxed_oxidized_cut_copper" | "item.minecraft.copper_ingot" | "key.keyboard.keypad.decimal" | "block.minecraft.orange_shulker_box" | "commands.teleport.invalidPosition" | "itemGroup.transportation" | "subtitles.entity.phantom.death" | "commands.banlist.none" | "item.minecraft.diamond_hoe" | "tutorial.punch_tree.title" | "commands.tag.add.success.single" | "key.sprint" | "narrator.button.difficulty_lock.locked" | "death.attack.message_too_long" | "subtitles.block.button.click" | "block.minecraft.banner.globe.cyan" | "forge.menu.updatescreen.title" | "subtitles.item.chorus_fruit.teleport" | "commands.scoreboard.players.remove.success.single" | "item.minecraft.guardian_spawn_egg" | "block.minecraft.banner.diagonal_left.blue" | "block.minecraft.banner.half_horizontal.green" | "commands.scoreboard.players.enable.invalid" | "advancements.nether.netherite_armor.title" | "advancements.story.mine_stone.description" | "block.minecraft.banner.base.white" | "commands.clear.test.multiple" | "subtitles.entity.cat.ambient" | "commands.summon.success" | "mco.configure.world.slot.tooltip" | "block.minecraft.horn_coral" | "item.minecraft.raw_iron" | "subtitles.entity.enderman.hurt" | "subtitles.entity.husk.death" | "block.minecraft.banner.cross.black" | "block.minecraft.banner.curly_border.purple" | "subtitles.entity.piglin.step" | "item.minecraft.clay_ball" | "block.minecraft.banner.diagonal_up_right.orange" | "item.minecraft.rabbit_hide" | "effect.minecraft.hunger" | "color.minecraft.black" | "item.minecraft.netherite_leggings" | "block.minecraft.gray_candle" | "mco.selectServer.closeserver" | "block.minecraft.banner.small_stripes.light_blue" | "death.attack.dragonBreath.player" | "advancements.adventure.two_birds_one_arrow.description" | "jigsaw_block.joint.rollable" | "item.minecraft.lingering_potion.effect.mundane" | "subtitles.entity.cow.milk" | "multiplayer.status.pinging" | "block.minecraft.light_gray_wool" | "advancements.nether.return_to_sender.title" | "commands.forceload.removed.all" | "block.minecraft.lime_stained_glass" | "block.minecraft.dead_bubble_coral_block" | "item.minecraft.pufferfish_bucket" | "block.minecraft.banner.half_horizontal.pink" | "item.minecraft.music_disc_pigstep" | "subtitles.entity.player.freeze_hurt" | "block.minecraft.banner.square_top_left.pink" | "block.minecraft.banner.half_vertical.purple" | "advancements.husbandry.complete_catalogue.description" | "block.minecraft.dark_oak_pressure_plate" | "subtitles.entity.drowned.shoot" | "sleep.players_sleeping" | "block.minecraft.crimson_roots" | "biome.minecraft.the_end" | "block.minecraft.banner.triangles_top.pink" | "effect.minecraft.haste" | "block.minecraft.polished_blackstone" | "options.showSubtitles" | "block.minecraft.polished_blackstone_stairs" | "fml.menu.mods.info.displayurl" | "subtitles.entity.vindicator.death" | "block.minecraft.banner.square_bottom_left.light_blue" | "advancements.end.dragon_egg.description" | "debug.pause.help" | "spectatorMenu.teleport" | "advancements.husbandry.silk_touch_nest.description" | "commands.trigger.failed.invalid" | "block.minecraft.banner.square_bottom_right.gray" | "block.minecraft.nether_quartz_ore" | "advancements.adventure.very_very_frightening.title" | "color.minecraft.cyan" | "item.minecraft.tnt_minecart" | "subtitles.entity.ravager.step" | "commands.forge.tags.copy_tag_names" | "argument.block.property.invalid" | "commands.forge.tracking.be.enabled" | "debug.advanced_tooltips.on" | "selectWorld.versionWarning" | "commands.seed.success" | "death.attack.lava.player" | "subtitles.item.trident.hit" | "argument.entity.options.predicate.description" | "key.keyboard.enter" | "subtitles.entity.strider.retreat" | "enchantment.minecraft.impaling" | "advancements.story.enter_the_end.description" | "block.minecraft.banner.stripe_left.cyan" | "advMode.notEnabled" | "book.pageIndicator" | "block.minecraft.purple_terracotta" | "subtitles.entity.squid.hurt" | "block.minecraft.banner.small_stripes.green" | "item.minecraft.redstone" | "block.minecraft.crimson_button" | "createWorld.customize.custom.useRavines" | "subtitles.entity.pig.ambient" | "advancements.story.upgrade_tools.title" | "block.minecraft.banner.half_horizontal.black" | "block.minecraft.banner.stripe_right.pink" | "narrator.toast.disabled" | "demo.help.fullWrapped" | "block.minecraft.banner.gradient.black" | "commands.perf.alreadyRunning" | "enchantment.level.8" | "enchantment.level.7" | "enchantment.level.6" | "enchantment.level.5" | "block.minecraft.oak_sapling" | "enchantment.level.4" | "enchantment.level.3" | "narration.suggestion.tooltip" | "enchantment.level.2" | "enchantment.level.1" | "key.loadToolbarActivator" | "item.minecraft.stone_shovel" | "enchantment.level.9" | "attribute.name.generic.armor" | "advancements.adventure.spyglass_at_parrot.description" | "commands.forceload.added.single" | "item.minecraft.arrow" | "subtitles.block.end_portal.spawn" | "block.minecraft.banner.base.magenta" | "advMode.mode.sequence" | "options.hideLightningFlashes.tooltip" | "attribute.name.generic.follow_range" | "argument.range.ints" | "forge.configgui.disableStairSlabCulling" | "block.minecraft.yellow_wool" | "options.title" | "block.minecraft.yellow_carpet" | "biome.minecraft.savanna" | "block.minecraft.banner.stripe_center.cyan" | "mco.terms.buttons.agree" | "block.minecraft.crimson_fence" | "attribute.name.generic.luck" | "attribute.name.generic.attack_speed" | "block.minecraft.banner.gradient.lime" | "block.minecraft.banner.stripe_downright.brown" | "selectWorld.load_folder_access" | "commands.pardonip.invalid" | "advancements.adventure.play_jukebox_in_meadows.description" | "key.keyboard.equal" | "commands.team.leave.success.multiple" | "mco.configure.world.subscription.day" | "entity.minecraft.polar_bear" | "createWorld.customize.custom.biomeScaleOffset" | "subtitles.entity.ender_eye.launch" | "advancements.end.kill_dragon.description" | "block.minecraft.green_candle_cake" | "subtitles.entity.fox.eat" | "narration.recipe.usage.more" | "subtitles.entity.villager.work_farmer" | "block.minecraft.banner.mojang.orange" | "inventory.hotbarInfo" | "forge.configgui.skipEmptyShapelessCheck" | "block.minecraft.green_terracotta" | "key.advancements" | "options.prioritizeChunkUpdates.nearby.tooltip" | "block.minecraft.chorus_flower" | "item.minecraft.scute" | "mco.create.world" | "subtitles.block.tripwire.detach" | "item.minecraft.popped_chorus_fruit" | "item.minecraft.lingering_potion.effect.swiftness" | "commands.forge.gen.start" | "stat.minecraft.inspect_hopper" | "block.minecraft.bubble_column" | "block.minecraft.cracked_deepslate_tiles" | "item.minecraft.elder_guardian_spawn_egg" | "jigsaw_block.joint_label" | "death.attack.starve.player" | "addServer.resourcePack.prompt" | "advancements.husbandry.tactical_fishing.title" | "block.minecraft.waxed_weathered_cut_copper_slab" | "arguments.operation.div0" | "key.keyboard.f22" | "mco.configure.world.status" | "key.keyboard.f23" | "key.keyboard.f20" | "key.keyboard.f21" | "block.minecraft.banner.mojang.purple" | "block.minecraft.chiseled_deepslate" | "item.minecraft.spectral_arrow" | "advancements.adventure.summon_iron_golem.title" | "stat.minecraft.interact_with_loom" | "block.minecraft.banner.half_horizontal_bottom.gray" | "commands.schedule.same_tick" | "block.minecraft.banner.piglin.lime" | "key.keyboard.f24" | "commands.spreadplayers.success.teams" | "key.keyboard.f25" | "filled_map.locked" | "mco.connect.failed" | "selectWorld.mapType" | "gui.narrate.slider" | "selectWorld.versionQuestion" | "death.attack.outOfWorld.player" | "selectWorld.access_failure" | "multiplayer.downloadingTerrain" | "item.minecraft.salmon_bucket" | "block.minecraft.deepslate_redstone_ore" | "block.minecraft.banner.small_stripes.red" | "advancements.husbandry.root.description" | "biome.minecraft.crimson_forest" | "block.minecraft.banner.gradient_up.light_gray" | "argument.rotation.incomplete" | "subtitles.entity.enderman.stare" | "block.minecraft.cyan_banner" | "gamerule.category.spawning" | "subtitles.entity.witch.throw" | "fml.modloading.missingclasses" | "createWorld.customize.custom.useDungeons" | "block.minecraft.tall_seagrass" | "commands.clone.failed" | "block.minecraft.andesite_slab" | "item.minecraft.axolotl_bucket" | "entity.minecraft.goat" | "block.minecraft.banner.stripe_right.red" | "commands.item.entity.set.success.multiple" | "fml.messages.version.restriction.bounded" | "block.minecraft.banner.diagonal_right.white" | "subtitles.item.trident.hit_ground" | "advMode.setCommand" | "subtitles.entity.goat.step" | "commands.save.enabled" | "fml.menu.mods.config" | "item.minecraft.golden_carrot" | "fml.modloading.errorduringevent" | "commands.save.alreadyOff" | "item.minecraft.melon_seeds" | "commands.whitelist.list" | "mco.upload.button.name" | "multiplayer.disconnect.incompatible" | "block.minecraft.white_glazed_terracotta" | "subtitles.entity.snow_golem.hurt" | "commands.spreadplayers.failed.entities" | "block.minecraft.banner.stripe_downleft.black" | "generator.custom" | "narration.slider.usage.hovered" | "argument.entity.selector.missing" | "item.minecraft.baked_potato" | "block.minecraft.nether_bricks" | "subtitles.entity.piglin.angry" | "block.minecraft.banner.diagonal_right.yellow" | "key.keyboard.f11" | "key.keyboard.f12" | "block.minecraft.smooth_red_sandstone_slab" | "key.keyboard.f10" | "death.attack.badRespawnPoint.link" | "options.accessibility.text_background" | "item.minecraft.rabbit" | "gamerule.fallDamage" | "block.minecraft.mushroom_stem" | "block.minecraft.warped_planks" | "item.minecraft.tipped_arrow.effect.weakness" | "block.minecraft.banner.diagonal_up_right.yellow" | "forge.controlsgui.alt" | "block.minecraft.light_blue_glazed_terracotta" | "block.minecraft.crying_obsidian" | "advancements.nether.use_lodestone.description" | "options.allowServerListing" | "key.keyboard.f15" | "key.keyboard.f16" | "item.minecraft.music_disc_mellohi.desc" | "key.keyboard.f13" | "narrator.position.screen" | "key.keyboard.f14" | "key.keyboard.f19" | "block.minecraft.banner.half_vertical_right.purple" | "options.autoSuggestCommands" | "key.keyboard.f17" | "block.minecraft.banner.diagonal_right.light_gray" | "key.keyboard.f18" | "block.minecraft.banner.cross.green" | "item.minecraft.creeper_banner_pattern" | "block.minecraft.polished_blackstone_brick_slab" | "block.minecraft.cracked_nether_bricks" | "commands.playsound.success.multiple" | "subtitles.item.trident.return" | "advancements.nether.fast_travel.description" | "book.editTitle" | "block.minecraft.deepslate_diamond_ore" | "subtitles.entity.mule.chest" | "key.keyboard.up" | "block.minecraft.waxed_oxidized_cut_copper_stairs" | "block.minecraft.banner.stripe_downleft.green" | "selectWorld.edit" | "mco.template.button.select" | "block.minecraft.banner.diagonal_right.pink" | "mco.configure.current.minigame" | "block.minecraft.banner.piglin.blue" | "item.minecraft.zombie_villager_spawn_egg" | "subtitles.entity.parrot.imitate.blaze" | "block.minecraft.stone_bricks" | "block.minecraft.banner.stripe_top.white" | "subtitles.entity.drowned.swim" | "block.minecraft.blackstone_slab" | "commands.title.show.title.multiple" | "block.minecraft.snow" | "block.minecraft.banner.creeper.light_blue" | "item.minecraft.shulker_spawn_egg" | "commands.publish.alreadyPublished" | "item.minecraft.zombie_horse_spawn_egg" | "subtitles.entity.goat.eat" | "commands.spawnpoint.success.multiple" | "commands.bossbar.set.color.success" | "block.minecraft.purple_stained_glass_pane" | "inventory.hotbarSaved" | "biome.minecraft.desert" | "structure_block.load_prepare" | "commands.item.target.no_changes" | "mco.gui.ok" | "item.minecraft.spider_eye" | "stat.minecraft.treasure_fished" | "subtitles.item.axe.scrape" | "commands.clone.toobig" | "gamerule.announceAdvancements" | "block.minecraft.stripped_warped_stem" | "subtitles.entity.stray.death" | "item.modifiers.chest" | "forge.configgui.removeErroringEntities.tooltip" | "item.minecraft.glow_squid_spawn_egg" | "block.minecraft.black_concrete_powder" | "block.minecraft.banner.diagonal_up_left.blue" | "difficulty.lock.title" | "options.difficulty.online" | "block.minecraft.banner.square_top_right.cyan" | "options.entityShadows" | "block.minecraft.cobweb" | "argument.color.invalid" | "color.minecraft.brown" | "menu.game" | "filled_map.buried_treasure" | "subtitles.entity.guardian.flop" | "forge.configgui.zombieBabyChance.tooltip" | "block.minecraft.banner.stripe_center.white" | "subtitles.entity.bat.takeoff" | "entity.minecraft.tropical_fish.type.sunstreak" | "block.minecraft.mycelium" | "multiplayer.applyingPack" | "item.minecraft.milk_bucket" | "entity.minecraft.villager.shepherd" | "block.minecraft.obsidian" | "attribute.name.horse.jump_strength" | "item.minecraft.evoker_spawn_egg" | "title.32bit.deprecation" | "commands.debug.stopped" | "resourcePack.title" | "selectWorld.backupQuestion.experimental" | "entity.minecraft.blaze" | "gui.narrate.editBox" | "block.minecraft.beehive" | "item.minecraft.diamond_boots" | "fml.menu.multiplayer.unknown" | "key.keyboard.print.screen" | "block.minecraft.beacon" | "argument.entity.options.inapplicable" | "item.minecraft.acacia_boat" | "entity.minecraft.vindicator" | "stat.minecraft.aviate_one_cm" | "book.finalizeButton" | "subtitles.entity.strider.hurt" | "tutorial.find_tree.description" | "block.minecraft.smooth_stone_slab" | "mco.template.select.none" | "effect.minecraft.saturation" | "biome.minecraft.snowy_beach" | "commands.effect.clear.everything.success.single" | "block.minecraft.orange_terracotta" | "item.minecraft.iron_horse_armor" | "death.fell.accident.other_climbable" | "chat.copy" | "entity.minecraft.fox" | "mco.selectServer.uninitialized" | "mco.template.name" | "selectWorld.backupWarning.snapshot" | "fml.modmismatchscreen.table.youhave" | "subtitles.block.chest.locked" | "subtitles.entity.rabbit.ambient" | "potion.whenDrank" | "spectatorMenu.previous_page" | "itemGroup.kubejs.kubejs" | "item.minecraft.filled_map" | "stat.minecraft.interact_with_beacon" | "block.minecraft.banner.piglin.red" | "subtitles.entity.ghast.hurt" | "block.minecraft.podzol" | "block.minecraft.cave_air" | "forge.configgui.selectiveResourceReloadEnabled" | "advancements.adventure.sleep_in_bed.title" | "subtitles.block.conduit.deactivate" | "subtitles.block.iron_trapdoor.close" | "slot.unknown" | "block.minecraft.kelp_plant" | "block.minecraft.banner.square_bottom_left.magenta" | "options.autosaveIndicator" | "selectWorld.version" | "controls.keybinds" | "death.attack.inWall.player" | "key.keyboard.right.control" | "item.minecraft.llama_spawn_egg" | "item.minecraft.splash_potion.effect.luck" | "tutorial.look.title" | "options.narrator.chat" | "fml.menu.mods.info.signature" | "death.fell.accident.scaffolding" | "fml.messages.artifactversion.notinstalled" | "block.minecraft.orange_stained_glass" | "item.minecraft.stone_hoe" | "block.minecraft.banner.flower.red" | "block.minecraft.attached_pumpkin_stem" | "item.minecraft.iron_nugget" | "block.minecraft.banner.diagonal_up_left.lime" | "item.minecraft.dolphin_spawn_egg" | "block.minecraft.acacia_sign" | "advMode.randomPlayer" | "subtitles.entity.player.attack.weak" | "commands.teleport.success.location.single" | "item.minecraft.splash_potion.effect.invisibility" | "options.graphics.fancy.tooltip" | "block.minecraft.soul_torch" | "block.minecraft.banner.half_vertical_right.red" | "key.keyboard.caps.lock" | "enchantment.minecraft.punch" | "key.keyboard.page.down" | "subtitles.entity.puffer_fish.death" | "merchant.next_level" | "block.minecraft.banner.diagonal_left.red" | "death.fell.accident.ladder" | "item.minecraft.item_frame" | "mco.backup.button.reset" | "mco.selectServer.expiredSubscribe" | "block.minecraft.banner.half_vertical_right.cyan" | "subtitles.entity.generic.eat" | "block.minecraft.red_concrete" | "debug.chunk_boundaries.off" | "biome.minecraft.old_growth_pine_taiga" | "subtitles.entity.hoglin.death" | "arguments.nbtpath.nothing_found" | "mco.reset.world.adventure" | "block.minecraft.cactus" | "options.darkMojangStudiosBackgroundColor" | "stat.minecraft.interact_with_campfire" | "subtitles.entity.shulker_bullet.hit" | "chat.type.team.hover" | "block.minecraft.dark_oak_wall_sign" | "block.minecraft.cyan_wool" | "subtitles.entity.glow_item_frame.break" | "block.minecraft.red_nether_brick_stairs" | "death.attack.magic.player" | "item.minecraft.music_disc_strad.desc" | "commands.attribute.failed.no_attribute" | "commands.gamemode.success.other" | "block.minecraft.diamond_ore" | "commands.kick.success" | "key.keyboard.keypad.subtract" | "item.minecraft.leather" | "item.minecraft.lingering_potion.effect.harming" | "commands.forceload.toobig" | "block.minecraft.banner.straight_cross.pink" | "subtitles.entity.shulker.open" | "key.categories.inventory" | "argument.entity.selector.allPlayers" | "multiplayer.disconnect.duplicate_login" | "createWorld.customize.custom.presets" | "container.enchant.lapis.one" | "stat.minecraft.fly_one_cm" | "item.modifiers.legs" | "options.particles.decreased" | "block.minecraft.banner.diagonal_up_left.cyan" | "optimizeWorld.confirm.title" | "block.minecraft.banner.stripe_left.orange" | "commands.bossbar.set.visible.success.visible" | "merchant.level.4" | "merchant.level.5" | "merchant.level.2" | "block.minecraft.banner.small_stripes.lime" | "merchant.level.3" | "block.minecraft.banner.stripe_middle.lime" | "merchant.level.1" | "commands.item.target.not_a_container" | "block.minecraft.warped_fungus" | "block.minecraft.cut_sandstone" | "block.minecraft.red_tulip" | "subtitles.block.cake.add_candle" | "item.minecraft.firework_star.shape.creeper" | "deathScreen.spectate" | "block.minecraft.birch_log" | "predicate.unknown" | "controls.title" | "block.minecraft.waxed_oxidized_cut_copper_slab" | "advancements.adventure.whos_the_pillager_now.title" | "subtitles.entity.piglin.jealous" | "block.minecraft.diorite" | "block.minecraft.light_gray_banner" | "fml.menu.mods.info.license" | "multiplayer.title" | "subtitles.entity.glow_squid.death" | "gamerule.randomTickSpeed" | "fml.menu.backupfailed.title" | "fml.modloading.brokenfile" | "item.minecraft.heart_of_the_sea" | "mco.minigame.world.changeButton" | "debug.clear_chat.help" | "options.fullscreen.current" | "key.keyboard.left.alt" | "item.minecraft.parrot_spawn_egg" | "stat.minecraft.junk_fished" | "block.minecraft.banner.diagonal_up_left.red" | "deathScreen.score" | "optimizeWorld.info.skipped" | "block.minecraft.banner.diagonal_up_right.magenta" | "subtitles.entity.skeleton.ambient" | "subtitles.entity.turtle.death" | "item.minecraft.name_tag" | "stat.minecraft.jump" | "block.minecraft.polished_deepslate_wall" | "commands.whitelist.none" | "selectWorld.backupWarning.customized" | "block.minecraft.banner.base.orange" | "selectWorld.import_worldgen_settings.deprecated.title" | "subtitles.entity.elder_guardian.curse" | "block.minecraft.banner.stripe_top.purple" | "advancements.story.mine_stone.title" | "item.minecraft.glass_bottle" | "item.minecraft.ender_eye" | "block.minecraft.banner.piglin.magenta" | "mco.upload.cancelled" | "chat.disabled.options" | "key.keyboard.pause" | "block.minecraft.jungle_wall_sign" | "block.minecraft.waxed_copper_block" | "entity.minecraft.tropical_fish.type.kob" | "block.minecraft.composter" | "mco.template.select.failure" | "commands.trigger.simple.success" | "item.minecraft.iron_shovel" | "death.attack.onFire" | "block.minecraft.stripped_warped_hyphae" | "item.minecraft.firework_star.white" | "chat.copy.click" | "item.minecraft.wooden_hoe" | "block.minecraft.gray_stained_glass" | "enchantment.minecraft.blast_protection" | "entity.minecraft.squid" | "container.enchant.level.many" | "block.minecraft.sandstone_slab" | "item.minecraft.lingering_potion.effect.leaping" | "item.minecraft.lingering_potion.effect.strength" | "advancements.nether.distract_piglin.description" | "container.furnace" | "block.minecraft.banner.diagonal_left.orange" | "commands.forceload.query.success" | "narration.slider.usage.focused" | "fml.dependencyloading.mismatchedcontaineddependencies" | "commands.team.add.duplicate" | "commands.whitelist.remove.failed" | "block.minecraft.banner.skull.white" | "block.minecraft.banner.square_bottom_left.yellow" | "block.minecraft.banner.circle.cyan" | "subtitles.item.flintandsteel.use" | "commands.scoreboard.players.reset.all.single" | "multiplayer.disconnect.banned_ip.expiration" | "block.minecraft.potted_allium" | "structure_block.button.load" | "subtitles.entity.endermite.hurt" | "block.minecraft.bubble_coral" | "commands.banip.success" | "item.minecraft.tipped_arrow.effect.invisibility" | "commands.debug.function.noRecursion" | "block.minecraft.banner.small_stripes.blue" | "block.minecraft.waxed_weathered_cut_copper_stairs" | "block.minecraft.stone" | "subtitles.item.lodestone_compass.lock" | "biome.minecraft.jungle" | "dataPack.vanilla.description" | "block.minecraft.banner.diagonal_up_left.light_blue" | "item.minecraft.glow_ink_sac" | "entity.minecraft.piglin" | "block.minecraft.banner.globe.black" | "block.minecraft.banner.skull.gray" | "advancements.adventure.very_very_frightening.description" | "selectWorld.backupQuestion.snapshot" | "block.minecraft.banner.stripe_top.green" | "fml.modmismatchscreen.table.modname" | "item.minecraft.lingering_potion.effect.poison" | "block.minecraft.banner.base.lime" | "selectWorld.createDemo" | "subtitles.entity.mule.eat" | "commands.scoreboard.players.list.empty" | "gamerule.doTraderSpawning" | "options.entityDistanceScaling" | "key.keyboard.minus" | "advancements.story.lava_bucket.description" | "item.minecraft.diamond_horse_armor" | "gui.recipebook.toggleRecipes.craftable" | "stat.minecraft.pot_flower" | "gamerule.maxEntityCramming" | "commands.forge.entity.list.none" | "block.minecraft.banner.square_bottom_right.light_blue" | "advancements.adventure.totem_of_undying.title" | "entity.minecraft.snow_golem" | "options.particles.minimal" | "block.minecraft.banner.triangle_top.pink" | "subtitles.block.barrel.open" | "title.32bit.deprecation.realms" | "block.minecraft.copper_ore" | "item.minecraft.iron_leggings" | "gui.socialInteractions.empty_blocked" | "block.minecraft.light_blue_shulker_box" | "block.minecraft.yellow_shulker_box" | "options.graphics.fast.tooltip" | "block.minecraft.green_wool" | "block.minecraft.carrots" | "itemGroup.combat" | "subtitles.entity.villager.work_mason" | "chat.square_brackets" | "commands.summon.failed.uuid" | "advMode.trackOutput" | "entity.minecraft.tropical_fish.type.betty" | "mco.minigame.world.switch.title" | "item.minecraft.cod" | "block.minecraft.gray_candle_cake" | "item.minecraft.debug_stick.select" | "block.minecraft.deepslate_brick_stairs" | "block.minecraft.piston_head" | "item.minecraft.potion.effect.night_vision" | "item.minecraft.potion.effect.slow_falling" | "options.resourcepack" | "mco.configure.world.edit.subscreen.experience" | "subtitles.entity.wither.hurt" | "selectServer.deleteQuestion" | "death.attack.mob" | "fml.button.open.file" | "mco.configure.world.resourcepack.question.line1" | "mco.reset.world.resetting.screen.title" | "block.minecraft.lime_carpet" | "advancements.nether.netherite_armor.description" | "mco.configure.world.resourcepack.question.line2" | "advancements.adventure.root.title" | "subtitles.item.armor.equip_elytra" | "selectServer.hiddenAddress" | "subtitles.entity.generic.explode" | "multiplayer.disconnect.not_whitelisted" | "commands.weather.set.thunder" | "block.minecraft.banner.stripe_center.purple" | "block.minecraft.chiseled_red_sandstone" | "debug.gamemodes.error" | "color.minecraft.light_blue" | "commands.worldborder.set.immediate" | "block.minecraft.banner.mojang.red" | "team.visibility.never" | "subtitles.entity.salmon.flop" | "block.minecraft.potted_crimson_roots" | "subtitles.entity.glow_item_frame.place" | "pack.incompatible.confirm.old" | "item.minecraft.debug_stick.update" | "options.narrator" | "subtitles.entity.shulker.close" | "fml.modloading.failedtoloadmod" | "block.minecraft.stripped_crimson_hyphae" | "block.minecraft.banner.half_horizontal_bottom.yellow" | "commands.title.show.subtitle.single" | "mco.brokenworld.download" | "subtitles.entity.zombie.break_wooden_door" | "block.minecraft.banner.base.blue" | "block.minecraft.banner.gradient_up.gray" | "block.minecraft.banner.stripe_left.lime" | "block.minecraft.banner.triangle_bottom.brown" | "createWorld.customize.preset.snowy_kingdom" | "stat_type.minecraft.killed_by.none" | "item.minecraft.bundle.fullness" | "subtitles.entity.hoglin.step" | "death.attack.dryout.player" | "forge.configgui.showLoadWarnings.tooltip" | "item.minecraft.iron_helmet" | "subtitles.block.bell.resonate" | "block.minecraft.snow_block" | "structure_block.mode_info.load" | "block.minecraft.banner.half_vertical_right.orange" | "item.minecraft.end_crystal" | "commands.experience.add.points.success.multiple" | "subtitles.entity.parrot.imitate.piglin_brute" | "subtitles.entity.polar_bear.ambient_baby" | "subtitles.item.spyglass.stop_using" | "container.cartography_table" | "block.minecraft.purple_carpet" | "block.minecraft.lava" | "subtitles.entity.horse.eat" | "parsing.float.expected" | "selectWorld.gameMode.survival" | "key.playerlist" | "options.graphics.warning.cancel" | "debug.copy_location.message" | "block.minecraft.beetroots" | "debug.help.message" | "block.minecraft.potted_blue_orchid" | "commands.data.modify.expected_list" | "block.minecraft.brick_stairs" | "structure_block.mode.data" | "subtitles.entity.goat.milk" | "gui.socialInteractions.tab_blocked" | "subtitles.entity.drowned.ambient_water" | "block.minecraft.banner.triangles_bottom.gray" | "subtitles.entity.potion.throw" | "fml.menu.backupfailed.message" | "block.minecraft.barrier" | "item.minecraft.beetroot_soup" | "item.minecraft.leather_boots" | "block.minecraft.waxed_cut_copper_stairs" | "subtitles.entity.turtle.death_baby" | "mco.terms.sentence.2" | "mco.terms.sentence.1" | "fml.messages.version.restriction.bounded.upperexclusive" | "options.framerateLimit.max" | "block.minecraft.banner.half_horizontal_bottom.red" | "addServer.enterName" | "subtitles.block.honey_block.slide" | "multiplayer.disconnect.kicked" | "block.minecraft.waxed_cut_copper_slab" | "mco.backup.changes.tooltip" | "subtitles.entity.skeleton.converted_to_stray" | "commands.forge.tags.tag_count" | "block.minecraft.banner.border.purple" | "item.minecraft.powder_snow_bucket" | "commands.worldborder.set.failed.nochange" | "block.minecraft.banner.flower.yellow" | "block.minecraft.blackstone" | "block.minecraft.banner.stripe_left.blue" | "subtitles.entity.hoglin.ambient" | "block.minecraft.banner.diagonal_right.magenta" | "block.minecraft.warped_wart_block" | "mco.upload.size.failure.line2" | "mco.upload.size.failure.line1" | "createWorld.customize.custom.minHeight" | "language.name" | "block.minecraft.banner.piglin.cyan" | "block.minecraft.banner.square_bottom_right.purple" | "subtitles.entity.cod.hurt" | "commands.scoreboard.objectives.add.success" | "block.minecraft.tube_coral_wall_fan" | "block.minecraft.banner.straight_cross.magenta" | "key.keyboard.left.shift" | "block.minecraft.banner.base.brown" | "block.minecraft.banner.base.red" | "subtitles.block.water.ambient" | "subtitles.entity.horse.ambient" | "command.context.here" | "mco.template.title" | "entity.minecraft.dragon_fireball" | "block.minecraft.red_terracotta" | "mco.configure.world.spawnNPCs" | "block.minecraft.polished_blackstone_button" | "item.minecraft.pillager_spawn_egg" | "entity.minecraft.tropical_fish.type.spotty" | "block.minecraft.coal_block" | "block.minecraft.banner.creeper.yellow" | "subtitles.entity.llama.step" | "structure_block.include_entities" | "multiplayerWarning.check" | "createWorld.customize.custom.useVillages" | "death.attack.trident.item" | "subtitles.entity.leash_knot.break" | "block.minecraft.banner.stripe_center.light_blue" | "subtitles.entity.piglin.hurt" | "commands.tag.list.single.empty" | "item.minecraft.raw_gold" | "entity.minecraft.axolotl" | "options.hidden" | "block.minecraft.white_wool" | "block.minecraft.banner.triangle_bottom.magenta" | "block.minecraft.dark_oak_fence" | "multiplayer.disconnect.banned" | "commands.fill.toobig" | "block.minecraft.banner.circle.brown" | "item.minecraft.potion.effect.harming" | "item.minecraft.cookie" | "item.minecraft.strider_spawn_egg" | "subtitles.entity.parrot.imitate.wither_skeleton" | "mco.gui.button" | "gui.socialInteractions.status_offline" | "block.minecraft.banner.square_bottom_right.blue" | "block.minecraft.banner.diagonal_up_right.pink" | "block.minecraft.weeping_vines_plant" | "mco.download.preparing" | "block.minecraft.banner.square_top_right.blue" | "block.minecraft.banner.rhombus.light_blue" | "createWorld.customize.custom.biomeSize" | "item.minecraft.leather_leggings" | "block.minecraft.gray_banner" | "commands.function.success.single" | "fml.modmismatchscreen.mismatchedmods" | "multiplayer.message_not_delivered" | "subtitles.entity.fox.aggro" | "mco.configure.world.buttons.settings" | "block.minecraft.dried_kelp_block" | "gamerule.mobGriefing" | "item.minecraft.spyglass" | "subtitles.item.bucket.fill_axolotl" | "mco.configure.world.buttons.resetworld" | "options.screenEffectScale.tooltip" | "selectWorld.gameMode" | "block.minecraft.sunflower" | "entity.minecraft.tropical_fish.type.stripey" | "createWorld.customize.custom.prev" | "createWorld.customize.presets.title" | "block.minecraft.white_stained_glass_pane" | "options.modelPart.right_sleeve" | "block.minecraft.potted_jungle_sapling" | "block.minecraft.banner.square_bottom_right.black" | "block.minecraft.redstone_wire" | "block.minecraft.banner.triangles_bottom.black" | "commands.summon.failed" | "arguments.operation.invalid" | "block.minecraft.banner.half_vertical.black" | "menu.returnToMenu" | "advancements.husbandry.safely_harvest_honey.description" | "item.minecraft.lingering_potion" | "subtitles.entity.villager.ambient" | "block.minecraft.banner.rhombus.lime" | "block.minecraft.banner.half_vertical.cyan" | "key.keyboard.left.bracket" | "block.minecraft.banner.creeper.lime" | "options.prioritizeChunkUpdates" | "item.minecraft.tipped_arrow.effect.swiftness" | "subtitles.item.trident.thunder" | "item.minecraft.potion.effect.water" | "argument.time.invalid_tick_count" | "menu.reportBugs" | "book.signButton" | "block.minecraft.banner.stripe_top.magenta" | "enchantment.minecraft.frost_walker" | "block.minecraft.banner.half_vertical_right.light_gray" | "subtitles.entity.zombie.hurt" | "subtitles.block.respawn_anchor.set_spawn" | "block.minecraft.banner.stripe_downright.orange" | "biome.minecraft.frozen_river" | "biome.minecraft.stony_shore" | "item.minecraft.tipped_arrow.effect.regeneration" | "subtitles.entity.firework_rocket.launch" | "translation.test.invalid" | "item.minecraft.endermite_spawn_egg" | "subtitles.entity.shulker.hurt" | "block.minecraft.birch_button" | "subtitles.weather.rain" | "block.minecraft.jungle_leaves" | "subtitles.entity.bee.loop_aggressive" | "fml.menu.multiplayer.incompatible" | "block.minecraft.purple_candle_cake" | "commands.summon.invalidPosition" | "createWorld.customize.custom.preset.caveDelight" | "block.minecraft.stripped_crimson_stem" | "subtitles.block.sculk_sensor.clicking" | "subtitles.entity.wandering_trader.death" | "block.minecraft.jungle_fence" | "entity.minecraft.item" | "selectWorld.mapType.normal" | "commands.forge.tags.containing_tag_count" | "commands.schedule.cleared.success" | "block.minecraft.banner.globe.magenta" | "menu.singleplayer" | "advMode.type" | "gamerule.category.mobs" | "recipe.toast.title" | "narrator.loading.done" | "createWorld.preparing" | "key.sneak" | "block.minecraft.horn_coral_block" | "commands.attribute.failed.entity" | "disconnect.timeout" | "options.ao" | "block.minecraft.banner.square_bottom_right.lime" | "advancements.story.enter_the_nether.description" | "block.minecraft.banner.triangle_top.orange" | "options.modelPart.left_sleeve" | "selectWorld.recreate.error.text" | "key.keyboard.right.win" | "book.generation.3" | "book.generation.1" | "block.minecraft.mossy_stone_bricks" | "book.generation.2" | "subtitles.entity.wandering_trader.reappeared" | "block.minecraft.seagrass" | "options.modelPart.hat" | "block.minecraft.diamond_block" | "item.minecraft.potion.effect.healing" | "subtitles.ui.cartography_table.take_result" | "block.minecraft.blue_carpet" | "block.minecraft.lightning_rod" | "gameMode.hardcore" | "enchantment.minecraft.sweeping" | "commands.data.block.query" | "subtitles.entity.zombie.attack_wooden_door" | "item.minecraft.dark_oak_boat" | "selectWorld.backupJoinSkipButton" | "options.chat.delay_none" | "narrator.button.difficulty_lock" | "item.minecraft.iron_boots" | "block.minecraft.mossy_stone_brick_wall" | "item.minecraft.white_dye" | "block.minecraft.potted_cactus" | "options.chat.visibility.hidden" | "item.minecraft.crossbow.projectile" | "block.minecraft.banner.small_stripes.white" | "container.enchant.clue" | "selectWorld.edit.export_worldgen_settings" | "block.minecraft.white_terracotta" | "block.minecraft.banner.rhombus.blue" | "subtitles.entity.zombie.ambient" | "item.minecraft.feather" | "item.minecraft.flower_pot" | "block.minecraft.potted_oxeye_daisy" | "selectWorld.gameMode.spectator.line2" | "selectWorld.gameMode.spectator.line1" | "options.languageWarning" | "block.minecraft.banner.creeper.blue" | "key.hotbar.8" | "key.hotbar.7" | "block.minecraft.banner.border.light_gray" | "commands.publish.success" | "key.hotbar.6" | "subtitles.entity.zombie.death" | "key.hotbar.5" | "item.minecraft.chainmail_helmet" | "subtitles.entity.evoker.cast_spell" | "key.hotbar.4" | "key.hotbar.3" | "key.hotbar.2" | "key.hotbar.1" | "team.visibility.always" | "commands.forceload.removed.multiple" | "forge.configgui.dimensionUnloadQueueDelay" | "mco.configure.world.backup" | "itemGroup.hotbar" | "block.minecraft.banner.globe.gray" | "block.minecraft.banner.skull.red" | "item.minecraft.mushroom_stew" | "argument.entity.options.level.description" | "block.minecraft.banner.gradient.cyan" | "fml.menu.mods.info.credits" | "block.minecraft.banner.gradient.orange" | "block.minecraft.netherrack" | "block.minecraft.ice" | "book.generation.0" | "block.minecraft.banner.square_bottom_right.light_gray" | "block.minecraft.crimson_sign" | "block.minecraft.lantern" | "block.minecraft.banner.square_top_right.purple" | "commands.worldborder.center.failed" | "mco.configure.world.invites.normal.tooltip" | "block.minecraft.banner.stripe_bottom.brown" | "color.minecraft.magenta" | "key.hotbar.9" | "block.minecraft.banner.half_horizontal.purple" | "block.minecraft.dropper" | "subtitles.entity.goat.ambient" | "commands.perf.notRunning" | "commands.item.source.no_such_slot" | "commands.forge.tps.invalid" | "narration.selection.usage" | "key.categories.gameplay" | "advMode.self" | "advancements.nether.distract_piglin.title" | "block.minecraft.quartz_bricks" | "attribute.name.forge.entity_gravity" | "block.minecraft.banner.straight_cross.brown" | "multiplayer.socialInteractions.not_available" | "block.minecraft.chiseled_quartz_block" | "subtitles.entity.vex.death" | "spectatorMenu.teleport.prompt" | "advancements.toast.task" | "createWorld.customize.preset.water_world" | "block.minecraft.banner.triangles_top.red" | "tutorial.bundleInsert.title" | "block.minecraft.purple_concrete_powder" | "subtitles.entity.blaze.shoot" | "block.minecraft.bookshelf" | "block.minecraft.banner.half_horizontal_bottom.lime" | "options.sensitivity" | "block.minecraft.blue_shulker_box" | "subtitles.entity.enderman.teleport" | "block.minecraft.pink_banner" | "item.minecraft.potion.effect.empty" | "commands.scoreboard.players.get.null" | "death.fell.finish.item" | "createWorld.customize.custom.spread" | "commands.clear.test.single" | "block.minecraft.pink_tulip" | "commands.drop.no_held_items" | "narrator.position.object_list" | "chat.link.open" | "mco.trial.message.line1" | "block.minecraft.banner.diagonal_up_right.green" | "mco.trial.message.line2" | "commands.forge.entity.list.single.header" | "subtitles.entity.strider.eat" | "block.minecraft.banner.gradient_up.magenta" | "block.minecraft.banner.globe.green" | "menu.shareToLan" | "argument.entity.options.tag.description" | "block.minecraft.polished_blackstone_wall" | "block.minecraft.tripwire_hook" | "argument.entity.options.dz.description" | "item.minecraft.golden_shovel" | "argument.entity.options.dy.description" | "block.minecraft.banner.stripe_middle.light_gray" | "block.minecraft.smooth_red_sandstone" | "subtitles.entity.leash_knot.place" | "block.minecraft.candle" | "block.minecraft.banner.circle.blue" | "commands.recipe.take.failed" | "block.minecraft.redstone_lamp" | "effect.minecraft.jump_boost" | "effect.minecraft.instant_health" | "commands.scoreboard.objectives.display.alreadyEmpty" | "item.minecraft.shulker_shell" | "mco.brokenworld.play" | "biome.minecraft.frozen_ocean" | "commands.datapack.unknown" | "options.modelPart.right_pants_leg" | "subtitles.entity.skeleton_horse.swim" | "soundCategory.music" | "commands.team.add.success" | "subtitles.entity.villager.work_cartographer" | "subtitles.entity.parrot.imitate.piglin" | "subtitles.entity.player.attack.knockback" | "commands.whitelist.add.failed" | "debug.inspect.server.block" | "death.attack.even_more_magic" | "enchantment.minecraft.fortune" | "block.minecraft.diorite_wall" | "mco.template.select.narrate.authors" | "commands.effect.clear.specific.success.multiple" | "death.attack.wither" | "advancements.nether.uneasy_alliance.description" | "key.keyboard.tab" | "options.biomeBlendRadius.13" | "advancements.husbandry.breed_all_animals.description" | "subtitles.block.beacon.power_select" | "options.biomeBlendRadius.15" | "options.biomeBlendRadius.11" | "gamerule.disableRaids" | "subtitles.block.beacon.deactivate" | "subtitles.entity.evoker.hurt" | "options.off" | "structure_block.detect_size" | "block.minecraft.end_portal" | "item.minecraft.tipped_arrow.effect.levitation" | "item.minecraft.painting" | "block.minecraft.black_banner" | "disconnect.loginFailed" | "block.minecraft.tube_coral_block" | "block.minecraft.banner.diagonal_up_right.black" | "enchantment.minecraft.channeling" | "block.minecraft.oak_button" | "subtitles.entity.endermite.ambient" | "block.minecraft.banner.stripe_left.magenta" | "createWorld.customize.flat.layer.bottom" | "block.minecraft.banner.square_top_right.lime" | "commands.perf.stopped" | "tutorial.craft_planks.title" | "commands.stopsound.success.source.sound" | "subtitles.item.crossbow.hit" | "entity.minecraft.minecart" | "block.minecraft.polished_basalt" | "item.minecraft.lingering_potion.effect.water_breathing" | "multiplayer.status.old" | "item.minecraft.potion.effect.luck" | "block.minecraft.purple_wool" | "stat.minecraft.drop" | "command.context.parse_error" | "fml.menu.multiplayer.incompatible.extra" | "block.minecraft.banner.stripe_downleft.red" | "options.chat.delay" | "block.minecraft.light_gray_bed" | "stat_type.minecraft.crafted" | "block.minecraft.yellow_concrete_powder" | "item.minecraft.potion.effect.thick" | "block.minecraft.polished_andesite_slab" | "item.minecraft.firework_star.magenta" | "block.minecraft.banner.stripe_left.green" | "item.minecraft.tropical_fish_bucket" | "subtitles.entity.villager.work_shepherd" | "argument.entity.options.z.description" | "block.minecraft.mossy_cobblestone_wall" | "argument.entity.options.limit.toosmall" | "gamerule.doDaylightCycle" | "multiplayer.stopSleeping" | "block.minecraft.banner.circle.lime" | "commands.particle.failed" | "commands.forge.tags.element_count" | "screenshot.failure" | "block.minecraft.banner.skull.yellow" | "parsing.quote.escape" | "stat.minecraft.sprint_one_cm" | "commands.scoreboard.objectives.remove.success" | "block.minecraft.dirt" | "build.tooHigh" | "subtitles.item.shield.block" | "advancements.nether.charge_respawn_anchor.description" | "biome.minecraft.dark_forest" | "entity.minecraft.trident" | "multiplayer.disconnect.unexpected_query_response" | "mco.configure.world.subscription.expired" | "block.minecraft.gilded_blackstone" | "container.stonecutter" | "subtitles.entity.husk.hurt" | "advancements.story.form_obsidian.title" | "commands.title.show.title.single" | "advancements.nether.charge_respawn_anchor.title" | "block.minecraft.jungle_slab" | "multiplayer.downloadingStats" | "subtitles.item.glow_ink_sac.use" | "subtitles.entity.cat.purr" | "fml.button.continue.launch" | "commands.forge.entity.list.invalid" | "difficulty.lock.question" | "options.particles" | "subtitles.item.bucket.fill" | "block.minecraft.white_tulip" | "gamerule.keepInventory" | "block.minecraft.banner.stripe_downright.purple" | "block.minecraft.banner.creeper.brown" | "block.minecraft.yellow_candle" | "subtitles.entity.parrot.imitate.ghast" | "team.visibility.hideForOtherTeams" | "fluid.minecraft.flowing_milk" | "block.minecraft.gray_wool" | "item.minecraft.chicken" | "death.attack.fireworks.item" | "block.minecraft.banner.square_bottom_left.white" | "mco.selectServer.trial" | "item.minecraft.firework_star.gray" | "gamerule.doWeatherCycle" | "debug.copy_location.help" | "block.minecraft.yellow_stained_glass" | "chat.coordinates" | "subtitles.entity.skeleton_horse.ambient" | "subtitles.block.chest.close" | "item.minecraft.tipped_arrow.effect.empty" | "advancements.nether.find_bastion.title" | "block.minecraft.banner.square_top_left.white" | "options.prioritizeChunkUpdates.none.tooltip" | "block.minecraft.weathered_cut_copper_slab" | "block.minecraft.banner.mojang.pink" | "subtitles.entity.villager.work_butcher" | "block.minecraft.banner.skull.light_blue" | "recipe.toast.description" | "item.minecraft.leather_horse_armor" | "block.minecraft.birch_sign" | "block.minecraft.soul_campfire" | "block.minecraft.banner.stripe_downleft.magenta" | "block.minecraft.nether_brick_slab" | "block.minecraft.banner.stripe_left.light_gray" | "entity.minecraft.trader_llama" | "subtitles.entity.hoglin.hurt" | "block.minecraft.nether_wart_block" | "createWorld.customize.flat.tile" | "mco.invites.button.accept" | "chat_screen.usage" | "multiplayerWarning.header" | "key.drop" | "block.minecraft.granite_wall" | "commands.help.failed" | "mco.configure.world.players.title" | "mco.configure.world.buttons.edit" | "multiplayer.status.and_more" | "item.minecraft.wheat" | "advMode.setCommand.success" | "entity.minecraft.end_crystal" | "options.mouse_settings.title" | "block.minecraft.shulker_box" | "subtitles.entity.zombie_horse.ambient" | "commands.jfr.started" | "container.shulkerBox" | "subtitles.entity.mooshroom.eat" | "block.minecraft.banner.base.cyan" | "selectWorld.recreate.customized.title" | "advancements.end.levitate.title" | "block.minecraft.crimson_stairs" | "item.minecraft.music_disc_chirp.desc" | "selectWorld.backupWarning.downgrade" | "createWorld.customize.custom.lavaLakeChance" | "key.keyboard.keypad.add" | "block.minecraft.cobbled_deepslate_stairs" | "block.minecraft.player_head.named" | "key.keyboard.slash" | "block.minecraft.tripwire" | "subtitles.entity.player.death" | "enchantment.minecraft.infinity" | "block.minecraft.banner.diagonal_up_left.yellow" | "block.minecraft.lever" | "block.minecraft.oak_stairs" | "menu.generatingTerrain" | "options.narrator.notavailable" | "subtitles.entity.wandering_trader.trade" | "argument.entity.selector.allEntities" | "item.minecraft.golden_sword" | "mco.error.invalid.session.message" | "createWorld.customize.custom.preset.mountains" | "container.lectern" | "block.minecraft.farmland" | "subtitles.entity.cat.hurt" | "commands.data.get.multiple" | "options.forceUnicodeFont" | "block.minecraft.sandstone_stairs" | "block.minecraft.cobblestone" | "subtitles.entity.horse.death" | "block.minecraft.polished_blackstone_brick_stairs" | "entity.minecraft.egg" | "advancements.husbandry.balanced_diet.title" | "subtitles.item.trident.riptide" | "block.minecraft.cyan_terracotta" | "merchant.trades" | "block.minecraft.beacon.primary" | "block.minecraft.light_blue_concrete" | "fml.menu.mods.normal" | "block.minecraft.acacia_button" | "item.minecraft.fermented_spider_eye" | "block.minecraft.banner.stripe_top.gray" | "mco.configure.world.activityfeed.disabled" | "block.minecraft.honeycomb_block" | "commands.deop.success" | "createWorld.customize.buffet.biome" | "block.minecraft.acacia_wall_sign" | "key.fullscreen" | "block.minecraft.banner.border.gray" | "item.minecraft.pink_dye" | "selectWorld.mapFeatures" | "item.minecraft.coal" | "subtitles.block.chorus_flower.death" | "block.minecraft.magenta_terracotta" | "entity.minecraft.evoker_fangs" | "enchantment.minecraft.projectile_protection" | "options.simulationDistance" | "block.minecraft.banner.circle.light_gray" | "subtitles.block.beehive.enter" | "enchantment.minecraft.bane_of_arthropods" | "block.minecraft.magenta_shulker_box" | "block.minecraft.dead_brain_coral_wall_fan" | "death.attack.arrow.item" | "subtitles.entity.vindicator.ambient" | "block.minecraft.infested_cobblestone" | "enchantment.minecraft.silk_touch" | "block.minecraft.tube_coral" | "item.minecraft.creeper_spawn_egg" | "options.on" | "block.minecraft.banner.base.purple" | "block.minecraft.stripped_jungle_wood" | "createWorld.customize.custom.fixedBiome" | "block.minecraft.banner.diagonal_right.light_blue" | "advancements.husbandry.plant_seed.description" | "gamerule.forgiveDeadPlayers" | "block.minecraft.banner.stripe_middle.magenta" | "commands.save.disabled" | "block.minecraft.banner.stripe_center.black" | "subtitles.item.bundle.insert" | "subtitles.block.tripwire.attach" | "commands.tag.add.failed" | "subtitles.entity.zombie_villager.ambient" | "mco.upload.select.world.title" | "pack.incompatible.confirm.new" | "subtitles.entity.villager.work_weaponsmith" | "commands.advancement.advancementNotFound" | "effect.minecraft.dolphins_grace" | "block.minecraft.banner.stripe_downleft.pink" | "mco.minigame.world.info.line1" | "gameMode.creative" | "item.minecraft.chorus_fruit" | "mco.minigame.world.info.line2" | "options.fov" | "block.minecraft.yellow_bed" | "advancements.adventure.trade.description" | "fml.resources.modresources" | "gui.done" | "block.minecraft.banner.stripe_left.black" | "block.minecraft.banner.triangles_bottom.green" | "commands.schedule.created.tag" | "arguments.nbtpath.node.invalid" | "death.attack.dragonBreath" | "selectWorld.cheats" | "item.minecraft.flint" | "debug.inspect.server.entity" | "commands.jfr.dump.failed" | "block.minecraft.polished_deepslate" | "stat.minecraft.climb_one_cm" | "subtitles.entity.parrot.imitate.elder_guardian" | "subtitles.entity.iron_golem.repair" | "forge.configgui.skipEmptyShapelessCheck.tooltip" | "key.keyboard.right" | "death.fell.assist.item" | "stat.minecraft.time_since_rest" | "title.multiplayer.realms" | "addServer.resourcePack.disabled" | "block.minecraft.crimson_nylium" | "item.minecraft.sheep_spawn_egg" | "advancements.adventure.sniper_duel.title" | "entity.minecraft.vex" | "advancements.nether.explore_nether.title" | "advancements.nether.loot_bastion.title" | "block.minecraft.mossy_cobblestone" | "death.attack.sweetBerryBush.player" | "block.minecraft.banner.triangle_bottom.orange" | "block.minecraft.prismarine_brick_stairs" | "block.minecraft.ladder" | "stat.minecraft.time_since_death" | "block.minecraft.banner.half_vertical.blue" | "debug.prefix" | "subtitles.block.lava.extinguish" | "block.minecraft.banner.square_bottom_right.orange" | "mco.upload.uploading" | "selectWorld.customizeType" | "options.chat.links.prompt" | "subtitles.item.bundle.drop_contents" | "block.minecraft.jungle_planks" | "block.minecraft.banner.stripe_center.green" | "block.minecraft.banner.half_horizontal.orange" | "gui.back" | "subtitles.entity.item_frame.break" | "argument.anchor.invalid" | "death.attack.dryout" | "block.minecraft.banner.diagonal_left.purple" | "stat.minecraft.trigger_trapped_chest" | "itemGroup.redstone" | "editGamerule.title" | "item.minecraft.chainmail_leggings" | "biome.minecraft.sparse_jungle" | "subtitles.entity.shulker.teleport" | "item.minecraft.skeleton_horse_spawn_egg" | "item.minecraft.squid_spawn_egg" | "selectWorld.conversion.tooltip" | "block.minecraft.banner.square_bottom_right.cyan" | "advancements.story.iron_tools.description" | "block.minecraft.oak_fence" | "item.minecraft.lingering_potion.effect.invisibility" | "block.minecraft.banner.triangles_top.yellow" | "block.minecraft.banner.creeper.light_gray" | "commands.forge.gen.usage" | "argument.entity.selector.nearestPlayer" | "container.beacon" | "item.minecraft.bucket" | "structure_block.structure_name" | "commands.scoreboard.players.operation.success.multiple" | "commands.clone.overlap" | "commands.forge.tracking.invalid" | "block.minecraft.banner.half_vertical_right.black" | "block.minecraft.banner.small_stripes.black" | "selectWorld.backupEraseCache" | "biome.minecraft.lush_caves" | "block.minecraft.crimson_fence_gate" | "block.minecraft.banner.cross.light_blue" | "block.minecraft.yellow_glazed_terracotta" | "block.minecraft.potted_pink_tulip" | "fml.modloading.brokenresources" | "block.minecraft.potted_fern" | "item.minecraft.nautilus_shell" | "item.minecraft.golden_hoe" | "item.minecraft.potion.effect.fire_resistance" | "block.minecraft.brown_shulker_box" | "block.minecraft.lily_of_the_valley" | "fml.modloading.brokenfile.oldforge" | "subtitles.entity.tropical_fish.death" | "block.minecraft.twisting_vines" | "item.minecraft.carrot_on_a_stick" | "block.minecraft.banner.bricks.pink" | "narration.recipe" | "subtitles.entity.player.hurt" | "subtitles.ui.loom.take_result" | "gui.socialInteractions.server_label.single" | "controls.reset" | "commands.stopsound.success.sourceless.sound" | "block.minecraft.banner.gradient_up.yellow" | "subtitles.entity.panda.aggressive_ambient" | "entity.minecraft.mooshroom" | "argument.scoreHolder.empty" | "advMode.nearestPlayer" | "commands.team.option.seeFriendlyInvisibles.alreadyEnabled" | "item.minecraft.bow" | "block.minecraft.banner.stripe_bottom.gray" | "advancements.nether.obtain_blaze_rod.title" | "block.minecraft.banner.straight_cross.yellow" | "block.minecraft.wheat" | "block.minecraft.pumpkin_stem" | "block.minecraft.deepslate" | "advancements.story.root.title" | "stat.minecraft.traded_with_villager" | "argument.nbt.expected.key" | "gamerule.maxCommandChainLength.description" | "mco.download.done" | "menu.online" | "fml.menu.multiplayer.networkincompatible" | "stat.minecraft.damage_dealt_absorbed" | "subtitles.entity.horse.jump" | "item.minecraft.poisonous_potato" | "options.difficulty.normal" | "block.minecraft.banner.triangle_bottom.white" | "options.accessibility.text_background.everywhere" | "options.darkMojangStudiosBackgroundColor.tooltip" | "item.minecraft.debug_stick" | "commands.placefeature.invalid" | "block.minecraft.banner.stripe_right.purple" | "block.minecraft.banner.piglin.brown" | "mco.selectServer.expiredRenew" | "block.minecraft.banner.half_vertical.lime" | "item.minecraft.mule_spawn_egg" | "block.minecraft.banner.piglin.yellow" | "argument.entity.options.scores.description" | "commands.forge.tags.element" | "block.minecraft.banner.cross.gray" | "subtitles.entity.illusioner.cast_spell" | "debug.help.help" | "block.minecraft.magenta_candle_cake" | "commands.publish.started" | "item.minecraft.hopper_minecart" | "block.minecraft.tube_coral_fan" | "death.attack.anvil.player" | "biome.minecraft.windswept_hills" | "demo.remainingTime" | "subtitles.entity.ghast.shoot" | "item.minecraft.tipped_arrow.effect.awkward" | "mco.client.incompatible.title" | "block.minecraft.banner.stripe_center.orange" | "mco.selectServer.create" | "parsing.double.invalid" | "item.minecraft.donkey_spawn_egg" | "block.minecraft.banner.stripe_left.purple" | "deathScreen.title" | "subtitles.entity.player.attack.crit" | "subtitles.entity.panda.worried_ambient" | "subtitles.item.dye.use" | "block.minecraft.banner.globe.white" | "gui.down" | "structure_block.button.save" | "block.minecraft.potted_azure_bluet" | "block.minecraft.black_bed" | "structure_block.mode_info.save" | "block.minecraft.banner.small_stripes.cyan" | "options.skinCustomisation" | "gui.socialInteractions.tab_hidden" | "death.attack.onFire.player" | "block.minecraft.banner.stripe_middle.gray" | "subtitles.block.composter.empty" | "demo.demoExpired" | "item.minecraft.spruce_boat" | "disconnect.loginFailedInfo.invalidSession" | "commands.weather.set.clear" | "subtitles.item.crossbow.shoot" | "mco.backup.restoring" | "mco.upload.close.failure" | "subtitles.entity.item_frame.place" | "subtitles.entity.hoglin.converted_to_zombified" | "subtitles.block.anvil.destroy" | "color.minecraft.purple" | "subtitles.entity.magma_cube.death" | "commands.worldborder.warning.time.failed" | "block.minecraft.banner.half_vertical_right.green" | "item.minecraft.tipped_arrow.effect.mundane" | "subtitles.entity.parrot.imitate.wither" | "options.touchscreen" | "advancements.adventure.honey_block_slide.description" | "block.minecraft.banner.gradient.blue" | "advancements.adventure.two_birds_one_arrow.title" | "createWorld.customize.custom.useLavaLakes" | "mco.selectServer.closed" | "block.minecraft.sea_lantern" | "block.minecraft.stripped_jungle_log" | "container.brewing" | "subtitles.block.generic.hit" | "item.minecraft.salmon_spawn_egg" | "block.minecraft.prismarine_bricks" | "item.minecraft.yellow_dye" | "block.minecraft.soul_sand" | "stat.minecraft.raid_win" | "selectServer.deleteWarning" | "subtitles.entity.donkey.ambient" | "subtitles.entity.piglin.death" | "death.attack.stalagmite.player" | "block.minecraft.banner.creeper.cyan" | "item.minecraft.shield.magenta" | "advancements.husbandry.wax_on.description" | "item.minecraft.brown_dye" | "item.minecraft.knowledge_book" | "parsing.quote.expected.end" | "subtitles.entity.egg.throw" | "mco.upload.hardcore" | "item.minecraft.clock" | "block.minecraft.banner.mojang.green" | "block.minecraft.banner.triangle_bottom.blue" | "entity.minecraft.tropical_fish.predefined.20" | "item.minecraft.splash_potion.effect.poison" | "stat.minecraft.walk_under_water_one_cm" | "block.minecraft.bedrock" | "createWorld.customize.custom.preset.caveChaos" | "entity.minecraft.tropical_fish.predefined.13" | "entity.minecraft.tropical_fish.predefined.12" | "entity.minecraft.tropical_fish.predefined.11" | "stat.minecraft.interact_with_blast_furnace" | "gui.recipebook.toggleRecipes.smeltable" | "entity.minecraft.tropical_fish.predefined.10" | "entity.minecraft.tropical_fish.predefined.17" | "block.minecraft.brown_banner" | "advancements.nether.find_bastion.description" | "commands.forge.entity.list.invalidworld" | "fluid.minecraft.milk" | "entity.minecraft.tropical_fish.predefined.16" | "entity.minecraft.tropical_fish.predefined.15" | "item.minecraft.panda_spawn_egg" | "entity.minecraft.tropical_fish.predefined.14" | "item.minecraft.tipped_arrow" | "entity.minecraft.tropical_fish.predefined.19" | "block.minecraft.conduit" | "block.minecraft.oxidized_cut_copper" | "entity.minecraft.tropical_fish.predefined.18" | "block.minecraft.banner.curly_border.pink" | "block.minecraft.dead_bubble_coral_wall_fan" | "block.minecraft.banner.stripe_left.light_blue" | "death.attack.cramming.player" | "commands.worldborder.damage.buffer.failed" | "block.minecraft.banner.triangles_bottom.orange" | "block.minecraft.polished_granite_slab" | "block.minecraft.white_candle_cake" | "options.clouds.fancy" | "block.minecraft.banner.triangle_bottom.yellow" | "advancements.end.respawn_dragon.title" | "block.minecraft.dead_bubble_coral" | "block.minecraft.stone_stairs" | "stat.minecraft.total_world_time" | "block.minecraft.cobblestone_stairs" | "block.minecraft.banner.bricks.purple" | "item.minecraft.warped_fungus_on_a_stick" | "item.minecraft.music_disc_cat.desc" | "item.minecraft.wooden_pickaxe" | "death.attack.thorns" | "key.back" | "block.minecraft.light_blue_stained_glass_pane" | "block.minecraft.banner.skull.brown" | "item.minecraft.piglin_banner_pattern" | "block.minecraft.banner.diagonal_up_left.light_gray" | "block.minecraft.banner.stripe_downleft.lime" | "commands.datapack.list.enabled.none" | "block.minecraft.dead_tube_coral" | "subtitles.entity.ravager.ambient" | "subtitles.entity.parrot.imitate.husk" | "advancements.husbandry.wax_off.description" | "mco.invites.nopending" | "stat.minecraft.play_time" | "block.minecraft.banner.half_horizontal_bottom.cyan" | "commands.execute.conditional.fail_count" | "subtitles.entity.axolotl.hurt" | "block.minecraft.banner.curly_border.red" | "block.minecraft.calcite" | "block.minecraft.small_dripleaf" | "item.minecraft.sugar" | "subtitles.entity.skeleton.hurt" | "block.minecraft.cyan_concrete_powder" | "commands.spawnpoint.success.single" | "fml.menu.multiplayer.modsincompatible" | "block.minecraft.gray_bed" | "argument.entity.options.limit.description" | "argument.entity.invalid" | "block.minecraft.banner.curly_border.green" | "block.minecraft.grass" | "mirror.left_right" | "subtitles.item.spyglass.use" | "createWorld.customize.presets.select" | "item.minecraft.music_disc_13.desc" | "createWorld.customize.custom.useMansions" | "commands.advancement.revoke.one.to.one.success" | "selectWorld.recreate.customized.text" | "commands.weather.set.rain" | "advMode.mode.conditional" | "block.minecraft.blue_candle_cake" | "color.minecraft.pink" | "advancements.nether.brew_potion.title" | "advancements.adventure.hero_of_the_village.description" | "block.minecraft.jungle_door" | "item.minecraft.music_disc_wait" | "block.minecraft.light_blue_candle_cake" | "item.minecraft.firework_star.custom_color" | "fml.modmismatchscreen.missingmods.server" | "death.attack.freeze.player" | "death.attack.generic" | "subtitles.entity.turtle.hurt" | "entity.minecraft.drowned" | "commands.forge.setdim.invalid.dim" | "container.enchant.level.one" | "fml.menu.mods" | "stat.minecraft.use_cauldron" | "entity.minecraft.pufferfish" | "block.minecraft.banner.globe.red" | "item.minecraft.dried_kelp" | "item.minecraft.potion.effect.leaping" | "subtitles.entity.parrot.ambient" | "item.minecraft.potato" | "block.minecraft.basalt" | "item.minecraft.diamond_chestplate" | "selectWorld.resultFolder" | "block.minecraft.creeper_head" | "block.minecraft.banner.stripe_right.brown" | "block.minecraft.banner.triangle_bottom.lime" | "commands.advancement.revoke.criterion.to.one.success" | "pack.source.server" | "subtitles.block.beacon.ambient" | "mco.backup.button.upload" | "block.minecraft.dark_prismarine" | "subtitles.item.armor.equip_iron" | "subtitles.item.armor.equip_turtle" | "stat.minecraft.minecart_one_cm" | "subtitles.entity.drowned.hurt" | "block.minecraft.fire_coral_block" | "advancements.story.upgrade_tools.description" | "item.minecraft.shield.green" | "narration.component_list.usage" | "selectWorld.edit.backupSize" | "subtitles.entity.parrot.imitate.phantom" | "block.minecraft.small_amethyst_bud" | "argument.entity.options.unterminated" | "mco.configure.world.description" | "block.minecraft.banner.diagonal_up_right.light_blue" | "subtitles.entity.dolphin.splash" | "biome.minecraft.grove" | "block.minecraft.nether_sprouts" | "commands.forge.tracking.entity.reset" | "block.minecraft.creeper_wall_head" | "item.minecraft.firework_star.brown" | "forge.swimSpeed" | "debug.reload_resourcepacks.help" | "item.minecraft.emerald" | "subtitles.entity.salmon.hurt" | "tutorial.punch_tree.description" | "optimizeWorld.info.total" | "commands.title.reset.multiple" | "pack.source.local" | "subtitles.entity.evoker.death" | "entity.minecraft.giant" | "item.modifiers.feet" | "subtitles.entity.horse.saddle" | "subtitles.entity.wither.ambient" | "subtitles.block.fence_gate.toggle" | "entity.minecraft.zombified_piglin" | "block.minecraft.banner.triangle_top.light_gray" | "stat.minecraft.play_noteblock" | "block.minecraft.banner.flower.light_gray" | "block.minecraft.banner.skull.blue" | "block.minecraft.green_concrete" | "argument.pos.missing.double" | "block.minecraft.potted_brown_mushroom" | "menu.convertingLevel" | "advancements.husbandry.make_a_sign_glow.description" | "soundCategory.hostile" | "block.minecraft.orange_concrete_powder" | "subtitles.entity.arrow.hit_player" | "disconnect.lost" | "block.minecraft.smithing_table" | "mco.configure.world.subscription.start" | "advMode.mode.autoexec.bat" | "block.minecraft.lime_shulker_box" | "block.minecraft.copper_block" | "stat.minecraft.ring_bell" | "fml.messages.version.restriction.bounded.exclusive" | "gui.socialInteractions.status_hidden" | "subtitles.entity.puffer_fish.blow_out" | "item.minecraft.wither_skeleton_spawn_egg" | "block.minecraft.banner.triangles_bottom.white" | "commands.spreadplayers.failed.teams" | "pack.incompatible.old" | "forge.controlsgui.control.mac" | "subtitles.block.tripwire.click" | "subtitles.entity.cod.flop" | "entity.minecraft.tropical_fish.predefined.21" | "commands.scoreboard.players.add.success.multiple" | "item.minecraft.quartz" | "death.fell.killer" | "block.minecraft.acacia_wood" | "item.modifiers.mainhand" | "gamerule.doTileDrops.description" | "options.graphics.fancy" | "block.minecraft.potted_azalea_bush" | "structure_block.save_failure" | "structure_block.integrity.seed" | "block.minecraft.banner.square_bottom_right.white" | "block.minecraft.banner.circle.orange" | "options.mainHand.right" | "block.minecraft.gravel" | "subtitles.entity.parrot.eats" | "block.minecraft.bubble_coral_wall_fan" | "subtitles.entity.minecart.riding" | "mco.template.button.publisher" | "block.minecraft.banner.mojang.gray" | "fml.menu.mods.info.changelogheader" | "mco.configure.world.close.question.line1" | "mco.configure.world.close.question.line2" | "block.minecraft.light_blue_terracotta" | "key.togglePerspective" | "block.minecraft.banner.stripe_center.red" | "commands.team.remove.success" | "subtitles.entity.parrot.imitate.evoker" | "item.minecraft.prismarine_shard" | "block.minecraft.banner.curly_border.black" | "options.skinCustomisation.title" | "item.minecraft.slime_spawn_egg" | "item.minecraft.rabbit_stew" | "subtitles.entity.parrot.imitate.guardian" | "item.minecraft.netherite_sword" | "block.minecraft.banner.half_horizontal.blue" | "biome.minecraft.ice_spikes" | "options.hideMatchedNames.tooltip" | "block.minecraft.sandstone" | "mco.client.incompatible.msg.line1" | "block.minecraft.pink_concrete" | "item.minecraft.chainmail_chestplate" | "mco.client.incompatible.msg.line3" | "mco.client.incompatible.msg.line2" | "commands.tag.remove.failed" | "narration.suggestion" | "entity.minecraft.villager.farmer" | "commands.forge.mods.list" | "deathScreen.titleScreen" | "item.minecraft.lingering_potion.effect.levitation" | "item.minecraft.nether_brick" | "attribute.modifier.plus.0" | "death.attack.inFire.player" | "attribute.modifier.plus.2" | "attribute.modifier.plus.1" | "block.minecraft.banner.triangle_top.green" | "block.minecraft.brown_mushroom" | "commands.setblock.failed" | "block.minecraft.prismarine" | "block.minecraft.lodestone" | "commands.item.entity.set.success.single" | "block.minecraft.banner.half_vertical_right.gray" | "item.minecraft.music_disc_far" | "block.minecraft.stone_brick_wall" | "structure_block.size_failure" | "subtitles.entity.llama.swag" | "entity.minecraft.panda" | "createWorld.customize.preset.the_void" | "commands.scoreboard.players.reset.all.multiple" | "entity.minecraft.furnace_minecart" | "attribute.name.generic.attack_range" | "attribute.name.generic.flying_speed" | "narration.button" | "gui.socialInteractions.tooltip.hide" | "selectWorld.backupJoinConfirmButton" | "block.minecraft.soul_fire" | "death.fell.accident.generic" | "mco.configure.world.delete.question.line1" | "selectWorld.conversion" | "multiplayer.status.quitting" | "gui.advancements" | "subtitles.entity.goat.ram_impact" | "item.minecraft.iron_hoe" | "block.minecraft.brown_stained_glass_pane" | "mco.configure.world.delete.question.line2" | "block.minecraft.magenta_carpet" | "entity.minecraft.potion" | "item.minecraft.shield.black" | "soundCategory.weather" | "block.minecraft.banner.piglin.orange" | "block.minecraft.banner.straight_cross.red" | "commands.attribute.value.get.success" | "commands.setworldspawn.success" | "commands.pardon.success" | "merchant.deprecated" | "item.minecraft.music_disc_ward" | "menu.savingChunks" | "block.minecraft.blue_orchid" | "block.minecraft.banner.flower.brown" | "commands.jfr.start.failed" | "commands.title.times.multiple" | "stat.mobsButton" | "block.minecraft.banner.stripe_middle.green" | "subtitles.entity.creeper.primed" | "block.minecraft.light_blue_stained_glass" | "block.minecraft.banner.stripe_center.brown" | "pack.copyFailure" | "item.minecraft.diamond_shovel" | "entity.minecraft.villager.toolsmith" | "gui.socialInteractions.shown_in_chat" | "createWorld.customize.custom.seaLevel" | "subtitles.entity.axolotl.idle_water" | "narrator.controls.bound" | "block.minecraft.banner.triangles_bottom.purple" | "block.minecraft.red_candle_cake" | "commands.forge.arguments.enum.invalid" | "block.minecraft.gray_concrete" | "subtitles.entity.zombie_villager.cure" | "mco.minigame.world.starting.screen.title" | "commands.locatebiome.notFound" | "block.minecraft.light_weighted_pressure_plate" | "commands.drop.success.single_with_table" | "subtitles.entity.drowned.death" | "commands.bossbar.set.value.unchanged" | "commands.forge.tps.summary.named" | "block.minecraft.black_stained_glass" | "block.minecraft.waxed_exposed_cut_copper_slab" | "structure_block.mode.corner" | "entity.minecraft.endermite" | "pack.folderInfo" | "commands.team.option.collisionRule.success" | "block.minecraft.banner.stripe_downleft.blue" | "gamerule.doInsomnia" | "block.minecraft.red_nether_bricks" | "filled_map.level" | "block.minecraft.banner.square_top_right.yellow" | "subtitles.entity.wolf.ambient" | "commands.team.list.members.empty" | "mco.configure.world.buttons.close" | "argument.entity.options.gamemode.description" | "key.smoothCamera" | "block.minecraft.banner.half_horizontal.lime" | "block.minecraft.banner.circle.purple" | "commands.scoreboard.players.list.entity.empty" | "block.minecraft.emerald_block" | "item.minecraft.pufferfish" | "block.minecraft.banner.stripe_top.light_blue" | "block.minecraft.banner.stripe_downleft.orange" | "subtitles.entity.wither.death" | "enchantment.minecraft.feather_falling" | "block.minecraft.stone_brick_stairs" | "argument.item.id.invalid" | "commands.tag.list.single.success" | "fml.messages.artifactversion" | "advancements.adventure.kill_a_mob.description" | "block.minecraft.smooth_quartz_slab" | "commands.list.nameAndId" | "stat_type.minecraft.picked_up" | "pack.incompatible.confirm.title" | "argument.entity.options.advancements.description" | "gamerule.freezeDamage" | "subtitles.block.big_dripleaf.tilt_down" | "commands.forceload.added.failure" | "gamerule.maxCommandChainLength" | "block.minecraft.target" | "item.minecraft.tipped_arrow.effect.water" | "block.minecraft.hanging_roots" | "block.minecraft.gold_ore" | "block.minecraft.lime_stained_glass_pane" | "stat.minecraft.fish_caught" | "block.minecraft.birch_sapling" | "commands.teleport.success.location.multiple" | "block.minecraft.banner.half_vertical_right.white" | "commands.difficulty.query" | "options.chat.height.focused" | "commands.placefeature.success" | "forge.configgui.fullBoundingBoxLadders.tooltip" | "item.minecraft.written_book" | "forge.entity_gravity" | "enchantment.minecraft.mending" | "item.minecraft.beetroot" | "block.minecraft.jungle_sapling" | "demo.help.movementMouse" | "block.minecraft.kelp" | "commands.whitelist.remove.success" | "item.minecraft.string" | "commands.execute.blocks.toobig" | "advancements.adventure.kill_a_mob.title" | "attribute.name.forge.nametag_distance" | "death.attack.hotFloor.player" | "commands.spectate.success.started" | "subtitles.entity.piglin_brute.converted_to_zombified" | "gui.recipebook.toggleRecipes.smokable" | "block.minecraft.banner.stripe_right.light_blue" | "advancements.adventure.whos_the_pillager_now.description" | "stat.minecraft.damage_taken" | "parsing.expected" | "block.minecraft.chorus_plant" | "options.graphics.warning.version" | "block.minecraft.banner.square_bottom_right.red" | "selectWorld.backupQuestion.downgrade" | "options.hideLightningFlashes" | "item.minecraft.cooked_rabbit" | "createWorld.customize.custom.biomeDepthOffset" | "key.keyboard.right.bracket" | "entity.minecraft.shulker_bullet" | "gui.recipebook.search_hint" | "advancements.husbandry.fishy_business.description" | "selectServer.deleteButton" | "mco.selectServer.expiredTrial" | "block.minecraft.banner.stripe_downleft.purple" | "subtitles.entity.evoker.ambient" | "block.minecraft.pink_stained_glass_pane" | "item.minecraft.music_disc_blocks" | "enchantment.minecraft.unbreaking" | "createWorld.customize.custom.upperLimitScale" | "block.minecraft.azure_bluet" | "argument.entity.options.type.description" | "item.minecraft.lava_bucket" | "block.minecraft.oak_log" | "subtitles.entity.glow_squid.ambient" | "dataPack.title" | "commands.experience.add.levels.success.multiple" | "commands.scoreboard.players.reset.specific.single" | "block.minecraft.banner.stripe_middle.white" | "subtitles.entity.squid.squirt" | "mco.create.world.skip" | "debug.pause_focus.help" | "fml.modloading.brokenfile.bukkit" | "chat.type.advancement.challenge" | "createWorld.customize.custom.waterLakeChance" | "options.chat.opacity" | "block.minecraft.potted_oak_sapling" | "subtitles.entity.arrow.shoot" | "subtitles.block.blastfurnace.fire_crackle" | "createWorld.customize.custom.size" | "block.minecraft.purpur_slab" | "item.durability" | "item.minecraft.lingering_potion.effect.turtle_master" | "mco.selectServer.close" | "item.minecraft.command_block_minecart" | "block.minecraft.honey_block" | "block.minecraft.banner.triangle_bottom.purple" | "entity.minecraft.chest_minecart" | "block.minecraft.spruce_sign" | "multiplayer.disconnect.invalid_player_data" | "subtitles.entity.piglin.converted_to_zombified" | "block.minecraft.lime_terracotta" | "item.minecraft.shield" | "item.minecraft.light_blue_dye" | "realms.missing.snapshot.error.text" | "stat.minecraft.fall_one_cm" | "block.minecraft.dragon_egg" | "block.minecraft.banner.bricks.yellow" | "block.minecraft.banner.square_bottom_left.cyan" | "block.minecraft.banner.gradient_up.pink" | "forge.configgui.forceSystemNanoTime.tooltip" | "block.minecraft.red_wool" | "mco.configure.world.slot.tooltip.active" | "block.minecraft.repeating_command_block" | "options.audioDevice.default" | "item.minecraft.wheat_seeds" | "arguments.block.tag.unknown" | "generator.large_biomes" | "block.minecraft.red_nether_brick_wall" | "commands.bossbar.set.max.success" | "block.minecraft.polished_diorite" | "parsing.int.expected" | "item.minecraft.hoglin_spawn_egg" | "mco.upload.verifying" | "commands.worldborder.set.grow" | "block.minecraft.purple_stained_glass" | "subtitles.block.pumpkin.carve" | "commands.experience.query.points" | "narrator.select.world" | "block.minecraft.peony" | "block.minecraft.banner.triangles_bottom.pink" | "item.minecraft.mojang_banner_pattern" | "block.minecraft.lava_cauldron" | "block.minecraft.banner.half_horizontal_bottom.blue" | "commands.recipe.give.success.multiple" | "commands.forceload.query.failure" | "block.minecraft.dead_horn_coral" | "block.minecraft.potted_birch_sapling" | "item.minecraft.suspicious_stew" | "advancements.adventure.trade_at_world_height.description" | "subtitles.block.bell.use" | "subtitles.block.comparator.click" | "subtitles.entity.potion.splash" | "block.minecraft.stone_button" | "item.minecraft.tipped_arrow.effect.luck" | "stat.minecraft.inspect_dropper" | "subtitles.entity.zoglin.step" | "key.keyboard.num.lock" | "block.minecraft.pink_stained_glass" | "death.attack.sting.player" | "item.minecraft.shears" | "biome.minecraft.taiga" | "item.minecraft.potion.effect.water_breathing" | "block.minecraft.banner.triangles_bottom.light_blue" | "death.attack.fallingStalactite.player" | "block.minecraft.banner.stripe_middle.yellow" | "multiplayer.disconnect.banned.expiration" | "effect.minecraft.regeneration" | "selectWorld.edit.backup" | "mco.configure.world.commandBlocks" | "subtitles.entity.horse.breathe" | "block.minecraft.red_candle" | "item.minecraft.enchanted_golden_apple" | "subtitles.entity.fox.spit" | "commands.scoreboard.players.list.entity.success" | "block.minecraft.blue_concrete_powder" | "commands.gamerule.query" | "title.multiplayer.other" | "multiplayer.player.left" | "subtitles.item.armor.equip_leather" | "mco.configure.world.subscription.month" | "createWorld.customize.custom.useMonuments" | "parsing.bool.invalid" | "subtitles.entity.hoglin.attack" | "mco.configure.world.subscription.title" | "block.minecraft.banner.square_top_left.light_blue" | "createWorld.customize.preset.bottomless_pit" | "item.minecraft.cocoa_beans" | "block.minecraft.brown_stained_glass" | "commands.team.option.friendlyfire.disabled" | "block.minecraft.crimson_door" | "block.minecraft.granite_stairs" | "multiplayer.disconnect.unverified_username" | "narration.checkbox.usage.hovered" | "block.minecraft.banner.globe.purple" | "subtitles.entity.phantom.ambient" | "block.minecraft.bed.too_far_away" | "block.minecraft.dead_tube_coral_fan" | "resourcePack.load_fail" | "block.minecraft.prismarine_stairs" | "mco.configure.world.buttons.invite" | "block.minecraft.cut_red_sandstone_slab" | "commands.locate.failed" | "block.minecraft.banner.square_bottom_right.green" | "key.keyboard.backslash" | "block.minecraft.banner.stripe_right.gray" | "gui.narrate.button" | "block.minecraft.banner.piglin.purple" | "commands.worldborder.damage.amount.failed" | "block.minecraft.banner.diagonal_left.light_blue" | "forge.container.enchant.limitedEnchantability" | "block.minecraft.bamboo_sapling" | "advancements.nether.get_wither_skull.title" | "translation.test.invalid2" | "block.minecraft.dead_bush" | "block.minecraft.banner.half_horizontal_bottom.orange" | "block.minecraft.banner.half_vertical.yellow" | "selectServer.add" | "block.minecraft.birch_pressure_plate" | "entity.minecraft.skeleton_horse" | "subtitles.entity.evoker_fangs.attack" | "mco.download.failed" | "options.renderDistance" | "death.attack.indirectMagic" | "selectWorld.gameMode.creative" | "mco.reset.world.generate" | "item.minecraft.music_disc_far.desc" | "advancements.husbandry.tactical_fishing.description" | "block.minecraft.banner.straight_cross.gray" | "commands.op.success" | "color.minecraft.orange" | "block.minecraft.banner.piglin.gray" | "item.minecraft.netherite_ingot" | "attribute.name.generic.attack_damage" | "mco.configure.world.name" | "attribute.name.generic.reach_distance" | "forge.configgui.forgeLightPipelineEnabled" | "block.minecraft.banner.half_vertical.red" | "advancements.end.levitate.description" | "forge.configgui.zoomInMissingModelTextInGui.tooltip" | "parsing.float.invalid" | "advMode.allPlayers" | "advancements.story.enchant_item.description" | "block.minecraft.banner.stripe_right.orange" | "block.minecraft.rail" | "item.minecraft.stone_axe" | "subtitles.entity.ender_dragon.ambient" | "block.minecraft.glowstone" | "argument.pos.outofbounds" | "mco.download.confirmation.line1" | "mco.download.confirmation.line2" | "item.minecraft.bread" | "block.minecraft.banner.triangle_top.white" | "mco.configure.world.buttons.options" | "multiplayer.status.ping" | "block.minecraft.jungle_fence_gate" | "block.minecraft.potted_cornflower" | "subtitles.item.axe.wax_off" | "gamerule.doFireTick" | "subtitles.block.conduit.attack.target" | "entity.minecraft.witch" | "gamerule.universalAnger.description" | "gui.toMenu" | "block.minecraft.banner.rhombus.yellow" | "subtitles.entity.spider.hurt" | "entity.minecraft.marker" | "block.minecraft.smooth_sandstone" | "mco.configure.world.forceGameMode" | "subtitles.entity.piglin_brute.death" | "advancements.nether.use_lodestone.title" | "block.minecraft.oxeye_daisy" | "subtitles.entity.player.attack.strong" | "subtitles.entity.witch.ambient" | "subtitles.block.pointed_dripstone.drip_lava_into_cauldron" | "debug.crash.warning" | "block.minecraft.jungle_wood" | "advancements.adventure.spyglass_at_dragon.description" | "subtitles.entity.polar_bear.warning" | "mco.client.outdated.title" | "entity.minecraft.wither" | "book.invalid.tag" | "block.minecraft.granite" | "item.minecraft.music_disc_stal.desc" | "item.minecraft.cow_spawn_egg" | "commands.deop.failed" | "item.minecraft.skeleton_spawn_egg" | "block.minecraft.banner.circle.gray" | "commands.title.show.subtitle.multiple" | "block.minecraft.banner.diagonal_up_left.gray" | "commands.bossbar.set.style.success" | "argument.block.property.unknown" | "key.keyboard.apostrophe" | "container.blast_furnace" | "enchantment.minecraft.respiration" | "stat.minecraft.deaths" | "block.minecraft.banner.triangle_top.magenta" | "narrator.screen.title" | "death.attack.explosion.player" | "subtitles.entity.glow_item_frame.rotate_item" | "subtitles.entity.lightning_bolt.impact" | "block.minecraft.banner.stripe_center.magenta" | "subtitles.entity.sheep.death" | "commands.recipe.take.success.multiple" | "subtitles.ui.stonecutter.take_result" | "block.minecraft.pink_wool" | "tutorial.move.title" | "block.minecraft.banner.skull.cyan" | "fml.menu.notification.title" | "structure_block.hover.corner" | "effect.minecraft.luck" | "advancements.husbandry.root.title" | "options.fullscreen" | "block.minecraft.chiseled_sandstone" | "subtitles.entity.wither.spawn" | "options.difficulty.peaceful" | "subtitles.entity.hoglin.angry" | "death.attack.hotFloor" | "team.notFound" | "selectWorld.enterName" | "block.minecraft.green_stained_glass_pane" | "item.minecraft.wooden_axe" | "optimizeWorld.title" | "block.minecraft.cobblestone_wall" | "subtitles.block.campfire.crackle" | "item.minecraft.cyan_dye" | "block.minecraft.infested_stone" | "debug.advanced_tooltips.help" | "subtitles.entity.tropical_fish.hurt" | "commands.gamerule.set" | "death.attack.wither.player" | "block.minecraft.banner.stripe_bottom.orange" | "stat.minecraft.horse_one_cm" | "title.singleplayer" | "forge.configgui.selectiveResourceReloadEnabled.tooltip" | "block.minecraft.jigsaw" | "block.minecraft.banner.diagonal_right.black" | "subtitles.block.respawn_anchor.charge" | "commands.forge.setdim.invalid.nochange" | "block.minecraft.banner.stripe_downleft.white" | "subtitles.entity.vex.ambient" | "subtitles.entity.blaze.death" | "forge.update.beta.1" | "gui.socialInteractions.empty_hidden" | "forge.update.beta.2" | "selectWorld.locked" | "options.graphics.warning.vendor" | "commands.advancement.grant.criterion.to.many.failure" | "demo.help.movement" | "block.minecraft.tall_grass" | "commands.advancement.grant.criterion.to.many.success" | "mco.configure.world.invites.ops.tooltip" | "advancements.adventure.adventuring_time.description" | "block.minecraft.dead_brain_coral_block" | "block.minecraft.fire_coral_fan" | "subtitles.entity.dolphin.attack" | "block.minecraft.potted_dark_oak_sapling" | "entity.minecraft.villager.fisherman" | "mco.configure.world.buttons.players" | "mco.brokenworld.message.line2" | "mco.brokenworld.message.line1" | "block.minecraft.acacia_door" | "item.minecraft.shield.orange" | "block.minecraft.blue_terracotta" | "block.minecraft.soul_soil" | "item.minecraft.sweet_berries" | "advancements.adventure.spyglass_at_ghast.title" | "block.minecraft.orange_stained_glass_pane" | "subtitles.entity.villager.work_leatherworker" | "effect.minecraft.water_breathing" | "item.minecraft.glowstone_dust" | "controls.resetAll" | "block.minecraft.banner.square_top_left.cyan" | "block.minecraft.banner.curly_border.white" | "entity.minecraft.tropical_fish.type.clayfish" | "block.minecraft.banner.stripe_right.light_gray" | "subtitles.block.portal.trigger" | "effect.minecraft.mining_fatigue" | "demo.day.warning" | "key.keyboard.left.control" | "block.minecraft.banner.stripe_left.yellow" | "item.minecraft.flint_and_steel" | "commands.datapack.disable.failed" | "block.minecraft.oxidized_cut_copper_stairs" | "block.minecraft.banner.half_horizontal.cyan" | "item.minecraft.firework_star.shape.star" | "generator.customized" | "block.minecraft.wither_skeleton_skull" | "generic.reachDistance" | "item.minecraft.raw_copper" | "item.minecraft.firework_star.yellow" | "death.attack.sting" | "stat_type.minecraft.used" | "commands.recipe.give.failed" | "item.minecraft.silverfish_spawn_egg" | "block.minecraft.red_concrete_powder" | "block.minecraft.banner.square_top_left.brown" | "key.attack" | "item.minecraft.firework_star.blue" | "block.minecraft.banner.stripe_top.lime" | "subtitles.entity.creeper.hurt" | "block.minecraft.banner.skull.light_gray" | "structure_block.load_not_found" | "block.minecraft.spore_blossom" | "optimizeWorld.stage.failed" | "key.keyboard.left.win" | "block.minecraft.banner.diagonal_up_left.purple" | "entity.minecraft.zombie" | "itemGroup.misc" | "block.minecraft.allium" | "block.minecraft.detector_rail" | "advancements.adventure.walk_on_powder_snow_with_leather_boots.description" | "block.minecraft.damaged_anvil" | "block.minecraft.green_glazed_terracotta" | "stat.minecraft.inspect_dispenser" | "fml.menu.mods.info.trust.noauthority" | "block.minecraft.loom" | "item.minecraft.music_disc_ward.desc" | "subtitles.entity.mule.angry" | "particle.notFound" | "block.minecraft.banner.border.lime" | "subtitles.entity.creeper.death" | "selectWorld.gameMode.survival.line1" | "block.minecraft.banner.mojang.magenta" | "subtitles.entity.piglin_brute.step" | "selectWorld.gameMode.survival.line2" | "block.minecraft.light_gray_glazed_terracotta" | "commands.forceload.added.multiple" | "block.minecraft.spawn.not_valid" | "pack.nameAndSource" | "chat.type.team.sent" | "advancements.nether.obtain_ancient_debris.description" | "subtitles.entity.ender_dragon.hurt" | "subtitles.block.bubble_column.upwards_ambient" | "mco.template.default.name" | "block.minecraft.banner.square_bottom_left.orange" | "commands.scoreboard.players.list.entity.entry" | "commands.give.success.single" | "selectWorld.gameRules" | "subtitles.entity.generic.big_fall" | "options.fovEffectScale" | "subtitles.entity.bee.sting" | "options.chat.title" | "subtitles.entity.ender_dragon.shoot" | "commands.data.storage.query" | "death.fell.finish" | "pack.incompatible.new" | "subtitles.entity.zoglin.hurt" | "selectWorld.edit.title" | "block.minecraft.stripped_spruce_log" | "block.minecraft.banner.triangles_top.cyan" | "pack.source.world" | "death.attack.fallingBlock.player" | "block.minecraft.banner.stripe_top.black" | "block.minecraft.lime_concrete" | "subtitles.entity.turtle.lay_egg" | "biome.minecraft.warm_ocean" | "mco.configure.world.invite.narration" | "block.minecraft.waxed_weathered_cut_copper" | "spectatorMenu.team_teleport.prompt" | "item.minecraft.shield.purple" | "block.minecraft.deepslate_iron_ore" | "block.minecraft.rose_bush" | "block.minecraft.iron_bars" | "commands.worldborder.damage.amount.success" | "death.attack.badRespawnPoint.message" | "block.minecraft.banner.small_stripes.gray" | "commands.advancement.grant.one.to.one.success" | "key.keyboard.keypad.0" | "key.keyboard.keypad.1" | "commands.drop.success.single" | "block.minecraft.banner.diagonal_left.light_gray" | "options.narrator.system" | "entity.minecraft.tropical_fish.type.brinely" | "death.attack.explosion.player.item" | "item.minecraft.blaze_powder" | "tutorial.bundleInsert.description" | "chat.type.advancement.task" | "block.minecraft.banner.diagonal_right.green" | "key.keyboard.keypad.2" | "subtitles.entity.donkey.hurt" | "disconnect.quitting" | "key.keyboard.keypad.3" | "key.keyboard.keypad.4" | "key.keyboard.keypad.5" | "block.minecraft.quartz_slab" | "key.keyboard.keypad.6" | "key.keyboard.keypad.7" | "key.keyboard.keypad.8" | "stat.minecraft.target_hit" | "block.minecraft.banner.half_horizontal_bottom.light_blue" | "key.keyboard.keypad.9" | "effect.minecraft.slow_falling" | "stat.minecraft.interact_with_anvil" | "subtitles.entity.glow_squid.hurt" | "commands.data.modify.expected_object" | "options.graphics.warning.title" | "commands.spectate.not_spectator" | "block.minecraft.yellow_candle_cake" | "block.minecraft.banner.stripe_top.blue" | "argument.entity.options.level.negative" | "block.minecraft.spruce_log" | "item.minecraft.ink_sac" | "subtitles.entity.salmon.death" | "commands.perf.reportSaved" | "item.minecraft.gold_ingot" | "advancements.empty" | "stat.minecraft.tune_noteblock" | "block.minecraft.acacia_stairs" | "fml.loadingerrorscreen.warningheader" | "subtitles.entity.wither_skeleton.death" | "block.minecraft.respawn_anchor" | "item.minecraft.piglin_brute_spawn_egg" | "commands.title.cleared.single" | "advancements.nether.ride_strider.title" | "commands.forceload.list.single" | "block.minecraft.brain_coral" | "commands.config.noconfig" | "block.minecraft.dark_oak_sign" | "block.minecraft.jack_o_lantern" | "block.minecraft.lime_wool" | "block.minecraft.banner.square_bottom_right.magenta" | "item.minecraft.shield.light_gray" | "options.graphics.warning.renderer" | "key.keyboard.end" | "item.minecraft.wooden_shovel" | "argument.nbt.array.invalid" | "block.minecraft.banner.half_horizontal.magenta" | "item.minecraft.cooked_mutton" | "block.minecraft.deepslate_brick_wall" | "item.minecraft.green_dye" | "block.minecraft.banner.border.blue" | "block.minecraft.crimson_planks" | "block.minecraft.sandstone_wall" | "item.minecraft.potion.effect.strength" | "subtitles.entity.parrot.imitate.shulker" | "block.minecraft.carved_pumpkin" | "commands.datapack.modify.enable" | "selectWorld.world" | "item.minecraft.shield.white" | "block.minecraft.banner.stripe_downright.red" | "block.minecraft.potted_acacia_sapling" | "block.minecraft.banner.square_bottom_left.brown" | "block.minecraft.banner.rhombus.magenta" | "block.minecraft.banner.stripe_middle.pink" | "commands.stopsound.success.sourceless.any" | "createWorld.customize.custom.count" | "block.minecraft.weathered_cut_copper_stairs" | "block.minecraft.nether_brick_stairs" | "subtitles.entity.parrot.imitate.endermite" | "argument.entity.selector.unknown" | "advancements.story.obtain_armor.description" | "commands.experience.set.points.invalid" | "entity.minecraft.pig" | "commands.advancement.criterionNotFound" | "mco.configure.worlds.title" | "block.minecraft.banner.stripe_center.lime" | "dataPack.validation.reset" | "block.minecraft.dead_bubble_coral_fan" | "commands.stopsound.success.source.any" | "selectWorld.edit.backupFolder" | "subtitles.item.trident.throw" | "block.minecraft.banner.stripe_bottom.lime" | "block.minecraft.banner.square_top_right.brown" | "death.attack.fireworks.player" | "commands.teleport.success.entity.multiple" | "entity.minecraft.falling_block" | "subtitles.entity.parrot.imitate.pillager" | "item.minecraft.debug_stick.empty" | "subtitles.entity.donkey.chest" | "block.minecraft.beacon.secondary" | "entity.minecraft.villager" | "advancements.husbandry.wax_off.title" | "block.minecraft.water_cauldron" | "item.minecraft.firework_star.shape.burst" | "item.minecraft.splash_potion.effect.strength" | "itemGroup.brewing" | "block.minecraft.banner.flower.pink" | "effect.minecraft.night_vision" | "item.minecraft.axolotl_spawn_egg" | "subtitles.entity.fox.death" | "subtitles.block.composter.ready" | "item.minecraft.purple_dye" | "container.enderchest" | "biome.minecraft.birch_forest" | "block.minecraft.banner.gradient.white" | "chat.type.text" | "biome.minecraft.sunflower_plains" | "menu.returnToGame" | "commands.attribute.base_value.get.success" | "item.minecraft.compass" | "subtitles.block.grindstone.use" | "subtitles.entity.zombie_villager.converted" | "mco.reset.world.upload" | "biome.minecraft.forest" | "key.keyboard.home" | "forge.configgui.zombieBaseSummonChance.tooltip" | "connect.encrypting" | "options.invertMouse" | "commands.scoreboard.objectives.modify.displayname" | "block.minecraft.water" | "block.minecraft.redstone_block" | "item.minecraft.melon_slice" | "subtitles.entity.boat.paddle_water" | "selectWorld.deleteWarning" | "commands.forge.gen.progress" | "block.minecraft.green_carpet" | "team.collision.always" | "subtitles.entity.guardian.ambient_land" | "block.minecraft.zombie_wall_head" | "stat.minecraft.fill_cauldron" | "block.minecraft.polished_deepslate_stairs" | "tutorial.look.description" | "container.shulkerBox.more" | "mco.configure.world.delete.button" | "debug.profiling.help" | "item.minecraft.paper" | "gamerule.sendCommandFeedback" | "block.minecraft.banner.triangle_top.purple" | "item.minecraft.lingering_potion.effect.slowness" | "entity.minecraft.villager.cartographer" | "multiplayer.disconnect.invalid_player_movement" | "block.minecraft.smooth_stone" | "block.minecraft.banner.stripe_bottom.magenta" | "advancements.end.respawn_dragon.description" | "argument.entity.options.name.description" | "subtitles.block.smithing_table.use" | "subtitles.entity.vindicator.celebrate" | "command.unknown.command" | "block.minecraft.banner.stripe_bottom.blue" | "advMode.previousOutput" | "stat.minecraft.enchant_item" | "key.keyboard.unknown" | "block.minecraft.dark_oak_leaves" | "item.minecraft.rabbit_spawn_egg" | "subtitles.entity.llama.death" | "item.minecraft.globe_banner_pattern.desc" | "block.minecraft.green_stained_glass" | "mirror.front_back" | "block.minecraft.command_block" | "language.region" | "narration.cycle_button.usage.focused" | "block.minecraft.banner.stripe_center.blue" | "subtitles.entity.wandering_trader.ambient" | "block.minecraft.banner.straight_cross.lime" | "stat.minecraft.play_record" | "advancements.nether.obtain_crying_obsidian.title" | "mco.minigame.world.slot.screen.title" | "disconnect.overflow" | "effect.minecraft.poison" | "block.minecraft.crimson_stem" | "block.minecraft.bed.no_sleep" | "selectWorld.search" | "block.minecraft.banner.bricks.brown" | "realms.missing.module.error.text" | "fml.messages.artifactversion.ornotinstalled" | "item.minecraft.netherite_shovel" | "commands.drop.success.multiple_with_table" | "commands.worldborder.set.failed.small" | "item.minecraft.firework_star.lime" | "stat.minecraft.swim_one_cm" | "subtitles.block.enchantment_table.use" | "narrator.toast.enabled" | "subtitles.entity.glow_item_frame.add_item" | "block.minecraft.raw_iron_block" | "item.minecraft.piglin_spawn_egg" | "enchantment.minecraft.multishot" | "options.modelPart.jacket" | "argument.block.id.invalid" | "block.minecraft.crafting_table" | "block.minecraft.red_glazed_terracotta" | "block.minecraft.banner.globe.pink" | "gamerule.reducedDebugInfo" | "key.keyboard.menu" | "block.minecraft.banner.diagonal_up_left.white" | "selectWorld.tooltip.snapshot1" | "selectWorld.tooltip.snapshot2" | "advMode.notAllowed" | "block.minecraft.coal_ore" | "options.graphics.warning.message" | "argument.pos.outofworld" | "block.minecraft.end_stone_brick_slab" | "item.minecraft.iron_chestplate" | "key.keyboard.escape" | "forge.selectWorld.backupWarning.experimental.additional" | "commands.team.option.seeFriendlyInvisibles.disabled" | "options.renderClouds" | "subtitles.entity.panda.cant_breed" | "stat.minecraft.damage_resisted" | "item.minecraft.chainmail_boots" | "subtitles.entity.drowned.step" | "createWorld.customize.custom.heightScale" | "commands.experience.set.points.success.multiple" | "structure_block.invalid_structure_name" | "block.minecraft.exposed_cut_copper_stairs" | "mco.brokenworld.nonowner.error" | "entity.minecraft.tropical_fish.type.glitter" | "block.minecraft.blue_glazed_terracotta" | "item.minecraft.vindicator_spawn_egg" | "death.attack.lightningBolt" | "mco.configure.world.edit.slot.name" | "block.minecraft.blast_furnace" | "subtitles.item.totem.use" | "block.minecraft.black_candle_cake" | "commands.forge.tps.summary.basic" | "block.minecraft.attached_melon_stem" | "block.minecraft.banner.stripe_downright.pink" | "block.minecraft.banner.mojang.white" | "block.minecraft.banner.straight_cross.blue" | "block.minecraft.cyan_stained_glass_pane" | "multiplayer.texturePrompt.line1" | "subtitles.entity.generic.small_fall" | "multiplayer.texturePrompt.line2" | "mco.errorMessage.serviceBusy" | "addServer.hideAddress" | "command.failed" | "block.minecraft.banner.cross.yellow" | "block.minecraft.banner.triangle_bottom.gray" | "biome.minecraft.windswept_savanna" | "block.minecraft.lime_bed" | "block.minecraft.banner.stripe_center.light_gray" | "subtitles.entity.puffer_fish.sting" | "block.minecraft.banner.diagonal_left.brown" | "mco.configure.world.pvp" | "createWorld.customize.custom.maxHeight" | "block.minecraft.spruce_fence_gate" | "block.minecraft.banner.diagonal_up_right.red" | "item.minecraft.splash_potion.effect.leaping" | "subtitles.entity.polar_bear.death" | "advancements.husbandry.kill_axolotl_target.title" | "mco.minigame.world.restore" | "createWorld.customize.preset.classic_flat" | "entity.minecraft.elder_guardian" | "advancements.husbandry.axolotl_in_a_bucket.title" | "advancements.nether.loot_bastion.description" | "advancements.story.shiny_gear.title" | "structure_block.load_success" | "structure_block.size.z" | "structure_block.size.x" | "structure_block.size.y" | "item.minecraft.horse_spawn_egg" | "advancements.husbandry.tame_an_animal.description" | "item.minecraft.zombie_spawn_egg" | "entity.minecraft.glow_item_frame" | "stat.minecraft.interact_with_brewingstand" | "block.minecraft.banner.rhombus.light_gray" | "commands.forge.gen.dim_fail" | "biome.minecraft.end_highlands" | "gamerule.doMobLoot.description" | "mco.reset.world.title" | "multiplayer.player.joined" | "subtitles.entity.mule.ambient" | "key.keyboard.scroll.lock" | "block.minecraft.banner.half_horizontal.red" | "subtitles.entity.parrot.imitate.zombie" | "entity.minecraft.wandering_trader" | "options.controls" | "argument.entity.options.mode.invalid" | "entity.minecraft.tropical_fish.type.flopper" | "effect.minecraft.wither" | "stat.minecraft.clean_armor" | "block.minecraft.banner.diagonal_left.pink" | "subtitles.entity.donkey.eat" | "subtitles.entity.parrot.imitate.ender_dragon" | "block.minecraft.jungle_pressure_plate" | "block.minecraft.banner.triangle_top.black" | "effect.minecraft.blindness" | "advancements.adventure.kill_all_mobs.description" | "commands.team.option.color.success" | "effect.minecraft.fire_resistance" | "block.minecraft.pink_shulker_box" | "block.minecraft.ominous_banner" | "subtitles.entity.strider.death" | "block.minecraft.white_concrete_powder" | "block.minecraft.banner.cross.pink" | "block.minecraft.waxed_exposed_cut_copper" | "narration.edit_box" | "item.minecraft.bat_spawn_egg" | "commands.datapack.modify.disable" | "block.minecraft.crimson_slab" | "fml.button.open.mods.folder" | "fml.modloading.failedtoloadforge" | "item.minecraft.trident" | "block.minecraft.acacia_sapling" | "block.minecraft.dragon_head" | "subtitles.block.beehive.work" | "commands.message.display.incoming" | "commands.bossbar.get.value" | "commands.tag.list.multiple.success" | "selectWorld.recreate" | "block.minecraft.banner.diagonal_up_left.black" | "item.minecraft.stone_pickaxe" | "fml.menu.multiplayer.vanilla" | "subtitles.entity.fox.screech" | "block.minecraft.banner.stripe_right.lime" | "options.biomeBlendRadius.9" | "block.minecraft.spruce_leaves" | "options.biomeBlendRadius.7" | "options.biomeBlendRadius.5" | "options.biomeBlendRadius.3" | "commands.advancement.grant.one.to.one.failure" | "options.biomeBlendRadius.1" | "multiplayer.player.joined.renamed" | "selectWorld.import_worldgen_settings.deprecated.question" | "effect.minecraft.slowness" | "fml.messages.version.restriction.bounded.inclusive" | "block.minecraft.potted_red_mushroom" | "death.attack.drown.player" | "block.minecraft.banner.border.yellow" | "death.attack.sweetBerryBush" | "mco.invites.pending" | "block.minecraft.banner.stripe_downright.black" | "block.minecraft.banner.stripe_downright.white" | "mco.minigame.world.switch.new" | "block.minecraft.banner.gradient.green" | "commands.team.option.deathMessageVisibility.unchanged" | "gamerule.commandBlockOutput" | "forge.configgui.disableVersionCheck.tooltip" | "selectServer.defaultName" | "item.minecraft.splash_potion.effect.regeneration" | "block.minecraft.banner.square_top_left.yellow" | "block.minecraft.banner.diagonal_up_right.light_gray" | "block.minecraft.banner.mojang.black" | "advancements.husbandry.tame_an_animal.title" | "subtitles.entity.llama.hurt" | "block.minecraft.banner.rhombus.gray" | "options.prioritizeChunkUpdates.byPlayer" | "item.minecraft.nether_wart" | "block.minecraft.purple_candle" | "advancements.end.root.title" | "block.minecraft.banner.triangle_top.light_blue" | "subtitles.entity.fishing_bobber.throw" | "narrator.screen.usage" | "block.minecraft.banner.stripe_middle.black" | "options.biomeBlendRadius" | "commands.give.failed.toomanyitems" | "fml.menu.mods.info.authors" | "subtitles.entity.shulker.death" | "options.graphics.fabulous.tooltip" | "argument.entity.options.distance.description" | "subtitles.entity.parrot.imitate.ravager" | "subtitles.entity.fox.sleep" | "narrator.button.accessibility" | "options.guiScale" | "block.minecraft.powder_snow" | "block.minecraft.banner.half_vertical_right.lime" | "compliance.playtime.greaterThan24Hours" | "entity.minecraft.snowball" | "menu.savingLevel" | "block.minecraft.banner.border.light_blue" | "biome.minecraft.deep_cold_ocean" | "block.minecraft.banner.stripe_top.orange" | "options.accessibility.text_background_opacity" | "spectatorMenu.team_teleport" | "block.minecraft.orange_bed" | "createWorld.customize.custom.dungeonChance" | "block.minecraft.jungle_stairs" | "enchantment.minecraft.smite" | "entity.minecraft.hopper_minecart" | "block.minecraft.iron_block" | "entity.minecraft.pillager" | "advancements.adventure.root.description" | "block.minecraft.bed.obstructed" | "block.minecraft.banner.cross.brown" | "subtitles.entity.polar_bear.hurt" | "advancements.adventure.bullseye.title" | "key.categories.misc" | "block.minecraft.pink_candle_cake" | "subtitles.entity.drowned.ambient" | "tutorial.open_inventory.title" | "subtitles.block.trapdoor.toggle" | "mco.configure.world.slot.switch.question.line2" | "block.minecraft.purple_concrete" | "subtitles.entity.item_frame.rotate_item" | "mco.configure.world.slot.switch.question.line1" | "item.minecraft.shield.pink" | "block.minecraft.banner.stripe_right.blue" | "subtitles.block.furnace.fire_crackle" | "stat.minecraft.interact_with_furnace" | "disconnect.exceeded_packet_rate" | "advancements.adventure.spyglass_at_ghast.description" | "advancements.adventure.sniper_duel.description" | "subtitles.entity.rabbit.jump" | "advancement.advancementNotFound" | "biome.minecraft.mushroom_fields" | "block.minecraft.red_carpet" | "commands.forge.tags.error.unknown_tag" | "key.keyboard.f8" | "key.keyboard.f9" | "key.keyboard.f6" | "key.keyboard.f7" | "subtitles.entity.wandering_trader.disappeared" | "debug.inspect.help" | "key.keyboard.f1" | "mco.template.button.trailer" | "block.minecraft.light_blue_banner" | "options.fovEffectScale.tooltip" | "key.keyboard.f4" | "multiplayer.disconnect.invalid_vehicle_movement" | "key.keyboard.f5" | "key.keyboard.f2" | "parsing.bool.expected" | "key.keyboard.f3" | "mco.template.select.none.linkTitle" | "block.minecraft.banner.curly_border.light_blue" | "advancements.story.smelt_iron.description" | "chat_screen.message" | "block.minecraft.banner.square_bottom_left.lime" | "subtitles.block.redstone_torch.burnout" | "createWorld.customize.presets" | "entity.minecraft.villager.nitwit" | "command.expected.separator" | "block.minecraft.cauldron" | "block.minecraft.oak_fence_gate" | "container.upgrade" | "subtitles.entity.horse.gallop" | "gamerule.category.misc" | "multiplayer.status.finished" | "subtitles.entity.parrot.imitate.magma_cube" | "block.minecraft.nether_brick_fence" | "block.minecraft.banner.creeper.gray" | "commands.forceload.list.multiple" | "subtitles.item.book.page_turn" | "block.minecraft.cyan_bed" | "subtitles.item.bone_meal.use" | "block.minecraft.banner.globe.orange" | "block.minecraft.banner.skull.lime" | "item.minecraft.golden_chestplate" | "soundCategory.player" | "stat_type.minecraft.mined" | "item.minecraft.rabbit_foot" | "argument.entity.options.dx.description" | "item_modifier.unknown" | "entity.minecraft.villager.cleric" | "gamerule.doPatrolSpawning" | "block.minecraft.banner.globe.light_blue" | "gui.socialInteractions.status_hidden_offline" | "jigsaw_block.target" | "block.minecraft.banner.stripe_middle.light_blue" | "item.minecraft.splash_potion.effect.night_vision" | "block.minecraft.wither_skeleton_wall_skull" | "block.minecraft.banner.stripe_downright.green" | "subtitles.entity.horse.hurt" | "item.minecraft.cooked_beef" | "stat.minecraft.interact_with_grindstone" | "biome.minecraft.old_growth_birch_forest" | "block.minecraft.player_wall_head" | "block.minecraft.banner.half_vertical_right.blue" | "optimizeWorld.info.converted" | "item.minecraft.magma_cube_spawn_egg" | "advancements.husbandry.kill_axolotl_target.description" | "commands.locate.success" | "block.minecraft.brown_glazed_terracotta" | "selectWorld.import_worldgen_settings.experimental.title" | "options.modelPart.left_pants_leg" | "mco.reset.world.template" | "effect.minecraft.resistance" | "commands.advancement.revoke.one.to.one.failure" | "arguments.function.unknown" | "generic.attack_range" | "container.repair.expensive" | "optimizeWorld.stage.counting" | "subtitles.entity.zombie_villager.hurt" | "block.minecraft.cave_vines" | "container.enchant" | "commands.bossbar.set.visible.success.hidden" | "mco.minigame.world.title" | "container.inventory" | "stat.minecraft.interact_with_smoker" | "createWorld.customize.flat.title" | "block.minecraft.magenta_stained_glass" | "item.minecraft.lingering_potion.effect.awkward" | "block.minecraft.weathered_cut_copper" | "mco.account.privacyinfo" | "block.minecraft.waxed_weathered_copper" | "options.pixel_value" | "argument.player.unknown" | "mco.minigame.world.selected" | "item.minecraft.splash_potion.effect.water_breathing" | "mco.create.world.error" | "gui.socialInteractions.tab_all" | "block.minecraft.banner.half_horizontal_bottom.purple" | "death.attack.freeze" | "block.minecraft.fletching_table" | "block.minecraft.banner.stripe_bottom.purple" | "argument.integer.low" | "resourcePack.broken_assets" | "block.minecraft.banner.stripe_downleft.gray" | "subtitles.entity.pig.hurt" | "argument.range.swapped" | "item.minecraft.leather_chestplate" | "commands.setblock.success" | "block.minecraft.banner.square_bottom_left.blue" | "item.minecraft.potion.effect.awkward" | "block.minecraft.banner.stripe_top.light_gray" | "item.minecraft.chicken_spawn_egg" | "item.minecraft.porkchop" | "block.minecraft.white_banner" | "entity.minecraft.rabbit" | "block.minecraft.large_fern" | "options.reducedDebugInfo" | "arguments.objective.notFound" | "block.minecraft.banner.diagonal_up_left.green" | "multiplayer.status.unrequested" | "attribute.modifier.take.1" | "attribute.modifier.take.0" | "block.minecraft.banner.triangles_top.brown" | "fml.messages.artifactversion.none" | "item.minecraft.flower_banner_pattern.desc" | "block.minecraft.granite_slab" | "argument.entity.options.x.description" | "advancements.story.iron_tools.title" | "subtitles.entity.skeleton.shoot" | "chat.coordinates.tooltip" | "menu.generatingLevel" | "argument.pos2d.incomplete" | "block.minecraft.dirt_path" | "block.minecraft.banner.square_bottom_left.purple" | "subtitles.entity.generic.hurt" | "entity.minecraft.villager.none" | "subtitles.entity.villager.work_cleric" | "commands.scoreboard.players.enable.success.single" | "block.minecraft.banner.triangles_bottom.red" | "item.minecraft.beef" | "block.minecraft.fern" | "attribute.modifier.take.2" | "advancements.husbandry.silk_touch_nest.title" | "block.minecraft.coarse_dirt" | "item.minecraft.rotten_flesh" | "stat.minecraft.sleep_in_bed" | "item.minecraft.crossbow" | "selectServer.select" | "death.attack.player.item" | "block.minecraft.banner.stripe_top.cyan" | "subtitles.entity.wither_skeleton.hurt" | "commands.execute.conditional.fail" | "item.minecraft.brewing_stand" | "block.minecraft.banner.border.cyan" | "subtitles.entity.fox.ambient" | "subtitles.entity.generic.drink" | "inventory.binSlot" | "mco.configure.world.spawnProtection" | "item.minecraft.potion" | "commands.advancement.revoke.many.to.one.success" | "gui.recipebook.moreRecipes" | "gamerule.category.player" | "item.minecraft.globe_banner_pattern" | "item.minecraft.splash_potion.effect.levitation" | "block.minecraft.blue_wool" | "block.minecraft.fire_coral" | "commands.advancement.revoke.many.to.one.failure" | "chat.link.warning" | "advancements.husbandry.ride_a_boat_with_a_goat.description" | "item.minecraft.music_disc_chirp" | "entity.minecraft.wolf"
    type RawTexture = "minecraft:textures/gui/title/background/panorama_0.png" | "minecraft:textures/gui/container/creative_inventory/tab_inventory.png" | "minecraft:textures/gui/container/creative_inventory/tab_item_search.png" | "minecraft:textures/gui/title/background/panorama_1.png" | "minecraft:textures/gui/options_background.png" | "minecraft:textures/atlas/mob_effects.png" | "minecraft:textures/gui/title/edition.png" | "minecraft:textures/atlas/paintings.png" | "minecraft:textures/gui/icons.png" | "minecraft:skins/32578afc3244822ef135d2c6a55fb1974fa24502" | "minecraft:textures/atlas/beds.png" | "minecraft:default/0" | "minecraft:textures/gui/toasts.png" | "minecraft:textures/entity/cow/cow.png" | "minecraft:worlds/new_world/937644a5a0f46ca6f4274075d3824d415449db8c/icon" | "minecraft:textures/entity/horse/horse_markings_whitefield.png" | "minecraft:textures/atlas/chest.png" | "minecraft:textures/misc/enchanted_item_glint.png" | "minecraft:uniform/0" | "minecraft:textures/entity/alex.png" | "minecraft:textures/gui/widgets.png" | "minecraft:dynamic/light_map_1" | "minecraft:textures/gui/accessibility.png" | "minecraft:textures/atlas/shield_patterns.png" | "minecraft:textures/gui/world_selection.png" | "minecraft:textures/gui/title/mojangstudios.png" | "minecraft:textures/gui/title/background/panorama_5.png" | "minecraft:textures/atlas/blocks.png" | "minecraft:textures/entity/slime/slime.png" | "minecraft:textures/atlas/shulker_boxes.png" | "minecraft:missing/0" | "minecraft:textures/environment/clouds.png" | "minecraft:textures/gui/title/background/panorama_overlay.png" | "minecraft:illageralt/0" | "minecraft:textures/environment/sun.png" | "minecraft:textures/environment/moon_phases.png" | "minecraft:textures/atlas/banner_patterns.png" | "minecraft:textures/entity/horse/horse_gray.png" | "minecraft:textures/gui/container/creative_inventory/tab_items.png" | "minecraft:textures/gui/title/background/panorama_4.png" | "minecraft:textures/misc/shadow.png" | "minecraft:alt/0" | "minecraft:textures/gui/title/background/panorama_3.png" | "minecraft:textures/misc/unknown_server.png" | "minecraft:textures/gui/container/creative_inventory/tabs.png" | "minecraft:textures/atlas/particles.png" | "minecraft:missingno" | "minecraft:textures/misc/vignette.png" | "minecraft:textures/atlas/signs.png" | "minecraft:textures/gui/title/background/panorama_2.png" | "minecraft:textures/gui/title/minecraft.png";
    type Texture = "minecraft:block/oak_door_top" | "minecraft:block/tnt_bottom" | "minecraft:item/filled_map_markings" | "minecraft:block/dandelion" | "minecraft:block/redstone_torch" | "minecraft:block/smithing_table_side" | "minecraft:block/lime_stained_glass_pane_top" | "minecraft:block/dropper_front" | "minecraft:item/nether_wart" | "minecraft:block/cut_red_sandstone" | "minecraft:block/melon_side" | "minecraft:item/wooden_hoe" | "minecraft:block/large_amethyst_bud" | "minecraft:block/twisting_vines_plant" | "minecraft:block/repeating_command_block_side" | "minecraft:block/redstone_dust_line1" | "minecraft:block/quartz_block_top" | "minecraft:block/hopper_top" | "minecraft:block/redstone_dust_line0" | "minecraft:item/fishing_rod_cast" | "minecraft:block/nether_wart_stage2" | "minecraft:block/nether_wart_stage1" | "minecraft:item/furnace_minecart" | "minecraft:block/nether_wart_stage0" | "minecraft:item/elytra" | "minecraft:block/small_dripleaf_top" | "minecraft:block/crafting_table_side" | "minecraft:block/blue_stained_glass_pane_top" | "minecraft:block/bricks" | "minecraft:block/peony_bottom" | "minecraft:block/brewing_stand" | "minecraft:block/stonecutter_side" | "minecraft:item/diamond_hoe" | "minecraft:block/carved_pumpkin" | "minecraft:item/minecart" | "minecraft:block/jungle_door_bottom" | "minecraft:block/jungle_planks" | "minecraft:block/dark_oak_log_top" | "minecraft:item/apple" | "minecraft:block/cactus_top" | "minecraft:block/dark_oak_log" | "minecraft:item/diamond_chestplate" | "minecraft:block/cactus_side" | "minecraft:block/pink_stained_glass_pane_top" | "minecraft:block/orange_shulker_box" | "minecraft:block/kelp_plant" | "minecraft:item/black_candle" | "minecraft:block/sweet_berry_bush_stage3" | "minecraft:block/lever" | "minecraft:block/sweet_berry_bush_stage2" | "minecraft:item/oak_sign" | "minecraft:block/lime_wool" | "minecraft:block/spruce_log_top" | "minecraft:block/sweet_berry_bush_stage1" | "minecraft:block/sweet_berry_bush_stage0" | "minecraft:item/mojang_banner_pattern" | "minecraft:item/spawn_egg" | "minecraft:block/cake_bottom" | "minecraft:item/acacia_boat" | "minecraft:item/iron_horse_armor" | "minecraft:block/enchanting_table_side" | "minecraft:block/sugar_cane" | "minecraft:block/small_dripleaf_stem_bottom" | "minecraft:item/golden_horse_armor" | "minecraft:block/magenta_stained_glass_pane_top" | "minecraft:block/cake_inner" | "minecraft:block/jigsaw_bottom" | "minecraft:block/oak_planks" | "minecraft:block/torch" | "minecraft:block/jungle_trapdoor" | "minecraft:block/activator_rail_on" | "minecraft:block/light_blue_concrete" | "minecraft:block/iron_bars" | "minecraft:item/bell" | "minecraft:block/light_gray_stained_glass" | "minecraft:block/pink_concrete" | "minecraft:block/farmland_moist" | "minecraft:item/golden_helmet" | "minecraft:item/orange_dye" | "minecraft:item/light_gray_dye" | "minecraft:block/beetroots_stage3" | "minecraft:item/diamond_sword" | "minecraft:block/beetroots_stage1" | "minecraft:block/beetroots_stage2" | "minecraft:block/beetroots_stage0" | "minecraft:block/smoker_front_on" | "minecraft:block/warped_door_top" | "minecraft:block/crimson_trapdoor" | "minecraft:block/repeater" | "minecraft:block/brown_stained_glass" | "minecraft:block/dead_fire_coral_block" | "minecraft:block/pink_stained_glass" | "minecraft:item/egg" | "minecraft:item/rabbit_stew" | "minecraft:block/terracotta" | "minecraft:item/glass_bottle" | "minecraft:item/crossbow_arrow" | "minecraft:block/chain_command_block_front" | "minecraft:block/fire_coral_fan" | "minecraft:block/furnace_top" | "minecraft:item/diamond" | "minecraft:block/crying_obsidian" | "minecraft:block/iron_block" | "minecraft:block/chain_command_block_conditional" | "minecraft:block/coal_ore" | "minecraft:block/stripped_dark_oak_log" | "minecraft:block/dead_brain_coral_fan" | "minecraft:item/leather_helmet_overlay" | "minecraft:block/polished_deepslate" | "minecraft:item/fermented_spider_eye" | "minecraft:block/dark_oak_door_top" | "minecraft:block/tall_grass_bottom" | "minecraft:block/lime_shulker_box" | "minecraft:block/daylight_detector_top" | "minecraft:block/cave_vines_plant_lit" | "minecraft:block/pointed_dripstone_down_tip" | "minecraft:block/white_shulker_box" | "minecraft:block/rose_bush_top" | "minecraft:block/birch_door_top" | "minecraft:block/prismarine_bricks" | "minecraft:item/chainmail_leggings" | "minecraft:block/magenta_stained_glass" | "minecraft:block/bee_nest_front" | "minecraft:item/barrier" | "minecraft:block/smoker_bottom" | "minecraft:block/loom_front" | "minecraft:item/birch_door" | "minecraft:block/grass_block_side" | "minecraft:item/lava_bucket" | "minecraft:block/gilded_blackstone" | "minecraft:block/repeater_on" | "minecraft:item/ghast_tear" | "minecraft:block/large_fern_top" | "minecraft:block/campfire_fire" | "minecraft:block/dead_brain_coral_block" | "minecraft:block/sandstone_top" | "minecraft:block/big_dripleaf_stem" | "minecraft:block/dead_tube_coral_fan" | "minecraft:block/stripped_crimson_stem" | "minecraft:block/chipped_anvil_top" | "minecraft:block/tnt_side" | "minecraft:block/orange_stained_glass" | "minecraft:block/brown_mushroom_block" | "minecraft:block/stripped_oak_log" | "minecraft:block/spruce_door_bottom" | "minecraft:block/end_rod" | "minecraft:block/cyan_terracotta" | "minecraft:item/filled_map" | "minecraft:block/bamboo_small_leaves" | "minecraft:item/carrot_on_a_stick" | "minecraft:item/netherite_pickaxe" | "minecraft:item/poisonous_potato" | "minecraft:block/deepslate_coal_ore" | "minecraft:block/magenta_candle_lit" | "minecraft:block/light_gray_concrete_powder" | "minecraft:block/stripped_birch_log_top" | "minecraft:block/gray_shulker_box" | "minecraft:item/bundle_filled" | "minecraft:item/stone_hoe" | "minecraft:block/yellow_concrete" | "minecraft:block/dragon_egg" | "minecraft:block/cyan_concrete_powder" | "minecraft:item/coal" | "minecraft:block/brown_concrete" | "minecraft:block/cyan_stained_glass" | "minecraft:block/gold_block" | "minecraft:item/armor_stand" | "minecraft:block/crimson_roots_pot" | "minecraft:block/lilac_bottom" | "minecraft:item/netherite_helmet" | "minecraft:block/hanging_roots" | "minecraft:block/lime_candle_lit" | "minecraft:item/redstone" | "minecraft:block/medium_amethyst_bud" | "minecraft:item/netherite_boots" | "minecraft:block/enchanting_table_bottom" | "minecraft:block/light_blue_candle_lit" | "minecraft:block/dark_prismarine" | "minecraft:block/structure_block_save" | "minecraft:block/glow_lichen" | "minecraft:block/loom_side" | "minecraft:block/tall_grass_top" | "minecraft:item/rabbit" | "minecraft:block/allium" | "minecraft:block/green_stained_glass" | "minecraft:block/potatoes_stage0" | "minecraft:item/dark_oak_sign" | "minecraft:block/potatoes_stage2" | "minecraft:item/sugar" | "minecraft:block/potatoes_stage1" | "forge:block/milk_flowing" | "minecraft:block/fern" | "minecraft:item/bamboo" | "minecraft:block/chain_command_block_side" | "minecraft:block/note_block" | "minecraft:block/magma" | "minecraft:item/empty_armor_slot_chestplate" | "minecraft:block/lantern" | "minecraft:item/blue_dye" | "minecraft:block/spruce_trapdoor" | "minecraft:block/oxidized_copper" | "minecraft:item/end_crystal" | "minecraft:item/cooked_salmon" | "minecraft:block/potted_azalea_bush_top" | "minecraft:block/potatoes_stage3" | "minecraft:block/blackstone" | "minecraft:block/deepslate_iron_ore" | "minecraft:block/spruce_door_top" | "minecraft:item/scute" | "minecraft:block/item_frame" | "minecraft:block/purple_stained_glass" | "minecraft:item/purple_dye" | "minecraft:block/coarse_dirt" | "minecraft:block/red_terracotta" | "minecraft:item/spawn_egg_overlay" | "minecraft:block/green_candle" | "minecraft:block/turtle_egg_slightly_cracked" | "minecraft:block/chorus_flower" | "minecraft:block/smoker_side" | "minecraft:block/seagrass" | "minecraft:block/barrel_top_open" | "minecraft:item/cooked_chicken" | "minecraft:item/charcoal" | "minecraft:item/diamond_axe" | "minecraft:block/tuff" | "minecraft:block/dripstone_block" | "minecraft:block/horn_coral" | "minecraft:block/grindstone_side" | "minecraft:item/raw_iron" | "minecraft:item/pufferfish" | "minecraft:item/bone_meal" | "minecraft:item/warped_fungus_on_a_stick" | "minecraft:item/porkchop" | "minecraft:block/smooth_basalt" | "minecraft:block/flowering_azalea_leaves" | "minecraft:block/melon_stem" | "minecraft:block/blue_terracotta" | "minecraft:item/spruce_door" | "minecraft:item/cyan_dye" | "minecraft:block/soul_sand" | "minecraft:item/pufferfish_bucket" | "minecraft:item/music_disc_pigstep" | "minecraft:block/melon_top" | "minecraft:item/potion_overlay" | "minecraft:item/firework_star_overlay" | "minecraft:item/stone_axe" | "minecraft:block/blast_furnace_side" | "minecraft:block/jungle_log" | "minecraft:block/lodestone_top" | "minecraft:item/stone_pickaxe" | "minecraft:block/bamboo_stage0" | "minecraft:block/deepslate" | "minecraft:block/coal_block" | "minecraft:block/attached_melon_stem" | "minecraft:block/lapis_block" | "minecraft:item/music_disc_13" | "minecraft:block/crimson_planks" | "minecraft:block/cake_side" | "minecraft:item/music_disc_11" | "minecraft:block/pink_candle" | "minecraft:item/splash_potion" | "minecraft:block/cocoa_stage0" | "minecraft:item/prismarine_shard" | "minecraft:block/brown_candle" | "minecraft:block/yellow_stained_glass" | "minecraft:block/cocoa_stage2" | "minecraft:item/lime_dye" | "minecraft:block/cocoa_stage1" | "minecraft:item/glow_item_frame" | "minecraft:block/red_wool" | "minecraft:block/redstone_dust_dot" | "minecraft:block/black_stained_glass_pane_top" | "minecraft:block/blast_furnace_front_on" | "minecraft:block/scaffolding_side" | "minecraft:block/light_blue_wool" | "minecraft:item/music_disc_stal" | "minecraft:item/turtle_egg" | "minecraft:block/farmland" | "minecraft:item/golden_chestplate" | "minecraft:item/emerald" | "minecraft:block/blue_wool" | "minecraft:block/mushroom_block_inside" | "minecraft:block/warped_stem_top" | "minecraft:item/command_block_minecart" | "minecraft:item/globe_banner_pattern" | "minecraft:block/orange_candle" | "minecraft:block/chain_command_block_back" | "minecraft:item/beetroot_soup" | "minecraft:item/music_disc_cat" | "minecraft:block/purple_concrete" | "minecraft:block/spawner" | "minecraft:block/dispenser_front_vertical" | "minecraft:block/glow_item_frame" | "minecraft:block/yellow_candle_lit" | "minecraft:block/quartz_pillar" | "minecraft:item/campfire" | "minecraft:item/iron_shovel" | "minecraft:block/gray_candle" | "minecraft:block/pointed_dripstone_up_frustum" | "minecraft:item/carrot" | "minecraft:block/magenta_candle" | "minecraft:block/tall_seagrass_bottom" | "minecraft:item/broken_elytra" | "minecraft:block/gray_candle_lit" | "minecraft:block/redstone_lamp_on" | "minecraft:block/iron_door_top" | "minecraft:block/ancient_debris_top" | "minecraft:block/cornflower" | "minecraft:item/dried_kelp" | "minecraft:item/golden_pickaxe" | "minecraft:item/chainmail_boots" | "minecraft:block/observer_front" | "minecraft:block/cobblestone" | "minecraft:item/spruce_boat" | "minecraft:block/purpur_block" | "minecraft:item/chicken" | "minecraft:block/purple_candle_lit" | "minecraft:item/cooked_beef" | "minecraft:block/orange_terracotta" | "minecraft:block/powder_snow" | "minecraft:block/ancient_debris_side" | "minecraft:block/crafting_table_front" | "minecraft:block/green_glazed_terracotta" | "minecraft:block/wheat_stage0" | "minecraft:item/ender_eye" | "minecraft:block/brain_coral_fan" | "minecraft:block/cartography_table_side2" | "minecraft:block/cartography_table_side3" | "minecraft:block/respawn_anchor_bottom" | "minecraft:block/anvil" | "minecraft:block/cartography_table_side1" | "minecraft:block/composter_top" | "minecraft:block/furnace_front_on" | "minecraft:item/flint" | "minecraft:item/bone" | "minecraft:block/red_sandstone_top" | "minecraft:block/candle" | "minecraft:block/twisting_vines" | "minecraft:item/map" | "minecraft:item/trident" | "minecraft:item/glow_ink_sac" | "minecraft:item/piglin_banner_pattern" | "minecraft:item/rabbit_foot" | "minecraft:block/moss_block" | "minecraft:block/barrel_bottom" | "minecraft:item/light_blue_dye" | "minecraft:block/weathered_cut_copper" | "minecraft:block/structure_block_corner" | "minecraft:item/diamond_pickaxe" | "minecraft:block/green_candle_lit" | "minecraft:block/purple_candle" | "minecraft:block/big_dripleaf_side" | "minecraft:item/warped_sign" | "minecraft:block/black_candle_lit" | "minecraft:block/detector_rail_on" | "minecraft:item/totem_of_undying" | "minecraft:block/magenta_glazed_terracotta" | "minecraft:item/flower_pot" | "minecraft:item/iron_door" | "minecraft:block/cut_copper" | "minecraft:block/piston_top" | "minecraft:block/white_stained_glass_pane_top" | "minecraft:block/azalea_plant" | "minecraft:item/book" | "minecraft:block/light_blue_stained_glass" | "minecraft:block/brown_candle_lit" | "minecraft:block/orange_candle_lit" | "minecraft:item/repeater" | "minecraft:block/tall_seagrass_top" | "minecraft:block/chiseled_nether_bricks" | "minecraft:block/warped_stem" | "minecraft:item/chainmail_chestplate" | "minecraft:entity/conduit/base" | "minecraft:block/chiseled_quartz_block_top" | "minecraft:block/crimson_door_top" | "minecraft:item/hopper_minecart" | "minecraft:block/fletching_table_side" | "minecraft:block/gray_wool" | "minecraft:block/stripped_acacia_log_top" | "minecraft:block/composter_bottom" | "minecraft:block/red_candle" | "minecraft:item/music_disc_chirp" | "minecraft:block/frosted_ice_3" | "minecraft:block/honeycomb_block" | "minecraft:block/frosted_ice_0" | "minecraft:block/frosted_ice_2" | "minecraft:block/stripped_warped_stem" | "minecraft:item/iron_pickaxe" | "minecraft:block/frosted_ice_1" | "minecraft:block/tripwire_hook" | "minecraft:block/light_gray_terracotta" | "minecraft:item/music_disc_mall" | "minecraft:block/carrots_stage1" | "minecraft:block/carrots_stage0" | "minecraft:block/green_wool" | "minecraft:block/birch_door_bottom" | "minecraft:block/glowstone" | "minecraft:block/observer_back" | "minecraft:block/dead_bush" | "minecraft:block/fletching_table_front" | "minecraft:item/leather_horse_armor" | "minecraft:block/carrots_stage3" | "minecraft:block/carrots_stage2" | "minecraft:item/golden_boots" | "minecraft:block/jack_o_lantern" | "minecraft:block/command_block_front" | "minecraft:block/brown_terracotta" | "minecraft:block/fire_0" | "minecraft:block/fire_1" | "minecraft:block/copper_ore" | "minecraft:block/prismarine" | "minecraft:block/smoker_front" | "minecraft:block/grindstone_pivot" | "minecraft:block/green_terracotta" | "minecraft:block/slime_block" | "minecraft:item/magenta_candle" | "minecraft:item/wheat" | "minecraft:block/acacia_door_top" | "minecraft:block/azalea_leaves" | "minecraft:item/crossbow_pulling_0" | "minecraft:item/crossbow_pulling_1" | "minecraft:block/pumpkin_stem" | "minecraft:item/crossbow_pulling_2" | "minecraft:item/snowball" | "minecraft:item/light" | "minecraft:block/blue_ice" | "minecraft:block/sunflower_front" | "minecraft:block/chorus_plant" | "minecraft:item/bow" | "minecraft:block/respawn_anchor_top" | "minecraft:item/water_bucket" | "minecraft:block/birch_sapling" | "minecraft:block/weeping_vines_plant" | "minecraft:block/orange_tulip" | "minecraft:block/gray_concrete" | "minecraft:block/structure_block_load" | "minecraft:block/light_gray_glazed_terracotta" | "minecraft:block/cracked_nether_bricks" | "minecraft:block/kelp" | "minecraft:block/tube_coral_fan" | "minecraft:block/nether_quartz_ore" | "minecraft:block/observer_top" | "minecraft:block/pink_glazed_terracotta" | "minecraft:block/spruce_planks" | "minecraft:item/spectral_arrow" | "minecraft:block/pink_concrete_powder" | "minecraft:block/light_blue_concrete_powder" | "minecraft:block/campfire_log" | "minecraft:block/wheat_stage1" | "minecraft:block/wheat_stage2" | "minecraft:block/birch_leaves" | "minecraft:block/wheat_stage3" | "minecraft:block/wheat_stage4" | "minecraft:block/wheat_stage5" | "minecraft:item/birch_sign" | "minecraft:block/wheat_stage6" | "minecraft:block/black_concrete" | "minecraft:block/podzol_side" | "minecraft:block/wheat_stage7" | "minecraft:block/soul_lantern" | "minecraft:block/light_gray_shulker_box" | "minecraft:item/jungle_boat" | "minecraft:block/bookshelf" | "minecraft:block/dead_tube_coral_block" | "minecraft:block/bee_nest_top" | "minecraft:block/exposed_cut_copper" | "minecraft:block/bubble_coral" | "minecraft:item/brown_dye" | "minecraft:block/dead_horn_coral_fan" | "minecraft:block/scaffolding_top" | "minecraft:block/loom_bottom" | "minecraft:block/azure_bluet" | "minecraft:block/cyan_candle" | "minecraft:block/spore_blossom_base" | "minecraft:block/horn_coral_block" | "minecraft:block/red_concrete" | "minecraft:block/green_shulker_box" | "minecraft:item/golden_apple" | "minecraft:block/dropper_front_vertical" | "minecraft:item/chorus_fruit" | "minecraft:block/cyan_wool" | "minecraft:block/repeating_command_block_front" | "minecraft:block/red_mushroom_block" | "minecraft:block/tripwire" | "minecraft:block/blast_furnace_top" | "minecraft:block/acacia_door_bottom" | "minecraft:block/quartz_bricks" | "minecraft:block/granite" | "minecraft:item/arrow" | "minecraft:block/brown_glazed_terracotta" | "minecraft:block/raw_gold_block" | "minecraft:block/white_candle" | "minecraft:item/axolotl_bucket" | "minecraft:item/gray_candle" | "minecraft:block/pointed_dripstone_up_tip" | "minecraft:item/turtle_helmet" | "minecraft:block/barrel_side" | "minecraft:item/gray_dye" | "minecraft:block/turtle_egg_very_cracked" | "minecraft:item/iron_ingot" | "minecraft:block/crafting_table_top" | "minecraft:item/green_candle" | "minecraft:block/deepslate_lapis_ore" | "minecraft:block/jigsaw_top" | "minecraft:item/cooked_porkchop" | "minecraft:item/leather_boots_overlay" | "minecraft:block/cauldron_inner" | "minecraft:block/amethyst_block" | "minecraft:block/respawn_anchor_top_off" | "minecraft:block/warped_planks" | "minecraft:item/blaze_rod" | "minecraft:block/lily_of_the_valley" | "minecraft:block/observer_side" | "minecraft:block/mycelium_top" | "minecraft:block/deepslate_diamond_ore" | "minecraft:block/flower_pot" | "minecraft:block/jungle_sapling" | "minecraft:block/jungle_leaves" | "minecraft:block/diamond_ore" | "minecraft:block/gray_terracotta" | "minecraft:block/stonecutter_bottom" | "minecraft:block/grass" | "minecraft:block/yellow_concrete_powder" | "minecraft:block/loom_top" | "minecraft:block/hopper_outside" | "minecraft:item/bowl" | "minecraft:block/soul_torch" | "minecraft:block/cracked_polished_blackstone_bricks" | "minecraft:block/honey_block_top" | "minecraft:block/iron_door_bottom" | "minecraft:block/red_glazed_terracotta" | "minecraft:item/tropical_fish_bucket" | "minecraft:block/deepslate_redstone_ore" | "minecraft:block/target_side" | "minecraft:item/red_candle" | "minecraft:block/pointed_dripstone_up_base" | "minecraft:item/bow_pulling_1" | "minecraft:item/bow_pulling_0" | "minecraft:item/bow_pulling_2" | "minecraft:block/pink_terracotta" | "minecraft:item/light_gray_candle" | "minecraft:block/deepslate_tiles" | "minecraft:item/rabbit_hide" | "minecraft:block/orange_concrete_powder" | "minecraft:block/cyan_stained_glass_pane_top" | "minecraft:item/melon_seeds" | "minecraft:block/poppy" | "minecraft:block/bee_nest_bottom" | "minecraft:block/magenta_concrete" | "minecraft:block/light_gray_candle" | "minecraft:block/yellow_candle" | "minecraft:block/purple_wool" | "minecraft:block/black_wool" | "minecraft:block/campfire_log_lit" | "minecraft:entity/banner_base" | "minecraft:block/smithing_table_bottom" | "minecraft:item/golden_shovel" | "minecraft:item/nether_sprouts" | "minecraft:block/ladder" | "minecraft:item/golden_leggings" | "minecraft:block/wet_sponge" | "minecraft:block/lime_stained_glass" | "minecraft:block/acacia_sapling" | "minecraft:entity/enchanting_table_book" | "minecraft:block/lightning_rod" | "minecraft:block/sponge" | "minecraft:item/beef" | "minecraft:block/stripped_dark_oak_log_top" | "minecraft:item/bundle" | "minecraft:item/fire_charge" | "minecraft:item/golden_axe" | "minecraft:item/crimson_sign" | "minecraft:block/yellow_stained_glass_pane_top" | "minecraft:block/pointed_dripstone_down_base" | "minecraft:item/diamond_horse_armor" | "minecraft:block/honey_block_side" | "minecraft:item/spyglass_model" | "minecraft:item/lapis_lazuli" | "minecraft:block/white_tulip" | "minecraft:block/sculk_sensor_bottom" | "minecraft:item/magenta_dye" | "minecraft:block/powered_rail_on" | "minecraft:block/crimson_stem" | "minecraft:block/chiseled_quartz_block" | "minecraft:item/kelp" | "minecraft:block/stone" | "minecraft:block/tnt_top" | "minecraft:block/pink_shulker_box" | "minecraft:item/honey_bottle" | "minecraft:block/red_sand" | "minecraft:block/flowering_azalea_top" | "minecraft:block/pumpkin_side" | "minecraft:item/white_candle" | "minecraft:block/jukebox_side" | "minecraft:block/light_gray_concrete" | "minecraft:block/oak_door_bottom" | "minecraft:item/dragon_breath" | "minecraft:block/iron_ore" | "minecraft:block/brown_wool" | "minecraft:block/big_dripleaf_tip" | "minecraft:block/dirt" | "minecraft:block/nether_wart_block" | "minecraft:item/glowstone_dust" | "minecraft:block/deepslate_top" | "minecraft:block/polished_basalt_side" | "minecraft:block/purpur_pillar_top" | "minecraft:block/sandstone" | "minecraft:block/stone_bricks" | "minecraft:block/purple_glazed_terracotta" | "minecraft:block/stripped_jungle_log_top" | "minecraft:item/quartz" | "minecraft:block/purple_stained_glass_pane_top" | "minecraft:block/small_dripleaf_stem_top" | "minecraft:block/spruce_leaves" | "minecraft:block/white_candle_lit" | "minecraft:block/cauldron_bottom" | "minecraft:item/lingering_potion" | "minecraft:block/bee_nest_side" | "minecraft:block/beehive_front" | "minecraft:block/destroy_stage_3" | "minecraft:block/oak_log" | "minecraft:item/music_disc_far" | "minecraft:block/destroy_stage_4" | "minecraft:block/destroy_stage_1" | "minecraft:item/empty_armor_slot_boots" | "minecraft:block/destroy_stage_2" | "minecraft:block/destroy_stage_0" | "minecraft:block/light_blue_stained_glass_pane_top" | "minecraft:item/leather_helmet" | "minecraft:block/chain" | "minecraft:block/destroy_stage_9" | "minecraft:item/creeper_banner_pattern" | "minecraft:block/destroy_stage_7" | "minecraft:block/bamboo_stalk" | "minecraft:block/birch_planks" | "minecraft:block/destroy_stage_8" | "minecraft:block/destroy_stage_5" | "minecraft:block/destroy_stage_6" | "minecraft:block/gold_ore" | "minecraft:item/oak_boat" | "minecraft:block/cave_vines_lit" | "minecraft:block/smithing_table_top" | "minecraft:block/polished_andesite" | "minecraft:block/furnace_side" | "minecraft:block/crimson_roots" | "minecraft:block/gray_stained_glass" | "minecraft:block/command_block_side" | "minecraft:block/polished_blackstone_bricks" | "minecraft:block/command_block_back" | "minecraft:item/mutton" | "minecraft:block/brown_concrete_powder" | "minecraft:block/tinted_glass" | "minecraft:item/jungle_door" | "minecraft:item/popped_chorus_fruit" | "minecraft:block/rose_bush_bottom" | "minecraft:block/dead_bubble_coral_block" | "minecraft:block/magenta_terracotta" | "minecraft:block/sea_lantern" | "minecraft:item/pumpkin_pie" | "minecraft:block/diamond_block" | "minecraft:block/brown_shulker_box" | "minecraft:item/white_dye" | "minecraft:block/big_dripleaf_top" | "minecraft:block/lava_still" | "minecraft:block/lectern_sides" | "minecraft:block/damaged_anvil_top" | "minecraft:block/yellow_wool" | "minecraft:block/attached_pumpkin_stem" | "minecraft:block/green_stained_glass_pane_top" | "minecraft:block/deepslate_bricks" | "minecraft:block/cobweb" | "minecraft:block/blue_candle_lit" | "minecraft:item/leather_leggings" | "minecraft:block/dark_oak_door_bottom" | "minecraft:block/hopper_inside" | "minecraft:item/cod_bucket" | "minecraft:item/magma_cream" | "minecraft:block/daylight_detector_side" | "minecraft:item/chainmail_helmet" | "minecraft:block/black_stained_glass" | "minecraft:item/feather" | "minecraft:item/light_05" | "minecraft:item/light_04" | "minecraft:item/light_07" | "minecraft:item/light_06" | "minecraft:item/ink_sac" | "minecraft:item/light_01" | "minecraft:item/netherite_axe" | "minecraft:item/light_00" | "minecraft:block/acacia_leaves" | "minecraft:item/light_03" | "minecraft:block/green_concrete_powder" | "minecraft:block/light_blue_shulker_box" | "minecraft:item/light_02" | "minecraft:item/stick" | "minecraft:entity/conduit/wind" | "minecraft:block/quartz_pillar_top" | "minecraft:block/rail_corner" | "minecraft:block/blue_shulker_box" | "minecraft:block/beacon" | "minecraft:block/target_top" | "minecraft:item/yellow_dye" | "minecraft:block/cauldron_side" | "minecraft:item/amethyst_shard" | "minecraft:block/piston_bottom" | "minecraft:block/red_shulker_box" | "minecraft:block/composter_side" | "minecraft:block/purple_concrete_powder" | "minecraft:item/honeycomb" | "minecraft:block/polished_granite" | "minecraft:block/end_portal_frame_side" | "minecraft:block/obsidian" | "minecraft:block/soul_campfire_fire" | "minecraft:item/shulker_shell" | "minecraft:block/birch_log_top" | "minecraft:item/golden_hoe" | "minecraft:block/basalt_side" | "minecraft:block/pink_tulip" | "minecraft:block/copper_block" | "minecraft:block/orange_wool" | "minecraft:block/deepslate_emerald_ore" | "minecraft:item/structure_void" | "minecraft:block/grass_block_snow" | "minecraft:item/item_frame" | "minecraft:block/raw_copper_block" | "minecraft:item/warped_door" | "minecraft:block/clay" | "minecraft:block/warped_door_bottom" | "minecraft:item/iron_sword" | "minecraft:block/packed_ice" | "minecraft:block/cobbled_deepslate" | "minecraft:block/enchanting_table_top" | "minecraft:block/sunflower_top" | "minecraft:block/bee_nest_front_honey" | "minecraft:block/horn_coral_fan" | "minecraft:item/ender_pearl" | "minecraft:block/dried_kelp_top" | "minecraft:block/stripped_acacia_log" | "minecraft:block/netherite_block" | "minecraft:item/string" | "minecraft:item/crossbow_standby" | "minecraft:block/hay_block_side" | "minecraft:item/light_15" | "minecraft:item/light_12" | "minecraft:item/light_11" | "minecraft:item/light_14" | "minecraft:item/cauldron" | "minecraft:item/experience_bottle" | "minecraft:item/light_13" | "minecraft:item/dark_oak_door" | "minecraft:item/brown_candle" | "minecraft:item/light_10" | "minecraft:item/netherite_scrap" | "minecraft:item/mushroom_stew" | "minecraft:block/crimson_nylium_side" | "minecraft:item/diamond_leggings" | "minecraft:item/stone_sword" | "minecraft:block/large_fern_bottom" | "minecraft:block/white_wool" | "minecraft:block/pointed_dripstone_down_middle" | "minecraft:item/potion" | "minecraft:block/red_stained_glass" | "minecraft:item/light_09" | "minecraft:item/light_08" | "minecraft:item/baked_potato" | "minecraft:item/clock_57" | "minecraft:item/clock_58" | "minecraft:item/clock_55" | "minecraft:item/clock_56" | "minecraft:block/exposed_copper" | "minecraft:block/deepslate_gold_ore" | "minecraft:item/clock_59" | "minecraft:item/iron_nugget" | "minecraft:block/smithing_table_front" | "minecraft:item/prismarine_crystals" | "minecraft:block/blackstone_top" | "minecraft:item/wooden_shovel" | "minecraft:item/clock_60" | "minecraft:item/music_disc_mellohi" | "minecraft:block/spruce_log" | "minecraft:item/clock_61" | "minecraft:item/raw_gold" | "minecraft:block/lily_pad" | "minecraft:block/lime_concrete" | "minecraft:block/chiseled_polished_blackstone" | "minecraft:item/clock_62" | "minecraft:block/quartz_block_side" | "minecraft:item/clock_63" | "minecraft:entity/bell/bell_body" | "minecraft:item/clock_46" | "minecraft:item/clock_47" | "minecraft:block/acacia_trapdoor" | "minecraft:item/clock_44" | "minecraft:item/clock_45" | "minecraft:block/red_mushroom" | "minecraft:item/tropical_fish" | "minecraft:item/clock_48" | "minecraft:item/clock_49" | "minecraft:item/black_dye" | "minecraft:block/white_terracotta" | "minecraft:block/warped_nylium_side" | "minecraft:block/cauldron_top" | "minecraft:block/polished_diorite" | "minecraft:item/seagrass" | "minecraft:block/smoker_top" | "minecraft:item/clock_50" | "minecraft:item/clay_ball" | "minecraft:block/honey_block_bottom" | "minecraft:item/clock_53" | "minecraft:item/bucket" | "minecraft:item/clock_54" | "minecraft:item/clock_51" | "minecraft:block/end_stone" | "minecraft:item/clock_52" | "minecraft:item/clock_35" | "minecraft:block/chiseled_deepslate" | "minecraft:block/oak_sapling" | "minecraft:item/clock_36" | "minecraft:item/sugar_cane" | "minecraft:item/clock_33" | "minecraft:item/clock_34" | "minecraft:item/clock_39" | "minecraft:entity/conduit/cage" | "minecraft:block/white_stained_glass" | "minecraft:item/clock_37" | "minecraft:item/clock_38" | "minecraft:block/polished_basalt_top" | "minecraft:block/sculk_sensor_tendril_active" | "minecraft:block/oak_log_top" | "minecraft:block/dark_oak_planks" | "minecraft:block/magenta_wool" | "minecraft:block/furnace_front" | "minecraft:entity/shield_base_nopattern" | "minecraft:block/lodestone_side" | "minecraft:block/stripped_oak_log_top" | "minecraft:block/netherrack" | "minecraft:block/pointed_dripstone_down_tip_merge" | "minecraft:item/clock_42" | "minecraft:item/golden_sword" | "minecraft:item/clock_43" | "minecraft:block/white_concrete" | "minecraft:item/clock_40" | "minecraft:block/oak_leaves" | "minecraft:block/warped_roots_pot" | "minecraft:item/clock_41" | "minecraft:item/clock_24" | "minecraft:item/clock_25" | "minecraft:item/clock_22" | "minecraft:item/clock_23" | "minecraft:item/clock_28" | "minecraft:item/clock_29" | "minecraft:item/clock_26" | "minecraft:block/redstone_dust_overlay" | "minecraft:item/clock_27" | "minecraft:block/potted_azalea_bush_side" | "minecraft:block/azalea_side" | "minecraft:block/glass_pane_top" | "minecraft:block/soul_campfire_log_lit" | "minecraft:item/leather_chestplate" | "minecraft:block/cave_vines_plant" | "minecraft:item/stone_shovel" | "minecraft:block/lectern_base" | "minecraft:block/redstone_ore" | "minecraft:block/pink_wool" | "minecraft:item/crimson_door" | "minecraft:block/bone_block_top" | "minecraft:item/clock_31" | "minecraft:item/clock_32" | "minecraft:block/purpur_pillar" | "minecraft:item/clock_30" | "minecraft:block/orange_stained_glass_pane_top" | "minecraft:item/clock_13" | "minecraft:block/green_concrete" | "minecraft:item/clock_14" | "minecraft:item/clock_11" | "minecraft:block/vine" | "minecraft:item/clock_12" | "minecraft:item/clock_17" | "minecraft:item/clock_18" | "minecraft:item/clock_15" | "minecraft:item/clock_16" | "minecraft:block/chiseled_red_sandstone" | "minecraft:item/clock_19" | "minecraft:block/glass" | "minecraft:item/salmon" | "minecraft:item/chain" | "minecraft:block/beehive_front_honey" | "minecraft:item/tnt_minecart" | "minecraft:block/lapis_ore" | "minecraft:block/light_blue_glazed_terracotta" | "minecraft:item/iron_chestplate" | "minecraft:block/lectern_front" | "minecraft:block/pink_candle_lit" | "minecraft:item/clock_20" | "minecraft:block/rail" | "minecraft:item/clock_21" | "minecraft:block/dead_fire_coral" | "minecraft:item/pointed_dripstone" | "minecraft:block/sculk_sensor_side" | "minecraft:item/clock_02" | "minecraft:item/birch_boat" | "minecraft:item/clock_03" | "minecraft:block/stonecutter_saw" | "minecraft:item/cake" | "minecraft:item/clock_00" | "minecraft:block/shulker_box" | "minecraft:item/clock_01" | "minecraft:item/clock_06" | "minecraft:block/blast_furnace_front" | "minecraft:block/water_still" | "minecraft:item/clock_07" | "minecraft:item/clock_04" | "minecraft:item/clock_05" | "minecraft:item/firework_rocket" | "minecraft:block/grass_block_side_overlay" | "minecraft:item/rotten_flesh" | "minecraft:item/clock_08" | "minecraft:item/skull_banner_pattern" | "minecraft:item/clock_09" | "minecraft:item/soul_lantern" | "minecraft:block/weathered_copper" | "minecraft:item/netherite_hoe" | "minecraft:block/bamboo_singleleaf" | "minecraft:item/cooked_rabbit" | "minecraft:block/blue_candle" | "minecraft:block/cyan_candle_lit" | "minecraft:block/diorite" | "minecraft:block/lime_glazed_terracotta" | "minecraft:block/oxidized_cut_copper" | "minecraft:block/ice" | "minecraft:block/mossy_cobblestone" | "minecraft:item/clock_10" | "minecraft:block/magenta_concrete_powder" | "minecraft:block/flowering_azalea_side" | "minecraft:block/candle_lit" | "minecraft:block/anvil_top" | "minecraft:item/iron_leggings" | "minecraft:block/bone_block_side" | "minecraft:block/activator_rail" | "minecraft:block/lightning_rod_on" | "minecraft:block/lime_concrete_powder" | "minecraft:item/diamond_shovel" | "minecraft:block/turtle_egg" | "minecraft:block/cracked_stone_bricks" | "minecraft:item/netherite_leggings" | "minecraft:item/nether_star" | "minecraft:block/bell_bottom" | "minecraft:entity/conduit/wind_vertical" | "minecraft:block/piston_side" | "minecraft:item/acacia_sign" | "minecraft:block/cactus_bottom" | "minecraft:block/oxeye_daisy" | "minecraft:block/cake_top" | "minecraft:item/leather_boots" | "minecraft:item/brewing_stand" | "minecraft:block/red_sandstone" | "minecraft:block/light_gray_wool" | "minecraft:item/music_disc_ward" | "minecraft:block/cut_sandstone" | "minecraft:block/tube_coral_block" | "minecraft:item/wooden_pickaxe" | "minecraft:block/bamboo_large_leaves" | "minecraft:block/stripped_birch_log" | "minecraft:item/hopper" | "minecraft:block/blue_concrete_powder" | "minecraft:block/bedrock" | "minecraft:block/soul_soil" | "minecraft:block/dead_horn_coral_block" | "minecraft:item/green_dye" | "minecraft:block/grindstone_round" | "minecraft:item/leather_chestplate_overlay" | "minecraft:block/respawn_anchor_side4" | "minecraft:block/smooth_stone_slab_side" | "minecraft:item/cod" | "minecraft:block/cave_vines" | "minecraft:block/respawn_anchor_side3" | "minecraft:block/respawn_anchor_side2" | "minecraft:block/respawn_anchor_side1" | "minecraft:block/respawn_anchor_side0" | "minecraft:block/warped_roots" | "minecraft:item/iron_boots" | "minecraft:block/shroomlight" | "minecraft:entity/shield_base" | "minecraft:block/acacia_planks" | "minecraft:block/calcite" | "minecraft:block/gravel" | "minecraft:block/jigsaw_side" | "minecraft:block/lilac_top" | "minecraft:block/dark_oak_sapling" | "minecraft:item/chest_minecart" | "minecraft:item/golden_carrot" | "minecraft:item/melon_slice" | "minecraft:item/cookie" | "minecraft:block/dirt_path_side" | "minecraft:block/piston_top_sticky" | "minecraft:item/leather_leggings_overlay" | "minecraft:block/iron_trapdoor" | "minecraft:block/redstone_lamp" | "minecraft:block/powered_rail" | "minecraft:block/small_amethyst_bud" | "minecraft:item/sweet_berries" | "minecraft:block/spruce_sapling" | "minecraft:block/orange_concrete" | "minecraft:block/crimson_nylium" | "minecraft:block/chiseled_stone_bricks" | "minecraft:block/scaffolding_bottom" | "minecraft:item/enchanted_book" | "minecraft:block/crimson_fungus" | "minecraft:block/light_gray_stained_glass_pane_top" | "minecraft:item/cooked_mutton" | "minecraft:block/white_glazed_terracotta" | "minecraft:item/empty_armor_slot_helmet" | "minecraft:block/red_sandstone_bottom" | "minecraft:item/crossbow_firework" | "minecraft:block/birch_log" | "minecraft:block/lectern_top" | "minecraft:block/tube_coral" | "minecraft:block/gray_stained_glass_pane_top" | "minecraft:item/empty_armor_slot_shield" | "minecraft:item/jungle_sign" | "minecraft:item/lime_candle" | "minecraft:item/empty_armor_slot_leggings" | "minecraft:block/blue_glazed_terracotta" | "minecraft:block/jigsaw_lock" | "minecraft:block/red_tulip" | "minecraft:block/dirt_path_top" | "minecraft:item/paper" | "minecraft:item/raw_copper" | "minecraft:block/fire_coral" | "minecraft:item/fishing_rod" | "minecraft:block/dark_oak_trapdoor" | "minecraft:block/wither_rose" | "minecraft:item/red_dye" | "minecraft:item/leather" | "minecraft:item/potato" | "minecraft:block/dead_horn_coral" | "minecraft:block/grass_block_top" | "minecraft:item/powder_snow_bucket" | "minecraft:block/crimson_stem_top" | "minecraft:block/pumpkin_top" | "minecraft:item/diamond_helmet" | "minecraft:item/nautilus_shell" | "minecraft:block/end_stone_bricks" | "minecraft:block/blue_orchid" | "minecraft:block/stripped_spruce_log" | "minecraft:item/tipped_arrow_base" | "minecraft:block/azalea_top" | "minecraft:block/mycelium_side" | "minecraft:block/blue_stained_glass" | "minecraft:block/birch_trapdoor" | "minecraft:block/composter_compost" | "minecraft:item/comparator" | "minecraft:item/blaze_powder" | "minecraft:item/heart_of_the_sea" | "minecraft:block/structure_block" | "minecraft:block/red_candle_lit" | "minecraft:item/music_disc_wait" | "minecraft:item/copper_ingot" | "minecraft:block/orange_glazed_terracotta" | "minecraft:item/cooked_cod" | "minecraft:block/yellow_terracotta" | "minecraft:item/cyan_candle" | "minecraft:item/dark_oak_boat" | "minecraft:item/gunpowder" | "minecraft:block/piston_inner" | "minecraft:block/quartz_block_bottom" | "minecraft:block/dried_kelp_bottom" | "minecraft:item/iron_axe" | "minecraft:item/yellow_candle" | "minecraft:block/water_flow" | "minecraft:item/salmon_bucket" | "minecraft:item/slime_ball" | "minecraft:block/potted_flowering_azalea_bush_side" | "minecraft:item/iron_helmet" | "minecraft:block/weeping_vines" | "minecraft:block/purple_shulker_box" | "minecraft:block/red_concrete_powder" | "minecraft:item/milk_bucket" | "minecraft:item/oak_door" | "minecraft:block/lime_terracotta" | "minecraft:block/potted_flowering_azalea_bush_top" | "minecraft:block/stripped_spruce_log_top" | "minecraft:item/lead" | "minecraft:item/wooden_axe" | "minecraft:block/chorus_flower_dead" | "minecraft:item/flint_and_steel" | "minecraft:item/pink_dye" | "minecraft:block/dead_fire_coral_fan" | "minecraft:block/emerald_block" | "minecraft:item/compass_31" | "minecraft:item/compass_30" | "minecraft:block/hay_block_top" | "minecraft:block/red_nether_bricks" | "minecraft:item/netherite_shovel" | "minecraft:block/warped_wart_block" | "minecraft:block/cyan_shulker_box" | "minecraft:block/deepslate_copper_ore" | "minecraft:item/pumpkin_seeds" | "minecraft:block/dispenser_front" | "minecraft:item/compass_28" | "minecraft:item/compass_29" | "minecraft:item/compass_26" | "minecraft:item/netherite_chestplate" | "minecraft:item/netherite_sword" | "minecraft:item/compass_27" | "minecraft:item/phantom_membrane" | "minecraft:block/sand" | "minecraft:block/white_concrete_powder" | "minecraft:block/barrel_top" | "minecraft:block/pointed_dripstone_up_tip_merge" | "minecraft:block/warped_trapdoor" | "minecraft:block/sunflower_bottom" | "minecraft:block/yellow_glazed_terracotta" | "minecraft:block/peony_top" | "minecraft:block/dead_bubble_coral" | "minecraft:block/conduit" | "minecraft:item/firework_star" | "minecraft:block/mossy_stone_bricks" | "minecraft:block/comparator" | "minecraft:item/saddle" | "minecraft:block/end_portal_frame_top" | "minecraft:block/black_candle" | "minecraft:block/fire_coral_block" | "minecraft:item/compass_13" | "minecraft:item/compass_14" | "minecraft:item/compass_11" | "minecraft:item/compass_12" | "minecraft:block/rooted_dirt" | "minecraft:block/cyan_concrete" | "minecraft:item/compass_10" | "minecraft:block/andesite" | "minecraft:item/purple_candle" | "minecraft:item/name_tag" | "minecraft:item/orange_candle" | "minecraft:block/sandstone_bottom" | "minecraft:block/end_portal_frame_eye" | "minecraft:item/knowledge_book" | "minecraft:item/compass_08" | "minecraft:item/beetroot" | "minecraft:item/compass_09" | "minecraft:item/compass_06" | "minecraft:item/compass_07" | "minecraft:item/compass_04" | "minecraft:item/compass_05" | "minecraft:item/compass_24" | "minecraft:item/compass_25" | "minecraft:item/compass_22" | "minecraft:item/wheat_seeds" | "minecraft:item/compass_23" | "minecraft:block/soul_fire_0" | "minecraft:item/compass_20" | "minecraft:block/soul_fire_1" | "minecraft:item/compass_21" | "minecraft:item/brick" | "minecraft:item/flower_banner_pattern" | "minecraft:item/music_disc_otherside" | "minecraft:item/written_book" | "minecraft:block/nether_sprouts" | "minecraft:block/sculk_sensor_top" | "minecraft:block/acacia_log" | "minecraft:block/stonecutter_top" | "minecraft:block/black_concrete_powder" | "minecraft:item/compass_19" | "minecraft:block/pointed_dripstone_up_middle" | "minecraft:item/compass_17" | "minecraft:item/compass_18" | "minecraft:item/compass_15" | "minecraft:item/compass_16" | "minecraft:block/brown_stained_glass_pane_top" | "minecraft:block/black_shulker_box" | "minecraft:block/jungle_door_top" | "minecraft:block/pointed_dripstone_down_frustum" | "minecraft:item/gold_ingot" | "minecraft:block/gray_glazed_terracotta" | "minecraft:block/daylight_detector_inverted_top" | "minecraft:block/beehive_side" | "minecraft:item/cocoa_beans" | "minecraft:item/sea_pickle" | "minecraft:block/magenta_shulker_box" | "minecraft:block/dead_tube_coral" | "minecraft:item/lantern" | "minecraft:block/dark_oak_leaves" | "minecraft:block/small_dripleaf_side" | "minecraft:block/jungle_log_top" | "minecraft:item/beetroot_seeds" | "minecraft:block/smooth_stone" | "minecraft:block/sunflower_back" | "minecraft:block/sea_pickle" | "minecraft:item/compass_02" | "minecraft:item/spider_eye" | "minecraft:block/black_glazed_terracotta" | "minecraft:item/compass_03" | "minecraft:entity/conduit/open_eye" | "minecraft:item/compass_00" | "minecraft:item/compass_01" | "minecraft:item/gold_nugget" | "minecraft:block/bubble_coral_fan" | "minecraft:item/music_disc_strad" | "minecraft:block/blue_concrete" | "minecraft:block/podzol_top" | "minecraft:block/spore_blossom" | "minecraft:block/composter_ready" | "minecraft:block/fletching_table_top" | "minecraft:block/yellow_shulker_box" | "minecraft:block/potted_azalea_bush_plant" | "minecraft:item/candle" | "minecraft:item/spyglass" | "minecraft:block/water_overlay" | "minecraft:block/brain_coral" | "minecraft:block/light_blue_candle" | "minecraft:block/lime_candle" | "minecraft:item/blue_candle" | "minecraft:item/light_blue_candle" | "minecraft:item/tipped_arrow_head" | "minecraft:item/suspicious_stew" | "minecraft:item/shears" | "minecraft:block/repeating_command_block_conditional" | "minecraft:item/iron_hoe" | "minecraft:block/raw_iron_block" | "minecraft:block/warped_nylium" | "minecraft:item/music_disc_blocks" | "minecraft:block/dead_bubble_coral_fan" | "minecraft:block/repeating_command_block_back" | "minecraft:block/brewing_stand_base" | "minecraft:block/redstone_block" | "minecraft:block/command_block_conditional" | "minecraft:item/spruce_sign" | "minecraft:block/budding_amethyst" | "minecraft:block/emerald_ore" | "minecraft:block/comparator_on" | "minecraft:block/lava_flow" | "minecraft:block/observer_back_on" | "minecraft:block/dead_brain_coral" | "forge:block/milk_still" | "minecraft:block/warped_fungus" | "minecraft:block/nether_portal" | "minecraft:block/dried_kelp_side" | "minecraft:item/glow_berries" | "minecraft:item/soul_campfire" | "minecraft:block/nether_gold_ore" | "minecraft:item/acacia_door" | "minecraft:block/mushroom_stem" | "minecraft:block/light_gray_candle_lit" | "minecraft:block/beehive_end" | "minecraft:block/bubble_coral_block" | "minecraft:block/cyan_glazed_terracotta" | "minecraft:block/red_stained_glass_pane_top" | "minecraft:block/brown_mushroom" | "minecraft:item/nether_brick" | "minecraft:block/cracked_deepslate_bricks" | "minecraft:block/polished_blackstone" | "minecraft:block/oak_trapdoor" | "minecraft:item/netherite_ingot" | "minecraft:item/diamond_boots" | "minecraft:block/stripped_crimson_stem_top" | "minecraft:block/redstone_torch_off" | "minecraft:block/amethyst_cluster" | "minecraft:block/nether_bricks" | "minecraft:block/acacia_log_top" | "minecraft:block/cracked_deepslate_tiles" | "minecraft:block/detector_rail" | "minecraft:item/wooden_sword" | "minecraft:block/snow" | "minecraft:block/black_terracotta" | "minecraft:block/crimson_door_bottom" | "minecraft:block/light_blue_terracotta" | "minecraft:item/glistering_melon_slice" | "minecraft:block/cartography_table_top" | "minecraft:block/purple_terracotta" | "minecraft:block/sculk_sensor_tendril_inactive" | "minecraft:missingno" | "minecraft:item/bread" | "minecraft:item/writable_book" | "minecraft:block/chiseled_sandstone" | "minecraft:block/gray_concrete_powder" | "minecraft:entity/conduit/closed_eye" | "minecraft:block/basalt_top" | "minecraft:block/stripped_warped_stem_top" | "minecraft:item/pink_candle" | "minecraft:block/stripped_jungle_log" | "minecraft:item/painting" | "minecraft:block/brain_coral_block" | "minecraft:block/structure_block_data" | "minecraft:block/jukebox_top";
    type DimensionTypeTag = never;
    type NoiseTag = never;
    type ConfiguredFeatureTag = never;
    type StructureSetTag = never;
    type ConfiguredStructureFeatureTag = "minecraft:dolphin_located" | "minecraft:on_ocean_explorer_maps" | "minecraft:ocean_ruin" | "minecraft:on_treasure_maps" | "minecraft:ruined_portal" | "minecraft:mineshaft" | "minecraft:on_woodland_explorer_maps" | "minecraft:village" | "minecraft:shipwreck" | "minecraft:eye_of_ender_located";
    type ProcessorListTag = never;
    type DensityFunctionTag = never;
    type BiomeTag = "forge:is_plateau" | "minecraft:has_structure/ruined_portal_standard" | "forge:is_hot" | "minecraft:has_structure/ruined_portal_swamp" | "forge:is_plains" | "minecraft:is_nether" | "forge:is_swamp" | "minecraft:has_structure/ruined_portal_desert" | "forge:is_coniferous" | "forge:is_cold" | "forge:is_dense" | "minecraft:has_structure/end_city" | "forge:is_slope" | "minecraft:has_structure/ruined_portal_jungle" | "minecraft:is_deep_ocean" | "minecraft:is_beach" | "minecraft:has_structure/ruined_portal_mountain" | "minecraft:has_structure/village_plains" | "minecraft:is_badlands" | "minecraft:has_structure/nether_fortress" | "minecraft:has_structure/ocean_monument" | "minecraft:has_structure/ruined_portal_ocean" | "forge:is_cold/end" | "minecraft:is_forest" | "minecraft:has_structure/desert_pyramid" | "minecraft:has_structure/shipwreck" | "forge:is_underground" | "minecraft:is_jungle" | "forge:is_wet" | "minecraft:has_structure/ocean_ruin_cold" | "minecraft:has_structure/igloo" | "minecraft:has_structure/village_taiga" | "forge:is_sparse" | "forge:is_wet/overworld" | "minecraft:has_structure/swamp_hut" | "forge:is_hot/overworld" | "minecraft:has_structure/ruined_portal_nether" | "forge:is_lush" | "forge:is_sandy" | "minecraft:has_structure/woodland_mansion" | "forge:is_snowy" | "forge:is_sparse/overworld" | "minecraft:is_taiga" | "forge:is_end" | "forge:is_mushroom" | "forge:is_void" | "forge:is_savanna" | "minecraft:has_structure/nether_fossil" | "minecraft:has_structure/mineshaft_mesa" | "forge:is_hot/nether" | "forge:is_spooky" | "minecraft:has_structure/village_savanna" | "forge:is_dry/overworld" | "minecraft:has_structure/shipwreck_beached" | "minecraft:is_hill" | "forge:is_beach" | "forge:is_wasteland" | "forge:is_dry/nether" | "minecraft:has_structure/stronghold" | "forge:is_peak" | "minecraft:has_structure/mineshaft" | "minecraft:has_structure/ocean_ruin_warm" | "forge:is_rare" | "forge:is_dry" | "forge:is_cold/overworld" | "minecraft:has_structure/village_desert" | "forge:is_dense/overworld" | "forge:is_overworld" | "forge:is_water" | "minecraft:has_structure/bastion_remnant" | "minecraft:is_ocean" | "minecraft:is_mountain" | "minecraft:has_structure/village_snowy" | "forge:is_dry/end" | "minecraft:has_structure/buried_treasure" | "minecraft:has_structure/pillager_outpost" | "minecraft:is_river" | "minecraft:has_structure/jungle_temple";
    type PlacedFeatureTag = never;
    type NoiseSettingsTag = never;
    type ConfiguredCarverTag = never;
    type TemplatePoolTag = never;
    type GameEventTag = "minecraft:ignore_vibrations_sneaking" | "minecraft:vibrations";
    type SoundEventTag = never;
    type FluidTag = "minecraft:lava" | "minecraft:water" | "forge:milk";
    type MobEffectTag = never;
    type BlockTag = "forge:glass/cyan" | "minecraft:inside_step_sound_blocks" | "minecraft:big_dripleaf_placeable" | "forge:chests" | "forge:glass/pink" | "forge:glass_panes/gray" | "forge:glass_panes/yellow" | "minecraft:walls" | "minecraft:moss_replaceable" | "minecraft:stone_bricks" | "forge:cobblestone" | "minecraft:diamond_ores" | "forge:glass_panes/magenta" | "minecraft:shulker_boxes" | "forge:glass_panes/red" | "minecraft:birch_logs" | "minecraft:rails" | "minecraft:trapdoors" | "minecraft:guarded_by_piglins" | "forge:glass_panes" | "forge:fences/nether_brick" | "minecraft:geode_invalid_blocks" | "forge:ore_rates/sparse" | "minecraft:wall_corals" | "minecraft:corals" | "forge:storage_blocks/netherite" | "forge:glass/tinted" | "minecraft:wooden_stairs" | "forge:storage_blocks/gold" | "minecraft:candle_cakes" | "forge:fence_gates/wooden" | "minecraft:lush_ground_replaceable" | "minecraft:climbable" | "forge:ores/diamond" | "minecraft:acacia_logs" | "forge:storage_blocks" | "minecraft:logs_that_burn" | "forge:ore_bearing_ground/stone" | "minecraft:soul_fire_base_blocks" | "forge:glass_panes/cyan" | "forge:glass/gray" | "minecraft:wooden_doors" | "forge:glass/magenta" | "minecraft:wither_summon_base_blocks" | "minecraft:cauldrons" | "minecraft:pressure_plates" | "minecraft:needs_iron_tool" | "minecraft:azalea_root_replaceable" | "minecraft:wooden_pressure_plates" | "minecraft:standing_signs" | "forge:ore_rates/singular" | "forge:glass/red" | "minecraft:infiniburn_end" | "minecraft:cave_vines" | "minecraft:jungle_logs" | "minecraft:signs" | "minecraft:dragon_immune" | "minecraft:wall_post_override" | "forge:ores/quartz" | "forge:storage_blocks/raw_copper" | "forge:ores_in_ground/stone" | "forge:cobblestone/normal" | "minecraft:stone_pressure_plates" | "forge:ores_in_ground/netherrack" | "forge:glass/colorless" | "minecraft:foxes_spawnable_on" | "minecraft:anvil" | "forge:netherrack" | "minecraft:coral_plants" | "forge:ores/netherite_scrap" | "minecraft:wooden_fences" | "minecraft:fence_gates" | "minecraft:iron_ores" | "minecraft:leaves" | "forge:sandstone" | "forge:chests/ender" | "minecraft:hoglin_repellents" | "forge:glass_panes/purple" | "minecraft:crimson_stems" | "forge:glass_panes/light_blue" | "minecraft:strider_warm_blocks" | "minecraft:beehives" | "minecraft:enderman_holdable" | "minecraft:doors" | "minecraft:slabs" | "minecraft:beds" | "forge:sand/red" | "forge:storage_blocks/iron" | "forge:ore_rates/dense" | "minecraft:mineable/pickaxe" | "forge:storage_blocks/coal" | "forge:barrels/wooden" | "minecraft:terracotta" | "minecraft:base_stone_overworld" | "minecraft:spruce_logs" | "minecraft:mooshrooms_spawnable_on" | "forge:ores/emerald" | "forge:glass/green" | "minecraft:small_flowers" | "minecraft:oak_logs" | "minecraft:underwater_bonemeals" | "forge:glass/yellow" | "minecraft:needs_diamond_tool" | "forge:glass/white" | "forge:sand" | "minecraft:small_dripleaf_placeable" | "forge:storage_blocks/redstone" | "forge:fences" | "forge:ores" | "forge:glass_panes/blue" | "minecraft:sand" | "minecraft:infiniburn_overworld" | "minecraft:wall_signs" | "forge:storage_blocks/lapis" | "minecraft:base_stone_nether" | "forge:cobblestone/deepslate" | "minecraft:bamboo_plantable_on" | "minecraft:crystal_sound_blocks" | "minecraft:stairs" | "minecraft:wooden_buttons" | "forge:glass_panes/light_gray" | "minecraft:wolves_spawnable_on" | "minecraft:stone_ore_replaceables" | "minecraft:coal_ores" | "forge:ores/coal" | "minecraft:wither_immune" | "forge:storage_blocks/quartz" | "minecraft:warped_stems" | "forge:glass_panes/green" | "minecraft:lava_pool_stone_cannot_replace" | "minecraft:prevent_mob_spawning_inside" | "forge:ores_in_ground/deepslate" | "minecraft:wool" | "forge:glass_panes/black" | "forge:glass_panes/orange" | "minecraft:non_flammable_wood" | "minecraft:beacon_base_blocks" | "forge:stone" | "forge:ores/iron" | "minecraft:flowers" | "minecraft:flower_pots" | "forge:obsidian" | "forge:glass/light_blue" | "minecraft:gold_ores" | "forge:ore_bearing_ground/deepslate" | "minecraft:wooden_trapdoors" | "minecraft:features_cannot_replace" | "minecraft:deepslate_ore_replaceables" | "forge:fences/wooden" | "forge:glass_panes/white" | "forge:glass/black" | "minecraft:needs_stone_tool" | "minecraft:fences" | "forge:ores/redstone" | "forge:glass/orange" | "forge:glass/silica" | "minecraft:dripstone_replaceable_blocks" | "minecraft:crops" | "minecraft:wart_blocks" | "minecraft:fire" | "minecraft:valid_spawn" | "forge:gravel" | "minecraft:soul_speed_blocks" | "minecraft:azalea_grows_on" | "minecraft:occludes_vibration_signals" | "minecraft:parrots_spawnable_on" | "forge:ore_bearing_ground/netherrack" | "minecraft:piglin_repellents" | "forge:fence_gates" | "forge:barrels" | "forge:chests/trapped" | "minecraft:portals" | "forge:storage_blocks/diamond" | "minecraft:mushroom_grow_block" | "minecraft:axolotls_spawnable_on" | "minecraft:fall_damage_resetting" | "forge:glass/purple" | "forge:glass/brown" | "minecraft:impermeable" | "minecraft:dirt" | "minecraft:animals_spawnable_on" | "minecraft:nylium" | "forge:stained_glass_panes" | "minecraft:mineable/hoe" | "minecraft:rabbits_spawnable_on" | "forge:end_stones" | "minecraft:polar_bears_spawnable_on_in_frozen_ocean" | "minecraft:carpets" | "minecraft:goats_spawnable_on" | "forge:storage_blocks/amethyst" | "minecraft:campfires" | "forge:stained_glass" | "forge:storage_blocks/raw_gold" | "minecraft:bee_growables" | "minecraft:mineable/axe" | "minecraft:lapis_ores" | "minecraft:emerald_ores" | "forge:glass_panes/colorless" | "minecraft:logs" | "minecraft:ice" | "minecraft:buttons" | "forge:ores/copper" | "minecraft:coral_blocks" | "minecraft:banners" | "forge:sand/colorless" | "minecraft:copper_ores" | "forge:storage_blocks/copper" | "minecraft:candles" | "minecraft:infiniburn_nether" | "forge:glass/lime" | "forge:glass/blue" | "minecraft:snow" | "forge:storage_blocks/raw_iron" | "minecraft:unstable_bottom_center" | "forge:chests/wooden" | "minecraft:redstone_ores" | "minecraft:replaceable_plants" | "forge:cobblestone/infested" | "forge:glass_panes/brown" | "minecraft:saplings" | "forge:ores/gold" | "forge:enderman_place_on_blacklist" | "forge:ores/lapis" | "forge:glass_panes/lime" | "forge:storage_blocks/emerald" | "forge:glass" | "forge:glass/light_gray" | "minecraft:wooden_slabs" | "forge:glass_panes/pink" | "minecraft:dark_oak_logs" | "minecraft:mineable/shovel" | "forge:cobblestone/mossy" | "minecraft:tall_flowers" | "minecraft:planks";
    type EnchantmentTag = never;
    type EntityTypeTag = "minecraft:axolotl_always_hostiles" | "minecraft:freeze_immune_entity_types" | "minecraft:arrows" | "minecraft:beehive_inhabitors" | "minecraft:axolotl_hunt_targets" | "minecraft:skeletons" | "minecraft:impact_projectiles" | "minecraft:raiders" | "minecraft:powder_snow_walkable_mobs" | "minecraft:freeze_hurts_extra_types";
    type ItemTag = "forge:gems/quartz" | "forge:shears" | "forge:dusts/glowstone" | "forge:ores/quartz" | "minecraft:beds" | "forge:glass/pink" | "forge:fences" | "forge:crops/beetroot" | "forge:heads" | "forge:ingots/iron" | "forge:glass/silica" | "minecraft:arrows" | "forge:dyes/blue" | "forge:ore_bearing_ground/deepslate" | "minecraft:piglin_loved" | "forge:gems" | "forge:glass_panes/cyan" | "forge:seeds/pumpkin" | "forge:glass/gray" | "forge:dyes/light_gray" | "forge:storage_blocks/copper" | "forge:glass/orange" | "forge:ores/copper" | "minecraft:piglin_repellents" | "forge:slimeballs" | "forge:glass_panes/black" | "forge:glass_panes/orange" | "forge:ingots/brick" | "minecraft:trapdoors" | "minecraft:tall_flowers" | "minecraft:planks" | "forge:ore_bearing_ground/netherrack" | "minecraft:music_discs" | "minecraft:wooden_buttons" | "minecraft:walls" | "forge:sand/red" | "forge:bookshelves" | "forge:dyes/green" | "minecraft:buttons" | "forge:glass/cyan" | "forge:barrels/wooden" | "forge:dyes/gray" | "forge:gems/diamond" | "forge:dyes/black" | "forge:gravel" | "forge:glass_panes/blue" | "forge:dyes/brown" | "forge:chests/trapped" | "forge:dyes/orange" | "forge:crops/carrot" | "forge:cobblestone" | "forge:ores/iron" | "minecraft:wooden_doors" | "forge:glass_panes" | "forge:fence_gates/wooden" | "forge:glass_panes/magenta" | "forge:bones" | "minecraft:spruce_logs" | "minecraft:jungle_logs" | "forge:glass_panes/light_gray" | "forge:glass/purple" | "minecraft:emerald_ores" | "forge:ore_rates/singular" | "forge:feathers" | "minecraft:small_flowers" | "minecraft:flowers" | "forge:nuggets/iron" | "forge:ores/diamond" | "forge:glass/white" | "forge:glass/blue" | "forge:raw_materials/gold" | "forge:gems/amethyst" | "forge:fences/wooden" | "minecraft:boats" | "minecraft:wooden_fences" | "forge:glass_panes/gray" | "forge:dyes/lime" | "forge:gunpowder" | "forge:glass" | "minecraft:carpets" | "forge:rods" | "forge:cobblestone/mossy" | "minecraft:fox_food" | "minecraft:wooden_trapdoors" | "forge:ores/emerald" | "minecraft:signs" | "minecraft:saplings" | "forge:storage_blocks/gold" | "forge:dusts/redstone" | "forge:enchanting_fuels" | "forge:chests" | "forge:ingots/nether_brick" | "forge:seeds/wheat" | "forge:storage_blocks/netherite" | "forge:dyes/light_blue" | "minecraft:dark_oak_logs" | "forge:gems/lapis" | "forge:glass/red" | "minecraft:beacon_payment_items" | "minecraft:creeper_drop_music_discs" | "forge:ingots/netherite" | "forge:string" | "minecraft:crimson_stems" | "forge:crops/nether_wart" | "forge:ores/lapis" | "forge:stained_glass_panes" | "forge:ores/coal" | "forge:eggs" | "forge:raw_materials" | "forge:seeds" | "forge:dyes" | "forge:glass/colorless" | "minecraft:ignored_by_piglin_babies" | "forge:ore_rates/sparse" | "forge:ingots/copper" | "forge:sandstone" | "forge:rods/wooden" | "forge:glass_panes/pink" | "forge:storage_blocks/redstone" | "minecraft:piglin_food" | "forge:glass_panes/colorless" | "forge:raw_materials/copper" | "forge:dusts/prismarine" | "minecraft:sand" | "forge:dyes/cyan" | "forge:storage_blocks/coal" | "minecraft:banners" | "forge:crops" | "minecraft:slabs" | "minecraft:candles" | "forge:stained_glass" | "forge:glass/magenta" | "minecraft:lapis_ores" | "forge:ores_in_ground/deepslate" | "forge:fences/nether_brick" | "forge:netherrack" | "minecraft:oak_logs" | "forge:nether_stars" | "minecraft:wool" | "forge:glass/black" | "forge:ores/netherite_scrap" | "forge:dyes/pink" | "forge:storage_blocks/diamond" | "minecraft:wooden_stairs" | "forge:barrels" | "forge:seeds/beetroot" | "forge:glass/green" | "forge:storage_blocks/iron" | "forge:dusts" | "forge:ingots/gold" | "forge:ender_pearls" | "forge:storage_blocks" | "forge:raw_materials/iron" | "forge:gems/prismarine" | "forge:glass/yellow" | "forge:storage_blocks/raw_iron" | "forge:fence_gates" | "minecraft:fences" | "minecraft:lectern_books" | "minecraft:redstone_ores" | "minecraft:anvil" | "forge:dyes/magenta" | "forge:glass_panes/white" | "forge:ore_rates/dense" | "minecraft:gold_ores" | "forge:storage_blocks/emerald" | "minecraft:coal_ores" | "forge:glass_panes/red" | "forge:storage_blocks/lapis" | "minecraft:stone_crafting_materials" | "forge:ores/redstone" | "forge:seeds/melon" | "minecraft:coals" | "forge:glass/light_gray" | "minecraft:axolotl_tempt_items" | "minecraft:stone_tool_materials" | "forge:sand" | "forge:leather" | "forge:glass_panes/purple" | "forge:crops/potato" | "forge:storage_blocks/quartz" | "minecraft:dirt" | "forge:glass_panes/yellow" | "minecraft:acacia_logs" | "forge:ores" | "minecraft:iron_ores" | "forge:cobblestone/deepslate" | "minecraft:wooden_slabs" | "minecraft:warped_stems" | "forge:gems/emerald" | "forge:glass/lime" | "forge:stone" | "minecraft:wooden_pressure_plates" | "forge:chests/ender" | "minecraft:copper_ores" | "minecraft:fishes" | "forge:glass_panes/light_blue" | "forge:ores_in_ground/stone" | "forge:glass/tinted" | "forge:cobblestone/infested" | "minecraft:birch_logs" | "minecraft:stone_bricks" | "minecraft:rails" | "forge:obsidian" | "forge:sand/colorless" | "forge:dyes/white" | "minecraft:cluster_max_harvestables" | "forge:storage_blocks/raw_gold" | "forge:ore_bearing_ground/stone" | "forge:glass_panes/green" | "minecraft:non_flammable_wood" | "forge:nuggets" | "forge:dyes/red" | "forge:nuggets/gold" | "minecraft:logs" | "forge:dyes/purple" | "minecraft:doors" | "forge:end_stones" | "forge:ores/gold" | "minecraft:diamond_ores" | "minecraft:terracotta" | "forge:glass/brown" | "forge:ingots" | "minecraft:freeze_immune_wearables" | "forge:storage_blocks/raw_copper" | "forge:rods/blaze" | "minecraft:soul_fire_base_blocks" | "forge:mushrooms" | "minecraft:logs_that_burn" | "forge:ores_in_ground/netherrack" | "forge:chests/wooden" | "forge:storage_blocks/amethyst" | "forge:glass_panes/lime" | "minecraft:occludes_vibration_signals" | "minecraft:leaves" | "forge:dyes/yellow" | "forge:glass/light_blue" | "forge:crops/wheat" | "minecraft:stairs" | "forge:glass_panes/brown" | "forge:cobblestone/normal";
    type PotionTag = never;
    type ParticleTypeTag = never;
    type BlockEntityTypeTag = never;
    type MotiveTag = never;
    type CustomStatTag = never;
    type ChunkStatusTag = never;
    type RuleTestTag = never;
    type PosRuleTestTag = never;
    type MenuTag = never;
    type RecipeTypeTag = never;
    type RecipeSerializerTag = never;
    type AttributeTag = never;
    type PositionSourceTypeTag = never;
    type StatTypeTag = never;
    type VillagerTypeTag = never;
    type VillagerProfessionTag = never;
    type PointOfInterestTypeTag = never;
    type MemoryModuleTypeTag = never;
    type SensorTypeTag = never;
    type ScheduleTag = never;
    type ActivityTag = never;
    type LootPoolEntryTypeTag = never;
    type LootFunctionTypeTag = never;
    type LootConditionTypeTag = never;
    type LootNumberProviderTypeTag = never;
    type LootNbtProviderTypeTag = never;
    type LootScoreProviderTypeTag = never;
    type FloatProviderTypeTag = never;
    type IntProviderTypeTag = never;
    type HeightProviderTypeTag = never;
    type BlockPredicateTypeTag = never;
    type CarverTag = never;
    type FeatureTag = never;
    type StructureFeatureTag = never;
    type StructurePlacementTag = never;
    type StructurePieceTag = never;
    type PlacementModifierTypeTag = never;
    type BlockStateProviderTypeTag = never;
    type FoliagePlacerTypeTag = never;
    type TrunkPlacerTypeTag = never;
    type TreeDecoratorTypeTag = never;
    type FeatureSizeTypeTag = never;
    type BiomeSourceTag = never;
    type ChunkGeneratorTag = never;
    type MaterialConditionTag = never;
    type MaterialRuleTag = never;
    type DensityFunctionTypeTag = never;
    type StructureProcessorTag = never;
    type StructurePoolElementTag = never;
    type LootModifierSerializersTag = never;
    type DataSerializersTag = never;
    type WorldTypesTag = never;
    type DimensionType = never;
    type NormalNoise$NoiseParameters = "packed_ice" | "minecraft:packed_ice" | "soul_sand_layer" | "minecraft:soul_sand_layer" | "ore_gap" | "minecraft:ore_gap" | "temperature_large" | "minecraft:temperature_large" | "erosion" | "minecraft:erosion" | "offset" | "minecraft:offset" | "cave_layer" | "minecraft:cave_layer" | "patch" | "minecraft:patch" | "jagged" | "minecraft:jagged" | "noodle" | "minecraft:noodle" | "continentalness" | "minecraft:continentalness" | "calcite" | "minecraft:calcite" | "temperature" | "minecraft:temperature" | "vegetation" | "minecraft:vegetation" | "nether_state_selector" | "minecraft:nether_state_selector" | "surface_secondary" | "minecraft:surface_secondary" | "erosion_large" | "minecraft:erosion_large" | "spaghetti_2d" | "minecraft:spaghetti_2d" | "ice" | "minecraft:ice" | "noodle_thickness" | "minecraft:noodle_thickness" | "spaghetti_3d_thickness" | "minecraft:spaghetti_3d_thickness" | "badlands_pillar_roof" | "minecraft:badlands_pillar_roof" | "spaghetti_2d_modulator" | "minecraft:spaghetti_2d_modulator" | "badlands_surface" | "minecraft:badlands_surface" | "iceberg_pillar" | "minecraft:iceberg_pillar" | "surface_swamp" | "minecraft:surface_swamp" | "gravel_layer" | "minecraft:gravel_layer" | "ore_veininess" | "minecraft:ore_veininess" | "spaghetti_2d_thickness" | "minecraft:spaghetti_2d_thickness" | "aquifer_fluid_level_floodedness" | "minecraft:aquifer_fluid_level_floodedness" | "pillar_thickness" | "minecraft:pillar_thickness" | "spaghetti_2d_elevation" | "minecraft:spaghetti_2d_elevation" | "clay_bands_offset" | "minecraft:clay_bands_offset" | "badlands_pillar" | "minecraft:badlands_pillar" | "spaghetti_3d_1" | "minecraft:spaghetti_3d_1" | "spaghetti_3d_2" | "minecraft:spaghetti_3d_2" | "spaghetti_3d_rarity" | "minecraft:spaghetti_3d_rarity" | "continentalness_large" | "minecraft:continentalness_large" | "ridge" | "minecraft:ridge" | "spaghetti_roughness_modulator" | "minecraft:spaghetti_roughness_modulator" | "nether_wart" | "minecraft:nether_wart" | "cave_entrance" | "minecraft:cave_entrance" | "ore_vein_b" | "minecraft:ore_vein_b" | "ore_vein_a" | "minecraft:ore_vein_a" | "aquifer_barrier" | "minecraft:aquifer_barrier" | "netherrack" | "minecraft:netherrack" | "vegetation_large" | "minecraft:vegetation_large" | "noodle_ridge_a" | "minecraft:noodle_ridge_a" | "noodle_ridge_b" | "minecraft:noodle_ridge_b" | "pillar_rareness" | "minecraft:pillar_rareness" | "iceberg_pillar_roof" | "minecraft:iceberg_pillar_roof" | "gravel" | "minecraft:gravel" | "pillar" | "minecraft:pillar" | "powder_snow" | "minecraft:powder_snow" | "aquifer_lava" | "minecraft:aquifer_lava" | "aquifer_fluid_level_spread" | "minecraft:aquifer_fluid_level_spread" | "surface" | "minecraft:surface" | "cave_cheese" | "minecraft:cave_cheese" | "iceberg_surface" | "minecraft:iceberg_surface" | "spaghetti_roughness" | "minecraft:spaghetti_roughness";
    type ConfiguredFeature = "lake_lava" | "minecraft:lake_lava" | "azalea_tree" | "minecraft:azalea_tree" | "fancy_oak_bees_002" | "minecraft:fancy_oak_bees_002" | "disk_sand" | "minecraft:disk_sand" | "spring_nether_open" | "minecraft:spring_nether_open" | "patch_large_fern" | "minecraft:patch_large_fern" | "fancy_oak_bees_005" | "minecraft:fancy_oak_bees_005" | "trees_old_growth_pine_taiga" | "minecraft:trees_old_growth_pine_taiga" | "cave_vine" | "minecraft:cave_vine" | "flower_meadow" | "minecraft:flower_meadow" | "patch_red_mushroom" | "minecraft:patch_red_mushroom" | "ore_lapis" | "minecraft:ore_lapis" | "blue_ice" | "minecraft:blue_ice" | "sea_pickle" | "minecraft:sea_pickle" | "end_gateway_delayed" | "minecraft:end_gateway_delayed" | "blackstone_blobs" | "minecraft:blackstone_blobs" | "huge_brown_mushroom" | "minecraft:huge_brown_mushroom" | "iceberg_blue" | "minecraft:iceberg_blue" | "patch_crimson_roots" | "minecraft:patch_crimson_roots" | "clay_with_dripleaves" | "minecraft:clay_with_dripleaves" | "ore_magma" | "minecraft:ore_magma" | "end_island" | "minecraft:end_island" | "bamboo_no_podzol" | "minecraft:bamboo_no_podzol" | "trees_water" | "minecraft:trees_water" | "patch_tall_grass" | "minecraft:patch_tall_grass" | "freeze_top_layer" | "minecraft:freeze_top_layer" | "ore_diorite" | "minecraft:ore_diorite" | "trees_jungle" | "minecraft:trees_jungle" | "seagrass_short" | "minecraft:seagrass_short" | "amethyst_geode" | "minecraft:amethyst_geode" | "ore_copper_large" | "minecraft:ore_copper_large" | "ore_soul_sand" | "minecraft:ore_soul_sand" | "fancy_oak_bees_0002" | "minecraft:fancy_oak_bees_0002" | "spore_blossom" | "minecraft:spore_blossom" | "flower_default" | "minecraft:flower_default" | "end_spike" | "minecraft:end_spike" | "seagrass_mid" | "minecraft:seagrass_mid" | "meadow_trees" | "minecraft:meadow_trees" | "patch_cactus" | "minecraft:patch_cactus" | "oak_bees_005" | "minecraft:oak_bees_005" | "ore_lapis_buried" | "minecraft:ore_lapis_buried" | "patch_grass" | "minecraft:patch_grass" | "trees_savanna" | "minecraft:trees_savanna" | "patch_sunflower" | "minecraft:patch_sunflower" | "trees_flower_forest" | "minecraft:trees_flower_forest" | "spring_lava_overworld" | "minecraft:spring_lava_overworld" | "bamboo_vegetation" | "minecraft:bamboo_vegetation" | "birch" | "minecraft:birch" | "oak_bees_002" | "minecraft:oak_bees_002" | "glowstone_extra" | "minecraft:glowstone_extra" | "seagrass_tall" | "minecraft:seagrass_tall" | "ice_patch" | "minecraft:ice_patch" | "pile_hay" | "minecraft:pile_hay" | "fossil_coal" | "minecraft:fossil_coal" | "basalt_pillar" | "minecraft:basalt_pillar" | "dripleaf" | "minecraft:dripleaf" | "monster_room" | "minecraft:monster_room" | "ore_andesite" | "minecraft:ore_andesite" | "jungle_tree" | "minecraft:jungle_tree" | "basalt_blobs" | "minecraft:basalt_blobs" | "trees_windswept_hills" | "minecraft:trees_windswept_hills" | "ore_ancient_debris_small" | "minecraft:ore_ancient_debris_small" | "moss_patch_bonemeal" | "minecraft:moss_patch_bonemeal" | "patch_soul_fire" | "minecraft:patch_soul_fire" | "huge_red_mushroom" | "minecraft:huge_red_mushroom" | "spruce" | "minecraft:spruce" | "crimson_forest_vegetation" | "minecraft:crimson_forest_vegetation" | "forest_rock" | "minecraft:forest_rock" | "warped_forest_vegetation_bonemeal" | "minecraft:warped_forest_vegetation_bonemeal" | "pointed_dripstone" | "minecraft:pointed_dripstone" | "moss_patch_ceiling" | "minecraft:moss_patch_ceiling" | "disk_clay" | "minecraft:disk_clay" | "underwater_magma" | "minecraft:underwater_magma" | "jungle_bush" | "minecraft:jungle_bush" | "birch_bees_002" | "minecraft:birch_bees_002" | "birch_bees_005" | "minecraft:birch_bees_005" | "ore_gold_buried" | "minecraft:ore_gold_buried" | "weeping_vines" | "minecraft:weeping_vines" | "large_dripstone" | "minecraft:large_dripstone" | "jungle_tree_no_vine" | "minecraft:jungle_tree_no_vine" | "flower_flower_forest" | "minecraft:flower_flower_forest" | "lush_caves_clay" | "minecraft:lush_caves_clay" | "void_start_platform" | "minecraft:void_start_platform" | "spring_nether_closed" | "minecraft:spring_nether_closed" | "nether_sprouts_bonemeal" | "minecraft:nether_sprouts_bonemeal" | "moss_patch" | "minecraft:moss_patch" | "spring_water" | "minecraft:spring_water" | "ore_tuff" | "minecraft:ore_tuff" | "ore_diamond_small" | "minecraft:ore_diamond_small" | "ore_blackstone" | "minecraft:ore_blackstone" | "fossil_diamonds" | "minecraft:fossil_diamonds" | "birch_tall" | "minecraft:birch_tall" | "mega_jungle_tree" | "minecraft:mega_jungle_tree" | "spring_lava_nether" | "minecraft:spring_lava_nether" | "end_gateway_return" | "minecraft:end_gateway_return" | "small_basalt_columns" | "minecraft:small_basalt_columns" | "crimson_fungus" | "minecraft:crimson_fungus" | "trees_birch_and_oak" | "minecraft:trees_birch_and_oak" | "trees_old_growth_spruce_taiga" | "minecraft:trees_old_growth_spruce_taiga" | "chorus_plant" | "minecraft:chorus_plant" | "patch_pumpkin" | "minecraft:patch_pumpkin" | "forest_flowers" | "minecraft:forest_flowers" | "ore_dirt" | "minecraft:ore_dirt" | "desert_well" | "minecraft:desert_well" | "seagrass_slightly_less_short" | "minecraft:seagrass_slightly_less_short" | "spring_lava_frozen" | "minecraft:spring_lava_frozen" | "patch_fire" | "minecraft:patch_fire" | "fancy_oak_bees" | "minecraft:fancy_oak_bees" | "disk_gravel" | "minecraft:disk_gravel" | "nether_sprouts" | "minecraft:nether_sprouts" | "oak" | "minecraft:oak" | "birch_bees_0002" | "minecraft:birch_bees_0002" | "warped_fungus_planted" | "minecraft:warped_fungus_planted" | "dark_oak" | "minecraft:dark_oak" | "warm_ocean_vegetation" | "minecraft:warm_ocean_vegetation" | "swamp_oak" | "minecraft:swamp_oak" | "super_birch_bees" | "minecraft:super_birch_bees" | "twisting_vines_bonemeal" | "minecraft:twisting_vines_bonemeal" | "seagrass_simple" | "minecraft:seagrass_simple" | "crimson_fungus_planted" | "minecraft:crimson_fungus_planted" | "ore_nether_gold" | "minecraft:ore_nether_gold" | "trees_taiga" | "minecraft:trees_taiga" | "delta" | "minecraft:delta" | "ore_granite" | "minecraft:ore_granite" | "ore_ancient_debris_large" | "minecraft:ore_ancient_debris_large" | "ore_clay" | "minecraft:ore_clay" | "ore_gold" | "minecraft:ore_gold" | "flower_swamp" | "minecraft:flower_swamp" | "mega_spruce" | "minecraft:mega_spruce" | "trees_plains" | "minecraft:trees_plains" | "patch_taiga_grass" | "minecraft:patch_taiga_grass" | "large_basalt_columns" | "minecraft:large_basalt_columns" | "single_piece_of_grass" | "minecraft:single_piece_of_grass" | "ice_spike" | "minecraft:ice_spike" | "bamboo_some_podzol" | "minecraft:bamboo_some_podzol" | "warped_forest_vegetation" | "minecraft:warped_forest_vegetation" | "acacia" | "minecraft:acacia" | "pile_pumpkin" | "minecraft:pile_pumpkin" | "ore_diamond_large" | "minecraft:ore_diamond_large" | "dripstone_cluster" | "minecraft:dripstone_cluster" | "pile_ice" | "minecraft:pile_ice" | "trees_grove" | "minecraft:trees_grove" | "ore_infested" | "minecraft:ore_infested" | "twisting_vines" | "minecraft:twisting_vines" | "ore_copper_small" | "minecraft:ore_copper_small" | "cave_vine_in_moss" | "minecraft:cave_vine_in_moss" | "super_birch_bees_0002" | "minecraft:super_birch_bees_0002" | "patch_waterlily" | "minecraft:patch_waterlily" | "ore_iron" | "minecraft:ore_iron" | "dark_forest_vegetation" | "minecraft:dark_forest_vegetation" | "flower_plain" | "minecraft:flower_plain" | "fancy_oak" | "minecraft:fancy_oak" | "patch_sugar_cane" | "minecraft:patch_sugar_cane" | "iceberg_packed" | "minecraft:iceberg_packed" | "ore_quartz" | "minecraft:ore_quartz" | "kelp" | "minecraft:kelp" | "clay_pool_with_dripleaves" | "minecraft:clay_pool_with_dripleaves" | "ore_iron_small" | "minecraft:ore_iron_small" | "ore_gravel" | "minecraft:ore_gravel" | "patch_grass_jungle" | "minecraft:patch_grass_jungle" | "mushroom_island_vegetation" | "minecraft:mushroom_island_vegetation" | "ore_diamond_buried" | "minecraft:ore_diamond_buried" | "ore_emerald" | "minecraft:ore_emerald" | "trees_sparse_jungle" | "minecraft:trees_sparse_jungle" | "rooted_azalea_tree" | "minecraft:rooted_azalea_tree" | "pine" | "minecraft:pine" | "bonus_chest" | "minecraft:bonus_chest" | "warped_fungus" | "minecraft:warped_fungus" | "oak_bees_0002" | "minecraft:oak_bees_0002" | "moss_vegetation" | "minecraft:moss_vegetation" | "glow_lichen" | "minecraft:glow_lichen" | "pile_snow" | "minecraft:pile_snow" | "ore_gravel_nether" | "minecraft:ore_gravel_nether" | "patch_dead_bush" | "minecraft:patch_dead_bush" | "mega_pine" | "minecraft:mega_pine" | "patch_melon" | "minecraft:patch_melon" | "ore_coal_buried" | "minecraft:ore_coal_buried" | "ore_coal" | "minecraft:ore_coal" | "patch_brown_mushroom" | "minecraft:patch_brown_mushroom" | "crimson_forest_vegetation_bonemeal" | "minecraft:crimson_forest_vegetation_bonemeal" | "ore_redstone" | "minecraft:ore_redstone" | "pile_melon" | "minecraft:pile_melon" | "vines" | "minecraft:vines" | "patch_berry_bush" | "minecraft:patch_berry_bush";
    type StructureSet = "igloos" | "minecraft:igloos" | "desert_pyramids" | "minecraft:desert_pyramids" | "end_cities" | "minecraft:end_cities" | "ocean_ruins" | "minecraft:ocean_ruins" | "shipwrecks" | "minecraft:shipwrecks" | "woodland_mansions" | "minecraft:woodland_mansions" | "buried_treasures" | "minecraft:buried_treasures" | "villages" | "minecraft:villages" | "nether_complexes" | "minecraft:nether_complexes" | "ocean_monuments" | "minecraft:ocean_monuments" | "jungle_temples" | "minecraft:jungle_temples" | "nether_fossils" | "minecraft:nether_fossils" | "swamp_huts" | "minecraft:swamp_huts" | "pillager_outposts" | "minecraft:pillager_outposts" | "mineshafts" | "minecraft:mineshafts" | "strongholds" | "minecraft:strongholds" | "ruined_portals" | "minecraft:ruined_portals";
    type ConfiguredStructureFeature = "desert_pyramid" | "minecraft:desert_pyramid" | "village_taiga" | "minecraft:village_taiga" | "ruined_portal_swamp" | "minecraft:ruined_portal_swamp" | "nether_fossil" | "minecraft:nether_fossil" | "bastion_remnant" | "minecraft:bastion_remnant" | "pillager_outpost" | "minecraft:pillager_outpost" | "shipwreck" | "minecraft:shipwreck" | "mineshaft_mesa" | "minecraft:mineshaft_mesa" | "jungle_pyramid" | "minecraft:jungle_pyramid" | "ruined_portal_jungle" | "minecraft:ruined_portal_jungle" | "swamp_hut" | "minecraft:swamp_hut" | "ocean_ruin_warm" | "minecraft:ocean_ruin_warm" | "village_plains" | "minecraft:village_plains" | "ruined_portal" | "minecraft:ruined_portal" | "buried_treasure" | "minecraft:buried_treasure" | "mansion" | "minecraft:mansion" | "ruined_portal_desert" | "minecraft:ruined_portal_desert" | "end_city" | "minecraft:end_city" | "mineshaft" | "minecraft:mineshaft" | "monument" | "minecraft:monument" | "igloo" | "minecraft:igloo" | "ruined_portal_ocean" | "minecraft:ruined_portal_ocean" | "ruined_portal_mountain" | "minecraft:ruined_portal_mountain" | "fortress" | "minecraft:fortress" | "village_savanna" | "minecraft:village_savanna" | "ruined_portal_nether" | "minecraft:ruined_portal_nether" | "shipwreck_beached" | "minecraft:shipwreck_beached" | "stronghold" | "minecraft:stronghold" | "village_desert" | "minecraft:village_desert" | "ocean_ruin_cold" | "minecraft:ocean_ruin_cold" | "village_snowy" | "minecraft:village_snowy";
    type StructureProcessorList = "zombie_snowy" | "minecraft:zombie_snowy" | "roof" | "minecraft:roof" | "bottom_rampart" | "minecraft:bottom_rampart" | "entrance_replacement" | "minecraft:entrance_replacement" | "treasure_rooms" | "minecraft:treasure_rooms" | "farm_desert" | "minecraft:farm_desert" | "zombie_plains" | "minecraft:zombie_plains" | "outpost_rot" | "minecraft:outpost_rot" | "fossil_rot" | "minecraft:fossil_rot" | "zombie_desert" | "minecraft:zombie_desert" | "farm_plains" | "minecraft:farm_plains" | "fossil_coal" | "minecraft:fossil_coal" | "rampart_degradation" | "minecraft:rampart_degradation" | "empty" | "minecraft:empty" | "mossify_70_percent" | "minecraft:mossify_70_percent" | "high_rampart" | "minecraft:high_rampart" | "bastion_generic_degradation" | "minecraft:bastion_generic_degradation" | "mossify_10_percent" | "minecraft:mossify_10_percent" | "street_snowy_or_taiga" | "minecraft:street_snowy_or_taiga" | "farm_taiga" | "minecraft:farm_taiga" | "stable_degradation" | "minecraft:stable_degradation" | "zombie_taiga" | "minecraft:zombie_taiga" | "street_plains" | "minecraft:street_plains" | "street_savanna" | "minecraft:street_savanna" | "mossify_20_percent" | "minecraft:mossify_20_percent" | "zombie_savanna" | "minecraft:zombie_savanna" | "farm_snowy" | "minecraft:farm_snowy" | "farm_savanna" | "minecraft:farm_savanna" | "fossil_diamonds" | "minecraft:fossil_diamonds" | "housing" | "minecraft:housing" | "side_wall_degradation" | "minecraft:side_wall_degradation" | "bridge" | "minecraft:bridge" | "high_wall" | "minecraft:high_wall";
    type DensityFunction = "overworld_large_biomes/erosion" | "minecraft:overworld_large_biomes/erosion" | "shift_x" | "minecraft:shift_x" | "overworld/caves/spaghetti_2d" | "minecraft:overworld/caves/spaghetti_2d" | "overworld/caves/noodle" | "minecraft:overworld/caves/noodle" | "overworld_large_biomes/factor" | "minecraft:overworld_large_biomes/factor" | "overworld/depth" | "minecraft:overworld/depth" | "overworld/continents" | "minecraft:overworld/continents" | "zero" | "minecraft:zero" | "overworld/base_3d_noise" | "minecraft:overworld/base_3d_noise" | "overworld/caves/pillars" | "minecraft:overworld/caves/pillars" | "overworld_large_biomes/continents" | "minecraft:overworld_large_biomes/continents" | "overworld_large_biomes/sloped_cheese" | "minecraft:overworld_large_biomes/sloped_cheese" | "overworld/caves/spaghetti_2d_thickness_modulator" | "minecraft:overworld/caves/spaghetti_2d_thickness_modulator" | "overworld_large_biomes/depth" | "minecraft:overworld_large_biomes/depth" | "overworld/erosion" | "minecraft:overworld/erosion" | "overworld/sloped_cheese" | "minecraft:overworld/sloped_cheese" | "overworld/factor" | "minecraft:overworld/factor" | "overworld/ridges" | "minecraft:overworld/ridges" | "end/sloped_cheese" | "minecraft:end/sloped_cheese" | "overworld/caves/spaghetti_roughness_function" | "minecraft:overworld/caves/spaghetti_roughness_function" | "overworld/caves/entrances" | "minecraft:overworld/caves/entrances" | "y" | "minecraft:y" | "shift_z" | "minecraft:shift_z";
    type Biome = "badlands" | "minecraft:badlands" | "bamboo_jungle" | "minecraft:bamboo_jungle" | "basalt_deltas" | "minecraft:basalt_deltas" | "beach" | "minecraft:beach" | "birch_forest" | "minecraft:birch_forest" | "cold_ocean" | "minecraft:cold_ocean" | "crimson_forest" | "minecraft:crimson_forest" | "dark_forest" | "minecraft:dark_forest" | "deep_cold_ocean" | "minecraft:deep_cold_ocean" | "deep_frozen_ocean" | "minecraft:deep_frozen_ocean" | "deep_lukewarm_ocean" | "minecraft:deep_lukewarm_ocean" | "deep_ocean" | "minecraft:deep_ocean" | "desert" | "minecraft:desert" | "dripstone_caves" | "minecraft:dripstone_caves" | "end_barrens" | "minecraft:end_barrens" | "end_highlands" | "minecraft:end_highlands" | "end_midlands" | "minecraft:end_midlands" | "eroded_badlands" | "minecraft:eroded_badlands" | "flower_forest" | "minecraft:flower_forest" | "forest" | "minecraft:forest" | "frozen_ocean" | "minecraft:frozen_ocean" | "frozen_peaks" | "minecraft:frozen_peaks" | "frozen_river" | "minecraft:frozen_river" | "grove" | "minecraft:grove" | "ice_spikes" | "minecraft:ice_spikes" | "jagged_peaks" | "minecraft:jagged_peaks" | "jungle" | "minecraft:jungle" | "lukewarm_ocean" | "minecraft:lukewarm_ocean" | "lush_caves" | "minecraft:lush_caves" | "meadow" | "minecraft:meadow" | "mushroom_fields" | "minecraft:mushroom_fields" | "nether_wastes" | "minecraft:nether_wastes" | "ocean" | "minecraft:ocean" | "old_growth_birch_forest" | "minecraft:old_growth_birch_forest" | "old_growth_pine_taiga" | "minecraft:old_growth_pine_taiga" | "old_growth_spruce_taiga" | "minecraft:old_growth_spruce_taiga" | "plains" | "minecraft:plains" | "river" | "minecraft:river" | "savanna" | "minecraft:savanna" | "savanna_plateau" | "minecraft:savanna_plateau" | "small_end_islands" | "minecraft:small_end_islands" | "snowy_beach" | "minecraft:snowy_beach" | "snowy_plains" | "minecraft:snowy_plains" | "snowy_slopes" | "minecraft:snowy_slopes" | "snowy_taiga" | "minecraft:snowy_taiga" | "soul_sand_valley" | "minecraft:soul_sand_valley" | "sparse_jungle" | "minecraft:sparse_jungle" | "stony_peaks" | "minecraft:stony_peaks" | "stony_shore" | "minecraft:stony_shore" | "sunflower_plains" | "minecraft:sunflower_plains" | "swamp" | "minecraft:swamp" | "taiga" | "minecraft:taiga" | "the_end" | "minecraft:the_end" | "the_void" | "minecraft:the_void" | "warm_ocean" | "minecraft:warm_ocean" | "warped_forest" | "minecraft:warped_forest" | "windswept_forest" | "minecraft:windswept_forest" | "windswept_gravelly_hills" | "minecraft:windswept_gravelly_hills" | "windswept_hills" | "minecraft:windswept_hills" | "windswept_savanna" | "minecraft:windswept_savanna" | "wooded_badlands" | "minecraft:wooded_badlands";
    type PlacedFeature = "disk_sand" | "minecraft:disk_sand" | "spruce_checked" | "minecraft:spruce_checked" | "patch_large_fern" | "minecraft:patch_large_fern" | "trees_old_growth_pine_taiga" | "minecraft:trees_old_growth_pine_taiga" | "spring_open" | "minecraft:spring_open" | "flower_meadow" | "minecraft:flower_meadow" | "patch_grass_taiga" | "minecraft:patch_grass_taiga" | "blue_ice" | "minecraft:blue_ice" | "sea_pickle" | "minecraft:sea_pickle" | "blackstone_blobs" | "minecraft:blackstone_blobs" | "ore_granite_lower" | "minecraft:ore_granite_lower" | "patch_crimson_roots" | "minecraft:patch_crimson_roots" | "ore_copper" | "minecraft:ore_copper" | "patch_tall_grass" | "minecraft:patch_tall_grass" | "trees_jungle" | "minecraft:trees_jungle" | "amethyst_geode" | "minecraft:amethyst_geode" | "ore_copper_large" | "minecraft:ore_copper_large" | "monster_room_deep" | "minecraft:monster_room_deep" | "lush_caves_ceiling_vegetation" | "minecraft:lush_caves_ceiling_vegetation" | "ore_soul_sand" | "minecraft:ore_soul_sand" | "fancy_oak_bees_0002" | "minecraft:fancy_oak_bees_0002" | "flower_default" | "minecraft:flower_default" | "trees_meadow" | "minecraft:trees_meadow" | "patch_berry_rare" | "minecraft:patch_berry_rare" | "patch_cactus" | "minecraft:patch_cactus" | "birch_checked" | "minecraft:birch_checked" | "trees_savanna" | "minecraft:trees_savanna" | "patch_sunflower" | "minecraft:patch_sunflower" | "trees_flower_forest" | "minecraft:trees_flower_forest" | "red_mushroom_taiga" | "minecraft:red_mushroom_taiga" | "bamboo_vegetation" | "minecraft:bamboo_vegetation" | "end_island_decorated" | "minecraft:end_island_decorated" | "ice_patch" | "minecraft:ice_patch" | "red_mushroom_normal" | "minecraft:red_mushroom_normal" | "basalt_blobs" | "minecraft:basalt_blobs" | "patch_cactus_desert" | "minecraft:patch_cactus_desert" | "red_mushroom_nether" | "minecraft:red_mushroom_nether" | "ore_coal_lower" | "minecraft:ore_coal_lower" | "crimson_forest_vegetation" | "minecraft:crimson_forest_vegetation" | "crimson_fungi" | "minecraft:crimson_fungi" | "forest_rock" | "minecraft:forest_rock" | "ore_gold_nether" | "minecraft:ore_gold_nether" | "pointed_dripstone" | "minecraft:pointed_dripstone" | "patch_grass_savanna" | "minecraft:patch_grass_savanna" | "disk_clay" | "minecraft:disk_clay" | "ore_quartz_deltas" | "minecraft:ore_quartz_deltas" | "jungle_bush" | "minecraft:jungle_bush" | "underwater_magma" | "minecraft:underwater_magma" | "birch_bees_002" | "minecraft:birch_bees_002" | "patch_grass_badlands" | "minecraft:patch_grass_badlands" | "large_dripstone" | "minecraft:large_dripstone" | "flower_flower_forest" | "minecraft:flower_flower_forest" | "lush_caves_clay" | "minecraft:lush_caves_clay" | "void_start_platform" | "minecraft:void_start_platform" | "classic_vines_cave_feature" | "minecraft:classic_vines_cave_feature" | "trees_badlands" | "minecraft:trees_badlands" | "kelp_cold" | "minecraft:kelp_cold" | "spring_water" | "minecraft:spring_water" | "ore_debris_small" | "minecraft:ore_debris_small" | "ore_blackstone" | "minecraft:ore_blackstone" | "birch_tall" | "minecraft:birch_tall" | "brown_mushroom_swamp" | "minecraft:brown_mushroom_swamp" | "fossil_lower" | "minecraft:fossil_lower" | "oak_checked" | "minecraft:oak_checked" | "patch_pumpkin" | "minecraft:patch_pumpkin" | "forest_flowers" | "minecraft:forest_flowers" | "seagrass_swamp" | "minecraft:seagrass_swamp" | "ore_diamond" | "minecraft:ore_diamond" | "spruce_on_snow" | "minecraft:spruce_on_snow" | "trees_snowy" | "minecraft:trees_snowy" | "spring_lava_frozen" | "minecraft:spring_lava_frozen" | "disk_gravel" | "minecraft:disk_gravel" | "patch_dead_bush_2" | "minecraft:patch_dead_bush_2" | "nether_sprouts" | "minecraft:nether_sprouts" | "birch_bees_0002" | "minecraft:birch_bees_0002" | "oak" | "minecraft:oak" | "dark_oak_checked" | "minecraft:dark_oak_checked" | "glowstone" | "minecraft:glowstone" | "super_birch_bees" | "minecraft:super_birch_bees" | "seagrass_simple" | "minecraft:seagrass_simple" | "trees_taiga" | "minecraft:trees_taiga" | "ore_clay" | "minecraft:ore_clay" | "ore_gold" | "minecraft:ore_gold" | "seagrass_warm" | "minecraft:seagrass_warm" | "ice_spike" | "minecraft:ice_spike" | "patch_sugar_cane_badlands" | "minecraft:patch_sugar_cane_badlands" | "acacia" | "minecraft:acacia" | "ore_diamond_large" | "minecraft:ore_diamond_large" | "dripstone_cluster" | "minecraft:dripstone_cluster" | "trees_grove" | "minecraft:trees_grove" | "pile_ice" | "minecraft:pile_ice" | "ore_infested" | "minecraft:ore_infested" | "super_birch_bees_0002" | "minecraft:super_birch_bees_0002" | "patch_cactus_decorated" | "minecraft:patch_cactus_decorated" | "flower_plain" | "minecraft:flower_plain" | "ore_gold_deltas" | "minecraft:ore_gold_deltas" | "patch_melon_sparse" | "minecraft:patch_melon_sparse" | "spring_closed_double" | "minecraft:spring_closed_double" | "ore_iron_small" | "minecraft:ore_iron_small" | "ore_gravel" | "minecraft:ore_gravel" | "cave_vines" | "minecraft:cave_vines" | "brown_mushroom_taiga" | "minecraft:brown_mushroom_taiga" | "bamboo_light" | "minecraft:bamboo_light" | "brown_mushroom_normal" | "minecraft:brown_mushroom_normal" | "patch_grass_jungle" | "minecraft:patch_grass_jungle" | "ore_diamond_buried" | "minecraft:ore_diamond_buried" | "spring_lava" | "minecraft:spring_lava" | "trees_birch" | "minecraft:trees_birch" | "pile_snow" | "minecraft:pile_snow" | "ore_gravel_nether" | "minecraft:ore_gravel_nether" | "patch_sugar_cane_desert" | "minecraft:patch_sugar_cane_desert" | "patch_melon" | "minecraft:patch_melon" | "pine_checked" | "minecraft:pine_checked" | "flower_plains" | "minecraft:flower_plains" | "mega_jungle_tree_checked" | "minecraft:mega_jungle_tree_checked" | "vines" | "minecraft:vines" | "seagrass_deep" | "minecraft:seagrass_deep" | "fancy_oak_bees_002" | "minecraft:fancy_oak_bees_002" | "patch_berry_common" | "minecraft:patch_berry_common" | "ore_lapis" | "minecraft:ore_lapis" | "seagrass_cold" | "minecraft:seagrass_cold" | "iceberg_blue" | "minecraft:iceberg_blue" | "ore_magma" | "minecraft:ore_magma" | "trees_water" | "minecraft:trees_water" | "freeze_top_layer" | "minecraft:freeze_top_layer" | "red_mushroom_old_growth" | "minecraft:red_mushroom_old_growth" | "ore_iron_middle" | "minecraft:ore_iron_middle" | "fancy_oak_checked" | "minecraft:fancy_oak_checked" | "spore_blossom" | "minecraft:spore_blossom" | "grass_bonemeal" | "minecraft:grass_bonemeal" | "ore_gold_extra" | "minecraft:ore_gold_extra" | "end_spike" | "minecraft:end_spike" | "ore_lapis_buried" | "minecraft:ore_lapis_buried" | "trees_swamp" | "minecraft:trees_swamp" | "ore_granite_upper" | "minecraft:ore_granite_upper" | "oak_bees_002" | "minecraft:oak_bees_002" | "glowstone_extra" | "minecraft:glowstone_extra" | "seagrass_river" | "minecraft:seagrass_river" | "flower_warm" | "minecraft:flower_warm" | "lush_caves_vegetation" | "minecraft:lush_caves_vegetation" | "pile_hay" | "minecraft:pile_hay" | "basalt_pillar" | "minecraft:basalt_pillar" | "monster_room" | "minecraft:monster_room" | "jungle_tree" | "minecraft:jungle_tree" | "trees_windswept_hills" | "minecraft:trees_windswept_hills" | "patch_grass_forest" | "minecraft:patch_grass_forest" | "patch_soul_fire" | "minecraft:patch_soul_fire" | "spruce" | "minecraft:spruce" | "seagrass_deep_cold" | "minecraft:seagrass_deep_cold" | "ore_andesite_upper" | "minecraft:ore_andesite_upper" | "fossil_upper" | "minecraft:fossil_upper" | "lake_lava_surface" | "minecraft:lake_lava_surface" | "ore_iron_upper" | "minecraft:ore_iron_upper" | "weeping_vines" | "minecraft:weeping_vines" | "trees_windswept_forest" | "minecraft:trees_windswept_forest" | "ore_tuff" | "minecraft:ore_tuff" | "patch_dead_bush_badlands" | "minecraft:patch_dead_bush_badlands" | "ore_coal_upper" | "minecraft:ore_coal_upper" | "mega_pine_checked" | "minecraft:mega_pine_checked" | "end_gateway_return" | "minecraft:end_gateway_return" | "small_basalt_columns" | "minecraft:small_basalt_columns" | "trees_birch_and_oak" | "minecraft:trees_birch_and_oak" | "trees_old_growth_spruce_taiga" | "minecraft:trees_old_growth_spruce_taiga" | "chorus_plant" | "minecraft:chorus_plant" | "ore_dirt" | "minecraft:ore_dirt" | "desert_well" | "minecraft:desert_well" | "ore_diorite_upper" | "minecraft:ore_diorite_upper" | "patch_grass_plain" | "minecraft:patch_grass_plain" | "warped_fungi" | "minecraft:warped_fungi" | "patch_fire" | "minecraft:patch_fire" | "patch_tall_grass_2" | "minecraft:patch_tall_grass_2" | "acacia_checked" | "minecraft:acacia_checked" | "fancy_oak_bees" | "minecraft:fancy_oak_bees" | "warm_ocean_vegetation" | "minecraft:warm_ocean_vegetation" | "flower_forest_flowers" | "minecraft:flower_forest_flowers" | "trees_windswept_savanna" | "minecraft:trees_windswept_savanna" | "delta" | "minecraft:delta" | "ore_ancient_debris_large" | "minecraft:ore_ancient_debris_large" | "ore_diorite_lower" | "minecraft:ore_diorite_lower" | "flower_swamp" | "minecraft:flower_swamp" | "trees_plains" | "minecraft:trees_plains" | "patch_taiga_grass" | "minecraft:patch_taiga_grass" | "spring_closed" | "minecraft:spring_closed" | "ore_andesite_lower" | "minecraft:ore_andesite_lower" | "large_basalt_columns" | "minecraft:large_basalt_columns" | "mega_spruce_checked" | "minecraft:mega_spruce_checked" | "warped_forest_vegetation" | "minecraft:warped_forest_vegetation" | "patch_grass_normal" | "minecraft:patch_grass_normal" | "ore_quartz_nether" | "minecraft:ore_quartz_nether" | "pile_pumpkin" | "minecraft:pile_pumpkin" | "brown_mushroom_nether" | "minecraft:brown_mushroom_nether" | "twisting_vines" | "minecraft:twisting_vines" | "patch_waterlily" | "minecraft:patch_waterlily" | "dark_forest_vegetation" | "minecraft:dark_forest_vegetation" | "kelp_warm" | "minecraft:kelp_warm" | "patch_sugar_cane" | "minecraft:patch_sugar_cane" | "iceberg_packed" | "minecraft:iceberg_packed" | "patch_grass_taiga_2" | "minecraft:patch_grass_taiga_2" | "brown_mushroom_old_growth" | "minecraft:brown_mushroom_old_growth" | "seagrass_normal" | "minecraft:seagrass_normal" | "spring_delta" | "minecraft:spring_delta" | "ore_gold_lower" | "minecraft:ore_gold_lower" | "mushroom_island_vegetation" | "minecraft:mushroom_island_vegetation" | "ore_emerald" | "minecraft:ore_emerald" | "patch_sugar_cane_swamp" | "minecraft:patch_sugar_cane_swamp" | "trees_sparse_jungle" | "minecraft:trees_sparse_jungle" | "seagrass_deep_warm" | "minecraft:seagrass_deep_warm" | "rooted_azalea_tree" | "minecraft:rooted_azalea_tree" | "pine" | "minecraft:pine" | "oak_bees_0002" | "minecraft:oak_bees_0002" | "pine_on_snow" | "minecraft:pine_on_snow" | "glow_lichen" | "minecraft:glow_lichen" | "patch_dead_bush" | "minecraft:patch_dead_bush" | "bamboo" | "minecraft:bamboo" | "ore_redstone_lower" | "minecraft:ore_redstone_lower" | "red_mushroom_swamp" | "minecraft:red_mushroom_swamp" | "ore_redstone" | "minecraft:ore_redstone" | "pile_melon" | "minecraft:pile_melon" | "patch_berry_bush" | "minecraft:patch_berry_bush" | "lake_lava_underground" | "minecraft:lake_lava_underground";
    type NoiseGeneratorSettings = "nether" | "minecraft:nether" | "floating_islands" | "minecraft:floating_islands" | "overworld" | "minecraft:overworld" | "amplified" | "minecraft:amplified" | "caves" | "minecraft:caves" | "end" | "minecraft:end" | "large_biomes" | "minecraft:large_biomes";
    type ConfiguredWorldCarver = "canyon" | "minecraft:canyon" | "cave_extra_underground" | "minecraft:cave_extra_underground" | "nether_cave" | "minecraft:nether_cave" | "cave" | "minecraft:cave";
    type StructureTemplatePool = "village/desert/streets" | "minecraft:village/desert/streets" | "bastion/hoglin_stable/connectors" | "minecraft:bastion/hoglin_stable/connectors" | "bastion/treasure/brains" | "minecraft:bastion/treasure/brains" | "bastion/blocks/gold" | "minecraft:bastion/blocks/gold" | "village/savanna/houses" | "minecraft:village/savanna/houses" | "village/common/sheep" | "minecraft:village/common/sheep" | "village/snowy/terminators" | "minecraft:village/snowy/terminators" | "bastion/units/rampart_plates" | "minecraft:bastion/units/rampart_plates" | "bastion/treasure/roofs" | "minecraft:bastion/treasure/roofs" | "village/taiga/town_centers" | "minecraft:village/taiga/town_centers" | "bastion/treasure/corners/top" | "minecraft:bastion/treasure/corners/top" | "village/common/well_bottoms" | "minecraft:village/common/well_bottoms" | "village/snowy/zombie/villagers" | "minecraft:village/snowy/zombie/villagers" | "village/desert/zombie/decor" | "minecraft:village/desert/zombie/decor" | "village/savanna/zombie/villagers" | "minecraft:village/savanna/zombie/villagers" | "bastion/mobs/hoglin" | "minecraft:bastion/mobs/hoglin" | "village/snowy/streets" | "minecraft:village/snowy/streets" | "village/savanna/town_centers" | "minecraft:village/savanna/town_centers" | "village/taiga/streets" | "minecraft:village/taiga/streets" | "bastion/bridge/legs" | "minecraft:bastion/bridge/legs" | "village/taiga/terminators" | "minecraft:village/taiga/terminators" | "bastion/hoglin_stable/small_stables/outer" | "minecraft:bastion/hoglin_stable/small_stables/outer" | "bastion/treasure/extensions/houses" | "minecraft:bastion/treasure/extensions/houses" | "bastion/units/stages/stage_1" | "minecraft:bastion/units/stages/stage_1" | "bastion/units/stages/stage_2" | "minecraft:bastion/units/stages/stage_2" | "bastion/units/stages/stage_3" | "minecraft:bastion/units/stages/stage_3" | "bastion/hoglin_stable/stairs" | "minecraft:bastion/hoglin_stable/stairs" | "village/snowy/town_centers" | "minecraft:village/snowy/town_centers" | "bastion/hoglin_stable/wall_bases" | "minecraft:bastion/hoglin_stable/wall_bases" | "village/taiga/zombie/decor" | "minecraft:village/taiga/zombie/decor" | "bastion/treasure/extensions/small_pool" | "minecraft:bastion/treasure/extensions/small_pool" | "bastion/treasure/walls/bottom" | "minecraft:bastion/treasure/walls/bottom" | "village/desert/zombie/houses" | "minecraft:village/desert/zombie/houses" | "village/common/cats" | "minecraft:village/common/cats" | "bastion/units/stages/stage_0" | "minecraft:bastion/units/stages/stage_0" | "pillager_outpost/feature_plates" | "minecraft:pillager_outpost/feature_plates" | "village/desert/zombie/terminators" | "minecraft:village/desert/zombie/terminators" | "bastion/hoglin_stable/posts" | "minecraft:bastion/hoglin_stable/posts" | "pillager_outpost/towers" | "minecraft:pillager_outpost/towers" | "bastion/treasure/walls/mid" | "minecraft:bastion/treasure/walls/mid" | "village/common/butcher_animals" | "minecraft:village/common/butcher_animals" | "bastion/hoglin_stable/starting_pieces" | "minecraft:bastion/hoglin_stable/starting_pieces" | "village/savanna/decor" | "minecraft:village/savanna/decor" | "bastion/units/pathways" | "minecraft:bastion/units/pathways" | "village/plains/trees" | "minecraft:village/plains/trees" | "village/taiga/decor" | "minecraft:village/taiga/decor" | "bastion/treasure/ramparts" | "minecraft:bastion/treasure/ramparts" | "village/plains/streets" | "minecraft:village/plains/streets" | "empty" | "minecraft:empty" | "bastion/treasure/bases/centers" | "minecraft:bastion/treasure/bases/centers" | "village/desert/decor" | "minecraft:village/desert/decor" | "bastion/bridge/starting_pieces" | "minecraft:bastion/bridge/starting_pieces" | "bastion/treasure/corners/middle" | "minecraft:bastion/treasure/corners/middle" | "village/common/iron_golem" | "minecraft:village/common/iron_golem" | "pillager_outpost/features" | "minecraft:pillager_outpost/features" | "village/taiga/zombie/villagers" | "minecraft:village/taiga/zombie/villagers" | "bastion/hoglin_stable/large_stables/outer" | "minecraft:bastion/hoglin_stable/large_stables/outer" | "bastion/units/wall_units" | "minecraft:bastion/units/wall_units" | "bastion/treasure/corners/edges" | "minecraft:bastion/treasure/corners/edges" | "bastion/bridge/ramparts" | "minecraft:bastion/bridge/ramparts" | "village/desert/zombie/streets" | "minecraft:village/desert/zombie/streets" | "village/savanna/villagers" | "minecraft:village/savanna/villagers" | "bastion/treasure/stairs" | "minecraft:bastion/treasure/stairs" | "village/plains/decor" | "minecraft:village/plains/decor" | "village/snowy/trees" | "minecraft:village/snowy/trees" | "village/savanna/zombie/decor" | "minecraft:village/savanna/zombie/decor" | "bastion/bridge/connectors" | "minecraft:bastion/bridge/connectors" | "village/snowy/zombie/streets" | "minecraft:village/snowy/zombie/streets" | "bastion/units/edge_wall_units" | "minecraft:bastion/units/edge_wall_units" | "bastion/units/walls/wall_bases" | "minecraft:bastion/units/walls/wall_bases" | "village/desert/villagers" | "minecraft:village/desert/villagers" | "village/savanna/trees" | "minecraft:village/savanna/trees" | "bastion/treasure/bases" | "minecraft:bastion/treasure/bases" | "village/plains/zombie/decor" | "minecraft:village/plains/zombie/decor" | "bastion/mobs/piglin_melee" | "minecraft:bastion/mobs/piglin_melee" | "village/savanna/terminators" | "minecraft:village/savanna/terminators" | "bastion/hoglin_stable/walls" | "minecraft:bastion/hoglin_stable/walls" | "village/snowy/decor" | "minecraft:village/snowy/decor" | "village/snowy/villagers" | "minecraft:village/snowy/villagers" | "village/plains/terminators" | "minecraft:village/plains/terminators" | "bastion/units/edges" | "minecraft:bastion/units/edges" | "village/desert/terminators" | "minecraft:village/desert/terminators" | "pillager_outpost/base_plates" | "minecraft:pillager_outpost/base_plates" | "bastion/hoglin_stable/rampart_plates" | "minecraft:bastion/hoglin_stable/rampart_plates" | "village/plains/houses" | "minecraft:village/plains/houses" | "village/taiga/villagers" | "minecraft:village/taiga/villagers" | "bastion/units/fillers/stage_0" | "minecraft:bastion/units/fillers/stage_0" | "village/plains/town_centers" | "minecraft:village/plains/town_centers" | "bastion/treasure/walls/top" | "minecraft:bastion/treasure/walls/top" | "village/taiga/zombie/houses" | "minecraft:village/taiga/zombie/houses" | "bastion/treasure/entrances" | "minecraft:bastion/treasure/entrances" | "village/plains/zombie/streets" | "minecraft:village/plains/zombie/streets" | "bastion/hoglin_stable/small_stables/inner" | "minecraft:bastion/hoglin_stable/small_stables/inner" | "village/snowy/zombie/decor" | "minecraft:village/snowy/zombie/decor" | "bastion/treasure/corners/bottom" | "minecraft:bastion/treasure/corners/bottom" | "bastion/units/large_ramparts" | "minecraft:bastion/units/large_ramparts" | "village/plains/villagers" | "minecraft:village/plains/villagers" | "bastion/units/stages/rot/stage_1" | "minecraft:bastion/units/stages/rot/stage_1" | "bastion/units/ramparts" | "minecraft:bastion/units/ramparts" | "bastion/bridge/rampart_plates" | "minecraft:bastion/bridge/rampart_plates" | "bastion/treasure/connectors" | "minecraft:bastion/treasure/connectors" | "village/savanna/streets" | "minecraft:village/savanna/streets" | "bastion/units/center_pieces" | "minecraft:bastion/units/center_pieces" | "bastion/bridge/bridge_pieces" | "minecraft:bastion/bridge/bridge_pieces" | "village/plains/zombie/houses" | "minecraft:village/plains/zombie/houses" | "village/taiga/houses" | "minecraft:village/taiga/houses" | "bastion/hoglin_stable/mirrored_starting_pieces" | "minecraft:bastion/hoglin_stable/mirrored_starting_pieces" | "bastion/mobs/piglin" | "minecraft:bastion/mobs/piglin" | "village/desert/zombie/villagers" | "minecraft:village/desert/zombie/villagers" | "bastion/treasure/walls/outer" | "minecraft:bastion/treasure/walls/outer" | "village/plains/zombie/villagers" | "minecraft:village/plains/zombie/villagers" | "bastion/treasure/extensions/large_pool" | "minecraft:bastion/treasure/extensions/large_pool" | "village/desert/houses" | "minecraft:village/desert/houses" | "bastion/starts" | "minecraft:bastion/starts" | "village/common/animals" | "minecraft:village/common/animals" | "bastion/hoglin_stable/large_stables/inner" | "minecraft:bastion/hoglin_stable/large_stables/inner" | "bastion/bridge/walls" | "minecraft:bastion/bridge/walls" | "village/taiga/zombie/streets" | "minecraft:village/taiga/zombie/streets" | "village/savanna/zombie/streets" | "minecraft:village/savanna/zombie/streets" | "bastion/treasure/walls" | "minecraft:bastion/treasure/walls" | "village/snowy/houses" | "minecraft:village/snowy/houses" | "village/savanna/zombie/terminators" | "minecraft:village/savanna/zombie/terminators" | "village/desert/town_centers" | "minecraft:village/desert/town_centers" | "bastion/hoglin_stable/ramparts" | "minecraft:bastion/hoglin_stable/ramparts" | "village/snowy/zombie/houses" | "minecraft:village/snowy/zombie/houses" | "village/savanna/zombie/houses" | "minecraft:village/savanna/zombie/houses";
    type GameEvent = "block_destroy" | "minecraft:block_destroy" | "container_close" | "minecraft:container_close" | "shear" | "minecraft:shear" | "wolf_shaking" | "minecraft:wolf_shaking" | "lightning_strike" | "minecraft:lightning_strike" | "block_place" | "minecraft:block_place" | "entity_killed" | "minecraft:entity_killed" | "ravager_roar" | "minecraft:ravager_roar" | "entity_place" | "minecraft:entity_place" | "prime_fuse" | "minecraft:prime_fuse" | "hit_ground" | "minecraft:hit_ground" | "shulker_close" | "minecraft:shulker_close" | "block_open" | "minecraft:block_open" | "entity_damaged" | "minecraft:entity_damaged" | "shulker_open" | "minecraft:shulker_open" | "block_unswitch" | "minecraft:block_unswitch" | "block_change" | "minecraft:block_change" | "block_press" | "minecraft:block_press" | "drinking_finish" | "minecraft:drinking_finish" | "fishing_rod_reel_in" | "minecraft:fishing_rod_reel_in" | "eat" | "minecraft:eat" | "elytra_free_fall" | "minecraft:elytra_free_fall" | "ring_bell" | "minecraft:ring_bell" | "explode" | "minecraft:explode" | "dispense_fail" | "minecraft:dispense_fail" | "piston_extend" | "minecraft:piston_extend" | "block_attach" | "minecraft:block_attach" | "projectile_shoot" | "minecraft:projectile_shoot" | "mob_interact" | "minecraft:mob_interact" | "flap" | "minecraft:flap" | "block_detach" | "minecraft:block_detach" | "projectile_land" | "minecraft:projectile_land" | "block_close" | "minecraft:block_close" | "minecart_moving" | "minecraft:minecart_moving" | "splash" | "minecraft:splash" | "fluid_place" | "minecraft:fluid_place" | "container_open" | "minecraft:container_open" | "fluid_pickup" | "minecraft:fluid_pickup" | "equip" | "minecraft:equip" | "block_unpress" | "minecraft:block_unpress" | "step" | "minecraft:step" | "fishing_rod_cast" | "minecraft:fishing_rod_cast" | "swim" | "minecraft:swim" | "block_switch" | "minecraft:block_switch" | "piston_contract" | "minecraft:piston_contract";
    type SoundEvent = "ambient.basalt_deltas.additions" | "minecraft:ambient.basalt_deltas.additions" | "ambient.basalt_deltas.loop" | "minecraft:ambient.basalt_deltas.loop" | "ambient.basalt_deltas.mood" | "minecraft:ambient.basalt_deltas.mood" | "ambient.cave" | "minecraft:ambient.cave" | "ambient.crimson_forest.additions" | "minecraft:ambient.crimson_forest.additions" | "ambient.crimson_forest.loop" | "minecraft:ambient.crimson_forest.loop" | "ambient.crimson_forest.mood" | "minecraft:ambient.crimson_forest.mood" | "ambient.nether_wastes.additions" | "minecraft:ambient.nether_wastes.additions" | "ambient.nether_wastes.loop" | "minecraft:ambient.nether_wastes.loop" | "ambient.nether_wastes.mood" | "minecraft:ambient.nether_wastes.mood" | "ambient.soul_sand_valley.additions" | "minecraft:ambient.soul_sand_valley.additions" | "ambient.soul_sand_valley.loop" | "minecraft:ambient.soul_sand_valley.loop" | "ambient.soul_sand_valley.mood" | "minecraft:ambient.soul_sand_valley.mood" | "ambient.underwater.enter" | "minecraft:ambient.underwater.enter" | "ambient.underwater.exit" | "minecraft:ambient.underwater.exit" | "ambient.underwater.loop" | "minecraft:ambient.underwater.loop" | "ambient.underwater.loop.additions" | "minecraft:ambient.underwater.loop.additions" | "ambient.underwater.loop.additions.rare" | "minecraft:ambient.underwater.loop.additions.rare" | "ambient.underwater.loop.additions.ultra_rare" | "minecraft:ambient.underwater.loop.additions.ultra_rare" | "ambient.warped_forest.additions" | "minecraft:ambient.warped_forest.additions" | "ambient.warped_forest.loop" | "minecraft:ambient.warped_forest.loop" | "ambient.warped_forest.mood" | "minecraft:ambient.warped_forest.mood" | "block.amethyst_block.break" | "minecraft:block.amethyst_block.break" | "block.amethyst_block.chime" | "minecraft:block.amethyst_block.chime" | "block.amethyst_block.fall" | "minecraft:block.amethyst_block.fall" | "block.amethyst_block.hit" | "minecraft:block.amethyst_block.hit" | "block.amethyst_block.place" | "minecraft:block.amethyst_block.place" | "block.amethyst_block.step" | "minecraft:block.amethyst_block.step" | "block.amethyst_cluster.break" | "minecraft:block.amethyst_cluster.break" | "block.amethyst_cluster.fall" | "minecraft:block.amethyst_cluster.fall" | "block.amethyst_cluster.hit" | "minecraft:block.amethyst_cluster.hit" | "block.amethyst_cluster.place" | "minecraft:block.amethyst_cluster.place" | "block.amethyst_cluster.step" | "minecraft:block.amethyst_cluster.step" | "block.ancient_debris.break" | "minecraft:block.ancient_debris.break" | "block.ancient_debris.fall" | "minecraft:block.ancient_debris.fall" | "block.ancient_debris.hit" | "minecraft:block.ancient_debris.hit" | "block.ancient_debris.place" | "minecraft:block.ancient_debris.place" | "block.ancient_debris.step" | "minecraft:block.ancient_debris.step" | "block.anvil.break" | "minecraft:block.anvil.break" | "block.anvil.destroy" | "minecraft:block.anvil.destroy" | "block.anvil.fall" | "minecraft:block.anvil.fall" | "block.anvil.hit" | "minecraft:block.anvil.hit" | "block.anvil.land" | "minecraft:block.anvil.land" | "block.anvil.place" | "minecraft:block.anvil.place" | "block.anvil.step" | "minecraft:block.anvil.step" | "block.anvil.use" | "minecraft:block.anvil.use" | "block.azalea.break" | "minecraft:block.azalea.break" | "block.azalea.fall" | "minecraft:block.azalea.fall" | "block.azalea.hit" | "minecraft:block.azalea.hit" | "block.azalea.place" | "minecraft:block.azalea.place" | "block.azalea.step" | "minecraft:block.azalea.step" | "block.azalea_leaves.break" | "minecraft:block.azalea_leaves.break" | "block.azalea_leaves.fall" | "minecraft:block.azalea_leaves.fall" | "block.azalea_leaves.hit" | "minecraft:block.azalea_leaves.hit" | "block.azalea_leaves.place" | "minecraft:block.azalea_leaves.place" | "block.azalea_leaves.step" | "minecraft:block.azalea_leaves.step" | "block.bamboo.break" | "minecraft:block.bamboo.break" | "block.bamboo.fall" | "minecraft:block.bamboo.fall" | "block.bamboo.hit" | "minecraft:block.bamboo.hit" | "block.bamboo.place" | "minecraft:block.bamboo.place" | "block.bamboo.step" | "minecraft:block.bamboo.step" | "block.bamboo_sapling.break" | "minecraft:block.bamboo_sapling.break" | "block.bamboo_sapling.hit" | "minecraft:block.bamboo_sapling.hit" | "block.bamboo_sapling.place" | "minecraft:block.bamboo_sapling.place" | "block.barrel.close" | "minecraft:block.barrel.close" | "block.barrel.open" | "minecraft:block.barrel.open" | "block.basalt.break" | "minecraft:block.basalt.break" | "block.basalt.fall" | "minecraft:block.basalt.fall" | "block.basalt.hit" | "minecraft:block.basalt.hit" | "block.basalt.place" | "minecraft:block.basalt.place" | "block.basalt.step" | "minecraft:block.basalt.step" | "block.beacon.activate" | "minecraft:block.beacon.activate" | "block.beacon.ambient" | "minecraft:block.beacon.ambient" | "block.beacon.deactivate" | "minecraft:block.beacon.deactivate" | "block.beacon.power_select" | "minecraft:block.beacon.power_select" | "block.beehive.drip" | "minecraft:block.beehive.drip" | "block.beehive.enter" | "minecraft:block.beehive.enter" | "block.beehive.exit" | "minecraft:block.beehive.exit" | "block.beehive.shear" | "minecraft:block.beehive.shear" | "block.beehive.work" | "minecraft:block.beehive.work" | "block.bell.resonate" | "minecraft:block.bell.resonate" | "block.bell.use" | "minecraft:block.bell.use" | "block.big_dripleaf.break" | "minecraft:block.big_dripleaf.break" | "block.big_dripleaf.fall" | "minecraft:block.big_dripleaf.fall" | "block.big_dripleaf.hit" | "minecraft:block.big_dripleaf.hit" | "block.big_dripleaf.place" | "minecraft:block.big_dripleaf.place" | "block.big_dripleaf.step" | "minecraft:block.big_dripleaf.step" | "block.big_dripleaf.tilt_down" | "minecraft:block.big_dripleaf.tilt_down" | "block.big_dripleaf.tilt_up" | "minecraft:block.big_dripleaf.tilt_up" | "block.blastfurnace.fire_crackle" | "minecraft:block.blastfurnace.fire_crackle" | "block.bone_block.break" | "minecraft:block.bone_block.break" | "block.bone_block.fall" | "minecraft:block.bone_block.fall" | "block.bone_block.hit" | "minecraft:block.bone_block.hit" | "block.bone_block.place" | "minecraft:block.bone_block.place" | "block.bone_block.step" | "minecraft:block.bone_block.step" | "block.brewing_stand.brew" | "minecraft:block.brewing_stand.brew" | "block.bubble_column.bubble_pop" | "minecraft:block.bubble_column.bubble_pop" | "block.bubble_column.upwards_ambient" | "minecraft:block.bubble_column.upwards_ambient" | "block.bubble_column.upwards_inside" | "minecraft:block.bubble_column.upwards_inside" | "block.bubble_column.whirlpool_ambient" | "minecraft:block.bubble_column.whirlpool_ambient" | "block.bubble_column.whirlpool_inside" | "minecraft:block.bubble_column.whirlpool_inside" | "block.cake.add_candle" | "minecraft:block.cake.add_candle" | "block.calcite.break" | "minecraft:block.calcite.break" | "block.calcite.fall" | "minecraft:block.calcite.fall" | "block.calcite.hit" | "minecraft:block.calcite.hit" | "block.calcite.place" | "minecraft:block.calcite.place" | "block.calcite.step" | "minecraft:block.calcite.step" | "block.campfire.crackle" | "minecraft:block.campfire.crackle" | "block.candle.ambient" | "minecraft:block.candle.ambient" | "block.candle.break" | "minecraft:block.candle.break" | "block.candle.extinguish" | "minecraft:block.candle.extinguish" | "block.candle.fall" | "minecraft:block.candle.fall" | "block.candle.hit" | "minecraft:block.candle.hit" | "block.candle.place" | "minecraft:block.candle.place" | "block.candle.step" | "minecraft:block.candle.step" | "block.cave_vines.break" | "minecraft:block.cave_vines.break" | "block.cave_vines.fall" | "minecraft:block.cave_vines.fall" | "block.cave_vines.hit" | "minecraft:block.cave_vines.hit" | "block.cave_vines.pick_berries" | "minecraft:block.cave_vines.pick_berries" | "block.cave_vines.place" | "minecraft:block.cave_vines.place" | "block.cave_vines.step" | "minecraft:block.cave_vines.step" | "block.chain.break" | "minecraft:block.chain.break" | "block.chain.fall" | "minecraft:block.chain.fall" | "block.chain.hit" | "minecraft:block.chain.hit" | "block.chain.place" | "minecraft:block.chain.place" | "block.chain.step" | "minecraft:block.chain.step" | "block.chest.close" | "minecraft:block.chest.close" | "block.chest.locked" | "minecraft:block.chest.locked" | "block.chest.open" | "minecraft:block.chest.open" | "block.chorus_flower.death" | "minecraft:block.chorus_flower.death" | "block.chorus_flower.grow" | "minecraft:block.chorus_flower.grow" | "block.comparator.click" | "minecraft:block.comparator.click" | "block.composter.empty" | "minecraft:block.composter.empty" | "block.composter.fill" | "minecraft:block.composter.fill" | "block.composter.fill_success" | "minecraft:block.composter.fill_success" | "block.composter.ready" | "minecraft:block.composter.ready" | "block.conduit.activate" | "minecraft:block.conduit.activate" | "block.conduit.ambient" | "minecraft:block.conduit.ambient" | "block.conduit.ambient.short" | "minecraft:block.conduit.ambient.short" | "block.conduit.attack.target" | "minecraft:block.conduit.attack.target" | "block.conduit.deactivate" | "minecraft:block.conduit.deactivate" | "block.copper.break" | "minecraft:block.copper.break" | "block.copper.fall" | "minecraft:block.copper.fall" | "block.copper.hit" | "minecraft:block.copper.hit" | "block.copper.place" | "minecraft:block.copper.place" | "block.copper.step" | "minecraft:block.copper.step" | "block.coral_block.break" | "minecraft:block.coral_block.break" | "block.coral_block.fall" | "minecraft:block.coral_block.fall" | "block.coral_block.hit" | "minecraft:block.coral_block.hit" | "block.coral_block.place" | "minecraft:block.coral_block.place" | "block.coral_block.step" | "minecraft:block.coral_block.step" | "block.crop.break" | "minecraft:block.crop.break" | "block.deepslate.break" | "minecraft:block.deepslate.break" | "block.deepslate.fall" | "minecraft:block.deepslate.fall" | "block.deepslate.hit" | "minecraft:block.deepslate.hit" | "block.deepslate.place" | "minecraft:block.deepslate.place" | "block.deepslate.step" | "minecraft:block.deepslate.step" | "block.deepslate_bricks.break" | "minecraft:block.deepslate_bricks.break" | "block.deepslate_bricks.fall" | "minecraft:block.deepslate_bricks.fall" | "block.deepslate_bricks.hit" | "minecraft:block.deepslate_bricks.hit" | "block.deepslate_bricks.place" | "minecraft:block.deepslate_bricks.place" | "block.deepslate_bricks.step" | "minecraft:block.deepslate_bricks.step" | "block.deepslate_tiles.break" | "minecraft:block.deepslate_tiles.break" | "block.deepslate_tiles.fall" | "minecraft:block.deepslate_tiles.fall" | "block.deepslate_tiles.hit" | "minecraft:block.deepslate_tiles.hit" | "block.deepslate_tiles.place" | "minecraft:block.deepslate_tiles.place" | "block.deepslate_tiles.step" | "minecraft:block.deepslate_tiles.step" | "block.dispenser.dispense" | "minecraft:block.dispenser.dispense" | "block.dispenser.fail" | "minecraft:block.dispenser.fail" | "block.dispenser.launch" | "minecraft:block.dispenser.launch" | "block.dripstone_block.break" | "minecraft:block.dripstone_block.break" | "block.dripstone_block.fall" | "minecraft:block.dripstone_block.fall" | "block.dripstone_block.hit" | "minecraft:block.dripstone_block.hit" | "block.dripstone_block.place" | "minecraft:block.dripstone_block.place" | "block.dripstone_block.step" | "minecraft:block.dripstone_block.step" | "block.enchantment_table.use" | "minecraft:block.enchantment_table.use" | "block.end_gateway.spawn" | "minecraft:block.end_gateway.spawn" | "block.end_portal.spawn" | "minecraft:block.end_portal.spawn" | "block.end_portal_frame.fill" | "minecraft:block.end_portal_frame.fill" | "block.ender_chest.close" | "minecraft:block.ender_chest.close" | "block.ender_chest.open" | "minecraft:block.ender_chest.open" | "block.fence_gate.close" | "minecraft:block.fence_gate.close" | "block.fence_gate.open" | "minecraft:block.fence_gate.open" | "block.fire.ambient" | "minecraft:block.fire.ambient" | "block.fire.extinguish" | "minecraft:block.fire.extinguish" | "block.flowering_azalea.break" | "minecraft:block.flowering_azalea.break" | "block.flowering_azalea.fall" | "minecraft:block.flowering_azalea.fall" | "block.flowering_azalea.hit" | "minecraft:block.flowering_azalea.hit" | "block.flowering_azalea.place" | "minecraft:block.flowering_azalea.place" | "block.flowering_azalea.step" | "minecraft:block.flowering_azalea.step" | "block.fungus.break" | "minecraft:block.fungus.break" | "block.fungus.fall" | "minecraft:block.fungus.fall" | "block.fungus.hit" | "minecraft:block.fungus.hit" | "block.fungus.place" | "minecraft:block.fungus.place" | "block.fungus.step" | "minecraft:block.fungus.step" | "block.furnace.fire_crackle" | "minecraft:block.furnace.fire_crackle" | "block.gilded_blackstone.break" | "minecraft:block.gilded_blackstone.break" | "block.gilded_blackstone.fall" | "minecraft:block.gilded_blackstone.fall" | "block.gilded_blackstone.hit" | "minecraft:block.gilded_blackstone.hit" | "block.gilded_blackstone.place" | "minecraft:block.gilded_blackstone.place" | "block.gilded_blackstone.step" | "minecraft:block.gilded_blackstone.step" | "block.glass.break" | "minecraft:block.glass.break" | "block.glass.fall" | "minecraft:block.glass.fall" | "block.glass.hit" | "minecraft:block.glass.hit" | "block.glass.place" | "minecraft:block.glass.place" | "block.glass.step" | "minecraft:block.glass.step" | "block.grass.break" | "minecraft:block.grass.break" | "block.grass.fall" | "minecraft:block.grass.fall" | "block.grass.hit" | "minecraft:block.grass.hit" | "block.grass.place" | "minecraft:block.grass.place" | "block.grass.step" | "minecraft:block.grass.step" | "block.gravel.break" | "minecraft:block.gravel.break" | "block.gravel.fall" | "minecraft:block.gravel.fall" | "block.gravel.hit" | "minecraft:block.gravel.hit" | "block.gravel.place" | "minecraft:block.gravel.place" | "block.gravel.step" | "minecraft:block.gravel.step" | "block.grindstone.use" | "minecraft:block.grindstone.use" | "block.growing_plant.crop" | "minecraft:block.growing_plant.crop" | "block.hanging_roots.break" | "minecraft:block.hanging_roots.break" | "block.hanging_roots.fall" | "minecraft:block.hanging_roots.fall" | "block.hanging_roots.hit" | "minecraft:block.hanging_roots.hit" | "block.hanging_roots.place" | "minecraft:block.hanging_roots.place" | "block.hanging_roots.step" | "minecraft:block.hanging_roots.step" | "block.honey_block.break" | "minecraft:block.honey_block.break" | "block.honey_block.fall" | "minecraft:block.honey_block.fall" | "block.honey_block.hit" | "minecraft:block.honey_block.hit" | "block.honey_block.place" | "minecraft:block.honey_block.place" | "block.honey_block.slide" | "minecraft:block.honey_block.slide" | "block.honey_block.step" | "minecraft:block.honey_block.step" | "block.iron_door.close" | "minecraft:block.iron_door.close" | "block.iron_door.open" | "minecraft:block.iron_door.open" | "block.iron_trapdoor.close" | "minecraft:block.iron_trapdoor.close" | "block.iron_trapdoor.open" | "minecraft:block.iron_trapdoor.open" | "block.ladder.break" | "minecraft:block.ladder.break" | "block.ladder.fall" | "minecraft:block.ladder.fall" | "block.ladder.hit" | "minecraft:block.ladder.hit" | "block.ladder.place" | "minecraft:block.ladder.place" | "block.ladder.step" | "minecraft:block.ladder.step" | "block.lantern.break" | "minecraft:block.lantern.break" | "block.lantern.fall" | "minecraft:block.lantern.fall" | "block.lantern.hit" | "minecraft:block.lantern.hit" | "block.lantern.place" | "minecraft:block.lantern.place" | "block.lantern.step" | "minecraft:block.lantern.step" | "block.large_amethyst_bud.break" | "minecraft:block.large_amethyst_bud.break" | "block.large_amethyst_bud.place" | "minecraft:block.large_amethyst_bud.place" | "block.lava.ambient" | "minecraft:block.lava.ambient" | "block.lava.extinguish" | "minecraft:block.lava.extinguish" | "block.lava.pop" | "minecraft:block.lava.pop" | "block.lever.click" | "minecraft:block.lever.click" | "block.lily_pad.place" | "minecraft:block.lily_pad.place" | "block.lodestone.break" | "minecraft:block.lodestone.break" | "block.lodestone.fall" | "minecraft:block.lodestone.fall" | "block.lodestone.hit" | "minecraft:block.lodestone.hit" | "block.lodestone.place" | "minecraft:block.lodestone.place" | "block.lodestone.step" | "minecraft:block.lodestone.step" | "block.medium_amethyst_bud.break" | "minecraft:block.medium_amethyst_bud.break" | "block.medium_amethyst_bud.place" | "minecraft:block.medium_amethyst_bud.place" | "block.metal.break" | "minecraft:block.metal.break" | "block.metal.fall" | "minecraft:block.metal.fall" | "block.metal.hit" | "minecraft:block.metal.hit" | "block.metal.place" | "minecraft:block.metal.place" | "block.metal.step" | "minecraft:block.metal.step" | "block.metal_pressure_plate.click_off" | "minecraft:block.metal_pressure_plate.click_off" | "block.metal_pressure_plate.click_on" | "minecraft:block.metal_pressure_plate.click_on" | "block.moss.break" | "minecraft:block.moss.break" | "block.moss.fall" | "minecraft:block.moss.fall" | "block.moss.hit" | "minecraft:block.moss.hit" | "block.moss.place" | "minecraft:block.moss.place" | "block.moss.step" | "minecraft:block.moss.step" | "block.moss_carpet.break" | "minecraft:block.moss_carpet.break" | "block.moss_carpet.fall" | "minecraft:block.moss_carpet.fall" | "block.moss_carpet.hit" | "minecraft:block.moss_carpet.hit" | "block.moss_carpet.place" | "minecraft:block.moss_carpet.place" | "block.moss_carpet.step" | "minecraft:block.moss_carpet.step" | "block.nether_bricks.break" | "minecraft:block.nether_bricks.break" | "block.nether_bricks.fall" | "minecraft:block.nether_bricks.fall" | "block.nether_bricks.hit" | "minecraft:block.nether_bricks.hit" | "block.nether_bricks.place" | "minecraft:block.nether_bricks.place" | "block.nether_bricks.step" | "minecraft:block.nether_bricks.step" | "block.nether_gold_ore.break" | "minecraft:block.nether_gold_ore.break" | "block.nether_gold_ore.fall" | "minecraft:block.nether_gold_ore.fall" | "block.nether_gold_ore.hit" | "minecraft:block.nether_gold_ore.hit" | "block.nether_gold_ore.place" | "minecraft:block.nether_gold_ore.place" | "block.nether_gold_ore.step" | "minecraft:block.nether_gold_ore.step" | "block.nether_ore.break" | "minecraft:block.nether_ore.break" | "block.nether_ore.fall" | "minecraft:block.nether_ore.fall" | "block.nether_ore.hit" | "minecraft:block.nether_ore.hit" | "block.nether_ore.place" | "minecraft:block.nether_ore.place" | "block.nether_ore.step" | "minecraft:block.nether_ore.step" | "block.nether_sprouts.break" | "minecraft:block.nether_sprouts.break" | "block.nether_sprouts.fall" | "minecraft:block.nether_sprouts.fall" | "block.nether_sprouts.hit" | "minecraft:block.nether_sprouts.hit" | "block.nether_sprouts.place" | "minecraft:block.nether_sprouts.place" | "block.nether_sprouts.step" | "minecraft:block.nether_sprouts.step" | "block.nether_wart.break" | "minecraft:block.nether_wart.break" | "block.netherite_block.break" | "minecraft:block.netherite_block.break" | "block.netherite_block.fall" | "minecraft:block.netherite_block.fall" | "block.netherite_block.hit" | "minecraft:block.netherite_block.hit" | "block.netherite_block.place" | "minecraft:block.netherite_block.place" | "block.netherite_block.step" | "minecraft:block.netherite_block.step" | "block.netherrack.break" | "minecraft:block.netherrack.break" | "block.netherrack.fall" | "minecraft:block.netherrack.fall" | "block.netherrack.hit" | "minecraft:block.netherrack.hit" | "block.netherrack.place" | "minecraft:block.netherrack.place" | "block.netherrack.step" | "minecraft:block.netherrack.step" | "block.note_block.banjo" | "minecraft:block.note_block.banjo" | "block.note_block.basedrum" | "minecraft:block.note_block.basedrum" | "block.note_block.bass" | "minecraft:block.note_block.bass" | "block.note_block.bell" | "minecraft:block.note_block.bell" | "block.note_block.bit" | "minecraft:block.note_block.bit" | "block.note_block.chime" | "minecraft:block.note_block.chime" | "block.note_block.cow_bell" | "minecraft:block.note_block.cow_bell" | "block.note_block.didgeridoo" | "minecraft:block.note_block.didgeridoo" | "block.note_block.flute" | "minecraft:block.note_block.flute" | "block.note_block.guitar" | "minecraft:block.note_block.guitar" | "block.note_block.harp" | "minecraft:block.note_block.harp" | "block.note_block.hat" | "minecraft:block.note_block.hat" | "block.note_block.iron_xylophone" | "minecraft:block.note_block.iron_xylophone" | "block.note_block.pling" | "minecraft:block.note_block.pling" | "block.note_block.snare" | "minecraft:block.note_block.snare" | "block.note_block.xylophone" | "minecraft:block.note_block.xylophone" | "block.nylium.break" | "minecraft:block.nylium.break" | "block.nylium.fall" | "minecraft:block.nylium.fall" | "block.nylium.hit" | "minecraft:block.nylium.hit" | "block.nylium.place" | "minecraft:block.nylium.place" | "block.nylium.step" | "minecraft:block.nylium.step" | "block.piston.contract" | "minecraft:block.piston.contract" | "block.piston.extend" | "minecraft:block.piston.extend" | "block.pointed_dripstone.break" | "minecraft:block.pointed_dripstone.break" | "block.pointed_dripstone.drip_lava" | "minecraft:block.pointed_dripstone.drip_lava" | "block.pointed_dripstone.drip_lava_into_cauldron" | "minecraft:block.pointed_dripstone.drip_lava_into_cauldron" | "block.pointed_dripstone.drip_water" | "minecraft:block.pointed_dripstone.drip_water" | "block.pointed_dripstone.drip_water_into_cauldron" | "minecraft:block.pointed_dripstone.drip_water_into_cauldron" | "block.pointed_dripstone.fall" | "minecraft:block.pointed_dripstone.fall" | "block.pointed_dripstone.hit" | "minecraft:block.pointed_dripstone.hit" | "block.pointed_dripstone.land" | "minecraft:block.pointed_dripstone.land" | "block.pointed_dripstone.place" | "minecraft:block.pointed_dripstone.place" | "block.pointed_dripstone.step" | "minecraft:block.pointed_dripstone.step" | "block.polished_deepslate.break" | "minecraft:block.polished_deepslate.break" | "block.polished_deepslate.fall" | "minecraft:block.polished_deepslate.fall" | "block.polished_deepslate.hit" | "minecraft:block.polished_deepslate.hit" | "block.polished_deepslate.place" | "minecraft:block.polished_deepslate.place" | "block.polished_deepslate.step" | "minecraft:block.polished_deepslate.step" | "block.portal.ambient" | "minecraft:block.portal.ambient" | "block.portal.travel" | "minecraft:block.portal.travel" | "block.portal.trigger" | "minecraft:block.portal.trigger" | "block.powder_snow.break" | "minecraft:block.powder_snow.break" | "block.powder_snow.fall" | "minecraft:block.powder_snow.fall" | "block.powder_snow.hit" | "minecraft:block.powder_snow.hit" | "block.powder_snow.place" | "minecraft:block.powder_snow.place" | "block.powder_snow.step" | "minecraft:block.powder_snow.step" | "block.pumpkin.carve" | "minecraft:block.pumpkin.carve" | "block.redstone_torch.burnout" | "minecraft:block.redstone_torch.burnout" | "block.respawn_anchor.ambient" | "minecraft:block.respawn_anchor.ambient" | "block.respawn_anchor.charge" | "minecraft:block.respawn_anchor.charge" | "block.respawn_anchor.deplete" | "minecraft:block.respawn_anchor.deplete" | "block.respawn_anchor.set_spawn" | "minecraft:block.respawn_anchor.set_spawn" | "block.rooted_dirt.break" | "minecraft:block.rooted_dirt.break" | "block.rooted_dirt.fall" | "minecraft:block.rooted_dirt.fall" | "block.rooted_dirt.hit" | "minecraft:block.rooted_dirt.hit" | "block.rooted_dirt.place" | "minecraft:block.rooted_dirt.place" | "block.rooted_dirt.step" | "minecraft:block.rooted_dirt.step" | "block.roots.break" | "minecraft:block.roots.break" | "block.roots.fall" | "minecraft:block.roots.fall" | "block.roots.hit" | "minecraft:block.roots.hit" | "block.roots.place" | "minecraft:block.roots.place" | "block.roots.step" | "minecraft:block.roots.step" | "block.sand.break" | "minecraft:block.sand.break" | "block.sand.fall" | "minecraft:block.sand.fall" | "block.sand.hit" | "minecraft:block.sand.hit" | "block.sand.place" | "minecraft:block.sand.place" | "block.sand.step" | "minecraft:block.sand.step" | "block.scaffolding.break" | "minecraft:block.scaffolding.break" | "block.scaffolding.fall" | "minecraft:block.scaffolding.fall" | "block.scaffolding.hit" | "minecraft:block.scaffolding.hit" | "block.scaffolding.place" | "minecraft:block.scaffolding.place" | "block.scaffolding.step" | "minecraft:block.scaffolding.step" | "block.sculk_sensor.break" | "minecraft:block.sculk_sensor.break" | "block.sculk_sensor.clicking" | "minecraft:block.sculk_sensor.clicking" | "block.sculk_sensor.clicking_stop" | "minecraft:block.sculk_sensor.clicking_stop" | "block.sculk_sensor.fall" | "minecraft:block.sculk_sensor.fall" | "block.sculk_sensor.hit" | "minecraft:block.sculk_sensor.hit" | "block.sculk_sensor.place" | "minecraft:block.sculk_sensor.place" | "block.sculk_sensor.step" | "minecraft:block.sculk_sensor.step" | "block.shroomlight.break" | "minecraft:block.shroomlight.break" | "block.shroomlight.fall" | "minecraft:block.shroomlight.fall" | "block.shroomlight.hit" | "minecraft:block.shroomlight.hit" | "block.shroomlight.place" | "minecraft:block.shroomlight.place" | "block.shroomlight.step" | "minecraft:block.shroomlight.step" | "block.shulker_box.close" | "minecraft:block.shulker_box.close" | "block.shulker_box.open" | "minecraft:block.shulker_box.open" | "block.slime_block.break" | "minecraft:block.slime_block.break" | "block.slime_block.fall" | "minecraft:block.slime_block.fall" | "block.slime_block.hit" | "minecraft:block.slime_block.hit" | "block.slime_block.place" | "minecraft:block.slime_block.place" | "block.slime_block.step" | "minecraft:block.slime_block.step" | "block.small_amethyst_bud.break" | "minecraft:block.small_amethyst_bud.break" | "block.small_amethyst_bud.place" | "minecraft:block.small_amethyst_bud.place" | "block.small_dripleaf.break" | "minecraft:block.small_dripleaf.break" | "block.small_dripleaf.fall" | "minecraft:block.small_dripleaf.fall" | "block.small_dripleaf.hit" | "minecraft:block.small_dripleaf.hit" | "block.small_dripleaf.place" | "minecraft:block.small_dripleaf.place" | "block.small_dripleaf.step" | "minecraft:block.small_dripleaf.step" | "block.smithing_table.use" | "minecraft:block.smithing_table.use" | "block.smoker.smoke" | "minecraft:block.smoker.smoke" | "block.snow.break" | "minecraft:block.snow.break" | "block.snow.fall" | "minecraft:block.snow.fall" | "block.snow.hit" | "minecraft:block.snow.hit" | "block.snow.place" | "minecraft:block.snow.place" | "block.snow.step" | "minecraft:block.snow.step" | "block.soul_sand.break" | "minecraft:block.soul_sand.break" | "block.soul_sand.fall" | "minecraft:block.soul_sand.fall" | "block.soul_sand.hit" | "minecraft:block.soul_sand.hit" | "block.soul_sand.place" | "minecraft:block.soul_sand.place" | "block.soul_sand.step" | "minecraft:block.soul_sand.step" | "block.soul_soil.break" | "minecraft:block.soul_soil.break" | "block.soul_soil.fall" | "minecraft:block.soul_soil.fall" | "block.soul_soil.hit" | "minecraft:block.soul_soil.hit" | "block.soul_soil.place" | "minecraft:block.soul_soil.place" | "block.soul_soil.step" | "minecraft:block.soul_soil.step" | "block.spore_blossom.break" | "minecraft:block.spore_blossom.break" | "block.spore_blossom.fall" | "minecraft:block.spore_blossom.fall" | "block.spore_blossom.hit" | "minecraft:block.spore_blossom.hit" | "block.spore_blossom.place" | "minecraft:block.spore_blossom.place" | "block.spore_blossom.step" | "minecraft:block.spore_blossom.step" | "block.stem.break" | "minecraft:block.stem.break" | "block.stem.fall" | "minecraft:block.stem.fall" | "block.stem.hit" | "minecraft:block.stem.hit" | "block.stem.place" | "minecraft:block.stem.place" | "block.stem.step" | "minecraft:block.stem.step" | "block.stone.break" | "minecraft:block.stone.break" | "block.stone.fall" | "minecraft:block.stone.fall" | "block.stone.hit" | "minecraft:block.stone.hit" | "block.stone.place" | "minecraft:block.stone.place" | "block.stone.step" | "minecraft:block.stone.step" | "block.stone_button.click_off" | "minecraft:block.stone_button.click_off" | "block.stone_button.click_on" | "minecraft:block.stone_button.click_on" | "block.stone_pressure_plate.click_off" | "minecraft:block.stone_pressure_plate.click_off" | "block.stone_pressure_plate.click_on" | "minecraft:block.stone_pressure_plate.click_on" | "block.sweet_berry_bush.break" | "minecraft:block.sweet_berry_bush.break" | "block.sweet_berry_bush.pick_berries" | "minecraft:block.sweet_berry_bush.pick_berries" | "block.sweet_berry_bush.place" | "minecraft:block.sweet_berry_bush.place" | "block.tripwire.attach" | "minecraft:block.tripwire.attach" | "block.tripwire.click_off" | "minecraft:block.tripwire.click_off" | "block.tripwire.click_on" | "minecraft:block.tripwire.click_on" | "block.tripwire.detach" | "minecraft:block.tripwire.detach" | "block.tuff.break" | "minecraft:block.tuff.break" | "block.tuff.fall" | "minecraft:block.tuff.fall" | "block.tuff.hit" | "minecraft:block.tuff.hit" | "block.tuff.place" | "minecraft:block.tuff.place" | "block.tuff.step" | "minecraft:block.tuff.step" | "block.vine.break" | "minecraft:block.vine.break" | "block.vine.fall" | "minecraft:block.vine.fall" | "block.vine.hit" | "minecraft:block.vine.hit" | "block.vine.place" | "minecraft:block.vine.place" | "block.vine.step" | "minecraft:block.vine.step" | "block.wart_block.break" | "minecraft:block.wart_block.break" | "block.wart_block.fall" | "minecraft:block.wart_block.fall" | "block.wart_block.hit" | "minecraft:block.wart_block.hit" | "block.wart_block.place" | "minecraft:block.wart_block.place" | "block.wart_block.step" | "minecraft:block.wart_block.step" | "block.water.ambient" | "minecraft:block.water.ambient" | "block.weeping_vines.break" | "minecraft:block.weeping_vines.break" | "block.weeping_vines.fall" | "minecraft:block.weeping_vines.fall" | "block.weeping_vines.hit" | "minecraft:block.weeping_vines.hit" | "block.weeping_vines.place" | "minecraft:block.weeping_vines.place" | "block.weeping_vines.step" | "minecraft:block.weeping_vines.step" | "block.wet_grass.break" | "minecraft:block.wet_grass.break" | "block.wet_grass.fall" | "minecraft:block.wet_grass.fall" | "block.wet_grass.hit" | "minecraft:block.wet_grass.hit" | "block.wet_grass.place" | "minecraft:block.wet_grass.place" | "block.wet_grass.step" | "minecraft:block.wet_grass.step" | "block.wood.break" | "minecraft:block.wood.break" | "block.wood.fall" | "minecraft:block.wood.fall" | "block.wood.hit" | "minecraft:block.wood.hit" | "block.wood.place" | "minecraft:block.wood.place" | "block.wood.step" | "minecraft:block.wood.step" | "block.wooden_button.click_off" | "minecraft:block.wooden_button.click_off" | "block.wooden_button.click_on" | "minecraft:block.wooden_button.click_on" | "block.wooden_door.close" | "minecraft:block.wooden_door.close" | "block.wooden_door.open" | "minecraft:block.wooden_door.open" | "block.wooden_pressure_plate.click_off" | "minecraft:block.wooden_pressure_plate.click_off" | "block.wooden_pressure_plate.click_on" | "minecraft:block.wooden_pressure_plate.click_on" | "block.wooden_trapdoor.close" | "minecraft:block.wooden_trapdoor.close" | "block.wooden_trapdoor.open" | "minecraft:block.wooden_trapdoor.open" | "block.wool.break" | "minecraft:block.wool.break" | "block.wool.fall" | "minecraft:block.wool.fall" | "block.wool.hit" | "minecraft:block.wool.hit" | "block.wool.place" | "minecraft:block.wool.place" | "block.wool.step" | "minecraft:block.wool.step" | "enchant.thorns.hit" | "minecraft:enchant.thorns.hit" | "entity.armor_stand.break" | "minecraft:entity.armor_stand.break" | "entity.armor_stand.fall" | "minecraft:entity.armor_stand.fall" | "entity.armor_stand.hit" | "minecraft:entity.armor_stand.hit" | "entity.armor_stand.place" | "minecraft:entity.armor_stand.place" | "entity.arrow.hit" | "minecraft:entity.arrow.hit" | "entity.arrow.hit_player" | "minecraft:entity.arrow.hit_player" | "entity.arrow.shoot" | "minecraft:entity.arrow.shoot" | "entity.axolotl.attack" | "minecraft:entity.axolotl.attack" | "entity.axolotl.death" | "minecraft:entity.axolotl.death" | "entity.axolotl.hurt" | "minecraft:entity.axolotl.hurt" | "entity.axolotl.idle_air" | "minecraft:entity.axolotl.idle_air" | "entity.axolotl.idle_water" | "minecraft:entity.axolotl.idle_water" | "entity.axolotl.splash" | "minecraft:entity.axolotl.splash" | "entity.axolotl.swim" | "minecraft:entity.axolotl.swim" | "entity.bat.ambient" | "minecraft:entity.bat.ambient" | "entity.bat.death" | "minecraft:entity.bat.death" | "entity.bat.hurt" | "minecraft:entity.bat.hurt" | "entity.bat.loop" | "minecraft:entity.bat.loop" | "entity.bat.takeoff" | "minecraft:entity.bat.takeoff" | "entity.bee.death" | "minecraft:entity.bee.death" | "entity.bee.hurt" | "minecraft:entity.bee.hurt" | "entity.bee.loop" | "minecraft:entity.bee.loop" | "entity.bee.loop_aggressive" | "minecraft:entity.bee.loop_aggressive" | "entity.bee.pollinate" | "minecraft:entity.bee.pollinate" | "entity.bee.sting" | "minecraft:entity.bee.sting" | "entity.blaze.ambient" | "minecraft:entity.blaze.ambient" | "entity.blaze.burn" | "minecraft:entity.blaze.burn" | "entity.blaze.death" | "minecraft:entity.blaze.death" | "entity.blaze.hurt" | "minecraft:entity.blaze.hurt" | "entity.blaze.shoot" | "minecraft:entity.blaze.shoot" | "entity.boat.paddle_land" | "minecraft:entity.boat.paddle_land" | "entity.boat.paddle_water" | "minecraft:entity.boat.paddle_water" | "entity.cat.ambient" | "minecraft:entity.cat.ambient" | "entity.cat.beg_for_food" | "minecraft:entity.cat.beg_for_food" | "entity.cat.death" | "minecraft:entity.cat.death" | "entity.cat.eat" | "minecraft:entity.cat.eat" | "entity.cat.hiss" | "minecraft:entity.cat.hiss" | "entity.cat.hurt" | "minecraft:entity.cat.hurt" | "entity.cat.purr" | "minecraft:entity.cat.purr" | "entity.cat.purreow" | "minecraft:entity.cat.purreow" | "entity.cat.stray_ambient" | "minecraft:entity.cat.stray_ambient" | "entity.chicken.ambient" | "minecraft:entity.chicken.ambient" | "entity.chicken.death" | "minecraft:entity.chicken.death" | "entity.chicken.egg" | "minecraft:entity.chicken.egg" | "entity.chicken.hurt" | "minecraft:entity.chicken.hurt" | "entity.chicken.step" | "minecraft:entity.chicken.step" | "entity.cod.ambient" | "minecraft:entity.cod.ambient" | "entity.cod.death" | "minecraft:entity.cod.death" | "entity.cod.flop" | "minecraft:entity.cod.flop" | "entity.cod.hurt" | "minecraft:entity.cod.hurt" | "entity.cow.ambient" | "minecraft:entity.cow.ambient" | "entity.cow.death" | "minecraft:entity.cow.death" | "entity.cow.hurt" | "minecraft:entity.cow.hurt" | "entity.cow.milk" | "minecraft:entity.cow.milk" | "entity.cow.step" | "minecraft:entity.cow.step" | "entity.creeper.death" | "minecraft:entity.creeper.death" | "entity.creeper.hurt" | "minecraft:entity.creeper.hurt" | "entity.creeper.primed" | "minecraft:entity.creeper.primed" | "entity.dolphin.ambient" | "minecraft:entity.dolphin.ambient" | "entity.dolphin.ambient_water" | "minecraft:entity.dolphin.ambient_water" | "entity.dolphin.attack" | "minecraft:entity.dolphin.attack" | "entity.dolphin.death" | "minecraft:entity.dolphin.death" | "entity.dolphin.eat" | "minecraft:entity.dolphin.eat" | "entity.dolphin.hurt" | "minecraft:entity.dolphin.hurt" | "entity.dolphin.jump" | "minecraft:entity.dolphin.jump" | "entity.dolphin.play" | "minecraft:entity.dolphin.play" | "entity.dolphin.splash" | "minecraft:entity.dolphin.splash" | "entity.dolphin.swim" | "minecraft:entity.dolphin.swim" | "entity.donkey.ambient" | "minecraft:entity.donkey.ambient" | "entity.donkey.angry" | "minecraft:entity.donkey.angry" | "entity.donkey.chest" | "minecraft:entity.donkey.chest" | "entity.donkey.death" | "minecraft:entity.donkey.death" | "entity.donkey.eat" | "minecraft:entity.donkey.eat" | "entity.donkey.hurt" | "minecraft:entity.donkey.hurt" | "entity.dragon_fireball.explode" | "minecraft:entity.dragon_fireball.explode" | "entity.drowned.ambient" | "minecraft:entity.drowned.ambient" | "entity.drowned.ambient_water" | "minecraft:entity.drowned.ambient_water" | "entity.drowned.death" | "minecraft:entity.drowned.death" | "entity.drowned.death_water" | "minecraft:entity.drowned.death_water" | "entity.drowned.hurt" | "minecraft:entity.drowned.hurt" | "entity.drowned.hurt_water" | "minecraft:entity.drowned.hurt_water" | "entity.drowned.shoot" | "minecraft:entity.drowned.shoot" | "entity.drowned.step" | "minecraft:entity.drowned.step" | "entity.drowned.swim" | "minecraft:entity.drowned.swim" | "entity.egg.throw" | "minecraft:entity.egg.throw" | "entity.elder_guardian.ambient" | "minecraft:entity.elder_guardian.ambient" | "entity.elder_guardian.ambient_land" | "minecraft:entity.elder_guardian.ambient_land" | "entity.elder_guardian.curse" | "minecraft:entity.elder_guardian.curse" | "entity.elder_guardian.death" | "minecraft:entity.elder_guardian.death" | "entity.elder_guardian.death_land" | "minecraft:entity.elder_guardian.death_land" | "entity.elder_guardian.flop" | "minecraft:entity.elder_guardian.flop" | "entity.elder_guardian.hurt" | "minecraft:entity.elder_guardian.hurt" | "entity.elder_guardian.hurt_land" | "minecraft:entity.elder_guardian.hurt_land" | "entity.ender_dragon.ambient" | "minecraft:entity.ender_dragon.ambient" | "entity.ender_dragon.death" | "minecraft:entity.ender_dragon.death" | "entity.ender_dragon.flap" | "minecraft:entity.ender_dragon.flap" | "entity.ender_dragon.growl" | "minecraft:entity.ender_dragon.growl" | "entity.ender_dragon.hurt" | "minecraft:entity.ender_dragon.hurt" | "entity.ender_dragon.shoot" | "minecraft:entity.ender_dragon.shoot" | "entity.ender_eye.death" | "minecraft:entity.ender_eye.death" | "entity.ender_eye.launch" | "minecraft:entity.ender_eye.launch" | "entity.ender_pearl.throw" | "minecraft:entity.ender_pearl.throw" | "entity.enderman.ambient" | "minecraft:entity.enderman.ambient" | "entity.enderman.death" | "minecraft:entity.enderman.death" | "entity.enderman.hurt" | "minecraft:entity.enderman.hurt" | "entity.enderman.scream" | "minecraft:entity.enderman.scream" | "entity.enderman.stare" | "minecraft:entity.enderman.stare" | "entity.enderman.teleport" | "minecraft:entity.enderman.teleport" | "entity.endermite.ambient" | "minecraft:entity.endermite.ambient" | "entity.endermite.death" | "minecraft:entity.endermite.death" | "entity.endermite.hurt" | "minecraft:entity.endermite.hurt" | "entity.endermite.step" | "minecraft:entity.endermite.step" | "entity.evoker.ambient" | "minecraft:entity.evoker.ambient" | "entity.evoker.cast_spell" | "minecraft:entity.evoker.cast_spell" | "entity.evoker.celebrate" | "minecraft:entity.evoker.celebrate" | "entity.evoker.death" | "minecraft:entity.evoker.death" | "entity.evoker.hurt" | "minecraft:entity.evoker.hurt" | "entity.evoker.prepare_attack" | "minecraft:entity.evoker.prepare_attack" | "entity.evoker.prepare_summon" | "minecraft:entity.evoker.prepare_summon" | "entity.evoker.prepare_wololo" | "minecraft:entity.evoker.prepare_wololo" | "entity.evoker_fangs.attack" | "minecraft:entity.evoker_fangs.attack" | "entity.experience_bottle.throw" | "minecraft:entity.experience_bottle.throw" | "entity.experience_orb.pickup" | "minecraft:entity.experience_orb.pickup" | "entity.firework_rocket.blast" | "minecraft:entity.firework_rocket.blast" | "entity.firework_rocket.blast_far" | "minecraft:entity.firework_rocket.blast_far" | "entity.firework_rocket.large_blast" | "minecraft:entity.firework_rocket.large_blast" | "entity.firework_rocket.large_blast_far" | "minecraft:entity.firework_rocket.large_blast_far" | "entity.firework_rocket.launch" | "minecraft:entity.firework_rocket.launch" | "entity.firework_rocket.shoot" | "minecraft:entity.firework_rocket.shoot" | "entity.firework_rocket.twinkle" | "minecraft:entity.firework_rocket.twinkle" | "entity.firework_rocket.twinkle_far" | "minecraft:entity.firework_rocket.twinkle_far" | "entity.fish.swim" | "minecraft:entity.fish.swim" | "entity.fishing_bobber.retrieve" | "minecraft:entity.fishing_bobber.retrieve" | "entity.fishing_bobber.splash" | "minecraft:entity.fishing_bobber.splash" | "entity.fishing_bobber.throw" | "minecraft:entity.fishing_bobber.throw" | "entity.fox.aggro" | "minecraft:entity.fox.aggro" | "entity.fox.ambient" | "minecraft:entity.fox.ambient" | "entity.fox.bite" | "minecraft:entity.fox.bite" | "entity.fox.death" | "minecraft:entity.fox.death" | "entity.fox.eat" | "minecraft:entity.fox.eat" | "entity.fox.hurt" | "minecraft:entity.fox.hurt" | "entity.fox.screech" | "minecraft:entity.fox.screech" | "entity.fox.sleep" | "minecraft:entity.fox.sleep" | "entity.fox.sniff" | "minecraft:entity.fox.sniff" | "entity.fox.spit" | "minecraft:entity.fox.spit" | "entity.fox.teleport" | "minecraft:entity.fox.teleport" | "entity.generic.big_fall" | "minecraft:entity.generic.big_fall" | "entity.generic.burn" | "minecraft:entity.generic.burn" | "entity.generic.death" | "minecraft:entity.generic.death" | "entity.generic.drink" | "minecraft:entity.generic.drink" | "entity.generic.eat" | "minecraft:entity.generic.eat" | "entity.generic.explode" | "minecraft:entity.generic.explode" | "entity.generic.extinguish_fire" | "minecraft:entity.generic.extinguish_fire" | "entity.generic.hurt" | "minecraft:entity.generic.hurt" | "entity.generic.small_fall" | "minecraft:entity.generic.small_fall" | "entity.generic.splash" | "minecraft:entity.generic.splash" | "entity.generic.swim" | "minecraft:entity.generic.swim" | "entity.ghast.ambient" | "minecraft:entity.ghast.ambient" | "entity.ghast.death" | "minecraft:entity.ghast.death" | "entity.ghast.hurt" | "minecraft:entity.ghast.hurt" | "entity.ghast.scream" | "minecraft:entity.ghast.scream" | "entity.ghast.shoot" | "minecraft:entity.ghast.shoot" | "entity.ghast.warn" | "minecraft:entity.ghast.warn" | "entity.glow_item_frame.add_item" | "minecraft:entity.glow_item_frame.add_item" | "entity.glow_item_frame.break" | "minecraft:entity.glow_item_frame.break" | "entity.glow_item_frame.place" | "minecraft:entity.glow_item_frame.place" | "entity.glow_item_frame.remove_item" | "minecraft:entity.glow_item_frame.remove_item" | "entity.glow_item_frame.rotate_item" | "minecraft:entity.glow_item_frame.rotate_item" | "entity.glow_squid.ambient" | "minecraft:entity.glow_squid.ambient" | "entity.glow_squid.death" | "minecraft:entity.glow_squid.death" | "entity.glow_squid.hurt" | "minecraft:entity.glow_squid.hurt" | "entity.glow_squid.squirt" | "minecraft:entity.glow_squid.squirt" | "entity.goat.ambient" | "minecraft:entity.goat.ambient" | "entity.goat.death" | "minecraft:entity.goat.death" | "entity.goat.eat" | "minecraft:entity.goat.eat" | "entity.goat.hurt" | "minecraft:entity.goat.hurt" | "entity.goat.long_jump" | "minecraft:entity.goat.long_jump" | "entity.goat.milk" | "minecraft:entity.goat.milk" | "entity.goat.prepare_ram" | "minecraft:entity.goat.prepare_ram" | "entity.goat.ram_impact" | "minecraft:entity.goat.ram_impact" | "entity.goat.screaming.ambient" | "minecraft:entity.goat.screaming.ambient" | "entity.goat.screaming.death" | "minecraft:entity.goat.screaming.death" | "entity.goat.screaming.eat" | "minecraft:entity.goat.screaming.eat" | "entity.goat.screaming.hurt" | "minecraft:entity.goat.screaming.hurt" | "entity.goat.screaming.long_jump" | "minecraft:entity.goat.screaming.long_jump" | "entity.goat.screaming.milk" | "minecraft:entity.goat.screaming.milk" | "entity.goat.screaming.prepare_ram" | "minecraft:entity.goat.screaming.prepare_ram" | "entity.goat.screaming.ram_impact" | "minecraft:entity.goat.screaming.ram_impact" | "entity.goat.step" | "minecraft:entity.goat.step" | "entity.guardian.ambient" | "minecraft:entity.guardian.ambient" | "entity.guardian.ambient_land" | "minecraft:entity.guardian.ambient_land" | "entity.guardian.attack" | "minecraft:entity.guardian.attack" | "entity.guardian.death" | "minecraft:entity.guardian.death" | "entity.guardian.death_land" | "minecraft:entity.guardian.death_land" | "entity.guardian.flop" | "minecraft:entity.guardian.flop" | "entity.guardian.hurt" | "minecraft:entity.guardian.hurt" | "entity.guardian.hurt_land" | "minecraft:entity.guardian.hurt_land" | "entity.hoglin.ambient" | "minecraft:entity.hoglin.ambient" | "entity.hoglin.angry" | "minecraft:entity.hoglin.angry" | "entity.hoglin.attack" | "minecraft:entity.hoglin.attack" | "entity.hoglin.converted_to_zombified" | "minecraft:entity.hoglin.converted_to_zombified" | "entity.hoglin.death" | "minecraft:entity.hoglin.death" | "entity.hoglin.hurt" | "minecraft:entity.hoglin.hurt" | "entity.hoglin.retreat" | "minecraft:entity.hoglin.retreat" | "entity.hoglin.step" | "minecraft:entity.hoglin.step" | "entity.horse.ambient" | "minecraft:entity.horse.ambient" | "entity.horse.angry" | "minecraft:entity.horse.angry" | "entity.horse.armor" | "minecraft:entity.horse.armor" | "entity.horse.breathe" | "minecraft:entity.horse.breathe" | "entity.horse.death" | "minecraft:entity.horse.death" | "entity.horse.eat" | "minecraft:entity.horse.eat" | "entity.horse.gallop" | "minecraft:entity.horse.gallop" | "entity.horse.hurt" | "minecraft:entity.horse.hurt" | "entity.horse.jump" | "minecraft:entity.horse.jump" | "entity.horse.land" | "minecraft:entity.horse.land" | "entity.horse.saddle" | "minecraft:entity.horse.saddle" | "entity.horse.step" | "minecraft:entity.horse.step" | "entity.horse.step_wood" | "minecraft:entity.horse.step_wood" | "entity.hostile.big_fall" | "minecraft:entity.hostile.big_fall" | "entity.hostile.death" | "minecraft:entity.hostile.death" | "entity.hostile.hurt" | "minecraft:entity.hostile.hurt" | "entity.hostile.small_fall" | "minecraft:entity.hostile.small_fall" | "entity.hostile.splash" | "minecraft:entity.hostile.splash" | "entity.hostile.swim" | "minecraft:entity.hostile.swim" | "entity.husk.ambient" | "minecraft:entity.husk.ambient" | "entity.husk.converted_to_zombie" | "minecraft:entity.husk.converted_to_zombie" | "entity.husk.death" | "minecraft:entity.husk.death" | "entity.husk.hurt" | "minecraft:entity.husk.hurt" | "entity.husk.step" | "minecraft:entity.husk.step" | "entity.illusioner.ambient" | "minecraft:entity.illusioner.ambient" | "entity.illusioner.cast_spell" | "minecraft:entity.illusioner.cast_spell" | "entity.illusioner.death" | "minecraft:entity.illusioner.death" | "entity.illusioner.hurt" | "minecraft:entity.illusioner.hurt" | "entity.illusioner.mirror_move" | "minecraft:entity.illusioner.mirror_move" | "entity.illusioner.prepare_blindness" | "minecraft:entity.illusioner.prepare_blindness" | "entity.illusioner.prepare_mirror" | "minecraft:entity.illusioner.prepare_mirror" | "entity.iron_golem.attack" | "minecraft:entity.iron_golem.attack" | "entity.iron_golem.damage" | "minecraft:entity.iron_golem.damage" | "entity.iron_golem.death" | "minecraft:entity.iron_golem.death" | "entity.iron_golem.hurt" | "minecraft:entity.iron_golem.hurt" | "entity.iron_golem.repair" | "minecraft:entity.iron_golem.repair" | "entity.iron_golem.step" | "minecraft:entity.iron_golem.step" | "entity.item.break" | "minecraft:entity.item.break" | "entity.item.pickup" | "minecraft:entity.item.pickup" | "entity.item_frame.add_item" | "minecraft:entity.item_frame.add_item" | "entity.item_frame.break" | "minecraft:entity.item_frame.break" | "entity.item_frame.place" | "minecraft:entity.item_frame.place" | "entity.item_frame.remove_item" | "minecraft:entity.item_frame.remove_item" | "entity.item_frame.rotate_item" | "minecraft:entity.item_frame.rotate_item" | "entity.leash_knot.break" | "minecraft:entity.leash_knot.break" | "entity.leash_knot.place" | "minecraft:entity.leash_knot.place" | "entity.lightning_bolt.impact" | "minecraft:entity.lightning_bolt.impact" | "entity.lightning_bolt.thunder" | "minecraft:entity.lightning_bolt.thunder" | "entity.lingering_potion.throw" | "minecraft:entity.lingering_potion.throw" | "entity.llama.ambient" | "minecraft:entity.llama.ambient" | "entity.llama.angry" | "minecraft:entity.llama.angry" | "entity.llama.chest" | "minecraft:entity.llama.chest" | "entity.llama.death" | "minecraft:entity.llama.death" | "entity.llama.eat" | "minecraft:entity.llama.eat" | "entity.llama.hurt" | "minecraft:entity.llama.hurt" | "entity.llama.spit" | "minecraft:entity.llama.spit" | "entity.llama.step" | "minecraft:entity.llama.step" | "entity.llama.swag" | "minecraft:entity.llama.swag" | "entity.magma_cube.death" | "minecraft:entity.magma_cube.death" | "entity.magma_cube.death_small" | "minecraft:entity.magma_cube.death_small" | "entity.magma_cube.hurt" | "minecraft:entity.magma_cube.hurt" | "entity.magma_cube.hurt_small" | "minecraft:entity.magma_cube.hurt_small" | "entity.magma_cube.jump" | "minecraft:entity.magma_cube.jump" | "entity.magma_cube.squish" | "minecraft:entity.magma_cube.squish" | "entity.magma_cube.squish_small" | "minecraft:entity.magma_cube.squish_small" | "entity.minecart.inside" | "minecraft:entity.minecart.inside" | "entity.minecart.inside.underwater" | "minecraft:entity.minecart.inside.underwater" | "entity.minecart.riding" | "minecraft:entity.minecart.riding" | "entity.mooshroom.convert" | "minecraft:entity.mooshroom.convert" | "entity.mooshroom.eat" | "minecraft:entity.mooshroom.eat" | "entity.mooshroom.milk" | "minecraft:entity.mooshroom.milk" | "entity.mooshroom.shear" | "minecraft:entity.mooshroom.shear" | "entity.mooshroom.suspicious_milk" | "minecraft:entity.mooshroom.suspicious_milk" | "entity.mule.ambient" | "minecraft:entity.mule.ambient" | "entity.mule.angry" | "minecraft:entity.mule.angry" | "entity.mule.chest" | "minecraft:entity.mule.chest" | "entity.mule.death" | "minecraft:entity.mule.death" | "entity.mule.eat" | "minecraft:entity.mule.eat" | "entity.mule.hurt" | "minecraft:entity.mule.hurt" | "entity.ocelot.ambient" | "minecraft:entity.ocelot.ambient" | "entity.ocelot.death" | "minecraft:entity.ocelot.death" | "entity.ocelot.hurt" | "minecraft:entity.ocelot.hurt" | "entity.painting.break" | "minecraft:entity.painting.break" | "entity.painting.place" | "minecraft:entity.painting.place" | "entity.panda.aggressive_ambient" | "minecraft:entity.panda.aggressive_ambient" | "entity.panda.ambient" | "minecraft:entity.panda.ambient" | "entity.panda.bite" | "minecraft:entity.panda.bite" | "entity.panda.cant_breed" | "minecraft:entity.panda.cant_breed" | "entity.panda.death" | "minecraft:entity.panda.death" | "entity.panda.eat" | "minecraft:entity.panda.eat" | "entity.panda.hurt" | "minecraft:entity.panda.hurt" | "entity.panda.pre_sneeze" | "minecraft:entity.panda.pre_sneeze" | "entity.panda.sneeze" | "minecraft:entity.panda.sneeze" | "entity.panda.step" | "minecraft:entity.panda.step" | "entity.panda.worried_ambient" | "minecraft:entity.panda.worried_ambient" | "entity.parrot.ambient" | "minecraft:entity.parrot.ambient" | "entity.parrot.death" | "minecraft:entity.parrot.death" | "entity.parrot.eat" | "minecraft:entity.parrot.eat" | "entity.parrot.fly" | "minecraft:entity.parrot.fly" | "entity.parrot.hurt" | "minecraft:entity.parrot.hurt" | "entity.parrot.imitate.blaze" | "minecraft:entity.parrot.imitate.blaze" | "entity.parrot.imitate.creeper" | "minecraft:entity.parrot.imitate.creeper" | "entity.parrot.imitate.drowned" | "minecraft:entity.parrot.imitate.drowned" | "entity.parrot.imitate.elder_guardian" | "minecraft:entity.parrot.imitate.elder_guardian" | "entity.parrot.imitate.ender_dragon" | "minecraft:entity.parrot.imitate.ender_dragon" | "entity.parrot.imitate.endermite" | "minecraft:entity.parrot.imitate.endermite" | "entity.parrot.imitate.evoker" | "minecraft:entity.parrot.imitate.evoker" | "entity.parrot.imitate.ghast" | "minecraft:entity.parrot.imitate.ghast" | "entity.parrot.imitate.guardian" | "minecraft:entity.parrot.imitate.guardian" | "entity.parrot.imitate.hoglin" | "minecraft:entity.parrot.imitate.hoglin" | "entity.parrot.imitate.husk" | "minecraft:entity.parrot.imitate.husk" | "entity.parrot.imitate.illusioner" | "minecraft:entity.parrot.imitate.illusioner" | "entity.parrot.imitate.magma_cube" | "minecraft:entity.parrot.imitate.magma_cube" | "entity.parrot.imitate.phantom" | "minecraft:entity.parrot.imitate.phantom" | "entity.parrot.imitate.piglin" | "minecraft:entity.parrot.imitate.piglin" | "entity.parrot.imitate.piglin_brute" | "minecraft:entity.parrot.imitate.piglin_brute" | "entity.parrot.imitate.pillager" | "minecraft:entity.parrot.imitate.pillager" | "entity.parrot.imitate.ravager" | "minecraft:entity.parrot.imitate.ravager" | "entity.parrot.imitate.shulker" | "minecraft:entity.parrot.imitate.shulker" | "entity.parrot.imitate.silverfish" | "minecraft:entity.parrot.imitate.silverfish" | "entity.parrot.imitate.skeleton" | "minecraft:entity.parrot.imitate.skeleton" | "entity.parrot.imitate.slime" | "minecraft:entity.parrot.imitate.slime" | "entity.parrot.imitate.spider" | "minecraft:entity.parrot.imitate.spider" | "entity.parrot.imitate.stray" | "minecraft:entity.parrot.imitate.stray" | "entity.parrot.imitate.vex" | "minecraft:entity.parrot.imitate.vex" | "entity.parrot.imitate.vindicator" | "minecraft:entity.parrot.imitate.vindicator" | "entity.parrot.imitate.witch" | "minecraft:entity.parrot.imitate.witch" | "entity.parrot.imitate.wither" | "minecraft:entity.parrot.imitate.wither" | "entity.parrot.imitate.wither_skeleton" | "minecraft:entity.parrot.imitate.wither_skeleton" | "entity.parrot.imitate.zoglin" | "minecraft:entity.parrot.imitate.zoglin" | "entity.parrot.imitate.zombie" | "minecraft:entity.parrot.imitate.zombie" | "entity.parrot.imitate.zombie_villager" | "minecraft:entity.parrot.imitate.zombie_villager" | "entity.parrot.step" | "minecraft:entity.parrot.step" | "entity.phantom.ambient" | "minecraft:entity.phantom.ambient" | "entity.phantom.bite" | "minecraft:entity.phantom.bite" | "entity.phantom.death" | "minecraft:entity.phantom.death" | "entity.phantom.flap" | "minecraft:entity.phantom.flap" | "entity.phantom.hurt" | "minecraft:entity.phantom.hurt" | "entity.phantom.swoop" | "minecraft:entity.phantom.swoop" | "entity.pig.ambient" | "minecraft:entity.pig.ambient" | "entity.pig.death" | "minecraft:entity.pig.death" | "entity.pig.hurt" | "minecraft:entity.pig.hurt" | "entity.pig.saddle" | "minecraft:entity.pig.saddle" | "entity.pig.step" | "minecraft:entity.pig.step" | "entity.piglin.admiring_item" | "minecraft:entity.piglin.admiring_item" | "entity.piglin.ambient" | "minecraft:entity.piglin.ambient" | "entity.piglin.angry" | "minecraft:entity.piglin.angry" | "entity.piglin.celebrate" | "minecraft:entity.piglin.celebrate" | "entity.piglin.converted_to_zombified" | "minecraft:entity.piglin.converted_to_zombified" | "entity.piglin.death" | "minecraft:entity.piglin.death" | "entity.piglin.hurt" | "minecraft:entity.piglin.hurt" | "entity.piglin.jealous" | "minecraft:entity.piglin.jealous" | "entity.piglin.retreat" | "minecraft:entity.piglin.retreat" | "entity.piglin.step" | "minecraft:entity.piglin.step" | "entity.piglin_brute.ambient" | "minecraft:entity.piglin_brute.ambient" | "entity.piglin_brute.angry" | "minecraft:entity.piglin_brute.angry" | "entity.piglin_brute.converted_to_zombified" | "minecraft:entity.piglin_brute.converted_to_zombified" | "entity.piglin_brute.death" | "minecraft:entity.piglin_brute.death" | "entity.piglin_brute.hurt" | "minecraft:entity.piglin_brute.hurt" | "entity.piglin_brute.step" | "minecraft:entity.piglin_brute.step" | "entity.pillager.ambient" | "minecraft:entity.pillager.ambient" | "entity.pillager.celebrate" | "minecraft:entity.pillager.celebrate" | "entity.pillager.death" | "minecraft:entity.pillager.death" | "entity.pillager.hurt" | "minecraft:entity.pillager.hurt" | "entity.player.attack.crit" | "minecraft:entity.player.attack.crit" | "entity.player.attack.knockback" | "minecraft:entity.player.attack.knockback" | "entity.player.attack.nodamage" | "minecraft:entity.player.attack.nodamage" | "entity.player.attack.strong" | "minecraft:entity.player.attack.strong" | "entity.player.attack.sweep" | "minecraft:entity.player.attack.sweep" | "entity.player.attack.weak" | "minecraft:entity.player.attack.weak" | "entity.player.big_fall" | "minecraft:entity.player.big_fall" | "entity.player.breath" | "minecraft:entity.player.breath" | "entity.player.burp" | "minecraft:entity.player.burp" | "entity.player.death" | "minecraft:entity.player.death" | "entity.player.hurt" | "minecraft:entity.player.hurt" | "entity.player.hurt_drown" | "minecraft:entity.player.hurt_drown" | "entity.player.hurt_freeze" | "minecraft:entity.player.hurt_freeze" | "entity.player.hurt_on_fire" | "minecraft:entity.player.hurt_on_fire" | "entity.player.hurt_sweet_berry_bush" | "minecraft:entity.player.hurt_sweet_berry_bush" | "entity.player.levelup" | "minecraft:entity.player.levelup" | "entity.player.small_fall" | "minecraft:entity.player.small_fall" | "entity.player.splash" | "minecraft:entity.player.splash" | "entity.player.splash.high_speed" | "minecraft:entity.player.splash.high_speed" | "entity.player.swim" | "minecraft:entity.player.swim" | "entity.polar_bear.ambient" | "minecraft:entity.polar_bear.ambient" | "entity.polar_bear.ambient_baby" | "minecraft:entity.polar_bear.ambient_baby" | "entity.polar_bear.death" | "minecraft:entity.polar_bear.death" | "entity.polar_bear.hurt" | "minecraft:entity.polar_bear.hurt" | "entity.polar_bear.step" | "minecraft:entity.polar_bear.step" | "entity.polar_bear.warning" | "minecraft:entity.polar_bear.warning" | "entity.puffer_fish.ambient" | "minecraft:entity.puffer_fish.ambient" | "entity.puffer_fish.blow_out" | "minecraft:entity.puffer_fish.blow_out" | "entity.puffer_fish.blow_up" | "minecraft:entity.puffer_fish.blow_up" | "entity.puffer_fish.death" | "minecraft:entity.puffer_fish.death" | "entity.puffer_fish.flop" | "minecraft:entity.puffer_fish.flop" | "entity.puffer_fish.hurt" | "minecraft:entity.puffer_fish.hurt" | "entity.puffer_fish.sting" | "minecraft:entity.puffer_fish.sting" | "entity.rabbit.ambient" | "minecraft:entity.rabbit.ambient" | "entity.rabbit.attack" | "minecraft:entity.rabbit.attack" | "entity.rabbit.death" | "minecraft:entity.rabbit.death" | "entity.rabbit.hurt" | "minecraft:entity.rabbit.hurt" | "entity.rabbit.jump" | "minecraft:entity.rabbit.jump" | "entity.ravager.ambient" | "minecraft:entity.ravager.ambient" | "entity.ravager.attack" | "minecraft:entity.ravager.attack" | "entity.ravager.celebrate" | "minecraft:entity.ravager.celebrate" | "entity.ravager.death" | "minecraft:entity.ravager.death" | "entity.ravager.hurt" | "minecraft:entity.ravager.hurt" | "entity.ravager.roar" | "minecraft:entity.ravager.roar" | "entity.ravager.step" | "minecraft:entity.ravager.step" | "entity.ravager.stunned" | "minecraft:entity.ravager.stunned" | "entity.salmon.ambient" | "minecraft:entity.salmon.ambient" | "entity.salmon.death" | "minecraft:entity.salmon.death" | "entity.salmon.flop" | "minecraft:entity.salmon.flop" | "entity.salmon.hurt" | "minecraft:entity.salmon.hurt" | "entity.sheep.ambient" | "minecraft:entity.sheep.ambient" | "entity.sheep.death" | "minecraft:entity.sheep.death" | "entity.sheep.hurt" | "minecraft:entity.sheep.hurt" | "entity.sheep.shear" | "minecraft:entity.sheep.shear" | "entity.sheep.step" | "minecraft:entity.sheep.step" | "entity.shulker.ambient" | "minecraft:entity.shulker.ambient" | "entity.shulker.close" | "minecraft:entity.shulker.close" | "entity.shulker.death" | "minecraft:entity.shulker.death" | "entity.shulker.hurt" | "minecraft:entity.shulker.hurt" | "entity.shulker.hurt_closed" | "minecraft:entity.shulker.hurt_closed" | "entity.shulker.open" | "minecraft:entity.shulker.open" | "entity.shulker.shoot" | "minecraft:entity.shulker.shoot" | "entity.shulker.teleport" | "minecraft:entity.shulker.teleport" | "entity.shulker_bullet.hit" | "minecraft:entity.shulker_bullet.hit" | "entity.shulker_bullet.hurt" | "minecraft:entity.shulker_bullet.hurt" | "entity.silverfish.ambient" | "minecraft:entity.silverfish.ambient" | "entity.silverfish.death" | "minecraft:entity.silverfish.death" | "entity.silverfish.hurt" | "minecraft:entity.silverfish.hurt" | "entity.silverfish.step" | "minecraft:entity.silverfish.step" | "entity.skeleton.ambient" | "minecraft:entity.skeleton.ambient" | "entity.skeleton.converted_to_stray" | "minecraft:entity.skeleton.converted_to_stray" | "entity.skeleton.death" | "minecraft:entity.skeleton.death" | "entity.skeleton.hurt" | "minecraft:entity.skeleton.hurt" | "entity.skeleton.shoot" | "minecraft:entity.skeleton.shoot" | "entity.skeleton.step" | "minecraft:entity.skeleton.step" | "entity.skeleton_horse.ambient" | "minecraft:entity.skeleton_horse.ambient" | "entity.skeleton_horse.ambient_water" | "minecraft:entity.skeleton_horse.ambient_water" | "entity.skeleton_horse.death" | "minecraft:entity.skeleton_horse.death" | "entity.skeleton_horse.gallop_water" | "minecraft:entity.skeleton_horse.gallop_water" | "entity.skeleton_horse.hurt" | "minecraft:entity.skeleton_horse.hurt" | "entity.skeleton_horse.jump_water" | "minecraft:entity.skeleton_horse.jump_water" | "entity.skeleton_horse.step_water" | "minecraft:entity.skeleton_horse.step_water" | "entity.skeleton_horse.swim" | "minecraft:entity.skeleton_horse.swim" | "entity.slime.attack" | "minecraft:entity.slime.attack" | "entity.slime.death" | "minecraft:entity.slime.death" | "entity.slime.death_small" | "minecraft:entity.slime.death_small" | "entity.slime.hurt" | "minecraft:entity.slime.hurt" | "entity.slime.hurt_small" | "minecraft:entity.slime.hurt_small" | "entity.slime.jump" | "minecraft:entity.slime.jump" | "entity.slime.jump_small" | "minecraft:entity.slime.jump_small" | "entity.slime.squish" | "minecraft:entity.slime.squish" | "entity.slime.squish_small" | "minecraft:entity.slime.squish_small" | "entity.snow_golem.ambient" | "minecraft:entity.snow_golem.ambient" | "entity.snow_golem.death" | "minecraft:entity.snow_golem.death" | "entity.snow_golem.hurt" | "minecraft:entity.snow_golem.hurt" | "entity.snow_golem.shear" | "minecraft:entity.snow_golem.shear" | "entity.snow_golem.shoot" | "minecraft:entity.snow_golem.shoot" | "entity.snowball.throw" | "minecraft:entity.snowball.throw" | "entity.spider.ambient" | "minecraft:entity.spider.ambient" | "entity.spider.death" | "minecraft:entity.spider.death" | "entity.spider.hurt" | "minecraft:entity.spider.hurt" | "entity.spider.step" | "minecraft:entity.spider.step" | "entity.splash_potion.break" | "minecraft:entity.splash_potion.break" | "entity.splash_potion.throw" | "minecraft:entity.splash_potion.throw" | "entity.squid.ambient" | "minecraft:entity.squid.ambient" | "entity.squid.death" | "minecraft:entity.squid.death" | "entity.squid.hurt" | "minecraft:entity.squid.hurt" | "entity.squid.squirt" | "minecraft:entity.squid.squirt" | "entity.stray.ambient" | "minecraft:entity.stray.ambient" | "entity.stray.death" | "minecraft:entity.stray.death" | "entity.stray.hurt" | "minecraft:entity.stray.hurt" | "entity.stray.step" | "minecraft:entity.stray.step" | "entity.strider.ambient" | "minecraft:entity.strider.ambient" | "entity.strider.death" | "minecraft:entity.strider.death" | "entity.strider.eat" | "minecraft:entity.strider.eat" | "entity.strider.happy" | "minecraft:entity.strider.happy" | "entity.strider.hurt" | "minecraft:entity.strider.hurt" | "entity.strider.retreat" | "minecraft:entity.strider.retreat" | "entity.strider.saddle" | "minecraft:entity.strider.saddle" | "entity.strider.step" | "minecraft:entity.strider.step" | "entity.strider.step_lava" | "minecraft:entity.strider.step_lava" | "entity.tnt.primed" | "minecraft:entity.tnt.primed" | "entity.tropical_fish.ambient" | "minecraft:entity.tropical_fish.ambient" | "entity.tropical_fish.death" | "minecraft:entity.tropical_fish.death" | "entity.tropical_fish.flop" | "minecraft:entity.tropical_fish.flop" | "entity.tropical_fish.hurt" | "minecraft:entity.tropical_fish.hurt" | "entity.turtle.ambient_land" | "minecraft:entity.turtle.ambient_land" | "entity.turtle.death" | "minecraft:entity.turtle.death" | "entity.turtle.death_baby" | "minecraft:entity.turtle.death_baby" | "entity.turtle.egg_break" | "minecraft:entity.turtle.egg_break" | "entity.turtle.egg_crack" | "minecraft:entity.turtle.egg_crack" | "entity.turtle.egg_hatch" | "minecraft:entity.turtle.egg_hatch" | "entity.turtle.hurt" | "minecraft:entity.turtle.hurt" | "entity.turtle.hurt_baby" | "minecraft:entity.turtle.hurt_baby" | "entity.turtle.lay_egg" | "minecraft:entity.turtle.lay_egg" | "entity.turtle.shamble" | "minecraft:entity.turtle.shamble" | "entity.turtle.shamble_baby" | "minecraft:entity.turtle.shamble_baby" | "entity.turtle.swim" | "minecraft:entity.turtle.swim" | "entity.vex.ambient" | "minecraft:entity.vex.ambient" | "entity.vex.charge" | "minecraft:entity.vex.charge" | "entity.vex.death" | "minecraft:entity.vex.death" | "entity.vex.hurt" | "minecraft:entity.vex.hurt" | "entity.villager.ambient" | "minecraft:entity.villager.ambient" | "entity.villager.celebrate" | "minecraft:entity.villager.celebrate" | "entity.villager.death" | "minecraft:entity.villager.death" | "entity.villager.hurt" | "minecraft:entity.villager.hurt" | "entity.villager.no" | "minecraft:entity.villager.no" | "entity.villager.trade" | "minecraft:entity.villager.trade" | "entity.villager.work_armorer" | "minecraft:entity.villager.work_armorer" | "entity.villager.work_butcher" | "minecraft:entity.villager.work_butcher" | "entity.villager.work_cartographer" | "minecraft:entity.villager.work_cartographer" | "entity.villager.work_cleric" | "minecraft:entity.villager.work_cleric" | "entity.villager.work_farmer" | "minecraft:entity.villager.work_farmer" | "entity.villager.work_fisherman" | "minecraft:entity.villager.work_fisherman" | "entity.villager.work_fletcher" | "minecraft:entity.villager.work_fletcher" | "entity.villager.work_leatherworker" | "minecraft:entity.villager.work_leatherworker" | "entity.villager.work_librarian" | "minecraft:entity.villager.work_librarian" | "entity.villager.work_mason" | "minecraft:entity.villager.work_mason" | "entity.villager.work_shepherd" | "minecraft:entity.villager.work_shepherd" | "entity.villager.work_toolsmith" | "minecraft:entity.villager.work_toolsmith" | "entity.villager.work_weaponsmith" | "minecraft:entity.villager.work_weaponsmith" | "entity.villager.yes" | "minecraft:entity.villager.yes" | "entity.vindicator.ambient" | "minecraft:entity.vindicator.ambient" | "entity.vindicator.celebrate" | "minecraft:entity.vindicator.celebrate" | "entity.vindicator.death" | "minecraft:entity.vindicator.death" | "entity.vindicator.hurt" | "minecraft:entity.vindicator.hurt" | "entity.wandering_trader.ambient" | "minecraft:entity.wandering_trader.ambient" | "entity.wandering_trader.death" | "minecraft:entity.wandering_trader.death" | "entity.wandering_trader.disappeared" | "minecraft:entity.wandering_trader.disappeared" | "entity.wandering_trader.drink_milk" | "minecraft:entity.wandering_trader.drink_milk" | "entity.wandering_trader.drink_potion" | "minecraft:entity.wandering_trader.drink_potion" | "entity.wandering_trader.hurt" | "minecraft:entity.wandering_trader.hurt" | "entity.wandering_trader.no" | "minecraft:entity.wandering_trader.no" | "entity.wandering_trader.reappeared" | "minecraft:entity.wandering_trader.reappeared" | "entity.wandering_trader.trade" | "minecraft:entity.wandering_trader.trade" | "entity.wandering_trader.yes" | "minecraft:entity.wandering_trader.yes" | "entity.witch.ambient" | "minecraft:entity.witch.ambient" | "entity.witch.celebrate" | "minecraft:entity.witch.celebrate" | "entity.witch.death" | "minecraft:entity.witch.death" | "entity.witch.drink" | "minecraft:entity.witch.drink" | "entity.witch.hurt" | "minecraft:entity.witch.hurt" | "entity.witch.throw" | "minecraft:entity.witch.throw" | "entity.wither.ambient" | "minecraft:entity.wither.ambient" | "entity.wither.break_block" | "minecraft:entity.wither.break_block" | "entity.wither.death" | "minecraft:entity.wither.death" | "entity.wither.hurt" | "minecraft:entity.wither.hurt" | "entity.wither.shoot" | "minecraft:entity.wither.shoot" | "entity.wither.spawn" | "minecraft:entity.wither.spawn" | "entity.wither_skeleton.ambient" | "minecraft:entity.wither_skeleton.ambient" | "entity.wither_skeleton.death" | "minecraft:entity.wither_skeleton.death" | "entity.wither_skeleton.hurt" | "minecraft:entity.wither_skeleton.hurt" | "entity.wither_skeleton.step" | "minecraft:entity.wither_skeleton.step" | "entity.wolf.ambient" | "minecraft:entity.wolf.ambient" | "entity.wolf.death" | "minecraft:entity.wolf.death" | "entity.wolf.growl" | "minecraft:entity.wolf.growl" | "entity.wolf.howl" | "minecraft:entity.wolf.howl" | "entity.wolf.hurt" | "minecraft:entity.wolf.hurt" | "entity.wolf.pant" | "minecraft:entity.wolf.pant" | "entity.wolf.shake" | "minecraft:entity.wolf.shake" | "entity.wolf.step" | "minecraft:entity.wolf.step" | "entity.wolf.whine" | "minecraft:entity.wolf.whine" | "entity.zoglin.ambient" | "minecraft:entity.zoglin.ambient" | "entity.zoglin.angry" | "minecraft:entity.zoglin.angry" | "entity.zoglin.attack" | "minecraft:entity.zoglin.attack" | "entity.zoglin.death" | "minecraft:entity.zoglin.death" | "entity.zoglin.hurt" | "minecraft:entity.zoglin.hurt" | "entity.zoglin.step" | "minecraft:entity.zoglin.step" | "entity.zombie.ambient" | "minecraft:entity.zombie.ambient" | "entity.zombie.attack_iron_door" | "minecraft:entity.zombie.attack_iron_door" | "entity.zombie.attack_wooden_door" | "minecraft:entity.zombie.attack_wooden_door" | "entity.zombie.break_wooden_door" | "minecraft:entity.zombie.break_wooden_door" | "entity.zombie.converted_to_drowned" | "minecraft:entity.zombie.converted_to_drowned" | "entity.zombie.death" | "minecraft:entity.zombie.death" | "entity.zombie.destroy_egg" | "minecraft:entity.zombie.destroy_egg" | "entity.zombie.hurt" | "minecraft:entity.zombie.hurt" | "entity.zombie.infect" | "minecraft:entity.zombie.infect" | "entity.zombie.step" | "minecraft:entity.zombie.step" | "entity.zombie_horse.ambient" | "minecraft:entity.zombie_horse.ambient" | "entity.zombie_horse.death" | "minecraft:entity.zombie_horse.death" | "entity.zombie_horse.hurt" | "minecraft:entity.zombie_horse.hurt" | "entity.zombie_villager.ambient" | "minecraft:entity.zombie_villager.ambient" | "entity.zombie_villager.converted" | "minecraft:entity.zombie_villager.converted" | "entity.zombie_villager.cure" | "minecraft:entity.zombie_villager.cure" | "entity.zombie_villager.death" | "minecraft:entity.zombie_villager.death" | "entity.zombie_villager.hurt" | "minecraft:entity.zombie_villager.hurt" | "entity.zombie_villager.step" | "minecraft:entity.zombie_villager.step" | "entity.zombified_piglin.ambient" | "minecraft:entity.zombified_piglin.ambient" | "entity.zombified_piglin.angry" | "minecraft:entity.zombified_piglin.angry" | "entity.zombified_piglin.death" | "minecraft:entity.zombified_piglin.death" | "entity.zombified_piglin.hurt" | "minecraft:entity.zombified_piglin.hurt" | "event.raid.horn" | "minecraft:event.raid.horn" | "item.armor.equip_chain" | "minecraft:item.armor.equip_chain" | "item.armor.equip_diamond" | "minecraft:item.armor.equip_diamond" | "item.armor.equip_elytra" | "minecraft:item.armor.equip_elytra" | "item.armor.equip_generic" | "minecraft:item.armor.equip_generic" | "item.armor.equip_gold" | "minecraft:item.armor.equip_gold" | "item.armor.equip_iron" | "minecraft:item.armor.equip_iron" | "item.armor.equip_leather" | "minecraft:item.armor.equip_leather" | "item.armor.equip_netherite" | "minecraft:item.armor.equip_netherite" | "item.armor.equip_turtle" | "minecraft:item.armor.equip_turtle" | "item.axe.scrape" | "minecraft:item.axe.scrape" | "item.axe.strip" | "minecraft:item.axe.strip" | "item.axe.wax_off" | "minecraft:item.axe.wax_off" | "item.bone_meal.use" | "minecraft:item.bone_meal.use" | "item.book.page_turn" | "minecraft:item.book.page_turn" | "item.book.put" | "minecraft:item.book.put" | "item.bottle.empty" | "minecraft:item.bottle.empty" | "item.bottle.fill" | "minecraft:item.bottle.fill" | "item.bottle.fill_dragonbreath" | "minecraft:item.bottle.fill_dragonbreath" | "item.bucket.empty" | "minecraft:item.bucket.empty" | "item.bucket.empty_axolotl" | "minecraft:item.bucket.empty_axolotl" | "item.bucket.empty_fish" | "minecraft:item.bucket.empty_fish" | "item.bucket.empty_lava" | "minecraft:item.bucket.empty_lava" | "item.bucket.empty_powder_snow" | "minecraft:item.bucket.empty_powder_snow" | "item.bucket.fill" | "minecraft:item.bucket.fill" | "item.bucket.fill_axolotl" | "minecraft:item.bucket.fill_axolotl" | "item.bucket.fill_fish" | "minecraft:item.bucket.fill_fish" | "item.bucket.fill_lava" | "minecraft:item.bucket.fill_lava" | "item.bucket.fill_powder_snow" | "minecraft:item.bucket.fill_powder_snow" | "item.bundle.drop_contents" | "minecraft:item.bundle.drop_contents" | "item.bundle.insert" | "minecraft:item.bundle.insert" | "item.bundle.remove_one" | "minecraft:item.bundle.remove_one" | "item.chorus_fruit.teleport" | "minecraft:item.chorus_fruit.teleport" | "item.crop.plant" | "minecraft:item.crop.plant" | "item.crossbow.hit" | "minecraft:item.crossbow.hit" | "item.crossbow.loading_end" | "minecraft:item.crossbow.loading_end" | "item.crossbow.loading_middle" | "minecraft:item.crossbow.loading_middle" | "item.crossbow.loading_start" | "minecraft:item.crossbow.loading_start" | "item.crossbow.quick_charge_1" | "minecraft:item.crossbow.quick_charge_1" | "item.crossbow.quick_charge_2" | "minecraft:item.crossbow.quick_charge_2" | "item.crossbow.quick_charge_3" | "minecraft:item.crossbow.quick_charge_3" | "item.crossbow.shoot" | "minecraft:item.crossbow.shoot" | "item.dye.use" | "minecraft:item.dye.use" | "item.elytra.flying" | "minecraft:item.elytra.flying" | "item.firecharge.use" | "minecraft:item.firecharge.use" | "item.flintandsteel.use" | "minecraft:item.flintandsteel.use" | "item.glow_ink_sac.use" | "minecraft:item.glow_ink_sac.use" | "item.hoe.till" | "minecraft:item.hoe.till" | "item.honey_bottle.drink" | "minecraft:item.honey_bottle.drink" | "item.honeycomb.wax_on" | "minecraft:item.honeycomb.wax_on" | "item.ink_sac.use" | "minecraft:item.ink_sac.use" | "item.lodestone_compass.lock" | "minecraft:item.lodestone_compass.lock" | "item.nether_wart.plant" | "minecraft:item.nether_wart.plant" | "item.shield.block" | "minecraft:item.shield.block" | "item.shield.break" | "minecraft:item.shield.break" | "item.shovel.flatten" | "minecraft:item.shovel.flatten" | "item.spyglass.stop_using" | "minecraft:item.spyglass.stop_using" | "item.spyglass.use" | "minecraft:item.spyglass.use" | "item.totem.use" | "minecraft:item.totem.use" | "item.trident.hit" | "minecraft:item.trident.hit" | "item.trident.hit_ground" | "minecraft:item.trident.hit_ground" | "item.trident.return" | "minecraft:item.trident.return" | "item.trident.riptide_1" | "minecraft:item.trident.riptide_1" | "item.trident.riptide_2" | "minecraft:item.trident.riptide_2" | "item.trident.riptide_3" | "minecraft:item.trident.riptide_3" | "item.trident.throw" | "minecraft:item.trident.throw" | "item.trident.thunder" | "minecraft:item.trident.thunder" | "music.creative" | "minecraft:music.creative" | "music.credits" | "minecraft:music.credits" | "music.dragon" | "minecraft:music.dragon" | "music.end" | "minecraft:music.end" | "music.game" | "minecraft:music.game" | "music.menu" | "minecraft:music.menu" | "music.nether.basalt_deltas" | "minecraft:music.nether.basalt_deltas" | "music.nether.crimson_forest" | "minecraft:music.nether.crimson_forest" | "music.nether.nether_wastes" | "minecraft:music.nether.nether_wastes" | "music.nether.soul_sand_valley" | "minecraft:music.nether.soul_sand_valley" | "music.nether.warped_forest" | "minecraft:music.nether.warped_forest" | "music.overworld.dripstone_caves" | "minecraft:music.overworld.dripstone_caves" | "music.overworld.frozen_peaks" | "minecraft:music.overworld.frozen_peaks" | "music.overworld.grove" | "minecraft:music.overworld.grove" | "music.overworld.jagged_peaks" | "minecraft:music.overworld.jagged_peaks" | "music.overworld.lush_caves" | "minecraft:music.overworld.lush_caves" | "music.overworld.meadow" | "minecraft:music.overworld.meadow" | "music.overworld.snowy_slopes" | "minecraft:music.overworld.snowy_slopes" | "music.overworld.stony_peaks" | "minecraft:music.overworld.stony_peaks" | "music.under_water" | "minecraft:music.under_water" | "music_disc.11" | "minecraft:music_disc.11" | "music_disc.13" | "minecraft:music_disc.13" | "music_disc.blocks" | "minecraft:music_disc.blocks" | "music_disc.cat" | "minecraft:music_disc.cat" | "music_disc.chirp" | "minecraft:music_disc.chirp" | "music_disc.far" | "minecraft:music_disc.far" | "music_disc.mall" | "minecraft:music_disc.mall" | "music_disc.mellohi" | "minecraft:music_disc.mellohi" | "music_disc.otherside" | "minecraft:music_disc.otherside" | "music_disc.pigstep" | "minecraft:music_disc.pigstep" | "music_disc.stal" | "minecraft:music_disc.stal" | "music_disc.strad" | "minecraft:music_disc.strad" | "music_disc.wait" | "minecraft:music_disc.wait" | "music_disc.ward" | "minecraft:music_disc.ward" | "particle.soul_escape" | "minecraft:particle.soul_escape" | "ui.button.click" | "minecraft:ui.button.click" | "ui.cartography_table.take_result" | "minecraft:ui.cartography_table.take_result" | "ui.loom.select_pattern" | "minecraft:ui.loom.select_pattern" | "ui.loom.take_result" | "minecraft:ui.loom.take_result" | "ui.stonecutter.select_recipe" | "minecraft:ui.stonecutter.select_recipe" | "ui.stonecutter.take_result" | "minecraft:ui.stonecutter.take_result" | "ui.toast.challenge_complete" | "minecraft:ui.toast.challenge_complete" | "ui.toast.in" | "minecraft:ui.toast.in" | "ui.toast.out" | "minecraft:ui.toast.out" | "weather.rain" | "minecraft:weather.rain" | "weather.rain.above" | "minecraft:weather.rain.above";
    type Fluid = "empty" | "minecraft:empty" | "flowing_lava" | "minecraft:flowing_lava" | "flowing_milk" | "minecraft:flowing_milk" | "flowing_water" | "minecraft:flowing_water" | "lava" | "minecraft:lava" | "milk" | "minecraft:milk" | "water" | "minecraft:water";
    type MobEffect = "absorption" | "minecraft:absorption" | "bad_omen" | "minecraft:bad_omen" | "blindness" | "minecraft:blindness" | "conduit_power" | "minecraft:conduit_power" | "dolphins_grace" | "minecraft:dolphins_grace" | "fire_resistance" | "minecraft:fire_resistance" | "glowing" | "minecraft:glowing" | "haste" | "minecraft:haste" | "health_boost" | "minecraft:health_boost" | "hero_of_the_village" | "minecraft:hero_of_the_village" | "hunger" | "minecraft:hunger" | "instant_damage" | "minecraft:instant_damage" | "instant_health" | "minecraft:instant_health" | "invisibility" | "minecraft:invisibility" | "jump_boost" | "minecraft:jump_boost" | "levitation" | "minecraft:levitation" | "luck" | "minecraft:luck" | "mining_fatigue" | "minecraft:mining_fatigue" | "nausea" | "minecraft:nausea" | "night_vision" | "minecraft:night_vision" | "poison" | "minecraft:poison" | "regeneration" | "minecraft:regeneration" | "resistance" | "minecraft:resistance" | "saturation" | "minecraft:saturation" | "slow_falling" | "minecraft:slow_falling" | "slowness" | "minecraft:slowness" | "speed" | "minecraft:speed" | "strength" | "minecraft:strength" | "unluck" | "minecraft:unluck" | "water_breathing" | "minecraft:water_breathing" | "weakness" | "minecraft:weakness" | "wither" | "minecraft:wither";
    type Block = "acacia_button" | "minecraft:acacia_button" | "acacia_door" | "minecraft:acacia_door" | "acacia_fence" | "minecraft:acacia_fence" | "acacia_fence_gate" | "minecraft:acacia_fence_gate" | "acacia_leaves" | "minecraft:acacia_leaves" | "acacia_log" | "minecraft:acacia_log" | "acacia_planks" | "minecraft:acacia_planks" | "acacia_pressure_plate" | "minecraft:acacia_pressure_plate" | "acacia_sapling" | "minecraft:acacia_sapling" | "acacia_sign" | "minecraft:acacia_sign" | "acacia_slab" | "minecraft:acacia_slab" | "acacia_stairs" | "minecraft:acacia_stairs" | "acacia_trapdoor" | "minecraft:acacia_trapdoor" | "acacia_wall_sign" | "minecraft:acacia_wall_sign" | "acacia_wood" | "minecraft:acacia_wood" | "activator_rail" | "minecraft:activator_rail" | "air" | "minecraft:air" | "allium" | "minecraft:allium" | "amethyst_block" | "minecraft:amethyst_block" | "amethyst_cluster" | "minecraft:amethyst_cluster" | "ancient_debris" | "minecraft:ancient_debris" | "andesite" | "minecraft:andesite" | "andesite_slab" | "minecraft:andesite_slab" | "andesite_stairs" | "minecraft:andesite_stairs" | "andesite_wall" | "minecraft:andesite_wall" | "anvil" | "minecraft:anvil" | "attached_melon_stem" | "minecraft:attached_melon_stem" | "attached_pumpkin_stem" | "minecraft:attached_pumpkin_stem" | "azalea" | "minecraft:azalea" | "azalea_leaves" | "minecraft:azalea_leaves" | "azure_bluet" | "minecraft:azure_bluet" | "bamboo" | "minecraft:bamboo" | "bamboo_sapling" | "minecraft:bamboo_sapling" | "barrel" | "minecraft:barrel" | "barrier" | "minecraft:barrier" | "basalt" | "minecraft:basalt" | "beacon" | "minecraft:beacon" | "bedrock" | "minecraft:bedrock" | "bee_nest" | "minecraft:bee_nest" | "beehive" | "minecraft:beehive" | "beetroots" | "minecraft:beetroots" | "bell" | "minecraft:bell" | "big_dripleaf" | "minecraft:big_dripleaf" | "big_dripleaf_stem" | "minecraft:big_dripleaf_stem" | "birch_button" | "minecraft:birch_button" | "birch_door" | "minecraft:birch_door" | "birch_fence" | "minecraft:birch_fence" | "birch_fence_gate" | "minecraft:birch_fence_gate" | "birch_leaves" | "minecraft:birch_leaves" | "birch_log" | "minecraft:birch_log" | "birch_planks" | "minecraft:birch_planks" | "birch_pressure_plate" | "minecraft:birch_pressure_plate" | "birch_sapling" | "minecraft:birch_sapling" | "birch_sign" | "minecraft:birch_sign" | "birch_slab" | "minecraft:birch_slab" | "birch_stairs" | "minecraft:birch_stairs" | "birch_trapdoor" | "minecraft:birch_trapdoor" | "birch_wall_sign" | "minecraft:birch_wall_sign" | "birch_wood" | "minecraft:birch_wood" | "black_banner" | "minecraft:black_banner" | "black_bed" | "minecraft:black_bed" | "black_candle" | "minecraft:black_candle" | "black_candle_cake" | "minecraft:black_candle_cake" | "black_carpet" | "minecraft:black_carpet" | "black_concrete" | "minecraft:black_concrete" | "black_concrete_powder" | "minecraft:black_concrete_powder" | "black_glazed_terracotta" | "minecraft:black_glazed_terracotta" | "black_shulker_box" | "minecraft:black_shulker_box" | "black_stained_glass" | "minecraft:black_stained_glass" | "black_stained_glass_pane" | "minecraft:black_stained_glass_pane" | "black_terracotta" | "minecraft:black_terracotta" | "black_wall_banner" | "minecraft:black_wall_banner" | "black_wool" | "minecraft:black_wool" | "blackstone" | "minecraft:blackstone" | "blackstone_slab" | "minecraft:blackstone_slab" | "blackstone_stairs" | "minecraft:blackstone_stairs" | "blackstone_wall" | "minecraft:blackstone_wall" | "blast_furnace" | "minecraft:blast_furnace" | "blue_banner" | "minecraft:blue_banner" | "blue_bed" | "minecraft:blue_bed" | "blue_candle" | "minecraft:blue_candle" | "blue_candle_cake" | "minecraft:blue_candle_cake" | "blue_carpet" | "minecraft:blue_carpet" | "blue_concrete" | "minecraft:blue_concrete" | "blue_concrete_powder" | "minecraft:blue_concrete_powder" | "blue_glazed_terracotta" | "minecraft:blue_glazed_terracotta" | "blue_ice" | "minecraft:blue_ice" | "blue_orchid" | "minecraft:blue_orchid" | "blue_shulker_box" | "minecraft:blue_shulker_box" | "blue_stained_glass" | "minecraft:blue_stained_glass" | "blue_stained_glass_pane" | "minecraft:blue_stained_glass_pane" | "blue_terracotta" | "minecraft:blue_terracotta" | "blue_wall_banner" | "minecraft:blue_wall_banner" | "blue_wool" | "minecraft:blue_wool" | "bone_block" | "minecraft:bone_block" | "bookshelf" | "minecraft:bookshelf" | "brain_coral" | "minecraft:brain_coral" | "brain_coral_block" | "minecraft:brain_coral_block" | "brain_coral_fan" | "minecraft:brain_coral_fan" | "brain_coral_wall_fan" | "minecraft:brain_coral_wall_fan" | "brewing_stand" | "minecraft:brewing_stand" | "brick_slab" | "minecraft:brick_slab" | "brick_stairs" | "minecraft:brick_stairs" | "brick_wall" | "minecraft:brick_wall" | "bricks" | "minecraft:bricks" | "brown_banner" | "minecraft:brown_banner" | "brown_bed" | "minecraft:brown_bed" | "brown_candle" | "minecraft:brown_candle" | "brown_candle_cake" | "minecraft:brown_candle_cake" | "brown_carpet" | "minecraft:brown_carpet" | "brown_concrete" | "minecraft:brown_concrete" | "brown_concrete_powder" | "minecraft:brown_concrete_powder" | "brown_glazed_terracotta" | "minecraft:brown_glazed_terracotta" | "brown_mushroom" | "minecraft:brown_mushroom" | "brown_mushroom_block" | "minecraft:brown_mushroom_block" | "brown_shulker_box" | "minecraft:brown_shulker_box" | "brown_stained_glass" | "minecraft:brown_stained_glass" | "brown_stained_glass_pane" | "minecraft:brown_stained_glass_pane" | "brown_terracotta" | "minecraft:brown_terracotta" | "brown_wall_banner" | "minecraft:brown_wall_banner" | "brown_wool" | "minecraft:brown_wool" | "bubble_column" | "minecraft:bubble_column" | "bubble_coral" | "minecraft:bubble_coral" | "bubble_coral_block" | "minecraft:bubble_coral_block" | "bubble_coral_fan" | "minecraft:bubble_coral_fan" | "bubble_coral_wall_fan" | "minecraft:bubble_coral_wall_fan" | "budding_amethyst" | "minecraft:budding_amethyst" | "cactus" | "minecraft:cactus" | "cake" | "minecraft:cake" | "calcite" | "minecraft:calcite" | "campfire" | "minecraft:campfire" | "candle" | "minecraft:candle" | "candle_cake" | "minecraft:candle_cake" | "carrots" | "minecraft:carrots" | "cartography_table" | "minecraft:cartography_table" | "carved_pumpkin" | "minecraft:carved_pumpkin" | "cauldron" | "minecraft:cauldron" | "cave_air" | "minecraft:cave_air" | "cave_vines" | "minecraft:cave_vines" | "cave_vines_plant" | "minecraft:cave_vines_plant" | "chain" | "minecraft:chain" | "chain_command_block" | "minecraft:chain_command_block" | "chest" | "minecraft:chest" | "chipped_anvil" | "minecraft:chipped_anvil" | "chiseled_deepslate" | "minecraft:chiseled_deepslate" | "chiseled_nether_bricks" | "minecraft:chiseled_nether_bricks" | "chiseled_polished_blackstone" | "minecraft:chiseled_polished_blackstone" | "chiseled_quartz_block" | "minecraft:chiseled_quartz_block" | "chiseled_red_sandstone" | "minecraft:chiseled_red_sandstone" | "chiseled_sandstone" | "minecraft:chiseled_sandstone" | "chiseled_stone_bricks" | "minecraft:chiseled_stone_bricks" | "chorus_flower" | "minecraft:chorus_flower" | "chorus_plant" | "minecraft:chorus_plant" | "clay" | "minecraft:clay" | "coal_block" | "minecraft:coal_block" | "coal_ore" | "minecraft:coal_ore" | "coarse_dirt" | "minecraft:coarse_dirt" | "cobbled_deepslate" | "minecraft:cobbled_deepslate" | "cobbled_deepslate_slab" | "minecraft:cobbled_deepslate_slab" | "cobbled_deepslate_stairs" | "minecraft:cobbled_deepslate_stairs" | "cobbled_deepslate_wall" | "minecraft:cobbled_deepslate_wall" | "cobblestone" | "minecraft:cobblestone" | "cobblestone_slab" | "minecraft:cobblestone_slab" | "cobblestone_stairs" | "minecraft:cobblestone_stairs" | "cobblestone_wall" | "minecraft:cobblestone_wall" | "cobweb" | "minecraft:cobweb" | "cocoa" | "minecraft:cocoa" | "command_block" | "minecraft:command_block" | "comparator" | "minecraft:comparator" | "composter" | "minecraft:composter" | "conduit" | "minecraft:conduit" | "copper_block" | "minecraft:copper_block" | "copper_ore" | "minecraft:copper_ore" | "cornflower" | "minecraft:cornflower" | "cracked_deepslate_bricks" | "minecraft:cracked_deepslate_bricks" | "cracked_deepslate_tiles" | "minecraft:cracked_deepslate_tiles" | "cracked_nether_bricks" | "minecraft:cracked_nether_bricks" | "cracked_polished_blackstone_bricks" | "minecraft:cracked_polished_blackstone_bricks" | "cracked_stone_bricks" | "minecraft:cracked_stone_bricks" | "crafting_table" | "minecraft:crafting_table" | "creeper_head" | "minecraft:creeper_head" | "creeper_wall_head" | "minecraft:creeper_wall_head" | "crimson_button" | "minecraft:crimson_button" | "crimson_door" | "minecraft:crimson_door" | "crimson_fence" | "minecraft:crimson_fence" | "crimson_fence_gate" | "minecraft:crimson_fence_gate" | "crimson_fungus" | "minecraft:crimson_fungus" | "crimson_hyphae" | "minecraft:crimson_hyphae" | "crimson_nylium" | "minecraft:crimson_nylium" | "crimson_planks" | "minecraft:crimson_planks" | "crimson_pressure_plate" | "minecraft:crimson_pressure_plate" | "crimson_roots" | "minecraft:crimson_roots" | "crimson_sign" | "minecraft:crimson_sign" | "crimson_slab" | "minecraft:crimson_slab" | "crimson_stairs" | "minecraft:crimson_stairs" | "crimson_stem" | "minecraft:crimson_stem" | "crimson_trapdoor" | "minecraft:crimson_trapdoor" | "crimson_wall_sign" | "minecraft:crimson_wall_sign" | "crying_obsidian" | "minecraft:crying_obsidian" | "cut_copper" | "minecraft:cut_copper" | "cut_copper_slab" | "minecraft:cut_copper_slab" | "cut_copper_stairs" | "minecraft:cut_copper_stairs" | "cut_red_sandstone" | "minecraft:cut_red_sandstone" | "cut_red_sandstone_slab" | "minecraft:cut_red_sandstone_slab" | "cut_sandstone" | "minecraft:cut_sandstone" | "cut_sandstone_slab" | "minecraft:cut_sandstone_slab" | "cyan_banner" | "minecraft:cyan_banner" | "cyan_bed" | "minecraft:cyan_bed" | "cyan_candle" | "minecraft:cyan_candle" | "cyan_candle_cake" | "minecraft:cyan_candle_cake" | "cyan_carpet" | "minecraft:cyan_carpet" | "cyan_concrete" | "minecraft:cyan_concrete" | "cyan_concrete_powder" | "minecraft:cyan_concrete_powder" | "cyan_glazed_terracotta" | "minecraft:cyan_glazed_terracotta" | "cyan_shulker_box" | "minecraft:cyan_shulker_box" | "cyan_stained_glass" | "minecraft:cyan_stained_glass" | "cyan_stained_glass_pane" | "minecraft:cyan_stained_glass_pane" | "cyan_terracotta" | "minecraft:cyan_terracotta" | "cyan_wall_banner" | "minecraft:cyan_wall_banner" | "cyan_wool" | "minecraft:cyan_wool" | "damaged_anvil" | "minecraft:damaged_anvil" | "dandelion" | "minecraft:dandelion" | "dark_oak_button" | "minecraft:dark_oak_button" | "dark_oak_door" | "minecraft:dark_oak_door" | "dark_oak_fence" | "minecraft:dark_oak_fence" | "dark_oak_fence_gate" | "minecraft:dark_oak_fence_gate" | "dark_oak_leaves" | "minecraft:dark_oak_leaves" | "dark_oak_log" | "minecraft:dark_oak_log" | "dark_oak_planks" | "minecraft:dark_oak_planks" | "dark_oak_pressure_plate" | "minecraft:dark_oak_pressure_plate" | "dark_oak_sapling" | "minecraft:dark_oak_sapling" | "dark_oak_sign" | "minecraft:dark_oak_sign" | "dark_oak_slab" | "minecraft:dark_oak_slab" | "dark_oak_stairs" | "minecraft:dark_oak_stairs" | "dark_oak_trapdoor" | "minecraft:dark_oak_trapdoor" | "dark_oak_wall_sign" | "minecraft:dark_oak_wall_sign" | "dark_oak_wood" | "minecraft:dark_oak_wood" | "dark_prismarine" | "minecraft:dark_prismarine" | "dark_prismarine_slab" | "minecraft:dark_prismarine_slab" | "dark_prismarine_stairs" | "minecraft:dark_prismarine_stairs" | "daylight_detector" | "minecraft:daylight_detector" | "dead_brain_coral" | "minecraft:dead_brain_coral" | "dead_brain_coral_block" | "minecraft:dead_brain_coral_block" | "dead_brain_coral_fan" | "minecraft:dead_brain_coral_fan" | "dead_brain_coral_wall_fan" | "minecraft:dead_brain_coral_wall_fan" | "dead_bubble_coral" | "minecraft:dead_bubble_coral" | "dead_bubble_coral_block" | "minecraft:dead_bubble_coral_block" | "dead_bubble_coral_fan" | "minecraft:dead_bubble_coral_fan" | "dead_bubble_coral_wall_fan" | "minecraft:dead_bubble_coral_wall_fan" | "dead_bush" | "minecraft:dead_bush" | "dead_fire_coral" | "minecraft:dead_fire_coral" | "dead_fire_coral_block" | "minecraft:dead_fire_coral_block" | "dead_fire_coral_fan" | "minecraft:dead_fire_coral_fan" | "dead_fire_coral_wall_fan" | "minecraft:dead_fire_coral_wall_fan" | "dead_horn_coral" | "minecraft:dead_horn_coral" | "dead_horn_coral_block" | "minecraft:dead_horn_coral_block" | "dead_horn_coral_fan" | "minecraft:dead_horn_coral_fan" | "dead_horn_coral_wall_fan" | "minecraft:dead_horn_coral_wall_fan" | "dead_tube_coral" | "minecraft:dead_tube_coral" | "dead_tube_coral_block" | "minecraft:dead_tube_coral_block" | "dead_tube_coral_fan" | "minecraft:dead_tube_coral_fan" | "dead_tube_coral_wall_fan" | "minecraft:dead_tube_coral_wall_fan" | "deepslate" | "minecraft:deepslate" | "deepslate_brick_slab" | "minecraft:deepslate_brick_slab" | "deepslate_brick_stairs" | "minecraft:deepslate_brick_stairs" | "deepslate_brick_wall" | "minecraft:deepslate_brick_wall" | "deepslate_bricks" | "minecraft:deepslate_bricks" | "deepslate_coal_ore" | "minecraft:deepslate_coal_ore" | "deepslate_copper_ore" | "minecraft:deepslate_copper_ore" | "deepslate_diamond_ore" | "minecraft:deepslate_diamond_ore" | "deepslate_emerald_ore" | "minecraft:deepslate_emerald_ore" | "deepslate_gold_ore" | "minecraft:deepslate_gold_ore" | "deepslate_iron_ore" | "minecraft:deepslate_iron_ore" | "deepslate_lapis_ore" | "minecraft:deepslate_lapis_ore" | "deepslate_redstone_ore" | "minecraft:deepslate_redstone_ore" | "deepslate_tile_slab" | "minecraft:deepslate_tile_slab" | "deepslate_tile_stairs" | "minecraft:deepslate_tile_stairs" | "deepslate_tile_wall" | "minecraft:deepslate_tile_wall" | "deepslate_tiles" | "minecraft:deepslate_tiles" | "detector_rail" | "minecraft:detector_rail" | "diamond_block" | "minecraft:diamond_block" | "diamond_ore" | "minecraft:diamond_ore" | "diorite" | "minecraft:diorite" | "diorite_slab" | "minecraft:diorite_slab" | "diorite_stairs" | "minecraft:diorite_stairs" | "diorite_wall" | "minecraft:diorite_wall" | "dirt" | "minecraft:dirt" | "dirt_path" | "minecraft:dirt_path" | "dispenser" | "minecraft:dispenser" | "dragon_egg" | "minecraft:dragon_egg" | "dragon_head" | "minecraft:dragon_head" | "dragon_wall_head" | "minecraft:dragon_wall_head" | "dried_kelp_block" | "minecraft:dried_kelp_block" | "dripstone_block" | "minecraft:dripstone_block" | "dropper" | "minecraft:dropper" | "emerald_block" | "minecraft:emerald_block" | "emerald_ore" | "minecraft:emerald_ore" | "enchanting_table" | "minecraft:enchanting_table" | "end_gateway" | "minecraft:end_gateway" | "end_portal" | "minecraft:end_portal" | "end_portal_frame" | "minecraft:end_portal_frame" | "end_rod" | "minecraft:end_rod" | "end_stone" | "minecraft:end_stone" | "end_stone_brick_slab" | "minecraft:end_stone_brick_slab" | "end_stone_brick_stairs" | "minecraft:end_stone_brick_stairs" | "end_stone_brick_wall" | "minecraft:end_stone_brick_wall" | "end_stone_bricks" | "minecraft:end_stone_bricks" | "ender_chest" | "minecraft:ender_chest" | "exposed_copper" | "minecraft:exposed_copper" | "exposed_cut_copper" | "minecraft:exposed_cut_copper" | "exposed_cut_copper_slab" | "minecraft:exposed_cut_copper_slab" | "exposed_cut_copper_stairs" | "minecraft:exposed_cut_copper_stairs" | "farmland" | "minecraft:farmland" | "fern" | "minecraft:fern" | "fire" | "minecraft:fire" | "fire_coral" | "minecraft:fire_coral" | "fire_coral_block" | "minecraft:fire_coral_block" | "fire_coral_fan" | "minecraft:fire_coral_fan" | "fire_coral_wall_fan" | "minecraft:fire_coral_wall_fan" | "fletching_table" | "minecraft:fletching_table" | "flower_pot" | "minecraft:flower_pot" | "flowering_azalea" | "minecraft:flowering_azalea" | "flowering_azalea_leaves" | "minecraft:flowering_azalea_leaves" | "frosted_ice" | "minecraft:frosted_ice" | "furnace" | "minecraft:furnace" | "gilded_blackstone" | "minecraft:gilded_blackstone" | "glass" | "minecraft:glass" | "glass_pane" | "minecraft:glass_pane" | "glow_lichen" | "minecraft:glow_lichen" | "glowstone" | "minecraft:glowstone" | "gold_block" | "minecraft:gold_block" | "gold_ore" | "minecraft:gold_ore" | "granite" | "minecraft:granite" | "granite_slab" | "minecraft:granite_slab" | "granite_stairs" | "minecraft:granite_stairs" | "granite_wall" | "minecraft:granite_wall" | "grass" | "minecraft:grass" | "grass_block" | "minecraft:grass_block" | "gravel" | "minecraft:gravel" | "gray_banner" | "minecraft:gray_banner" | "gray_bed" | "minecraft:gray_bed" | "gray_candle" | "minecraft:gray_candle" | "gray_candle_cake" | "minecraft:gray_candle_cake" | "gray_carpet" | "minecraft:gray_carpet" | "gray_concrete" | "minecraft:gray_concrete" | "gray_concrete_powder" | "minecraft:gray_concrete_powder" | "gray_glazed_terracotta" | "minecraft:gray_glazed_terracotta" | "gray_shulker_box" | "minecraft:gray_shulker_box" | "gray_stained_glass" | "minecraft:gray_stained_glass" | "gray_stained_glass_pane" | "minecraft:gray_stained_glass_pane" | "gray_terracotta" | "minecraft:gray_terracotta" | "gray_wall_banner" | "minecraft:gray_wall_banner" | "gray_wool" | "minecraft:gray_wool" | "green_banner" | "minecraft:green_banner" | "green_bed" | "minecraft:green_bed" | "green_candle" | "minecraft:green_candle" | "green_candle_cake" | "minecraft:green_candle_cake" | "green_carpet" | "minecraft:green_carpet" | "green_concrete" | "minecraft:green_concrete" | "green_concrete_powder" | "minecraft:green_concrete_powder" | "green_glazed_terracotta" | "minecraft:green_glazed_terracotta" | "green_shulker_box" | "minecraft:green_shulker_box" | "green_stained_glass" | "minecraft:green_stained_glass" | "green_stained_glass_pane" | "minecraft:green_stained_glass_pane" | "green_terracotta" | "minecraft:green_terracotta" | "green_wall_banner" | "minecraft:green_wall_banner" | "green_wool" | "minecraft:green_wool" | "grindstone" | "minecraft:grindstone" | "hanging_roots" | "minecraft:hanging_roots" | "hay_block" | "minecraft:hay_block" | "heavy_weighted_pressure_plate" | "minecraft:heavy_weighted_pressure_plate" | "honey_block" | "minecraft:honey_block" | "honeycomb_block" | "minecraft:honeycomb_block" | "hopper" | "minecraft:hopper" | "horn_coral" | "minecraft:horn_coral" | "horn_coral_block" | "minecraft:horn_coral_block" | "horn_coral_fan" | "minecraft:horn_coral_fan" | "horn_coral_wall_fan" | "minecraft:horn_coral_wall_fan" | "ice" | "minecraft:ice" | "infested_chiseled_stone_bricks" | "minecraft:infested_chiseled_stone_bricks" | "infested_cobblestone" | "minecraft:infested_cobblestone" | "infested_cracked_stone_bricks" | "minecraft:infested_cracked_stone_bricks" | "infested_deepslate" | "minecraft:infested_deepslate" | "infested_mossy_stone_bricks" | "minecraft:infested_mossy_stone_bricks" | "infested_stone" | "minecraft:infested_stone" | "infested_stone_bricks" | "minecraft:infested_stone_bricks" | "iron_bars" | "minecraft:iron_bars" | "iron_block" | "minecraft:iron_block" | "iron_door" | "minecraft:iron_door" | "iron_ore" | "minecraft:iron_ore" | "iron_trapdoor" | "minecraft:iron_trapdoor" | "jack_o_lantern" | "minecraft:jack_o_lantern" | "jigsaw" | "minecraft:jigsaw" | "jukebox" | "minecraft:jukebox" | "jungle_button" | "minecraft:jungle_button" | "jungle_door" | "minecraft:jungle_door" | "jungle_fence" | "minecraft:jungle_fence" | "jungle_fence_gate" | "minecraft:jungle_fence_gate" | "jungle_leaves" | "minecraft:jungle_leaves" | "jungle_log" | "minecraft:jungle_log" | "jungle_planks" | "minecraft:jungle_planks" | "jungle_pressure_plate" | "minecraft:jungle_pressure_plate" | "jungle_sapling" | "minecraft:jungle_sapling" | "jungle_sign" | "minecraft:jungle_sign" | "jungle_slab" | "minecraft:jungle_slab" | "jungle_stairs" | "minecraft:jungle_stairs" | "jungle_trapdoor" | "minecraft:jungle_trapdoor" | "jungle_wall_sign" | "minecraft:jungle_wall_sign" | "jungle_wood" | "minecraft:jungle_wood" | "kelp" | "minecraft:kelp" | "kelp_plant" | "minecraft:kelp_plant" | "ladder" | "minecraft:ladder" | "lantern" | "minecraft:lantern" | "lapis_block" | "minecraft:lapis_block" | "lapis_ore" | "minecraft:lapis_ore" | "large_amethyst_bud" | "minecraft:large_amethyst_bud" | "large_fern" | "minecraft:large_fern" | "lava" | "minecraft:lava" | "lava_cauldron" | "minecraft:lava_cauldron" | "lectern" | "minecraft:lectern" | "lever" | "minecraft:lever" | "light" | "minecraft:light" | "light_blue_banner" | "minecraft:light_blue_banner" | "light_blue_bed" | "minecraft:light_blue_bed" | "light_blue_candle" | "minecraft:light_blue_candle" | "light_blue_candle_cake" | "minecraft:light_blue_candle_cake" | "light_blue_carpet" | "minecraft:light_blue_carpet" | "light_blue_concrete" | "minecraft:light_blue_concrete" | "light_blue_concrete_powder" | "minecraft:light_blue_concrete_powder" | "light_blue_glazed_terracotta" | "minecraft:light_blue_glazed_terracotta" | "light_blue_shulker_box" | "minecraft:light_blue_shulker_box" | "light_blue_stained_glass" | "minecraft:light_blue_stained_glass" | "light_blue_stained_glass_pane" | "minecraft:light_blue_stained_glass_pane" | "light_blue_terracotta" | "minecraft:light_blue_terracotta" | "light_blue_wall_banner" | "minecraft:light_blue_wall_banner" | "light_blue_wool" | "minecraft:light_blue_wool" | "light_gray_banner" | "minecraft:light_gray_banner" | "light_gray_bed" | "minecraft:light_gray_bed" | "light_gray_candle" | "minecraft:light_gray_candle" | "light_gray_candle_cake" | "minecraft:light_gray_candle_cake" | "light_gray_carpet" | "minecraft:light_gray_carpet" | "light_gray_concrete" | "minecraft:light_gray_concrete" | "light_gray_concrete_powder" | "minecraft:light_gray_concrete_powder" | "light_gray_glazed_terracotta" | "minecraft:light_gray_glazed_terracotta" | "light_gray_shulker_box" | "minecraft:light_gray_shulker_box" | "light_gray_stained_glass" | "minecraft:light_gray_stained_glass" | "light_gray_stained_glass_pane" | "minecraft:light_gray_stained_glass_pane" | "light_gray_terracotta" | "minecraft:light_gray_terracotta" | "light_gray_wall_banner" | "minecraft:light_gray_wall_banner" | "light_gray_wool" | "minecraft:light_gray_wool" | "light_weighted_pressure_plate" | "minecraft:light_weighted_pressure_plate" | "lightning_rod" | "minecraft:lightning_rod" | "lilac" | "minecraft:lilac" | "lily_of_the_valley" | "minecraft:lily_of_the_valley" | "lily_pad" | "minecraft:lily_pad" | "lime_banner" | "minecraft:lime_banner" | "lime_bed" | "minecraft:lime_bed" | "lime_candle" | "minecraft:lime_candle" | "lime_candle_cake" | "minecraft:lime_candle_cake" | "lime_carpet" | "minecraft:lime_carpet" | "lime_concrete" | "minecraft:lime_concrete" | "lime_concrete_powder" | "minecraft:lime_concrete_powder" | "lime_glazed_terracotta" | "minecraft:lime_glazed_terracotta" | "lime_shulker_box" | "minecraft:lime_shulker_box" | "lime_stained_glass" | "minecraft:lime_stained_glass" | "lime_stained_glass_pane" | "minecraft:lime_stained_glass_pane" | "lime_terracotta" | "minecraft:lime_terracotta" | "lime_wall_banner" | "minecraft:lime_wall_banner" | "lime_wool" | "minecraft:lime_wool" | "lodestone" | "minecraft:lodestone" | "loom" | "minecraft:loom" | "magenta_banner" | "minecraft:magenta_banner" | "magenta_bed" | "minecraft:magenta_bed" | "magenta_candle" | "minecraft:magenta_candle" | "magenta_candle_cake" | "minecraft:magenta_candle_cake" | "magenta_carpet" | "minecraft:magenta_carpet" | "magenta_concrete" | "minecraft:magenta_concrete" | "magenta_concrete_powder" | "minecraft:magenta_concrete_powder" | "magenta_glazed_terracotta" | "minecraft:magenta_glazed_terracotta" | "magenta_shulker_box" | "minecraft:magenta_shulker_box" | "magenta_stained_glass" | "minecraft:magenta_stained_glass" | "magenta_stained_glass_pane" | "minecraft:magenta_stained_glass_pane" | "magenta_terracotta" | "minecraft:magenta_terracotta" | "magenta_wall_banner" | "minecraft:magenta_wall_banner" | "magenta_wool" | "minecraft:magenta_wool" | "magma_block" | "minecraft:magma_block" | "medium_amethyst_bud" | "minecraft:medium_amethyst_bud" | "melon" | "minecraft:melon" | "melon_stem" | "minecraft:melon_stem" | "moss_block" | "minecraft:moss_block" | "moss_carpet" | "minecraft:moss_carpet" | "mossy_cobblestone" | "minecraft:mossy_cobblestone" | "mossy_cobblestone_slab" | "minecraft:mossy_cobblestone_slab" | "mossy_cobblestone_stairs" | "minecraft:mossy_cobblestone_stairs" | "mossy_cobblestone_wall" | "minecraft:mossy_cobblestone_wall" | "mossy_stone_brick_slab" | "minecraft:mossy_stone_brick_slab" | "mossy_stone_brick_stairs" | "minecraft:mossy_stone_brick_stairs" | "mossy_stone_brick_wall" | "minecraft:mossy_stone_brick_wall" | "mossy_stone_bricks" | "minecraft:mossy_stone_bricks" | "moving_piston" | "minecraft:moving_piston" | "mushroom_stem" | "minecraft:mushroom_stem" | "mycelium" | "minecraft:mycelium" | "nether_brick_fence" | "minecraft:nether_brick_fence" | "nether_brick_slab" | "minecraft:nether_brick_slab" | "nether_brick_stairs" | "minecraft:nether_brick_stairs" | "nether_brick_wall" | "minecraft:nether_brick_wall" | "nether_bricks" | "minecraft:nether_bricks" | "nether_gold_ore" | "minecraft:nether_gold_ore" | "nether_portal" | "minecraft:nether_portal" | "nether_quartz_ore" | "minecraft:nether_quartz_ore" | "nether_sprouts" | "minecraft:nether_sprouts" | "nether_wart" | "minecraft:nether_wart" | "nether_wart_block" | "minecraft:nether_wart_block" | "netherite_block" | "minecraft:netherite_block" | "netherrack" | "minecraft:netherrack" | "note_block" | "minecraft:note_block" | "oak_button" | "minecraft:oak_button" | "oak_door" | "minecraft:oak_door" | "oak_fence" | "minecraft:oak_fence" | "oak_fence_gate" | "minecraft:oak_fence_gate" | "oak_leaves" | "minecraft:oak_leaves" | "oak_log" | "minecraft:oak_log" | "oak_planks" | "minecraft:oak_planks" | "oak_pressure_plate" | "minecraft:oak_pressure_plate" | "oak_sapling" | "minecraft:oak_sapling" | "oak_sign" | "minecraft:oak_sign" | "oak_slab" | "minecraft:oak_slab" | "oak_stairs" | "minecraft:oak_stairs" | "oak_trapdoor" | "minecraft:oak_trapdoor" | "oak_wall_sign" | "minecraft:oak_wall_sign" | "oak_wood" | "minecraft:oak_wood" | "observer" | "minecraft:observer" | "obsidian" | "minecraft:obsidian" | "orange_banner" | "minecraft:orange_banner" | "orange_bed" | "minecraft:orange_bed" | "orange_candle" | "minecraft:orange_candle" | "orange_candle_cake" | "minecraft:orange_candle_cake" | "orange_carpet" | "minecraft:orange_carpet" | "orange_concrete" | "minecraft:orange_concrete" | "orange_concrete_powder" | "minecraft:orange_concrete_powder" | "orange_glazed_terracotta" | "minecraft:orange_glazed_terracotta" | "orange_shulker_box" | "minecraft:orange_shulker_box" | "orange_stained_glass" | "minecraft:orange_stained_glass" | "orange_stained_glass_pane" | "minecraft:orange_stained_glass_pane" | "orange_terracotta" | "minecraft:orange_terracotta" | "orange_tulip" | "minecraft:orange_tulip" | "orange_wall_banner" | "minecraft:orange_wall_banner" | "orange_wool" | "minecraft:orange_wool" | "oxeye_daisy" | "minecraft:oxeye_daisy" | "oxidized_copper" | "minecraft:oxidized_copper" | "oxidized_cut_copper" | "minecraft:oxidized_cut_copper" | "oxidized_cut_copper_slab" | "minecraft:oxidized_cut_copper_slab" | "oxidized_cut_copper_stairs" | "minecraft:oxidized_cut_copper_stairs" | "packed_ice" | "minecraft:packed_ice" | "peony" | "minecraft:peony" | "petrified_oak_slab" | "minecraft:petrified_oak_slab" | "pink_banner" | "minecraft:pink_banner" | "pink_bed" | "minecraft:pink_bed" | "pink_candle" | "minecraft:pink_candle" | "pink_candle_cake" | "minecraft:pink_candle_cake" | "pink_carpet" | "minecraft:pink_carpet" | "pink_concrete" | "minecraft:pink_concrete" | "pink_concrete_powder" | "minecraft:pink_concrete_powder" | "pink_glazed_terracotta" | "minecraft:pink_glazed_terracotta" | "pink_shulker_box" | "minecraft:pink_shulker_box" | "pink_stained_glass" | "minecraft:pink_stained_glass" | "pink_stained_glass_pane" | "minecraft:pink_stained_glass_pane" | "pink_terracotta" | "minecraft:pink_terracotta" | "pink_tulip" | "minecraft:pink_tulip" | "pink_wall_banner" | "minecraft:pink_wall_banner" | "pink_wool" | "minecraft:pink_wool" | "piston" | "minecraft:piston" | "piston_head" | "minecraft:piston_head" | "player_head" | "minecraft:player_head" | "player_wall_head" | "minecraft:player_wall_head" | "podzol" | "minecraft:podzol" | "pointed_dripstone" | "minecraft:pointed_dripstone" | "polished_andesite" | "minecraft:polished_andesite" | "polished_andesite_slab" | "minecraft:polished_andesite_slab" | "polished_andesite_stairs" | "minecraft:polished_andesite_stairs" | "polished_basalt" | "minecraft:polished_basalt" | "polished_blackstone" | "minecraft:polished_blackstone" | "polished_blackstone_brick_slab" | "minecraft:polished_blackstone_brick_slab" | "polished_blackstone_brick_stairs" | "minecraft:polished_blackstone_brick_stairs" | "polished_blackstone_brick_wall" | "minecraft:polished_blackstone_brick_wall" | "polished_blackstone_bricks" | "minecraft:polished_blackstone_bricks" | "polished_blackstone_button" | "minecraft:polished_blackstone_button" | "polished_blackstone_pressure_plate" | "minecraft:polished_blackstone_pressure_plate" | "polished_blackstone_slab" | "minecraft:polished_blackstone_slab" | "polished_blackstone_stairs" | "minecraft:polished_blackstone_stairs" | "polished_blackstone_wall" | "minecraft:polished_blackstone_wall" | "polished_deepslate" | "minecraft:polished_deepslate" | "polished_deepslate_slab" | "minecraft:polished_deepslate_slab" | "polished_deepslate_stairs" | "minecraft:polished_deepslate_stairs" | "polished_deepslate_wall" | "minecraft:polished_deepslate_wall" | "polished_diorite" | "minecraft:polished_diorite" | "polished_diorite_slab" | "minecraft:polished_diorite_slab" | "polished_diorite_stairs" | "minecraft:polished_diorite_stairs" | "polished_granite" | "minecraft:polished_granite" | "polished_granite_slab" | "minecraft:polished_granite_slab" | "polished_granite_stairs" | "minecraft:polished_granite_stairs" | "poppy" | "minecraft:poppy" | "potatoes" | "minecraft:potatoes" | "potted_acacia_sapling" | "minecraft:potted_acacia_sapling" | "potted_allium" | "minecraft:potted_allium" | "potted_azalea_bush" | "minecraft:potted_azalea_bush" | "potted_azure_bluet" | "minecraft:potted_azure_bluet" | "potted_bamboo" | "minecraft:potted_bamboo" | "potted_birch_sapling" | "minecraft:potted_birch_sapling" | "potted_blue_orchid" | "minecraft:potted_blue_orchid" | "potted_brown_mushroom" | "minecraft:potted_brown_mushroom" | "potted_cactus" | "minecraft:potted_cactus" | "potted_cornflower" | "minecraft:potted_cornflower" | "potted_crimson_fungus" | "minecraft:potted_crimson_fungus" | "potted_crimson_roots" | "minecraft:potted_crimson_roots" | "potted_dandelion" | "minecraft:potted_dandelion" | "potted_dark_oak_sapling" | "minecraft:potted_dark_oak_sapling" | "potted_dead_bush" | "minecraft:potted_dead_bush" | "potted_fern" | "minecraft:potted_fern" | "potted_flowering_azalea_bush" | "minecraft:potted_flowering_azalea_bush" | "potted_jungle_sapling" | "minecraft:potted_jungle_sapling" | "potted_lily_of_the_valley" | "minecraft:potted_lily_of_the_valley" | "potted_oak_sapling" | "minecraft:potted_oak_sapling" | "potted_orange_tulip" | "minecraft:potted_orange_tulip" | "potted_oxeye_daisy" | "minecraft:potted_oxeye_daisy" | "potted_pink_tulip" | "minecraft:potted_pink_tulip" | "potted_poppy" | "minecraft:potted_poppy" | "potted_red_mushroom" | "minecraft:potted_red_mushroom" | "potted_red_tulip" | "minecraft:potted_red_tulip" | "potted_spruce_sapling" | "minecraft:potted_spruce_sapling" | "potted_warped_fungus" | "minecraft:potted_warped_fungus" | "potted_warped_roots" | "minecraft:potted_warped_roots" | "potted_white_tulip" | "minecraft:potted_white_tulip" | "potted_wither_rose" | "minecraft:potted_wither_rose" | "powder_snow" | "minecraft:powder_snow" | "powder_snow_cauldron" | "minecraft:powder_snow_cauldron" | "powered_rail" | "minecraft:powered_rail" | "prismarine" | "minecraft:prismarine" | "prismarine_brick_slab" | "minecraft:prismarine_brick_slab" | "prismarine_brick_stairs" | "minecraft:prismarine_brick_stairs" | "prismarine_bricks" | "minecraft:prismarine_bricks" | "prismarine_slab" | "minecraft:prismarine_slab" | "prismarine_stairs" | "minecraft:prismarine_stairs" | "prismarine_wall" | "minecraft:prismarine_wall" | "pumpkin" | "minecraft:pumpkin" | "pumpkin_stem" | "minecraft:pumpkin_stem" | "purple_banner" | "minecraft:purple_banner" | "purple_bed" | "minecraft:purple_bed" | "purple_candle" | "minecraft:purple_candle" | "purple_candle_cake" | "minecraft:purple_candle_cake" | "purple_carpet" | "minecraft:purple_carpet" | "purple_concrete" | "minecraft:purple_concrete" | "purple_concrete_powder" | "minecraft:purple_concrete_powder" | "purple_glazed_terracotta" | "minecraft:purple_glazed_terracotta" | "purple_shulker_box" | "minecraft:purple_shulker_box" | "purple_stained_glass" | "minecraft:purple_stained_glass" | "purple_stained_glass_pane" | "minecraft:purple_stained_glass_pane" | "purple_terracotta" | "minecraft:purple_terracotta" | "purple_wall_banner" | "minecraft:purple_wall_banner" | "purple_wool" | "minecraft:purple_wool" | "purpur_block" | "minecraft:purpur_block" | "purpur_pillar" | "minecraft:purpur_pillar" | "purpur_slab" | "minecraft:purpur_slab" | "purpur_stairs" | "minecraft:purpur_stairs" | "quartz_block" | "minecraft:quartz_block" | "quartz_bricks" | "minecraft:quartz_bricks" | "quartz_pillar" | "minecraft:quartz_pillar" | "quartz_slab" | "minecraft:quartz_slab" | "quartz_stairs" | "minecraft:quartz_stairs" | "rail" | "minecraft:rail" | "raw_copper_block" | "minecraft:raw_copper_block" | "raw_gold_block" | "minecraft:raw_gold_block" | "raw_iron_block" | "minecraft:raw_iron_block" | "red_banner" | "minecraft:red_banner" | "red_bed" | "minecraft:red_bed" | "red_candle" | "minecraft:red_candle" | "red_candle_cake" | "minecraft:red_candle_cake" | "red_carpet" | "minecraft:red_carpet" | "red_concrete" | "minecraft:red_concrete" | "red_concrete_powder" | "minecraft:red_concrete_powder" | "red_glazed_terracotta" | "minecraft:red_glazed_terracotta" | "red_mushroom" | "minecraft:red_mushroom" | "red_mushroom_block" | "minecraft:red_mushroom_block" | "red_nether_brick_slab" | "minecraft:red_nether_brick_slab" | "red_nether_brick_stairs" | "minecraft:red_nether_brick_stairs" | "red_nether_brick_wall" | "minecraft:red_nether_brick_wall" | "red_nether_bricks" | "minecraft:red_nether_bricks" | "red_sand" | "minecraft:red_sand" | "red_sandstone" | "minecraft:red_sandstone" | "red_sandstone_slab" | "minecraft:red_sandstone_slab" | "red_sandstone_stairs" | "minecraft:red_sandstone_stairs" | "red_sandstone_wall" | "minecraft:red_sandstone_wall" | "red_shulker_box" | "minecraft:red_shulker_box" | "red_stained_glass" | "minecraft:red_stained_glass" | "red_stained_glass_pane" | "minecraft:red_stained_glass_pane" | "red_terracotta" | "minecraft:red_terracotta" | "red_tulip" | "minecraft:red_tulip" | "red_wall_banner" | "minecraft:red_wall_banner" | "red_wool" | "minecraft:red_wool" | "redstone_block" | "minecraft:redstone_block" | "redstone_lamp" | "minecraft:redstone_lamp" | "redstone_ore" | "minecraft:redstone_ore" | "redstone_torch" | "minecraft:redstone_torch" | "redstone_wall_torch" | "minecraft:redstone_wall_torch" | "redstone_wire" | "minecraft:redstone_wire" | "repeater" | "minecraft:repeater" | "repeating_command_block" | "minecraft:repeating_command_block" | "respawn_anchor" | "minecraft:respawn_anchor" | "rooted_dirt" | "minecraft:rooted_dirt" | "rose_bush" | "minecraft:rose_bush" | "sand" | "minecraft:sand" | "sandstone" | "minecraft:sandstone" | "sandstone_slab" | "minecraft:sandstone_slab" | "sandstone_stairs" | "minecraft:sandstone_stairs" | "sandstone_wall" | "minecraft:sandstone_wall" | "scaffolding" | "minecraft:scaffolding" | "sculk_sensor" | "minecraft:sculk_sensor" | "sea_lantern" | "minecraft:sea_lantern" | "sea_pickle" | "minecraft:sea_pickle" | "seagrass" | "minecraft:seagrass" | "shroomlight" | "minecraft:shroomlight" | "shulker_box" | "minecraft:shulker_box" | "skeleton_skull" | "minecraft:skeleton_skull" | "skeleton_wall_skull" | "minecraft:skeleton_wall_skull" | "slime_block" | "minecraft:slime_block" | "small_amethyst_bud" | "minecraft:small_amethyst_bud" | "small_dripleaf" | "minecraft:small_dripleaf" | "smithing_table" | "minecraft:smithing_table" | "smoker" | "minecraft:smoker" | "smooth_basalt" | "minecraft:smooth_basalt" | "smooth_quartz" | "minecraft:smooth_quartz" | "smooth_quartz_slab" | "minecraft:smooth_quartz_slab" | "smooth_quartz_stairs" | "minecraft:smooth_quartz_stairs" | "smooth_red_sandstone" | "minecraft:smooth_red_sandstone" | "smooth_red_sandstone_slab" | "minecraft:smooth_red_sandstone_slab" | "smooth_red_sandstone_stairs" | "minecraft:smooth_red_sandstone_stairs" | "smooth_sandstone" | "minecraft:smooth_sandstone" | "smooth_sandstone_slab" | "minecraft:smooth_sandstone_slab" | "smooth_sandstone_stairs" | "minecraft:smooth_sandstone_stairs" | "smooth_stone" | "minecraft:smooth_stone" | "smooth_stone_slab" | "minecraft:smooth_stone_slab" | "snow" | "minecraft:snow" | "snow_block" | "minecraft:snow_block" | "soul_campfire" | "minecraft:soul_campfire" | "soul_fire" | "minecraft:soul_fire" | "soul_lantern" | "minecraft:soul_lantern" | "soul_sand" | "minecraft:soul_sand" | "soul_soil" | "minecraft:soul_soil" | "soul_torch" | "minecraft:soul_torch" | "soul_wall_torch" | "minecraft:soul_wall_torch" | "spawner" | "minecraft:spawner" | "sponge" | "minecraft:sponge" | "spore_blossom" | "minecraft:spore_blossom" | "spruce_button" | "minecraft:spruce_button" | "spruce_door" | "minecraft:spruce_door" | "spruce_fence" | "minecraft:spruce_fence" | "spruce_fence_gate" | "minecraft:spruce_fence_gate" | "spruce_leaves" | "minecraft:spruce_leaves" | "spruce_log" | "minecraft:spruce_log" | "spruce_planks" | "minecraft:spruce_planks" | "spruce_pressure_plate" | "minecraft:spruce_pressure_plate" | "spruce_sapling" | "minecraft:spruce_sapling" | "spruce_sign" | "minecraft:spruce_sign" | "spruce_slab" | "minecraft:spruce_slab" | "spruce_stairs" | "minecraft:spruce_stairs" | "spruce_trapdoor" | "minecraft:spruce_trapdoor" | "spruce_wall_sign" | "minecraft:spruce_wall_sign" | "spruce_wood" | "minecraft:spruce_wood" | "sticky_piston" | "minecraft:sticky_piston" | "stone" | "minecraft:stone" | "stone_brick_slab" | "minecraft:stone_brick_slab" | "stone_brick_stairs" | "minecraft:stone_brick_stairs" | "stone_brick_wall" | "minecraft:stone_brick_wall" | "stone_bricks" | "minecraft:stone_bricks" | "stone_button" | "minecraft:stone_button" | "stone_pressure_plate" | "minecraft:stone_pressure_plate" | "stone_slab" | "minecraft:stone_slab" | "stone_stairs" | "minecraft:stone_stairs" | "stonecutter" | "minecraft:stonecutter" | "stripped_acacia_log" | "minecraft:stripped_acacia_log" | "stripped_acacia_wood" | "minecraft:stripped_acacia_wood" | "stripped_birch_log" | "minecraft:stripped_birch_log" | "stripped_birch_wood" | "minecraft:stripped_birch_wood" | "stripped_crimson_hyphae" | "minecraft:stripped_crimson_hyphae" | "stripped_crimson_stem" | "minecraft:stripped_crimson_stem" | "stripped_dark_oak_log" | "minecraft:stripped_dark_oak_log" | "stripped_dark_oak_wood" | "minecraft:stripped_dark_oak_wood" | "stripped_jungle_log" | "minecraft:stripped_jungle_log" | "stripped_jungle_wood" | "minecraft:stripped_jungle_wood" | "stripped_oak_log" | "minecraft:stripped_oak_log" | "stripped_oak_wood" | "minecraft:stripped_oak_wood" | "stripped_spruce_log" | "minecraft:stripped_spruce_log" | "stripped_spruce_wood" | "minecraft:stripped_spruce_wood" | "stripped_warped_hyphae" | "minecraft:stripped_warped_hyphae" | "stripped_warped_stem" | "minecraft:stripped_warped_stem" | "structure_block" | "minecraft:structure_block" | "structure_void" | "minecraft:structure_void" | "sugar_cane" | "minecraft:sugar_cane" | "sunflower" | "minecraft:sunflower" | "sweet_berry_bush" | "minecraft:sweet_berry_bush" | "tall_grass" | "minecraft:tall_grass" | "tall_seagrass" | "minecraft:tall_seagrass" | "target" | "minecraft:target" | "terracotta" | "minecraft:terracotta" | "tinted_glass" | "minecraft:tinted_glass" | "tnt" | "minecraft:tnt" | "torch" | "minecraft:torch" | "trapped_chest" | "minecraft:trapped_chest" | "tripwire" | "minecraft:tripwire" | "tripwire_hook" | "minecraft:tripwire_hook" | "tube_coral" | "minecraft:tube_coral" | "tube_coral_block" | "minecraft:tube_coral_block" | "tube_coral_fan" | "minecraft:tube_coral_fan" | "tube_coral_wall_fan" | "minecraft:tube_coral_wall_fan" | "tuff" | "minecraft:tuff" | "turtle_egg" | "minecraft:turtle_egg" | "twisting_vines" | "minecraft:twisting_vines" | "twisting_vines_plant" | "minecraft:twisting_vines_plant" | "vine" | "minecraft:vine" | "void_air" | "minecraft:void_air" | "wall_torch" | "minecraft:wall_torch" | "warped_button" | "minecraft:warped_button" | "warped_door" | "minecraft:warped_door" | "warped_fence" | "minecraft:warped_fence" | "warped_fence_gate" | "minecraft:warped_fence_gate" | "warped_fungus" | "minecraft:warped_fungus" | "warped_hyphae" | "minecraft:warped_hyphae" | "warped_nylium" | "minecraft:warped_nylium" | "warped_planks" | "minecraft:warped_planks" | "warped_pressure_plate" | "minecraft:warped_pressure_plate" | "warped_roots" | "minecraft:warped_roots" | "warped_sign" | "minecraft:warped_sign" | "warped_slab" | "minecraft:warped_slab" | "warped_stairs" | "minecraft:warped_stairs" | "warped_stem" | "minecraft:warped_stem" | "warped_trapdoor" | "minecraft:warped_trapdoor" | "warped_wall_sign" | "minecraft:warped_wall_sign" | "warped_wart_block" | "minecraft:warped_wart_block" | "water" | "minecraft:water" | "water_cauldron" | "minecraft:water_cauldron" | "waxed_copper_block" | "minecraft:waxed_copper_block" | "waxed_cut_copper" | "minecraft:waxed_cut_copper" | "waxed_cut_copper_slab" | "minecraft:waxed_cut_copper_slab" | "waxed_cut_copper_stairs" | "minecraft:waxed_cut_copper_stairs" | "waxed_exposed_copper" | "minecraft:waxed_exposed_copper" | "waxed_exposed_cut_copper" | "minecraft:waxed_exposed_cut_copper" | "waxed_exposed_cut_copper_slab" | "minecraft:waxed_exposed_cut_copper_slab" | "waxed_exposed_cut_copper_stairs" | "minecraft:waxed_exposed_cut_copper_stairs" | "waxed_oxidized_copper" | "minecraft:waxed_oxidized_copper" | "waxed_oxidized_cut_copper" | "minecraft:waxed_oxidized_cut_copper" | "waxed_oxidized_cut_copper_slab" | "minecraft:waxed_oxidized_cut_copper_slab" | "waxed_oxidized_cut_copper_stairs" | "minecraft:waxed_oxidized_cut_copper_stairs" | "waxed_weathered_copper" | "minecraft:waxed_weathered_copper" | "waxed_weathered_cut_copper" | "minecraft:waxed_weathered_cut_copper" | "waxed_weathered_cut_copper_slab" | "minecraft:waxed_weathered_cut_copper_slab" | "waxed_weathered_cut_copper_stairs" | "minecraft:waxed_weathered_cut_copper_stairs" | "weathered_copper" | "minecraft:weathered_copper" | "weathered_cut_copper" | "minecraft:weathered_cut_copper" | "weathered_cut_copper_slab" | "minecraft:weathered_cut_copper_slab" | "weathered_cut_copper_stairs" | "minecraft:weathered_cut_copper_stairs" | "weeping_vines" | "minecraft:weeping_vines" | "weeping_vines_plant" | "minecraft:weeping_vines_plant" | "wet_sponge" | "minecraft:wet_sponge" | "wheat" | "minecraft:wheat" | "white_banner" | "minecraft:white_banner" | "white_bed" | "minecraft:white_bed" | "white_candle" | "minecraft:white_candle" | "white_candle_cake" | "minecraft:white_candle_cake" | "white_carpet" | "minecraft:white_carpet" | "white_concrete" | "minecraft:white_concrete" | "white_concrete_powder" | "minecraft:white_concrete_powder" | "white_glazed_terracotta" | "minecraft:white_glazed_terracotta" | "white_shulker_box" | "minecraft:white_shulker_box" | "white_stained_glass" | "minecraft:white_stained_glass" | "white_stained_glass_pane" | "minecraft:white_stained_glass_pane" | "white_terracotta" | "minecraft:white_terracotta" | "white_tulip" | "minecraft:white_tulip" | "white_wall_banner" | "minecraft:white_wall_banner" | "white_wool" | "minecraft:white_wool" | "wither_rose" | "minecraft:wither_rose" | "wither_skeleton_skull" | "minecraft:wither_skeleton_skull" | "wither_skeleton_wall_skull" | "minecraft:wither_skeleton_wall_skull" | "yellow_banner" | "minecraft:yellow_banner" | "yellow_bed" | "minecraft:yellow_bed" | "yellow_candle" | "minecraft:yellow_candle" | "yellow_candle_cake" | "minecraft:yellow_candle_cake" | "yellow_carpet" | "minecraft:yellow_carpet" | "yellow_concrete" | "minecraft:yellow_concrete" | "yellow_concrete_powder" | "minecraft:yellow_concrete_powder" | "yellow_glazed_terracotta" | "minecraft:yellow_glazed_terracotta" | "yellow_shulker_box" | "minecraft:yellow_shulker_box" | "yellow_stained_glass" | "minecraft:yellow_stained_glass" | "yellow_stained_glass_pane" | "minecraft:yellow_stained_glass_pane" | "yellow_terracotta" | "minecraft:yellow_terracotta" | "yellow_wall_banner" | "minecraft:yellow_wall_banner" | "yellow_wool" | "minecraft:yellow_wool" | "zombie_head" | "minecraft:zombie_head" | "zombie_wall_head" | "minecraft:zombie_wall_head";
    type Enchantment = "aqua_affinity" | "minecraft:aqua_affinity" | "bane_of_arthropods" | "minecraft:bane_of_arthropods" | "binding_curse" | "minecraft:binding_curse" | "blast_protection" | "minecraft:blast_protection" | "channeling" | "minecraft:channeling" | "depth_strider" | "minecraft:depth_strider" | "efficiency" | "minecraft:efficiency" | "feather_falling" | "minecraft:feather_falling" | "fire_aspect" | "minecraft:fire_aspect" | "fire_protection" | "minecraft:fire_protection" | "flame" | "minecraft:flame" | "fortune" | "minecraft:fortune" | "frost_walker" | "minecraft:frost_walker" | "impaling" | "minecraft:impaling" | "infinity" | "minecraft:infinity" | "knockback" | "minecraft:knockback" | "looting" | "minecraft:looting" | "loyalty" | "minecraft:loyalty" | "luck_of_the_sea" | "minecraft:luck_of_the_sea" | "lure" | "minecraft:lure" | "mending" | "minecraft:mending" | "multishot" | "minecraft:multishot" | "piercing" | "minecraft:piercing" | "power" | "minecraft:power" | "projectile_protection" | "minecraft:projectile_protection" | "protection" | "minecraft:protection" | "punch" | "minecraft:punch" | "quick_charge" | "minecraft:quick_charge" | "respiration" | "minecraft:respiration" | "riptide" | "minecraft:riptide" | "sharpness" | "minecraft:sharpness" | "silk_touch" | "minecraft:silk_touch" | "smite" | "minecraft:smite" | "soul_speed" | "minecraft:soul_speed" | "sweeping" | "minecraft:sweeping" | "thorns" | "minecraft:thorns" | "unbreaking" | "minecraft:unbreaking" | "vanishing_curse" | "minecraft:vanishing_curse";
    type EntityType = "area_effect_cloud" | "minecraft:area_effect_cloud" | "armor_stand" | "minecraft:armor_stand" | "arrow" | "minecraft:arrow" | "axolotl" | "minecraft:axolotl" | "bat" | "minecraft:bat" | "bee" | "minecraft:bee" | "blaze" | "minecraft:blaze" | "boat" | "minecraft:boat" | "cat" | "minecraft:cat" | "cave_spider" | "minecraft:cave_spider" | "chest_minecart" | "minecraft:chest_minecart" | "chicken" | "minecraft:chicken" | "cod" | "minecraft:cod" | "command_block_minecart" | "minecraft:command_block_minecart" | "cow" | "minecraft:cow" | "creeper" | "minecraft:creeper" | "dolphin" | "minecraft:dolphin" | "donkey" | "minecraft:donkey" | "dragon_fireball" | "minecraft:dragon_fireball" | "drowned" | "minecraft:drowned" | "egg" | "minecraft:egg" | "elder_guardian" | "minecraft:elder_guardian" | "end_crystal" | "minecraft:end_crystal" | "ender_dragon" | "minecraft:ender_dragon" | "ender_pearl" | "minecraft:ender_pearl" | "enderman" | "minecraft:enderman" | "endermite" | "minecraft:endermite" | "evoker" | "minecraft:evoker" | "evoker_fangs" | "minecraft:evoker_fangs" | "experience_bottle" | "minecraft:experience_bottle" | "experience_orb" | "minecraft:experience_orb" | "eye_of_ender" | "minecraft:eye_of_ender" | "falling_block" | "minecraft:falling_block" | "fireball" | "minecraft:fireball" | "firework_rocket" | "minecraft:firework_rocket" | "fishing_bobber" | "minecraft:fishing_bobber" | "fox" | "minecraft:fox" | "furnace_minecart" | "minecraft:furnace_minecart" | "ghast" | "minecraft:ghast" | "giant" | "minecraft:giant" | "glow_item_frame" | "minecraft:glow_item_frame" | "glow_squid" | "minecraft:glow_squid" | "goat" | "minecraft:goat" | "guardian" | "minecraft:guardian" | "hoglin" | "minecraft:hoglin" | "hopper_minecart" | "minecraft:hopper_minecart" | "horse" | "minecraft:horse" | "husk" | "minecraft:husk" | "illusioner" | "minecraft:illusioner" | "iron_golem" | "minecraft:iron_golem" | "item" | "minecraft:item" | "item_frame" | "minecraft:item_frame" | "leash_knot" | "minecraft:leash_knot" | "lightning_bolt" | "minecraft:lightning_bolt" | "llama" | "minecraft:llama" | "llama_spit" | "minecraft:llama_spit" | "magma_cube" | "minecraft:magma_cube" | "marker" | "minecraft:marker" | "minecart" | "minecraft:minecart" | "mooshroom" | "minecraft:mooshroom" | "mule" | "minecraft:mule" | "ocelot" | "minecraft:ocelot" | "painting" | "minecraft:painting" | "panda" | "minecraft:panda" | "parrot" | "minecraft:parrot" | "phantom" | "minecraft:phantom" | "pig" | "minecraft:pig" | "piglin" | "minecraft:piglin" | "piglin_brute" | "minecraft:piglin_brute" | "pillager" | "minecraft:pillager" | "player" | "minecraft:player" | "polar_bear" | "minecraft:polar_bear" | "potion" | "minecraft:potion" | "pufferfish" | "minecraft:pufferfish" | "rabbit" | "minecraft:rabbit" | "ravager" | "minecraft:ravager" | "salmon" | "minecraft:salmon" | "sheep" | "minecraft:sheep" | "shulker" | "minecraft:shulker" | "shulker_bullet" | "minecraft:shulker_bullet" | "silverfish" | "minecraft:silverfish" | "skeleton" | "minecraft:skeleton" | "skeleton_horse" | "minecraft:skeleton_horse" | "slime" | "minecraft:slime" | "small_fireball" | "minecraft:small_fireball" | "snow_golem" | "minecraft:snow_golem" | "snowball" | "minecraft:snowball" | "spawner_minecart" | "minecraft:spawner_minecart" | "spectral_arrow" | "minecraft:spectral_arrow" | "spider" | "minecraft:spider" | "squid" | "minecraft:squid" | "stray" | "minecraft:stray" | "strider" | "minecraft:strider" | "tnt" | "minecraft:tnt" | "tnt_minecart" | "minecraft:tnt_minecart" | "trader_llama" | "minecraft:trader_llama" | "trident" | "minecraft:trident" | "tropical_fish" | "minecraft:tropical_fish" | "turtle" | "minecraft:turtle" | "vex" | "minecraft:vex" | "villager" | "minecraft:villager" | "vindicator" | "minecraft:vindicator" | "wandering_trader" | "minecraft:wandering_trader" | "witch" | "minecraft:witch" | "wither" | "minecraft:wither" | "wither_skeleton" | "minecraft:wither_skeleton" | "wither_skull" | "minecraft:wither_skull" | "wolf" | "minecraft:wolf" | "zoglin" | "minecraft:zoglin" | "zombie" | "minecraft:zombie" | "zombie_horse" | "minecraft:zombie_horse" | "zombie_villager" | "minecraft:zombie_villager" | "zombified_piglin" | "minecraft:zombified_piglin";
    type Item = "acacia_boat" | "minecraft:acacia_boat" | "acacia_button" | "minecraft:acacia_button" | "acacia_door" | "minecraft:acacia_door" | "acacia_fence" | "minecraft:acacia_fence" | "acacia_fence_gate" | "minecraft:acacia_fence_gate" | "acacia_leaves" | "minecraft:acacia_leaves" | "acacia_log" | "minecraft:acacia_log" | "acacia_planks" | "minecraft:acacia_planks" | "acacia_pressure_plate" | "minecraft:acacia_pressure_plate" | "acacia_sapling" | "minecraft:acacia_sapling" | "acacia_sign" | "minecraft:acacia_sign" | "acacia_slab" | "minecraft:acacia_slab" | "acacia_stairs" | "minecraft:acacia_stairs" | "acacia_trapdoor" | "minecraft:acacia_trapdoor" | "acacia_wood" | "minecraft:acacia_wood" | "activator_rail" | "minecraft:activator_rail" | "air" | "minecraft:air" | "allium" | "minecraft:allium" | "amethyst_block" | "minecraft:amethyst_block" | "amethyst_cluster" | "minecraft:amethyst_cluster" | "amethyst_shard" | "minecraft:amethyst_shard" | "ancient_debris" | "minecraft:ancient_debris" | "andesite" | "minecraft:andesite" | "andesite_slab" | "minecraft:andesite_slab" | "andesite_stairs" | "minecraft:andesite_stairs" | "andesite_wall" | "minecraft:andesite_wall" | "anvil" | "minecraft:anvil" | "apple" | "minecraft:apple" | "armor_stand" | "minecraft:armor_stand" | "arrow" | "minecraft:arrow" | "axolotl_bucket" | "minecraft:axolotl_bucket" | "axolotl_spawn_egg" | "minecraft:axolotl_spawn_egg" | "azalea" | "minecraft:azalea" | "azalea_leaves" | "minecraft:azalea_leaves" | "azure_bluet" | "minecraft:azure_bluet" | "baked_potato" | "minecraft:baked_potato" | "bamboo" | "minecraft:bamboo" | "barrel" | "minecraft:barrel" | "barrier" | "minecraft:barrier" | "basalt" | "minecraft:basalt" | "bat_spawn_egg" | "minecraft:bat_spawn_egg" | "beacon" | "minecraft:beacon" | "bedrock" | "minecraft:bedrock" | "bee_nest" | "minecraft:bee_nest" | "bee_spawn_egg" | "minecraft:bee_spawn_egg" | "beef" | "minecraft:beef" | "beehive" | "minecraft:beehive" | "beetroot" | "minecraft:beetroot" | "beetroot_seeds" | "minecraft:beetroot_seeds" | "beetroot_soup" | "minecraft:beetroot_soup" | "bell" | "minecraft:bell" | "big_dripleaf" | "minecraft:big_dripleaf" | "birch_boat" | "minecraft:birch_boat" | "birch_button" | "minecraft:birch_button" | "birch_door" | "minecraft:birch_door" | "birch_fence" | "minecraft:birch_fence" | "birch_fence_gate" | "minecraft:birch_fence_gate" | "birch_leaves" | "minecraft:birch_leaves" | "birch_log" | "minecraft:birch_log" | "birch_planks" | "minecraft:birch_planks" | "birch_pressure_plate" | "minecraft:birch_pressure_plate" | "birch_sapling" | "minecraft:birch_sapling" | "birch_sign" | "minecraft:birch_sign" | "birch_slab" | "minecraft:birch_slab" | "birch_stairs" | "minecraft:birch_stairs" | "birch_trapdoor" | "minecraft:birch_trapdoor" | "birch_wood" | "minecraft:birch_wood" | "black_banner" | "minecraft:black_banner" | "black_bed" | "minecraft:black_bed" | "black_candle" | "minecraft:black_candle" | "black_carpet" | "minecraft:black_carpet" | "black_concrete" | "minecraft:black_concrete" | "black_concrete_powder" | "minecraft:black_concrete_powder" | "black_dye" | "minecraft:black_dye" | "black_glazed_terracotta" | "minecraft:black_glazed_terracotta" | "black_shulker_box" | "minecraft:black_shulker_box" | "black_stained_glass" | "minecraft:black_stained_glass" | "black_stained_glass_pane" | "minecraft:black_stained_glass_pane" | "black_terracotta" | "minecraft:black_terracotta" | "black_wool" | "minecraft:black_wool" | "blackstone" | "minecraft:blackstone" | "blackstone_slab" | "minecraft:blackstone_slab" | "blackstone_stairs" | "minecraft:blackstone_stairs" | "blackstone_wall" | "minecraft:blackstone_wall" | "blast_furnace" | "minecraft:blast_furnace" | "blaze_powder" | "minecraft:blaze_powder" | "blaze_rod" | "minecraft:blaze_rod" | "blaze_spawn_egg" | "minecraft:blaze_spawn_egg" | "blue_banner" | "minecraft:blue_banner" | "blue_bed" | "minecraft:blue_bed" | "blue_candle" | "minecraft:blue_candle" | "blue_carpet" | "minecraft:blue_carpet" | "blue_concrete" | "minecraft:blue_concrete" | "blue_concrete_powder" | "minecraft:blue_concrete_powder" | "blue_dye" | "minecraft:blue_dye" | "blue_glazed_terracotta" | "minecraft:blue_glazed_terracotta" | "blue_ice" | "minecraft:blue_ice" | "blue_orchid" | "minecraft:blue_orchid" | "blue_shulker_box" | "minecraft:blue_shulker_box" | "blue_stained_glass" | "minecraft:blue_stained_glass" | "blue_stained_glass_pane" | "minecraft:blue_stained_glass_pane" | "blue_terracotta" | "minecraft:blue_terracotta" | "blue_wool" | "minecraft:blue_wool" | "bone" | "minecraft:bone" | "bone_block" | "minecraft:bone_block" | "bone_meal" | "minecraft:bone_meal" | "book" | "minecraft:book" | "bookshelf" | "minecraft:bookshelf" | "bow" | "minecraft:bow" | "bowl" | "minecraft:bowl" | "brain_coral" | "minecraft:brain_coral" | "brain_coral_block" | "minecraft:brain_coral_block" | "brain_coral_fan" | "minecraft:brain_coral_fan" | "bread" | "minecraft:bread" | "brewing_stand" | "minecraft:brewing_stand" | "brick" | "minecraft:brick" | "brick_slab" | "minecraft:brick_slab" | "brick_stairs" | "minecraft:brick_stairs" | "brick_wall" | "minecraft:brick_wall" | "bricks" | "minecraft:bricks" | "brown_banner" | "minecraft:brown_banner" | "brown_bed" | "minecraft:brown_bed" | "brown_candle" | "minecraft:brown_candle" | "brown_carpet" | "minecraft:brown_carpet" | "brown_concrete" | "minecraft:brown_concrete" | "brown_concrete_powder" | "minecraft:brown_concrete_powder" | "brown_dye" | "minecraft:brown_dye" | "brown_glazed_terracotta" | "minecraft:brown_glazed_terracotta" | "brown_mushroom" | "minecraft:brown_mushroom" | "brown_mushroom_block" | "minecraft:brown_mushroom_block" | "brown_shulker_box" | "minecraft:brown_shulker_box" | "brown_stained_glass" | "minecraft:brown_stained_glass" | "brown_stained_glass_pane" | "minecraft:brown_stained_glass_pane" | "brown_terracotta" | "minecraft:brown_terracotta" | "brown_wool" | "minecraft:brown_wool" | "bubble_coral" | "minecraft:bubble_coral" | "bubble_coral_block" | "minecraft:bubble_coral_block" | "bubble_coral_fan" | "minecraft:bubble_coral_fan" | "bucket" | "minecraft:bucket" | "budding_amethyst" | "minecraft:budding_amethyst" | "bundle" | "minecraft:bundle" | "cactus" | "minecraft:cactus" | "cake" | "minecraft:cake" | "calcite" | "minecraft:calcite" | "campfire" | "minecraft:campfire" | "candle" | "minecraft:candle" | "carrot" | "minecraft:carrot" | "carrot_on_a_stick" | "minecraft:carrot_on_a_stick" | "cartography_table" | "minecraft:cartography_table" | "carved_pumpkin" | "minecraft:carved_pumpkin" | "cat_spawn_egg" | "minecraft:cat_spawn_egg" | "cauldron" | "minecraft:cauldron" | "cave_spider_spawn_egg" | "minecraft:cave_spider_spawn_egg" | "chain" | "minecraft:chain" | "chain_command_block" | "minecraft:chain_command_block" | "chainmail_boots" | "minecraft:chainmail_boots" | "chainmail_chestplate" | "minecraft:chainmail_chestplate" | "chainmail_helmet" | "minecraft:chainmail_helmet" | "chainmail_leggings" | "minecraft:chainmail_leggings" | "charcoal" | "minecraft:charcoal" | "chest" | "minecraft:chest" | "chest_minecart" | "minecraft:chest_minecart" | "chicken" | "minecraft:chicken" | "chicken_spawn_egg" | "minecraft:chicken_spawn_egg" | "chipped_anvil" | "minecraft:chipped_anvil" | "chiseled_deepslate" | "minecraft:chiseled_deepslate" | "chiseled_nether_bricks" | "minecraft:chiseled_nether_bricks" | "chiseled_polished_blackstone" | "minecraft:chiseled_polished_blackstone" | "chiseled_quartz_block" | "minecraft:chiseled_quartz_block" | "chiseled_red_sandstone" | "minecraft:chiseled_red_sandstone" | "chiseled_sandstone" | "minecraft:chiseled_sandstone" | "chiseled_stone_bricks" | "minecraft:chiseled_stone_bricks" | "chorus_flower" | "minecraft:chorus_flower" | "chorus_fruit" | "minecraft:chorus_fruit" | "chorus_plant" | "minecraft:chorus_plant" | "clay" | "minecraft:clay" | "clay_ball" | "minecraft:clay_ball" | "clock" | "minecraft:clock" | "coal" | "minecraft:coal" | "coal_block" | "minecraft:coal_block" | "coal_ore" | "minecraft:coal_ore" | "coarse_dirt" | "minecraft:coarse_dirt" | "cobbled_deepslate" | "minecraft:cobbled_deepslate" | "cobbled_deepslate_slab" | "minecraft:cobbled_deepslate_slab" | "cobbled_deepslate_stairs" | "minecraft:cobbled_deepslate_stairs" | "cobbled_deepslate_wall" | "minecraft:cobbled_deepslate_wall" | "cobblestone" | "minecraft:cobblestone" | "cobblestone_slab" | "minecraft:cobblestone_slab" | "cobblestone_stairs" | "minecraft:cobblestone_stairs" | "cobblestone_wall" | "minecraft:cobblestone_wall" | "cobweb" | "minecraft:cobweb" | "cocoa_beans" | "minecraft:cocoa_beans" | "cod" | "minecraft:cod" | "cod_bucket" | "minecraft:cod_bucket" | "cod_spawn_egg" | "minecraft:cod_spawn_egg" | "command_block" | "minecraft:command_block" | "command_block_minecart" | "minecraft:command_block_minecart" | "comparator" | "minecraft:comparator" | "compass" | "minecraft:compass" | "composter" | "minecraft:composter" | "conduit" | "minecraft:conduit" | "cooked_beef" | "minecraft:cooked_beef" | "cooked_chicken" | "minecraft:cooked_chicken" | "cooked_cod" | "minecraft:cooked_cod" | "cooked_mutton" | "minecraft:cooked_mutton" | "cooked_porkchop" | "minecraft:cooked_porkchop" | "cooked_rabbit" | "minecraft:cooked_rabbit" | "cooked_salmon" | "minecraft:cooked_salmon" | "cookie" | "minecraft:cookie" | "copper_block" | "minecraft:copper_block" | "copper_ingot" | "minecraft:copper_ingot" | "copper_ore" | "minecraft:copper_ore" | "cornflower" | "minecraft:cornflower" | "cow_spawn_egg" | "minecraft:cow_spawn_egg" | "cracked_deepslate_bricks" | "minecraft:cracked_deepslate_bricks" | "cracked_deepslate_tiles" | "minecraft:cracked_deepslate_tiles" | "cracked_nether_bricks" | "minecraft:cracked_nether_bricks" | "cracked_polished_blackstone_bricks" | "minecraft:cracked_polished_blackstone_bricks" | "cracked_stone_bricks" | "minecraft:cracked_stone_bricks" | "crafting_table" | "minecraft:crafting_table" | "creeper_banner_pattern" | "minecraft:creeper_banner_pattern" | "creeper_head" | "minecraft:creeper_head" | "creeper_spawn_egg" | "minecraft:creeper_spawn_egg" | "crimson_button" | "minecraft:crimson_button" | "crimson_door" | "minecraft:crimson_door" | "crimson_fence" | "minecraft:crimson_fence" | "crimson_fence_gate" | "minecraft:crimson_fence_gate" | "crimson_fungus" | "minecraft:crimson_fungus" | "crimson_hyphae" | "minecraft:crimson_hyphae" | "crimson_nylium" | "minecraft:crimson_nylium" | "crimson_planks" | "minecraft:crimson_planks" | "crimson_pressure_plate" | "minecraft:crimson_pressure_plate" | "crimson_roots" | "minecraft:crimson_roots" | "crimson_sign" | "minecraft:crimson_sign" | "crimson_slab" | "minecraft:crimson_slab" | "crimson_stairs" | "minecraft:crimson_stairs" | "crimson_stem" | "minecraft:crimson_stem" | "crimson_trapdoor" | "minecraft:crimson_trapdoor" | "crossbow" | "minecraft:crossbow" | "crying_obsidian" | "minecraft:crying_obsidian" | "cut_copper" | "minecraft:cut_copper" | "cut_copper_slab" | "minecraft:cut_copper_slab" | "cut_copper_stairs" | "minecraft:cut_copper_stairs" | "cut_red_sandstone" | "minecraft:cut_red_sandstone" | "cut_red_sandstone_slab" | "minecraft:cut_red_sandstone_slab" | "cut_sandstone" | "minecraft:cut_sandstone" | "cut_sandstone_slab" | "minecraft:cut_sandstone_slab" | "cyan_banner" | "minecraft:cyan_banner" | "cyan_bed" | "minecraft:cyan_bed" | "cyan_candle" | "minecraft:cyan_candle" | "cyan_carpet" | "minecraft:cyan_carpet" | "cyan_concrete" | "minecraft:cyan_concrete" | "cyan_concrete_powder" | "minecraft:cyan_concrete_powder" | "cyan_dye" | "minecraft:cyan_dye" | "cyan_glazed_terracotta" | "minecraft:cyan_glazed_terracotta" | "cyan_shulker_box" | "minecraft:cyan_shulker_box" | "cyan_stained_glass" | "minecraft:cyan_stained_glass" | "cyan_stained_glass_pane" | "minecraft:cyan_stained_glass_pane" | "cyan_terracotta" | "minecraft:cyan_terracotta" | "cyan_wool" | "minecraft:cyan_wool" | "damaged_anvil" | "minecraft:damaged_anvil" | "dandelion" | "minecraft:dandelion" | "dark_oak_boat" | "minecraft:dark_oak_boat" | "dark_oak_button" | "minecraft:dark_oak_button" | "dark_oak_door" | "minecraft:dark_oak_door" | "dark_oak_fence" | "minecraft:dark_oak_fence" | "dark_oak_fence_gate" | "minecraft:dark_oak_fence_gate" | "dark_oak_leaves" | "minecraft:dark_oak_leaves" | "dark_oak_log" | "minecraft:dark_oak_log" | "dark_oak_planks" | "minecraft:dark_oak_planks" | "dark_oak_pressure_plate" | "minecraft:dark_oak_pressure_plate" | "dark_oak_sapling" | "minecraft:dark_oak_sapling" | "dark_oak_sign" | "minecraft:dark_oak_sign" | "dark_oak_slab" | "minecraft:dark_oak_slab" | "dark_oak_stairs" | "minecraft:dark_oak_stairs" | "dark_oak_trapdoor" | "minecraft:dark_oak_trapdoor" | "dark_oak_wood" | "minecraft:dark_oak_wood" | "dark_prismarine" | "minecraft:dark_prismarine" | "dark_prismarine_slab" | "minecraft:dark_prismarine_slab" | "dark_prismarine_stairs" | "minecraft:dark_prismarine_stairs" | "daylight_detector" | "minecraft:daylight_detector" | "dead_brain_coral" | "minecraft:dead_brain_coral" | "dead_brain_coral_block" | "minecraft:dead_brain_coral_block" | "dead_brain_coral_fan" | "minecraft:dead_brain_coral_fan" | "dead_bubble_coral" | "minecraft:dead_bubble_coral" | "dead_bubble_coral_block" | "minecraft:dead_bubble_coral_block" | "dead_bubble_coral_fan" | "minecraft:dead_bubble_coral_fan" | "dead_bush" | "minecraft:dead_bush" | "dead_fire_coral" | "minecraft:dead_fire_coral" | "dead_fire_coral_block" | "minecraft:dead_fire_coral_block" | "dead_fire_coral_fan" | "minecraft:dead_fire_coral_fan" | "dead_horn_coral" | "minecraft:dead_horn_coral" | "dead_horn_coral_block" | "minecraft:dead_horn_coral_block" | "dead_horn_coral_fan" | "minecraft:dead_horn_coral_fan" | "dead_tube_coral" | "minecraft:dead_tube_coral" | "dead_tube_coral_block" | "minecraft:dead_tube_coral_block" | "dead_tube_coral_fan" | "minecraft:dead_tube_coral_fan" | "debug_stick" | "minecraft:debug_stick" | "deepslate" | "minecraft:deepslate" | "deepslate_brick_slab" | "minecraft:deepslate_brick_slab" | "deepslate_brick_stairs" | "minecraft:deepslate_brick_stairs" | "deepslate_brick_wall" | "minecraft:deepslate_brick_wall" | "deepslate_bricks" | "minecraft:deepslate_bricks" | "deepslate_coal_ore" | "minecraft:deepslate_coal_ore" | "deepslate_copper_ore" | "minecraft:deepslate_copper_ore" | "deepslate_diamond_ore" | "minecraft:deepslate_diamond_ore" | "deepslate_emerald_ore" | "minecraft:deepslate_emerald_ore" | "deepslate_gold_ore" | "minecraft:deepslate_gold_ore" | "deepslate_iron_ore" | "minecraft:deepslate_iron_ore" | "deepslate_lapis_ore" | "minecraft:deepslate_lapis_ore" | "deepslate_redstone_ore" | "minecraft:deepslate_redstone_ore" | "deepslate_tile_slab" | "minecraft:deepslate_tile_slab" | "deepslate_tile_stairs" | "minecraft:deepslate_tile_stairs" | "deepslate_tile_wall" | "minecraft:deepslate_tile_wall" | "deepslate_tiles" | "minecraft:deepslate_tiles" | "detector_rail" | "minecraft:detector_rail" | "diamond" | "minecraft:diamond" | "diamond_axe" | "minecraft:diamond_axe" | "diamond_block" | "minecraft:diamond_block" | "diamond_boots" | "minecraft:diamond_boots" | "diamond_chestplate" | "minecraft:diamond_chestplate" | "diamond_helmet" | "minecraft:diamond_helmet" | "diamond_hoe" | "minecraft:diamond_hoe" | "diamond_horse_armor" | "minecraft:diamond_horse_armor" | "diamond_leggings" | "minecraft:diamond_leggings" | "diamond_ore" | "minecraft:diamond_ore" | "diamond_pickaxe" | "minecraft:diamond_pickaxe" | "diamond_shovel" | "minecraft:diamond_shovel" | "diamond_sword" | "minecraft:diamond_sword" | "diorite" | "minecraft:diorite" | "diorite_slab" | "minecraft:diorite_slab" | "diorite_stairs" | "minecraft:diorite_stairs" | "diorite_wall" | "minecraft:diorite_wall" | "dirt" | "minecraft:dirt" | "dirt_path" | "minecraft:dirt_path" | "dispenser" | "minecraft:dispenser" | "dolphin_spawn_egg" | "minecraft:dolphin_spawn_egg" | "donkey_spawn_egg" | "minecraft:donkey_spawn_egg" | "dragon_breath" | "minecraft:dragon_breath" | "dragon_egg" | "minecraft:dragon_egg" | "dragon_head" | "minecraft:dragon_head" | "dried_kelp" | "minecraft:dried_kelp" | "dried_kelp_block" | "minecraft:dried_kelp_block" | "dripstone_block" | "minecraft:dripstone_block" | "dropper" | "minecraft:dropper" | "drowned_spawn_egg" | "minecraft:drowned_spawn_egg" | "egg" | "minecraft:egg" | "elder_guardian_spawn_egg" | "minecraft:elder_guardian_spawn_egg" | "elytra" | "minecraft:elytra" | "emerald" | "minecraft:emerald" | "emerald_block" | "minecraft:emerald_block" | "emerald_ore" | "minecraft:emerald_ore" | "enchanted_book" | "minecraft:enchanted_book" | "enchanted_golden_apple" | "minecraft:enchanted_golden_apple" | "enchanting_table" | "minecraft:enchanting_table" | "end_crystal" | "minecraft:end_crystal" | "end_portal_frame" | "minecraft:end_portal_frame" | "end_rod" | "minecraft:end_rod" | "end_stone" | "minecraft:end_stone" | "end_stone_brick_slab" | "minecraft:end_stone_brick_slab" | "end_stone_brick_stairs" | "minecraft:end_stone_brick_stairs" | "end_stone_brick_wall" | "minecraft:end_stone_brick_wall" | "end_stone_bricks" | "minecraft:end_stone_bricks" | "ender_chest" | "minecraft:ender_chest" | "ender_eye" | "minecraft:ender_eye" | "ender_pearl" | "minecraft:ender_pearl" | "enderman_spawn_egg" | "minecraft:enderman_spawn_egg" | "endermite_spawn_egg" | "minecraft:endermite_spawn_egg" | "evoker_spawn_egg" | "minecraft:evoker_spawn_egg" | "experience_bottle" | "minecraft:experience_bottle" | "exposed_copper" | "minecraft:exposed_copper" | "exposed_cut_copper" | "minecraft:exposed_cut_copper" | "exposed_cut_copper_slab" | "minecraft:exposed_cut_copper_slab" | "exposed_cut_copper_stairs" | "minecraft:exposed_cut_copper_stairs" | "farmland" | "minecraft:farmland" | "feather" | "minecraft:feather" | "fermented_spider_eye" | "minecraft:fermented_spider_eye" | "fern" | "minecraft:fern" | "filled_map" | "minecraft:filled_map" | "fire_charge" | "minecraft:fire_charge" | "fire_coral" | "minecraft:fire_coral" | "fire_coral_block" | "minecraft:fire_coral_block" | "fire_coral_fan" | "minecraft:fire_coral_fan" | "firework_rocket" | "minecraft:firework_rocket" | "firework_star" | "minecraft:firework_star" | "fishing_rod" | "minecraft:fishing_rod" | "fletching_table" | "minecraft:fletching_table" | "flint" | "minecraft:flint" | "flint_and_steel" | "minecraft:flint_and_steel" | "flower_banner_pattern" | "minecraft:flower_banner_pattern" | "flower_pot" | "minecraft:flower_pot" | "flowering_azalea" | "minecraft:flowering_azalea" | "flowering_azalea_leaves" | "minecraft:flowering_azalea_leaves" | "fox_spawn_egg" | "minecraft:fox_spawn_egg" | "furnace" | "minecraft:furnace" | "furnace_minecart" | "minecraft:furnace_minecart" | "ghast_spawn_egg" | "minecraft:ghast_spawn_egg" | "ghast_tear" | "minecraft:ghast_tear" | "gilded_blackstone" | "minecraft:gilded_blackstone" | "glass" | "minecraft:glass" | "glass_bottle" | "minecraft:glass_bottle" | "glass_pane" | "minecraft:glass_pane" | "glistering_melon_slice" | "minecraft:glistering_melon_slice" | "globe_banner_pattern" | "minecraft:globe_banner_pattern" | "glow_berries" | "minecraft:glow_berries" | "glow_ink_sac" | "minecraft:glow_ink_sac" | "glow_item_frame" | "minecraft:glow_item_frame" | "glow_lichen" | "minecraft:glow_lichen" | "glow_squid_spawn_egg" | "minecraft:glow_squid_spawn_egg" | "glowstone" | "minecraft:glowstone" | "glowstone_dust" | "minecraft:glowstone_dust" | "goat_spawn_egg" | "minecraft:goat_spawn_egg" | "gold_block" | "minecraft:gold_block" | "gold_ingot" | "minecraft:gold_ingot" | "gold_nugget" | "minecraft:gold_nugget" | "gold_ore" | "minecraft:gold_ore" | "golden_apple" | "minecraft:golden_apple" | "golden_axe" | "minecraft:golden_axe" | "golden_boots" | "minecraft:golden_boots" | "golden_carrot" | "minecraft:golden_carrot" | "golden_chestplate" | "minecraft:golden_chestplate" | "golden_helmet" | "minecraft:golden_helmet" | "golden_hoe" | "minecraft:golden_hoe" | "golden_horse_armor" | "minecraft:golden_horse_armor" | "golden_leggings" | "minecraft:golden_leggings" | "golden_pickaxe" | "minecraft:golden_pickaxe" | "golden_shovel" | "minecraft:golden_shovel" | "golden_sword" | "minecraft:golden_sword" | "granite" | "minecraft:granite" | "granite_slab" | "minecraft:granite_slab" | "granite_stairs" | "minecraft:granite_stairs" | "granite_wall" | "minecraft:granite_wall" | "grass" | "minecraft:grass" | "grass_block" | "minecraft:grass_block" | "gravel" | "minecraft:gravel" | "gray_banner" | "minecraft:gray_banner" | "gray_bed" | "minecraft:gray_bed" | "gray_candle" | "minecraft:gray_candle" | "gray_carpet" | "minecraft:gray_carpet" | "gray_concrete" | "minecraft:gray_concrete" | "gray_concrete_powder" | "minecraft:gray_concrete_powder" | "gray_dye" | "minecraft:gray_dye" | "gray_glazed_terracotta" | "minecraft:gray_glazed_terracotta" | "gray_shulker_box" | "minecraft:gray_shulker_box" | "gray_stained_glass" | "minecraft:gray_stained_glass" | "gray_stained_glass_pane" | "minecraft:gray_stained_glass_pane" | "gray_terracotta" | "minecraft:gray_terracotta" | "gray_wool" | "minecraft:gray_wool" | "green_banner" | "minecraft:green_banner" | "green_bed" | "minecraft:green_bed" | "green_candle" | "minecraft:green_candle" | "green_carpet" | "minecraft:green_carpet" | "green_concrete" | "minecraft:green_concrete" | "green_concrete_powder" | "minecraft:green_concrete_powder" | "green_dye" | "minecraft:green_dye" | "green_glazed_terracotta" | "minecraft:green_glazed_terracotta" | "green_shulker_box" | "minecraft:green_shulker_box" | "green_stained_glass" | "minecraft:green_stained_glass" | "green_stained_glass_pane" | "minecraft:green_stained_glass_pane" | "green_terracotta" | "minecraft:green_terracotta" | "green_wool" | "minecraft:green_wool" | "grindstone" | "minecraft:grindstone" | "guardian_spawn_egg" | "minecraft:guardian_spawn_egg" | "gunpowder" | "minecraft:gunpowder" | "hanging_roots" | "minecraft:hanging_roots" | "hay_block" | "minecraft:hay_block" | "heart_of_the_sea" | "minecraft:heart_of_the_sea" | "heavy_weighted_pressure_plate" | "minecraft:heavy_weighted_pressure_plate" | "hoglin_spawn_egg" | "minecraft:hoglin_spawn_egg" | "honey_block" | "minecraft:honey_block" | "honey_bottle" | "minecraft:honey_bottle" | "honeycomb" | "minecraft:honeycomb" | "honeycomb_block" | "minecraft:honeycomb_block" | "hopper" | "minecraft:hopper" | "hopper_minecart" | "minecraft:hopper_minecart" | "horn_coral" | "minecraft:horn_coral" | "horn_coral_block" | "minecraft:horn_coral_block" | "horn_coral_fan" | "minecraft:horn_coral_fan" | "horse_spawn_egg" | "minecraft:horse_spawn_egg" | "husk_spawn_egg" | "minecraft:husk_spawn_egg" | "ice" | "minecraft:ice" | "infested_chiseled_stone_bricks" | "minecraft:infested_chiseled_stone_bricks" | "infested_cobblestone" | "minecraft:infested_cobblestone" | "infested_cracked_stone_bricks" | "minecraft:infested_cracked_stone_bricks" | "infested_deepslate" | "minecraft:infested_deepslate" | "infested_mossy_stone_bricks" | "minecraft:infested_mossy_stone_bricks" | "infested_stone" | "minecraft:infested_stone" | "infested_stone_bricks" | "minecraft:infested_stone_bricks" | "ink_sac" | "minecraft:ink_sac" | "iron_axe" | "minecraft:iron_axe" | "iron_bars" | "minecraft:iron_bars" | "iron_block" | "minecraft:iron_block" | "iron_boots" | "minecraft:iron_boots" | "iron_chestplate" | "minecraft:iron_chestplate" | "iron_door" | "minecraft:iron_door" | "iron_helmet" | "minecraft:iron_helmet" | "iron_hoe" | "minecraft:iron_hoe" | "iron_horse_armor" | "minecraft:iron_horse_armor" | "iron_ingot" | "minecraft:iron_ingot" | "iron_leggings" | "minecraft:iron_leggings" | "iron_nugget" | "minecraft:iron_nugget" | "iron_ore" | "minecraft:iron_ore" | "iron_pickaxe" | "minecraft:iron_pickaxe" | "iron_shovel" | "minecraft:iron_shovel" | "iron_sword" | "minecraft:iron_sword" | "iron_trapdoor" | "minecraft:iron_trapdoor" | "item_frame" | "minecraft:item_frame" | "jack_o_lantern" | "minecraft:jack_o_lantern" | "jigsaw" | "minecraft:jigsaw" | "jukebox" | "minecraft:jukebox" | "jungle_boat" | "minecraft:jungle_boat" | "jungle_button" | "minecraft:jungle_button" | "jungle_door" | "minecraft:jungle_door" | "jungle_fence" | "minecraft:jungle_fence" | "jungle_fence_gate" | "minecraft:jungle_fence_gate" | "jungle_leaves" | "minecraft:jungle_leaves" | "jungle_log" | "minecraft:jungle_log" | "jungle_planks" | "minecraft:jungle_planks" | "jungle_pressure_plate" | "minecraft:jungle_pressure_plate" | "jungle_sapling" | "minecraft:jungle_sapling" | "jungle_sign" | "minecraft:jungle_sign" | "jungle_slab" | "minecraft:jungle_slab" | "jungle_stairs" | "minecraft:jungle_stairs" | "jungle_trapdoor" | "minecraft:jungle_trapdoor" | "jungle_wood" | "minecraft:jungle_wood" | "kelp" | "minecraft:kelp" | "knowledge_book" | "minecraft:knowledge_book" | "ladder" | "minecraft:ladder" | "lantern" | "minecraft:lantern" | "lapis_block" | "minecraft:lapis_block" | "lapis_lazuli" | "minecraft:lapis_lazuli" | "lapis_ore" | "minecraft:lapis_ore" | "large_amethyst_bud" | "minecraft:large_amethyst_bud" | "large_fern" | "minecraft:large_fern" | "lava_bucket" | "minecraft:lava_bucket" | "lead" | "minecraft:lead" | "leather" | "minecraft:leather" | "leather_boots" | "minecraft:leather_boots" | "leather_chestplate" | "minecraft:leather_chestplate" | "leather_helmet" | "minecraft:leather_helmet" | "leather_horse_armor" | "minecraft:leather_horse_armor" | "leather_leggings" | "minecraft:leather_leggings" | "lectern" | "minecraft:lectern" | "lever" | "minecraft:lever" | "light" | "minecraft:light" | "light_blue_banner" | "minecraft:light_blue_banner" | "light_blue_bed" | "minecraft:light_blue_bed" | "light_blue_candle" | "minecraft:light_blue_candle" | "light_blue_carpet" | "minecraft:light_blue_carpet" | "light_blue_concrete" | "minecraft:light_blue_concrete" | "light_blue_concrete_powder" | "minecraft:light_blue_concrete_powder" | "light_blue_dye" | "minecraft:light_blue_dye" | "light_blue_glazed_terracotta" | "minecraft:light_blue_glazed_terracotta" | "light_blue_shulker_box" | "minecraft:light_blue_shulker_box" | "light_blue_stained_glass" | "minecraft:light_blue_stained_glass" | "light_blue_stained_glass_pane" | "minecraft:light_blue_stained_glass_pane" | "light_blue_terracotta" | "minecraft:light_blue_terracotta" | "light_blue_wool" | "minecraft:light_blue_wool" | "light_gray_banner" | "minecraft:light_gray_banner" | "light_gray_bed" | "minecraft:light_gray_bed" | "light_gray_candle" | "minecraft:light_gray_candle" | "light_gray_carpet" | "minecraft:light_gray_carpet" | "light_gray_concrete" | "minecraft:light_gray_concrete" | "light_gray_concrete_powder" | "minecraft:light_gray_concrete_powder" | "light_gray_dye" | "minecraft:light_gray_dye" | "light_gray_glazed_terracotta" | "minecraft:light_gray_glazed_terracotta" | "light_gray_shulker_box" | "minecraft:light_gray_shulker_box" | "light_gray_stained_glass" | "minecraft:light_gray_stained_glass" | "light_gray_stained_glass_pane" | "minecraft:light_gray_stained_glass_pane" | "light_gray_terracotta" | "minecraft:light_gray_terracotta" | "light_gray_wool" | "minecraft:light_gray_wool" | "light_weighted_pressure_plate" | "minecraft:light_weighted_pressure_plate" | "lightning_rod" | "minecraft:lightning_rod" | "lilac" | "minecraft:lilac" | "lily_of_the_valley" | "minecraft:lily_of_the_valley" | "lily_pad" | "minecraft:lily_pad" | "lime_banner" | "minecraft:lime_banner" | "lime_bed" | "minecraft:lime_bed" | "lime_candle" | "minecraft:lime_candle" | "lime_carpet" | "minecraft:lime_carpet" | "lime_concrete" | "minecraft:lime_concrete" | "lime_concrete_powder" | "minecraft:lime_concrete_powder" | "lime_dye" | "minecraft:lime_dye" | "lime_glazed_terracotta" | "minecraft:lime_glazed_terracotta" | "lime_shulker_box" | "minecraft:lime_shulker_box" | "lime_stained_glass" | "minecraft:lime_stained_glass" | "lime_stained_glass_pane" | "minecraft:lime_stained_glass_pane" | "lime_terracotta" | "minecraft:lime_terracotta" | "lime_wool" | "minecraft:lime_wool" | "lingering_potion" | "minecraft:lingering_potion" | "llama_spawn_egg" | "minecraft:llama_spawn_egg" | "lodestone" | "minecraft:lodestone" | "loom" | "minecraft:loom" | "magenta_banner" | "minecraft:magenta_banner" | "magenta_bed" | "minecraft:magenta_bed" | "magenta_candle" | "minecraft:magenta_candle" | "magenta_carpet" | "minecraft:magenta_carpet" | "magenta_concrete" | "minecraft:magenta_concrete" | "magenta_concrete_powder" | "minecraft:magenta_concrete_powder" | "magenta_dye" | "minecraft:magenta_dye" | "magenta_glazed_terracotta" | "minecraft:magenta_glazed_terracotta" | "magenta_shulker_box" | "minecraft:magenta_shulker_box" | "magenta_stained_glass" | "minecraft:magenta_stained_glass" | "magenta_stained_glass_pane" | "minecraft:magenta_stained_glass_pane" | "magenta_terracotta" | "minecraft:magenta_terracotta" | "magenta_wool" | "minecraft:magenta_wool" | "magma_block" | "minecraft:magma_block" | "magma_cream" | "minecraft:magma_cream" | "magma_cube_spawn_egg" | "minecraft:magma_cube_spawn_egg" | "map" | "minecraft:map" | "medium_amethyst_bud" | "minecraft:medium_amethyst_bud" | "melon" | "minecraft:melon" | "melon_seeds" | "minecraft:melon_seeds" | "melon_slice" | "minecraft:melon_slice" | "milk_bucket" | "minecraft:milk_bucket" | "minecart" | "minecraft:minecart" | "mojang_banner_pattern" | "minecraft:mojang_banner_pattern" | "mooshroom_spawn_egg" | "minecraft:mooshroom_spawn_egg" | "moss_block" | "minecraft:moss_block" | "moss_carpet" | "minecraft:moss_carpet" | "mossy_cobblestone" | "minecraft:mossy_cobblestone" | "mossy_cobblestone_slab" | "minecraft:mossy_cobblestone_slab" | "mossy_cobblestone_stairs" | "minecraft:mossy_cobblestone_stairs" | "mossy_cobblestone_wall" | "minecraft:mossy_cobblestone_wall" | "mossy_stone_brick_slab" | "minecraft:mossy_stone_brick_slab" | "mossy_stone_brick_stairs" | "minecraft:mossy_stone_brick_stairs" | "mossy_stone_brick_wall" | "minecraft:mossy_stone_brick_wall" | "mossy_stone_bricks" | "minecraft:mossy_stone_bricks" | "mule_spawn_egg" | "minecraft:mule_spawn_egg" | "mushroom_stem" | "minecraft:mushroom_stem" | "mushroom_stew" | "minecraft:mushroom_stew" | "music_disc_11" | "minecraft:music_disc_11" | "music_disc_13" | "minecraft:music_disc_13" | "music_disc_blocks" | "minecraft:music_disc_blocks" | "music_disc_cat" | "minecraft:music_disc_cat" | "music_disc_chirp" | "minecraft:music_disc_chirp" | "music_disc_far" | "minecraft:music_disc_far" | "music_disc_mall" | "minecraft:music_disc_mall" | "music_disc_mellohi" | "minecraft:music_disc_mellohi" | "music_disc_otherside" | "minecraft:music_disc_otherside" | "music_disc_pigstep" | "minecraft:music_disc_pigstep" | "music_disc_stal" | "minecraft:music_disc_stal" | "music_disc_strad" | "minecraft:music_disc_strad" | "music_disc_wait" | "minecraft:music_disc_wait" | "music_disc_ward" | "minecraft:music_disc_ward" | "mutton" | "minecraft:mutton" | "mycelium" | "minecraft:mycelium" | "name_tag" | "minecraft:name_tag" | "nautilus_shell" | "minecraft:nautilus_shell" | "nether_brick" | "minecraft:nether_brick" | "nether_brick_fence" | "minecraft:nether_brick_fence" | "nether_brick_slab" | "minecraft:nether_brick_slab" | "nether_brick_stairs" | "minecraft:nether_brick_stairs" | "nether_brick_wall" | "minecraft:nether_brick_wall" | "nether_bricks" | "minecraft:nether_bricks" | "nether_gold_ore" | "minecraft:nether_gold_ore" | "nether_quartz_ore" | "minecraft:nether_quartz_ore" | "nether_sprouts" | "minecraft:nether_sprouts" | "nether_star" | "minecraft:nether_star" | "nether_wart" | "minecraft:nether_wart" | "nether_wart_block" | "minecraft:nether_wart_block" | "netherite_axe" | "minecraft:netherite_axe" | "netherite_block" | "minecraft:netherite_block" | "netherite_boots" | "minecraft:netherite_boots" | "netherite_chestplate" | "minecraft:netherite_chestplate" | "netherite_helmet" | "minecraft:netherite_helmet" | "netherite_hoe" | "minecraft:netherite_hoe" | "netherite_ingot" | "minecraft:netherite_ingot" | "netherite_leggings" | "minecraft:netherite_leggings" | "netherite_pickaxe" | "minecraft:netherite_pickaxe" | "netherite_scrap" | "minecraft:netherite_scrap" | "netherite_shovel" | "minecraft:netherite_shovel" | "netherite_sword" | "minecraft:netherite_sword" | "netherrack" | "minecraft:netherrack" | "note_block" | "minecraft:note_block" | "oak_boat" | "minecraft:oak_boat" | "oak_button" | "minecraft:oak_button" | "oak_door" | "minecraft:oak_door" | "oak_fence" | "minecraft:oak_fence" | "oak_fence_gate" | "minecraft:oak_fence_gate" | "oak_leaves" | "minecraft:oak_leaves" | "oak_log" | "minecraft:oak_log" | "oak_planks" | "minecraft:oak_planks" | "oak_pressure_plate" | "minecraft:oak_pressure_plate" | "oak_sapling" | "minecraft:oak_sapling" | "oak_sign" | "minecraft:oak_sign" | "oak_slab" | "minecraft:oak_slab" | "oak_stairs" | "minecraft:oak_stairs" | "oak_trapdoor" | "minecraft:oak_trapdoor" | "oak_wood" | "minecraft:oak_wood" | "observer" | "minecraft:observer" | "obsidian" | "minecraft:obsidian" | "ocelot_spawn_egg" | "minecraft:ocelot_spawn_egg" | "orange_banner" | "minecraft:orange_banner" | "orange_bed" | "minecraft:orange_bed" | "orange_candle" | "minecraft:orange_candle" | "orange_carpet" | "minecraft:orange_carpet" | "orange_concrete" | "minecraft:orange_concrete" | "orange_concrete_powder" | "minecraft:orange_concrete_powder" | "orange_dye" | "minecraft:orange_dye" | "orange_glazed_terracotta" | "minecraft:orange_glazed_terracotta" | "orange_shulker_box" | "minecraft:orange_shulker_box" | "orange_stained_glass" | "minecraft:orange_stained_glass" | "orange_stained_glass_pane" | "minecraft:orange_stained_glass_pane" | "orange_terracotta" | "minecraft:orange_terracotta" | "orange_tulip" | "minecraft:orange_tulip" | "orange_wool" | "minecraft:orange_wool" | "oxeye_daisy" | "minecraft:oxeye_daisy" | "oxidized_copper" | "minecraft:oxidized_copper" | "oxidized_cut_copper" | "minecraft:oxidized_cut_copper" | "oxidized_cut_copper_slab" | "minecraft:oxidized_cut_copper_slab" | "oxidized_cut_copper_stairs" | "minecraft:oxidized_cut_copper_stairs" | "packed_ice" | "minecraft:packed_ice" | "painting" | "minecraft:painting" | "panda_spawn_egg" | "minecraft:panda_spawn_egg" | "paper" | "minecraft:paper" | "parrot_spawn_egg" | "minecraft:parrot_spawn_egg" | "peony" | "minecraft:peony" | "petrified_oak_slab" | "minecraft:petrified_oak_slab" | "phantom_membrane" | "minecraft:phantom_membrane" | "phantom_spawn_egg" | "minecraft:phantom_spawn_egg" | "pig_spawn_egg" | "minecraft:pig_spawn_egg" | "piglin_banner_pattern" | "minecraft:piglin_banner_pattern" | "piglin_brute_spawn_egg" | "minecraft:piglin_brute_spawn_egg" | "piglin_spawn_egg" | "minecraft:piglin_spawn_egg" | "pillager_spawn_egg" | "minecraft:pillager_spawn_egg" | "pink_banner" | "minecraft:pink_banner" | "pink_bed" | "minecraft:pink_bed" | "pink_candle" | "minecraft:pink_candle" | "pink_carpet" | "minecraft:pink_carpet" | "pink_concrete" | "minecraft:pink_concrete" | "pink_concrete_powder" | "minecraft:pink_concrete_powder" | "pink_dye" | "minecraft:pink_dye" | "pink_glazed_terracotta" | "minecraft:pink_glazed_terracotta" | "pink_shulker_box" | "minecraft:pink_shulker_box" | "pink_stained_glass" | "minecraft:pink_stained_glass" | "pink_stained_glass_pane" | "minecraft:pink_stained_glass_pane" | "pink_terracotta" | "minecraft:pink_terracotta" | "pink_tulip" | "minecraft:pink_tulip" | "pink_wool" | "minecraft:pink_wool" | "piston" | "minecraft:piston" | "player_head" | "minecraft:player_head" | "podzol" | "minecraft:podzol" | "pointed_dripstone" | "minecraft:pointed_dripstone" | "poisonous_potato" | "minecraft:poisonous_potato" | "polar_bear_spawn_egg" | "minecraft:polar_bear_spawn_egg" | "polished_andesite" | "minecraft:polished_andesite" | "polished_andesite_slab" | "minecraft:polished_andesite_slab" | "polished_andesite_stairs" | "minecraft:polished_andesite_stairs" | "polished_basalt" | "minecraft:polished_basalt" | "polished_blackstone" | "minecraft:polished_blackstone" | "polished_blackstone_brick_slab" | "minecraft:polished_blackstone_brick_slab" | "polished_blackstone_brick_stairs" | "minecraft:polished_blackstone_brick_stairs" | "polished_blackstone_brick_wall" | "minecraft:polished_blackstone_brick_wall" | "polished_blackstone_bricks" | "minecraft:polished_blackstone_bricks" | "polished_blackstone_button" | "minecraft:polished_blackstone_button" | "polished_blackstone_pressure_plate" | "minecraft:polished_blackstone_pressure_plate" | "polished_blackstone_slab" | "minecraft:polished_blackstone_slab" | "polished_blackstone_stairs" | "minecraft:polished_blackstone_stairs" | "polished_blackstone_wall" | "minecraft:polished_blackstone_wall" | "polished_deepslate" | "minecraft:polished_deepslate" | "polished_deepslate_slab" | "minecraft:polished_deepslate_slab" | "polished_deepslate_stairs" | "minecraft:polished_deepslate_stairs" | "polished_deepslate_wall" | "minecraft:polished_deepslate_wall" | "polished_diorite" | "minecraft:polished_diorite" | "polished_diorite_slab" | "minecraft:polished_diorite_slab" | "polished_diorite_stairs" | "minecraft:polished_diorite_stairs" | "polished_granite" | "minecraft:polished_granite" | "polished_granite_slab" | "minecraft:polished_granite_slab" | "polished_granite_stairs" | "minecraft:polished_granite_stairs" | "popped_chorus_fruit" | "minecraft:popped_chorus_fruit" | "poppy" | "minecraft:poppy" | "porkchop" | "minecraft:porkchop" | "potato" | "minecraft:potato" | "potion" | "minecraft:potion" | "powder_snow_bucket" | "minecraft:powder_snow_bucket" | "powered_rail" | "minecraft:powered_rail" | "prismarine" | "minecraft:prismarine" | "prismarine_brick_slab" | "minecraft:prismarine_brick_slab" | "prismarine_brick_stairs" | "minecraft:prismarine_brick_stairs" | "prismarine_bricks" | "minecraft:prismarine_bricks" | "prismarine_crystals" | "minecraft:prismarine_crystals" | "prismarine_shard" | "minecraft:prismarine_shard" | "prismarine_slab" | "minecraft:prismarine_slab" | "prismarine_stairs" | "minecraft:prismarine_stairs" | "prismarine_wall" | "minecraft:prismarine_wall" | "pufferfish" | "minecraft:pufferfish" | "pufferfish_bucket" | "minecraft:pufferfish_bucket" | "pufferfish_spawn_egg" | "minecraft:pufferfish_spawn_egg" | "pumpkin" | "minecraft:pumpkin" | "pumpkin_pie" | "minecraft:pumpkin_pie" | "pumpkin_seeds" | "minecraft:pumpkin_seeds" | "purple_banner" | "minecraft:purple_banner" | "purple_bed" | "minecraft:purple_bed" | "purple_candle" | "minecraft:purple_candle" | "purple_carpet" | "minecraft:purple_carpet" | "purple_concrete" | "minecraft:purple_concrete" | "purple_concrete_powder" | "minecraft:purple_concrete_powder" | "purple_dye" | "minecraft:purple_dye" | "purple_glazed_terracotta" | "minecraft:purple_glazed_terracotta" | "purple_shulker_box" | "minecraft:purple_shulker_box" | "purple_stained_glass" | "minecraft:purple_stained_glass" | "purple_stained_glass_pane" | "minecraft:purple_stained_glass_pane" | "purple_terracotta" | "minecraft:purple_terracotta" | "purple_wool" | "minecraft:purple_wool" | "purpur_block" | "minecraft:purpur_block" | "purpur_pillar" | "minecraft:purpur_pillar" | "purpur_slab" | "minecraft:purpur_slab" | "purpur_stairs" | "minecraft:purpur_stairs" | "quartz" | "minecraft:quartz" | "quartz_block" | "minecraft:quartz_block" | "quartz_bricks" | "minecraft:quartz_bricks" | "quartz_pillar" | "minecraft:quartz_pillar" | "quartz_slab" | "minecraft:quartz_slab" | "quartz_stairs" | "minecraft:quartz_stairs" | "rabbit" | "minecraft:rabbit" | "rabbit_foot" | "minecraft:rabbit_foot" | "rabbit_hide" | "minecraft:rabbit_hide" | "rabbit_spawn_egg" | "minecraft:rabbit_spawn_egg" | "rabbit_stew" | "minecraft:rabbit_stew" | "rail" | "minecraft:rail" | "ravager_spawn_egg" | "minecraft:ravager_spawn_egg" | "raw_copper" | "minecraft:raw_copper" | "raw_copper_block" | "minecraft:raw_copper_block" | "raw_gold" | "minecraft:raw_gold" | "raw_gold_block" | "minecraft:raw_gold_block" | "raw_iron" | "minecraft:raw_iron" | "raw_iron_block" | "minecraft:raw_iron_block" | "red_banner" | "minecraft:red_banner" | "red_bed" | "minecraft:red_bed" | "red_candle" | "minecraft:red_candle" | "red_carpet" | "minecraft:red_carpet" | "red_concrete" | "minecraft:red_concrete" | "red_concrete_powder" | "minecraft:red_concrete_powder" | "red_dye" | "minecraft:red_dye" | "red_glazed_terracotta" | "minecraft:red_glazed_terracotta" | "red_mushroom" | "minecraft:red_mushroom" | "red_mushroom_block" | "minecraft:red_mushroom_block" | "red_nether_brick_slab" | "minecraft:red_nether_brick_slab" | "red_nether_brick_stairs" | "minecraft:red_nether_brick_stairs" | "red_nether_brick_wall" | "minecraft:red_nether_brick_wall" | "red_nether_bricks" | "minecraft:red_nether_bricks" | "red_sand" | "minecraft:red_sand" | "red_sandstone" | "minecraft:red_sandstone" | "red_sandstone_slab" | "minecraft:red_sandstone_slab" | "red_sandstone_stairs" | "minecraft:red_sandstone_stairs" | "red_sandstone_wall" | "minecraft:red_sandstone_wall" | "red_shulker_box" | "minecraft:red_shulker_box" | "red_stained_glass" | "minecraft:red_stained_glass" | "red_stained_glass_pane" | "minecraft:red_stained_glass_pane" | "red_terracotta" | "minecraft:red_terracotta" | "red_tulip" | "minecraft:red_tulip" | "red_wool" | "minecraft:red_wool" | "redstone" | "minecraft:redstone" | "redstone_block" | "minecraft:redstone_block" | "redstone_lamp" | "minecraft:redstone_lamp" | "redstone_ore" | "minecraft:redstone_ore" | "redstone_torch" | "minecraft:redstone_torch" | "repeater" | "minecraft:repeater" | "repeating_command_block" | "minecraft:repeating_command_block" | "respawn_anchor" | "minecraft:respawn_anchor" | "rooted_dirt" | "minecraft:rooted_dirt" | "rose_bush" | "minecraft:rose_bush" | "rotten_flesh" | "minecraft:rotten_flesh" | "saddle" | "minecraft:saddle" | "salmon" | "minecraft:salmon" | "salmon_bucket" | "minecraft:salmon_bucket" | "salmon_spawn_egg" | "minecraft:salmon_spawn_egg" | "sand" | "minecraft:sand" | "sandstone" | "minecraft:sandstone" | "sandstone_slab" | "minecraft:sandstone_slab" | "sandstone_stairs" | "minecraft:sandstone_stairs" | "sandstone_wall" | "minecraft:sandstone_wall" | "scaffolding" | "minecraft:scaffolding" | "sculk_sensor" | "minecraft:sculk_sensor" | "scute" | "minecraft:scute" | "sea_lantern" | "minecraft:sea_lantern" | "sea_pickle" | "minecraft:sea_pickle" | "seagrass" | "minecraft:seagrass" | "shears" | "minecraft:shears" | "sheep_spawn_egg" | "minecraft:sheep_spawn_egg" | "shield" | "minecraft:shield" | "shroomlight" | "minecraft:shroomlight" | "shulker_box" | "minecraft:shulker_box" | "shulker_shell" | "minecraft:shulker_shell" | "shulker_spawn_egg" | "minecraft:shulker_spawn_egg" | "silverfish_spawn_egg" | "minecraft:silverfish_spawn_egg" | "skeleton_horse_spawn_egg" | "minecraft:skeleton_horse_spawn_egg" | "skeleton_skull" | "minecraft:skeleton_skull" | "skeleton_spawn_egg" | "minecraft:skeleton_spawn_egg" | "skull_banner_pattern" | "minecraft:skull_banner_pattern" | "slime_ball" | "minecraft:slime_ball" | "slime_block" | "minecraft:slime_block" | "slime_spawn_egg" | "minecraft:slime_spawn_egg" | "small_amethyst_bud" | "minecraft:small_amethyst_bud" | "small_dripleaf" | "minecraft:small_dripleaf" | "smithing_table" | "minecraft:smithing_table" | "smoker" | "minecraft:smoker" | "smooth_basalt" | "minecraft:smooth_basalt" | "smooth_quartz" | "minecraft:smooth_quartz" | "smooth_quartz_slab" | "minecraft:smooth_quartz_slab" | "smooth_quartz_stairs" | "minecraft:smooth_quartz_stairs" | "smooth_red_sandstone" | "minecraft:smooth_red_sandstone" | "smooth_red_sandstone_slab" | "minecraft:smooth_red_sandstone_slab" | "smooth_red_sandstone_stairs" | "minecraft:smooth_red_sandstone_stairs" | "smooth_sandstone" | "minecraft:smooth_sandstone" | "smooth_sandstone_slab" | "minecraft:smooth_sandstone_slab" | "smooth_sandstone_stairs" | "minecraft:smooth_sandstone_stairs" | "smooth_stone" | "minecraft:smooth_stone" | "smooth_stone_slab" | "minecraft:smooth_stone_slab" | "snow" | "minecraft:snow" | "snow_block" | "minecraft:snow_block" | "snowball" | "minecraft:snowball" | "soul_campfire" | "minecraft:soul_campfire" | "soul_lantern" | "minecraft:soul_lantern" | "soul_sand" | "minecraft:soul_sand" | "soul_soil" | "minecraft:soul_soil" | "soul_torch" | "minecraft:soul_torch" | "spawner" | "minecraft:spawner" | "spectral_arrow" | "minecraft:spectral_arrow" | "spider_eye" | "minecraft:spider_eye" | "spider_spawn_egg" | "minecraft:spider_spawn_egg" | "splash_potion" | "minecraft:splash_potion" | "sponge" | "minecraft:sponge" | "spore_blossom" | "minecraft:spore_blossom" | "spruce_boat" | "minecraft:spruce_boat" | "spruce_button" | "minecraft:spruce_button" | "spruce_door" | "minecraft:spruce_door" | "spruce_fence" | "minecraft:spruce_fence" | "spruce_fence_gate" | "minecraft:spruce_fence_gate" | "spruce_leaves" | "minecraft:spruce_leaves" | "spruce_log" | "minecraft:spruce_log" | "spruce_planks" | "minecraft:spruce_planks" | "spruce_pressure_plate" | "minecraft:spruce_pressure_plate" | "spruce_sapling" | "minecraft:spruce_sapling" | "spruce_sign" | "minecraft:spruce_sign" | "spruce_slab" | "minecraft:spruce_slab" | "spruce_stairs" | "minecraft:spruce_stairs" | "spruce_trapdoor" | "minecraft:spruce_trapdoor" | "spruce_wood" | "minecraft:spruce_wood" | "spyglass" | "minecraft:spyglass" | "squid_spawn_egg" | "minecraft:squid_spawn_egg" | "stick" | "minecraft:stick" | "sticky_piston" | "minecraft:sticky_piston" | "stone" | "minecraft:stone" | "stone_axe" | "minecraft:stone_axe" | "stone_brick_slab" | "minecraft:stone_brick_slab" | "stone_brick_stairs" | "minecraft:stone_brick_stairs" | "stone_brick_wall" | "minecraft:stone_brick_wall" | "stone_bricks" | "minecraft:stone_bricks" | "stone_button" | "minecraft:stone_button" | "stone_hoe" | "minecraft:stone_hoe" | "stone_pickaxe" | "minecraft:stone_pickaxe" | "stone_pressure_plate" | "minecraft:stone_pressure_plate" | "stone_shovel" | "minecraft:stone_shovel" | "stone_slab" | "minecraft:stone_slab" | "stone_stairs" | "minecraft:stone_stairs" | "stone_sword" | "minecraft:stone_sword" | "stonecutter" | "minecraft:stonecutter" | "stray_spawn_egg" | "minecraft:stray_spawn_egg" | "strider_spawn_egg" | "minecraft:strider_spawn_egg" | "string" | "minecraft:string" | "stripped_acacia_log" | "minecraft:stripped_acacia_log" | "stripped_acacia_wood" | "minecraft:stripped_acacia_wood" | "stripped_birch_log" | "minecraft:stripped_birch_log" | "stripped_birch_wood" | "minecraft:stripped_birch_wood" | "stripped_crimson_hyphae" | "minecraft:stripped_crimson_hyphae" | "stripped_crimson_stem" | "minecraft:stripped_crimson_stem" | "stripped_dark_oak_log" | "minecraft:stripped_dark_oak_log" | "stripped_dark_oak_wood" | "minecraft:stripped_dark_oak_wood" | "stripped_jungle_log" | "minecraft:stripped_jungle_log" | "stripped_jungle_wood" | "minecraft:stripped_jungle_wood" | "stripped_oak_log" | "minecraft:stripped_oak_log" | "stripped_oak_wood" | "minecraft:stripped_oak_wood" | "stripped_spruce_log" | "minecraft:stripped_spruce_log" | "stripped_spruce_wood" | "minecraft:stripped_spruce_wood" | "stripped_warped_hyphae" | "minecraft:stripped_warped_hyphae" | "stripped_warped_stem" | "minecraft:stripped_warped_stem" | "structure_block" | "minecraft:structure_block" | "structure_void" | "minecraft:structure_void" | "sugar" | "minecraft:sugar" | "sugar_cane" | "minecraft:sugar_cane" | "sunflower" | "minecraft:sunflower" | "suspicious_stew" | "minecraft:suspicious_stew" | "sweet_berries" | "minecraft:sweet_berries" | "tall_grass" | "minecraft:tall_grass" | "target" | "minecraft:target" | "terracotta" | "minecraft:terracotta" | "tinted_glass" | "minecraft:tinted_glass" | "tipped_arrow" | "minecraft:tipped_arrow" | "tnt" | "minecraft:tnt" | "tnt_minecart" | "minecraft:tnt_minecart" | "torch" | "minecraft:torch" | "totem_of_undying" | "minecraft:totem_of_undying" | "trader_llama_spawn_egg" | "minecraft:trader_llama_spawn_egg" | "trapped_chest" | "minecraft:trapped_chest" | "trident" | "minecraft:trident" | "tripwire_hook" | "minecraft:tripwire_hook" | "tropical_fish" | "minecraft:tropical_fish" | "tropical_fish_bucket" | "minecraft:tropical_fish_bucket" | "tropical_fish_spawn_egg" | "minecraft:tropical_fish_spawn_egg" | "tube_coral" | "minecraft:tube_coral" | "tube_coral_block" | "minecraft:tube_coral_block" | "tube_coral_fan" | "minecraft:tube_coral_fan" | "tuff" | "minecraft:tuff" | "turtle_egg" | "minecraft:turtle_egg" | "turtle_helmet" | "minecraft:turtle_helmet" | "turtle_spawn_egg" | "minecraft:turtle_spawn_egg" | "twisting_vines" | "minecraft:twisting_vines" | "vex_spawn_egg" | "minecraft:vex_spawn_egg" | "villager_spawn_egg" | "minecraft:villager_spawn_egg" | "vindicator_spawn_egg" | "minecraft:vindicator_spawn_egg" | "vine" | "minecraft:vine" | "wandering_trader_spawn_egg" | "minecraft:wandering_trader_spawn_egg" | "warped_button" | "minecraft:warped_button" | "warped_door" | "minecraft:warped_door" | "warped_fence" | "minecraft:warped_fence" | "warped_fence_gate" | "minecraft:warped_fence_gate" | "warped_fungus" | "minecraft:warped_fungus" | "warped_fungus_on_a_stick" | "minecraft:warped_fungus_on_a_stick" | "warped_hyphae" | "minecraft:warped_hyphae" | "warped_nylium" | "minecraft:warped_nylium" | "warped_planks" | "minecraft:warped_planks" | "warped_pressure_plate" | "minecraft:warped_pressure_plate" | "warped_roots" | "minecraft:warped_roots" | "warped_sign" | "minecraft:warped_sign" | "warped_slab" | "minecraft:warped_slab" | "warped_stairs" | "minecraft:warped_stairs" | "warped_stem" | "minecraft:warped_stem" | "warped_trapdoor" | "minecraft:warped_trapdoor" | "warped_wart_block" | "minecraft:warped_wart_block" | "water_bucket" | "minecraft:water_bucket" | "waxed_copper_block" | "minecraft:waxed_copper_block" | "waxed_cut_copper" | "minecraft:waxed_cut_copper" | "waxed_cut_copper_slab" | "minecraft:waxed_cut_copper_slab" | "waxed_cut_copper_stairs" | "minecraft:waxed_cut_copper_stairs" | "waxed_exposed_copper" | "minecraft:waxed_exposed_copper" | "waxed_exposed_cut_copper" | "minecraft:waxed_exposed_cut_copper" | "waxed_exposed_cut_copper_slab" | "minecraft:waxed_exposed_cut_copper_slab" | "waxed_exposed_cut_copper_stairs" | "minecraft:waxed_exposed_cut_copper_stairs" | "waxed_oxidized_copper" | "minecraft:waxed_oxidized_copper" | "waxed_oxidized_cut_copper" | "minecraft:waxed_oxidized_cut_copper" | "waxed_oxidized_cut_copper_slab" | "minecraft:waxed_oxidized_cut_copper_slab" | "waxed_oxidized_cut_copper_stairs" | "minecraft:waxed_oxidized_cut_copper_stairs" | "waxed_weathered_copper" | "minecraft:waxed_weathered_copper" | "waxed_weathered_cut_copper" | "minecraft:waxed_weathered_cut_copper" | "waxed_weathered_cut_copper_slab" | "minecraft:waxed_weathered_cut_copper_slab" | "waxed_weathered_cut_copper_stairs" | "minecraft:waxed_weathered_cut_copper_stairs" | "weathered_copper" | "minecraft:weathered_copper" | "weathered_cut_copper" | "minecraft:weathered_cut_copper" | "weathered_cut_copper_slab" | "minecraft:weathered_cut_copper_slab" | "weathered_cut_copper_stairs" | "minecraft:weathered_cut_copper_stairs" | "weeping_vines" | "minecraft:weeping_vines" | "wet_sponge" | "minecraft:wet_sponge" | "wheat" | "minecraft:wheat" | "wheat_seeds" | "minecraft:wheat_seeds" | "white_banner" | "minecraft:white_banner" | "white_bed" | "minecraft:white_bed" | "white_candle" | "minecraft:white_candle" | "white_carpet" | "minecraft:white_carpet" | "white_concrete" | "minecraft:white_concrete" | "white_concrete_powder" | "minecraft:white_concrete_powder" | "white_dye" | "minecraft:white_dye" | "white_glazed_terracotta" | "minecraft:white_glazed_terracotta" | "white_shulker_box" | "minecraft:white_shulker_box" | "white_stained_glass" | "minecraft:white_stained_glass" | "white_stained_glass_pane" | "minecraft:white_stained_glass_pane" | "white_terracotta" | "minecraft:white_terracotta" | "white_tulip" | "minecraft:white_tulip" | "white_wool" | "minecraft:white_wool" | "witch_spawn_egg" | "minecraft:witch_spawn_egg" | "wither_rose" | "minecraft:wither_rose" | "wither_skeleton_skull" | "minecraft:wither_skeleton_skull" | "wither_skeleton_spawn_egg" | "minecraft:wither_skeleton_spawn_egg" | "wolf_spawn_egg" | "minecraft:wolf_spawn_egg" | "wooden_axe" | "minecraft:wooden_axe" | "wooden_hoe" | "minecraft:wooden_hoe" | "wooden_pickaxe" | "minecraft:wooden_pickaxe" | "wooden_shovel" | "minecraft:wooden_shovel" | "wooden_sword" | "minecraft:wooden_sword" | "writable_book" | "minecraft:writable_book" | "written_book" | "minecraft:written_book" | "yellow_banner" | "minecraft:yellow_banner" | "yellow_bed" | "minecraft:yellow_bed" | "yellow_candle" | "minecraft:yellow_candle" | "yellow_carpet" | "minecraft:yellow_carpet" | "yellow_concrete" | "minecraft:yellow_concrete" | "yellow_concrete_powder" | "minecraft:yellow_concrete_powder" | "yellow_dye" | "minecraft:yellow_dye" | "yellow_glazed_terracotta" | "minecraft:yellow_glazed_terracotta" | "yellow_shulker_box" | "minecraft:yellow_shulker_box" | "yellow_stained_glass" | "minecraft:yellow_stained_glass" | "yellow_stained_glass_pane" | "minecraft:yellow_stained_glass_pane" | "yellow_terracotta" | "minecraft:yellow_terracotta" | "yellow_wool" | "minecraft:yellow_wool" | "zoglin_spawn_egg" | "minecraft:zoglin_spawn_egg" | "zombie_head" | "minecraft:zombie_head" | "zombie_horse_spawn_egg" | "minecraft:zombie_horse_spawn_egg" | "zombie_spawn_egg" | "minecraft:zombie_spawn_egg" | "zombie_villager_spawn_egg" | "minecraft:zombie_villager_spawn_egg" | "zombified_piglin_spawn_egg" | "minecraft:zombified_piglin_spawn_egg";
    type Potion = "awkward" | "minecraft:awkward" | "empty" | "minecraft:empty" | "fire_resistance" | "minecraft:fire_resistance" | "harming" | "minecraft:harming" | "healing" | "minecraft:healing" | "invisibility" | "minecraft:invisibility" | "leaping" | "minecraft:leaping" | "long_fire_resistance" | "minecraft:long_fire_resistance" | "long_invisibility" | "minecraft:long_invisibility" | "long_leaping" | "minecraft:long_leaping" | "long_night_vision" | "minecraft:long_night_vision" | "long_poison" | "minecraft:long_poison" | "long_regeneration" | "minecraft:long_regeneration" | "long_slow_falling" | "minecraft:long_slow_falling" | "long_slowness" | "minecraft:long_slowness" | "long_strength" | "minecraft:long_strength" | "long_swiftness" | "minecraft:long_swiftness" | "long_turtle_master" | "minecraft:long_turtle_master" | "long_water_breathing" | "minecraft:long_water_breathing" | "long_weakness" | "minecraft:long_weakness" | "luck" | "minecraft:luck" | "mundane" | "minecraft:mundane" | "night_vision" | "minecraft:night_vision" | "poison" | "minecraft:poison" | "regeneration" | "minecraft:regeneration" | "slow_falling" | "minecraft:slow_falling" | "slowness" | "minecraft:slowness" | "strength" | "minecraft:strength" | "strong_harming" | "minecraft:strong_harming" | "strong_healing" | "minecraft:strong_healing" | "strong_leaping" | "minecraft:strong_leaping" | "strong_poison" | "minecraft:strong_poison" | "strong_regeneration" | "minecraft:strong_regeneration" | "strong_slowness" | "minecraft:strong_slowness" | "strong_strength" | "minecraft:strong_strength" | "strong_swiftness" | "minecraft:strong_swiftness" | "strong_turtle_master" | "minecraft:strong_turtle_master" | "swiftness" | "minecraft:swiftness" | "thick" | "minecraft:thick" | "turtle_master" | "minecraft:turtle_master" | "water" | "minecraft:water" | "water_breathing" | "minecraft:water_breathing" | "weakness" | "minecraft:weakness";
    type ParticleType = "ambient_entity_effect" | "minecraft:ambient_entity_effect" | "angry_villager" | "minecraft:angry_villager" | "block" | "minecraft:block" | "block_marker" | "minecraft:block_marker" | "bubble" | "minecraft:bubble" | "cloud" | "minecraft:cloud" | "crit" | "minecraft:crit" | "damage_indicator" | "minecraft:damage_indicator" | "dragon_breath" | "minecraft:dragon_breath" | "dripping_lava" | "minecraft:dripping_lava" | "falling_lava" | "minecraft:falling_lava" | "landing_lava" | "minecraft:landing_lava" | "dripping_water" | "minecraft:dripping_water" | "falling_water" | "minecraft:falling_water" | "dust" | "minecraft:dust" | "dust_color_transition" | "minecraft:dust_color_transition" | "effect" | "minecraft:effect" | "elder_guardian" | "minecraft:elder_guardian" | "enchanted_hit" | "minecraft:enchanted_hit" | "enchant" | "minecraft:enchant" | "end_rod" | "minecraft:end_rod" | "entity_effect" | "minecraft:entity_effect" | "explosion_emitter" | "minecraft:explosion_emitter" | "explosion" | "minecraft:explosion" | "falling_dust" | "minecraft:falling_dust" | "firework" | "minecraft:firework" | "fishing" | "minecraft:fishing" | "flame" | "minecraft:flame" | "soul_fire_flame" | "minecraft:soul_fire_flame" | "soul" | "minecraft:soul" | "flash" | "minecraft:flash" | "happy_villager" | "minecraft:happy_villager" | "composter" | "minecraft:composter" | "heart" | "minecraft:heart" | "instant_effect" | "minecraft:instant_effect" | "item" | "minecraft:item" | "vibration" | "minecraft:vibration" | "item_slime" | "minecraft:item_slime" | "item_snowball" | "minecraft:item_snowball" | "large_smoke" | "minecraft:large_smoke" | "lava" | "minecraft:lava" | "mycelium" | "minecraft:mycelium" | "note" | "minecraft:note" | "poof" | "minecraft:poof" | "portal" | "minecraft:portal" | "rain" | "minecraft:rain" | "smoke" | "minecraft:smoke" | "sneeze" | "minecraft:sneeze" | "spit" | "minecraft:spit" | "squid_ink" | "minecraft:squid_ink" | "sweep_attack" | "minecraft:sweep_attack" | "totem_of_undying" | "minecraft:totem_of_undying" | "underwater" | "minecraft:underwater" | "splash" | "minecraft:splash" | "witch" | "minecraft:witch" | "bubble_pop" | "minecraft:bubble_pop" | "current_down" | "minecraft:current_down" | "bubble_column_up" | "minecraft:bubble_column_up" | "nautilus" | "minecraft:nautilus" | "dolphin" | "minecraft:dolphin" | "campfire_cosy_smoke" | "minecraft:campfire_cosy_smoke" | "campfire_signal_smoke" | "minecraft:campfire_signal_smoke" | "dripping_honey" | "minecraft:dripping_honey" | "falling_honey" | "minecraft:falling_honey" | "landing_honey" | "minecraft:landing_honey" | "falling_nectar" | "minecraft:falling_nectar" | "falling_spore_blossom" | "minecraft:falling_spore_blossom" | "ash" | "minecraft:ash" | "crimson_spore" | "minecraft:crimson_spore" | "warped_spore" | "minecraft:warped_spore" | "spore_blossom_air" | "minecraft:spore_blossom_air" | "dripping_obsidian_tear" | "minecraft:dripping_obsidian_tear" | "falling_obsidian_tear" | "minecraft:falling_obsidian_tear" | "landing_obsidian_tear" | "minecraft:landing_obsidian_tear" | "reverse_portal" | "minecraft:reverse_portal" | "white_ash" | "minecraft:white_ash" | "small_flame" | "minecraft:small_flame" | "snowflake" | "minecraft:snowflake" | "dripping_dripstone_lava" | "minecraft:dripping_dripstone_lava" | "falling_dripstone_lava" | "minecraft:falling_dripstone_lava" | "dripping_dripstone_water" | "minecraft:dripping_dripstone_water" | "falling_dripstone_water" | "minecraft:falling_dripstone_water" | "glow_squid_ink" | "minecraft:glow_squid_ink" | "glow" | "minecraft:glow" | "wax_on" | "minecraft:wax_on" | "wax_off" | "minecraft:wax_off" | "electric_spark" | "minecraft:electric_spark" | "scrape" | "minecraft:scrape";
    type BlockEntityType = "furnace" | "minecraft:furnace" | "chest" | "minecraft:chest" | "trapped_chest" | "minecraft:trapped_chest" | "ender_chest" | "minecraft:ender_chest" | "jukebox" | "minecraft:jukebox" | "dispenser" | "minecraft:dispenser" | "dropper" | "minecraft:dropper" | "sign" | "minecraft:sign" | "mob_spawner" | "minecraft:mob_spawner" | "piston" | "minecraft:piston" | "brewing_stand" | "minecraft:brewing_stand" | "enchanting_table" | "minecraft:enchanting_table" | "end_portal" | "minecraft:end_portal" | "beacon" | "minecraft:beacon" | "skull" | "minecraft:skull" | "daylight_detector" | "minecraft:daylight_detector" | "hopper" | "minecraft:hopper" | "comparator" | "minecraft:comparator" | "banner" | "minecraft:banner" | "structure_block" | "minecraft:structure_block" | "end_gateway" | "minecraft:end_gateway" | "command_block" | "minecraft:command_block" | "shulker_box" | "minecraft:shulker_box" | "bed" | "minecraft:bed" | "conduit" | "minecraft:conduit" | "barrel" | "minecraft:barrel" | "smoker" | "minecraft:smoker" | "blast_furnace" | "minecraft:blast_furnace" | "lectern" | "minecraft:lectern" | "bell" | "minecraft:bell" | "jigsaw" | "minecraft:jigsaw" | "campfire" | "minecraft:campfire" | "beehive" | "minecraft:beehive" | "sculk_sensor" | "minecraft:sculk_sensor";
    type Motive = "alban" | "minecraft:alban" | "aztec" | "minecraft:aztec" | "aztec2" | "minecraft:aztec2" | "bomb" | "minecraft:bomb" | "burning_skull" | "minecraft:burning_skull" | "bust" | "minecraft:bust" | "courbet" | "minecraft:courbet" | "creebet" | "minecraft:creebet" | "donkey_kong" | "minecraft:donkey_kong" | "fighters" | "minecraft:fighters" | "graham" | "minecraft:graham" | "kebab" | "minecraft:kebab" | "match" | "minecraft:match" | "pigscene" | "minecraft:pigscene" | "plant" | "minecraft:plant" | "pointer" | "minecraft:pointer" | "pool" | "minecraft:pool" | "sea" | "minecraft:sea" | "skeleton" | "minecraft:skeleton" | "skull_and_roses" | "minecraft:skull_and_roses" | "stage" | "minecraft:stage" | "sunset" | "minecraft:sunset" | "void" | "minecraft:void" | "wanderer" | "minecraft:wanderer" | "wasteland" | "minecraft:wasteland" | "wither" | "minecraft:wither";
    type ResourceLocation = "play_time" | "minecraft:play_time" | "fish_caught" | "minecraft:fish_caught" | "walk_one_cm" | "minecraft:walk_one_cm" | "damage_dealt_resisted" | "minecraft:damage_dealt_resisted" | "clean_banner" | "minecraft:clean_banner" | "clean_shulker_box" | "minecraft:clean_shulker_box" | "interact_with_loom" | "minecraft:interact_with_loom" | "interact_with_campfire" | "minecraft:interact_with_campfire" | "target_hit" | "minecraft:target_hit" | "inspect_hopper" | "minecraft:inspect_hopper" | "open_shulker_box" | "minecraft:open_shulker_box" | "pig_one_cm" | "minecraft:pig_one_cm" | "play_noteblock" | "minecraft:play_noteblock" | "tune_noteblock" | "minecraft:tune_noteblock" | "trigger_trapped_chest" | "minecraft:trigger_trapped_chest" | "clean_armor" | "minecraft:clean_armor" | "aviate_one_cm" | "minecraft:aviate_one_cm" | "interact_with_smoker" | "minecraft:interact_with_smoker" | "interact_with_smithing_table" | "minecraft:interact_with_smithing_table" | "crouch_one_cm" | "minecraft:crouch_one_cm" | "open_chest" | "minecraft:open_chest" | "jump" | "minecraft:jump" | "mob_kills" | "minecraft:mob_kills" | "fall_one_cm" | "minecraft:fall_one_cm" | "interact_with_furnace" | "minecraft:interact_with_furnace" | "raid_trigger" | "minecraft:raid_trigger" | "interact_with_brewingstand" | "minecraft:interact_with_brewingstand" | "climb_one_cm" | "minecraft:climb_one_cm" | "talked_to_villager" | "minecraft:talked_to_villager" | "sleep_in_bed" | "minecraft:sleep_in_bed" | "damage_resisted" | "minecraft:damage_resisted" | "interact_with_cartography_table" | "minecraft:interact_with_cartography_table" | "pot_flower" | "minecraft:pot_flower" | "raid_win" | "minecraft:raid_win" | "interact_with_anvil" | "minecraft:interact_with_anvil" | "interact_with_crafting_table" | "minecraft:interact_with_crafting_table" | "use_cauldron" | "minecraft:use_cauldron" | "inspect_dropper" | "minecraft:inspect_dropper" | "open_barrel" | "minecraft:open_barrel" | "interact_with_lectern" | "minecraft:interact_with_lectern" | "damage_absorbed" | "minecraft:damage_absorbed" | "deaths" | "minecraft:deaths" | "damage_taken" | "minecraft:damage_taken" | "play_record" | "minecraft:play_record" | "eat_cake_slice" | "minecraft:eat_cake_slice" | "interact_with_beacon" | "minecraft:interact_with_beacon" | "fill_cauldron" | "minecraft:fill_cauldron" | "time_since_rest" | "minecraft:time_since_rest" | "walk_under_water_one_cm" | "minecraft:walk_under_water_one_cm" | "enchant_item" | "minecraft:enchant_item" | "inspect_dispenser" | "minecraft:inspect_dispenser" | "minecart_one_cm" | "minecraft:minecart_one_cm" | "strider_one_cm" | "minecraft:strider_one_cm" | "player_kills" | "minecraft:player_kills" | "swim_one_cm" | "minecraft:swim_one_cm" | "damage_blocked_by_shield" | "minecraft:damage_blocked_by_shield" | "sneak_time" | "minecraft:sneak_time" | "fly_one_cm" | "minecraft:fly_one_cm" | "walk_on_water_one_cm" | "minecraft:walk_on_water_one_cm" | "time_since_death" | "minecraft:time_since_death" | "drop" | "minecraft:drop" | "interact_with_grindstone" | "minecraft:interact_with_grindstone" | "total_world_time" | "minecraft:total_world_time" | "damage_dealt" | "minecraft:damage_dealt" | "interact_with_stonecutter" | "minecraft:interact_with_stonecutter" | "bell_ring" | "minecraft:bell_ring" | "animals_bred" | "minecraft:animals_bred" | "interact_with_blast_furnace" | "minecraft:interact_with_blast_furnace" | "leave_game" | "minecraft:leave_game" | "traded_with_villager" | "minecraft:traded_with_villager" | "damage_dealt_absorbed" | "minecraft:damage_dealt_absorbed" | "boat_one_cm" | "minecraft:boat_one_cm" | "sprint_one_cm" | "minecraft:sprint_one_cm" | "open_enderchest" | "minecraft:open_enderchest" | "horse_one_cm" | "minecraft:horse_one_cm";
    type ChunkStatus = "empty" | "minecraft:empty" | "structure_starts" | "minecraft:structure_starts" | "structure_references" | "minecraft:structure_references" | "biomes" | "minecraft:biomes" | "noise" | "minecraft:noise" | "surface" | "minecraft:surface" | "carvers" | "minecraft:carvers" | "liquid_carvers" | "minecraft:liquid_carvers" | "features" | "minecraft:features" | "light" | "minecraft:light" | "spawn" | "minecraft:spawn" | "heightmaps" | "minecraft:heightmaps" | "full" | "minecraft:full";
    type RuleTestType = "tag_match" | "minecraft:tag_match" | "blockstate_match" | "minecraft:blockstate_match" | "always_true" | "minecraft:always_true" | "block_match" | "minecraft:block_match" | "kubejs:invert" | "kubejs:always_false" | "random_blockstate_match" | "minecraft:random_blockstate_match" | "random_block_match" | "minecraft:random_block_match" | "kubejs:any_match" | "kubejs:all_match";
    type PosRuleTestType = "linear_pos" | "minecraft:linear_pos" | "axis_aligned_linear_pos" | "minecraft:axis_aligned_linear_pos" | "always_true" | "minecraft:always_true";
    type MenuType = "generic_9x1" | "minecraft:generic_9x1" | "generic_9x2" | "minecraft:generic_9x2" | "generic_9x3" | "minecraft:generic_9x3" | "generic_9x4" | "minecraft:generic_9x4" | "generic_9x5" | "minecraft:generic_9x5" | "generic_9x6" | "minecraft:generic_9x6" | "generic_3x3" | "minecraft:generic_3x3" | "anvil" | "minecraft:anvil" | "beacon" | "minecraft:beacon" | "blast_furnace" | "minecraft:blast_furnace" | "brewing_stand" | "minecraft:brewing_stand" | "crafting" | "minecraft:crafting" | "enchantment" | "minecraft:enchantment" | "furnace" | "minecraft:furnace" | "grindstone" | "minecraft:grindstone" | "hopper" | "minecraft:hopper" | "lectern" | "minecraft:lectern" | "loom" | "minecraft:loom" | "merchant" | "minecraft:merchant" | "shulker_box" | "minecraft:shulker_box" | "smithing" | "minecraft:smithing" | "smoker" | "minecraft:smoker" | "cartography_table" | "minecraft:cartography_table" | "stonecutter" | "minecraft:stonecutter";
    type RecipeType$1 = "crafting" | "minecraft:crafting" | "stonecutting" | "minecraft:stonecutting" | "smelting" | "minecraft:smelting" | "smoking" | "minecraft:smoking" | "blasting" | "minecraft:blasting" | "campfire_cooking" | "minecraft:campfire_cooking" | "smithing" | "minecraft:smithing";
    type RecipeSerializer = "crafting_shaped" | "minecraft:crafting_shaped" | "crafting_shapeless" | "minecraft:crafting_shapeless" | "crafting_special_armordye" | "minecraft:crafting_special_armordye" | "crafting_special_bookcloning" | "minecraft:crafting_special_bookcloning" | "crafting_special_mapcloning" | "minecraft:crafting_special_mapcloning" | "crafting_special_mapextending" | "minecraft:crafting_special_mapextending" | "crafting_special_firework_rocket" | "minecraft:crafting_special_firework_rocket" | "crafting_special_firework_star" | "minecraft:crafting_special_firework_star" | "crafting_special_firework_star_fade" | "minecraft:crafting_special_firework_star_fade" | "crafting_special_tippedarrow" | "minecraft:crafting_special_tippedarrow" | "crafting_special_bannerduplicate" | "minecraft:crafting_special_bannerduplicate" | "crafting_special_shielddecoration" | "minecraft:crafting_special_shielddecoration" | "crafting_special_shulkerboxcoloring" | "minecraft:crafting_special_shulkerboxcoloring" | "crafting_special_suspiciousstew" | "minecraft:crafting_special_suspiciousstew" | "crafting_special_repairitem" | "minecraft:crafting_special_repairitem" | "smelting" | "minecraft:smelting" | "blasting" | "minecraft:blasting" | "smoking" | "minecraft:smoking" | "campfire_cooking" | "minecraft:campfire_cooking" | "stonecutting" | "minecraft:stonecutting" | "smithing" | "minecraft:smithing" | "forge:conditional" | "kubejs:shaped" | "kubejs:shapeless";
    type RangedAttribute = "generic.max_health" | "minecraft:generic.max_health" | "generic.follow_range" | "minecraft:generic.follow_range" | "generic.knockback_resistance" | "minecraft:generic.knockback_resistance" | "generic.movement_speed" | "minecraft:generic.movement_speed" | "generic.flying_speed" | "minecraft:generic.flying_speed" | "generic.attack_damage" | "minecraft:generic.attack_damage" | "generic.attack_knockback" | "minecraft:generic.attack_knockback" | "generic.attack_speed" | "minecraft:generic.attack_speed" | "generic.armor" | "minecraft:generic.armor" | "generic.armor_toughness" | "minecraft:generic.armor_toughness" | "generic.luck" | "minecraft:generic.luck" | "zombie.spawn_reinforcements" | "minecraft:zombie.spawn_reinforcements" | "horse.jump_strength" | "minecraft:horse.jump_strength" | "forge:swim_speed" | "forge:nametag_distance" | "forge:entity_gravity" | "forge:reach_distance" | "forge:attack_range" | "forge:step_height_addition";
    type PositionSourceType = "block" | "minecraft:block" | "entity" | "minecraft:entity";
    type StatType = "broken" | "minecraft:broken" | "crafted" | "minecraft:crafted" | "custom" | "minecraft:custom" | "dropped" | "minecraft:dropped" | "killed" | "minecraft:killed" | "killed_by" | "minecraft:killed_by" | "mined" | "minecraft:mined" | "picked_up" | "minecraft:picked_up" | "used" | "minecraft:used";
    type VillagerType = "snow" | "minecraft:snow" | "desert" | "minecraft:desert" | "plains" | "minecraft:plains" | "jungle" | "minecraft:jungle" | "taiga" | "minecraft:taiga" | "savanna" | "minecraft:savanna" | "swamp" | "minecraft:swamp";
    type VillagerProfession = "armorer" | "minecraft:armorer" | "butcher" | "minecraft:butcher" | "cartographer" | "minecraft:cartographer" | "cleric" | "minecraft:cleric" | "farmer" | "minecraft:farmer" | "fisherman" | "minecraft:fisherman" | "fletcher" | "minecraft:fletcher" | "leatherworker" | "minecraft:leatherworker" | "librarian" | "minecraft:librarian" | "mason" | "minecraft:mason" | "nitwit" | "minecraft:nitwit" | "none" | "minecraft:none" | "shepherd" | "minecraft:shepherd" | "toolsmith" | "minecraft:toolsmith" | "weaponsmith" | "minecraft:weaponsmith";
    type PoiType = "armorer" | "minecraft:armorer" | "bee_nest" | "minecraft:bee_nest" | "beehive" | "minecraft:beehive" | "butcher" | "minecraft:butcher" | "cartographer" | "minecraft:cartographer" | "cleric" | "minecraft:cleric" | "farmer" | "minecraft:farmer" | "fisherman" | "minecraft:fisherman" | "fletcher" | "minecraft:fletcher" | "home" | "minecraft:home" | "leatherworker" | "minecraft:leatherworker" | "librarian" | "minecraft:librarian" | "lightning_rod" | "minecraft:lightning_rod" | "lodestone" | "minecraft:lodestone" | "mason" | "minecraft:mason" | "meeting" | "minecraft:meeting" | "nether_portal" | "minecraft:nether_portal" | "nitwit" | "minecraft:nitwit" | "shepherd" | "minecraft:shepherd" | "toolsmith" | "minecraft:toolsmith" | "unemployed" | "minecraft:unemployed" | "weaponsmith" | "minecraft:weaponsmith";
    type MemoryModuleType = "admiring_disabled" | "minecraft:admiring_disabled" | "admiring_item" | "minecraft:admiring_item" | "angry_at" | "minecraft:angry_at" | "ate_recently" | "minecraft:ate_recently" | "attack_cooling_down" | "minecraft:attack_cooling_down" | "attack_target" | "minecraft:attack_target" | "avoid_target" | "minecraft:avoid_target" | "breed_target" | "minecraft:breed_target" | "cant_reach_walk_target_since" | "minecraft:cant_reach_walk_target_since" | "celebrate_location" | "minecraft:celebrate_location" | "dancing" | "minecraft:dancing" | "disable_walk_to_admire_item" | "minecraft:disable_walk_to_admire_item" | "doors_to_close" | "minecraft:doors_to_close" | "dummy" | "minecraft:dummy" | "golem_detected_recently" | "minecraft:golem_detected_recently" | "has_hunting_cooldown" | "minecraft:has_hunting_cooldown" | "heard_bell_time" | "minecraft:heard_bell_time" | "hiding_place" | "minecraft:hiding_place" | "home" | "minecraft:home" | "hunted_recently" | "minecraft:hunted_recently" | "hurt_by" | "minecraft:hurt_by" | "hurt_by_entity" | "minecraft:hurt_by_entity" | "interactable_doors" | "minecraft:interactable_doors" | "interaction_target" | "minecraft:interaction_target" | "is_tempted" | "minecraft:is_tempted" | "job_site" | "minecraft:job_site" | "last_slept" | "minecraft:last_slept" | "last_woken" | "minecraft:last_woken" | "last_worked_at_poi" | "minecraft:last_worked_at_poi" | "long_jump_cooling_down" | "minecraft:long_jump_cooling_down" | "long_jump_mid_jump" | "minecraft:long_jump_mid_jump" | "look_target" | "minecraft:look_target" | "meeting_point" | "minecraft:meeting_point" | "mobs" | "minecraft:mobs" | "nearby_adult_piglins" | "minecraft:nearby_adult_piglins" | "nearest_attackable" | "minecraft:nearest_attackable" | "nearest_bed" | "minecraft:nearest_bed" | "nearest_hostile" | "minecraft:nearest_hostile" | "nearest_player_holding_wanted_item" | "minecraft:nearest_player_holding_wanted_item" | "nearest_players" | "minecraft:nearest_players" | "nearest_repellent" | "minecraft:nearest_repellent" | "nearest_targetable_player_not_wearing_gold" | "minecraft:nearest_targetable_player_not_wearing_gold" | "nearest_visible_adult" | "minecraft:nearest_visible_adult" | "nearest_visible_adult_hoglins" | "minecraft:nearest_visible_adult_hoglins" | "nearest_visible_adult_piglin" | "minecraft:nearest_visible_adult_piglin" | "nearest_visible_adult_piglins" | "minecraft:nearest_visible_adult_piglins" | "nearest_visible_baby_hoglin" | "minecraft:nearest_visible_baby_hoglin" | "nearest_visible_huntable_hoglin" | "minecraft:nearest_visible_huntable_hoglin" | "nearest_visible_nemesis" | "minecraft:nearest_visible_nemesis" | "nearest_visible_player" | "minecraft:nearest_visible_player" | "nearest_visible_targetable_player" | "minecraft:nearest_visible_targetable_player" | "nearest_visible_wanted_item" | "minecraft:nearest_visible_wanted_item" | "nearest_visible_zombified" | "minecraft:nearest_visible_zombified" | "pacified" | "minecraft:pacified" | "path" | "minecraft:path" | "play_dead_ticks" | "minecraft:play_dead_ticks" | "potential_job_site" | "minecraft:potential_job_site" | "ram_cooldown_ticks" | "minecraft:ram_cooldown_ticks" | "ram_target" | "minecraft:ram_target" | "ride_target" | "minecraft:ride_target" | "secondary_job_site" | "minecraft:secondary_job_site" | "temptation_cooldown_ticks" | "minecraft:temptation_cooldown_ticks" | "tempting_player" | "minecraft:tempting_player" | "time_trying_to_reach_admire_item" | "minecraft:time_trying_to_reach_admire_item" | "universal_anger" | "minecraft:universal_anger" | "visible_adult_hoglin_count" | "minecraft:visible_adult_hoglin_count" | "visible_adult_piglin_count" | "minecraft:visible_adult_piglin_count" | "visible_mobs" | "minecraft:visible_mobs" | "visible_villager_babies" | "minecraft:visible_villager_babies" | "walk_target" | "minecraft:walk_target";
    type SensorType = "dummy" | "minecraft:dummy" | "nearest_items" | "minecraft:nearest_items" | "nearest_living_entities" | "minecraft:nearest_living_entities" | "nearest_players" | "minecraft:nearest_players" | "nearest_bed" | "minecraft:nearest_bed" | "hurt_by" | "minecraft:hurt_by" | "villager_hostiles" | "minecraft:villager_hostiles" | "villager_babies" | "minecraft:villager_babies" | "secondary_pois" | "minecraft:secondary_pois" | "golem_detected" | "minecraft:golem_detected" | "piglin_specific_sensor" | "minecraft:piglin_specific_sensor" | "piglin_brute_specific_sensor" | "minecraft:piglin_brute_specific_sensor" | "hoglin_specific_sensor" | "minecraft:hoglin_specific_sensor" | "nearest_adult" | "minecraft:nearest_adult" | "axolotl_attackables" | "minecraft:axolotl_attackables" | "axolotl_temptations" | "minecraft:axolotl_temptations" | "goat_temptations" | "minecraft:goat_temptations";
    type Schedule = "empty" | "minecraft:empty" | "simple" | "minecraft:simple" | "villager_baby" | "minecraft:villager_baby" | "villager_default" | "minecraft:villager_default";
    type Activity = "core" | "minecraft:core" | "idle" | "minecraft:idle" | "work" | "minecraft:work" | "play" | "minecraft:play" | "rest" | "minecraft:rest" | "meet" | "minecraft:meet" | "panic" | "minecraft:panic" | "raid" | "minecraft:raid" | "pre_raid" | "minecraft:pre_raid" | "hide" | "minecraft:hide" | "fight" | "minecraft:fight" | "celebrate" | "minecraft:celebrate" | "admire_item" | "minecraft:admire_item" | "avoid" | "minecraft:avoid" | "ride" | "minecraft:ride" | "play_dead" | "minecraft:play_dead" | "long_jump" | "minecraft:long_jump" | "ram" | "minecraft:ram";
    type LootPoolEntryType = "group" | "minecraft:group" | "loot_table" | "minecraft:loot_table" | "empty" | "minecraft:empty" | "item" | "minecraft:item" | "dynamic" | "minecraft:dynamic" | "sequence" | "minecraft:sequence" | "alternatives" | "minecraft:alternatives" | "tag" | "minecraft:tag";
    type LootItemFunctionType = "set_stew_effect" | "minecraft:set_stew_effect" | "enchant_with_levels" | "minecraft:enchant_with_levels" | "copy_name" | "minecraft:copy_name" | "furnace_smelt" | "minecraft:furnace_smelt" | "copy_nbt" | "minecraft:copy_nbt" | "set_attributes" | "minecraft:set_attributes" | "set_banner_pattern" | "minecraft:set_banner_pattern" | "set_damage" | "minecraft:set_damage" | "set_lore" | "minecraft:set_lore" | "set_loot_table" | "minecraft:set_loot_table" | "set_nbt" | "minecraft:set_nbt" | "apply_bonus" | "minecraft:apply_bonus" | "explosion_decay" | "minecraft:explosion_decay" | "fill_player_head" | "minecraft:fill_player_head" | "set_name" | "minecraft:set_name" | "exploration_map" | "minecraft:exploration_map" | "set_count" | "minecraft:set_count" | "looting_enchant" | "minecraft:looting_enchant" | "copy_state" | "minecraft:copy_state" | "enchant_randomly" | "minecraft:enchant_randomly" | "set_enchantments" | "minecraft:set_enchantments" | "set_potion" | "minecraft:set_potion" | "set_contents" | "minecraft:set_contents" | "limit_count" | "minecraft:limit_count";
    type LootItemConditionType = "value_check" | "minecraft:value_check" | "random_chance" | "minecraft:random_chance" | "killed_by_player" | "minecraft:killed_by_player" | "survives_explosion" | "minecraft:survives_explosion" | "table_bonus" | "minecraft:table_bonus" | "location_check" | "minecraft:location_check" | "damage_source_properties" | "minecraft:damage_source_properties" | "random_chance_with_looting" | "minecraft:random_chance_with_looting" | "entity_properties" | "minecraft:entity_properties" | "entity_scores" | "minecraft:entity_scores" | "inverted" | "minecraft:inverted" | "block_state_property" | "minecraft:block_state_property" | "reference" | "minecraft:reference" | "alternative" | "minecraft:alternative" | "time_check" | "minecraft:time_check" | "weather_check" | "minecraft:weather_check" | "forge:loot_table_id" | "match_tool" | "minecraft:match_tool" | "forge:can_tool_perform_action";
    type LootNumberProviderType = "uniform" | "minecraft:uniform" | "score" | "minecraft:score" | "binomial" | "minecraft:binomial" | "constant" | "minecraft:constant";
    type LootNbtProviderType = "context" | "minecraft:context" | "storage" | "minecraft:storage";
    type LootScoreProviderType = "fixed" | "minecraft:fixed" | "context" | "minecraft:context";
    type FloatProviderType = "uniform" | "minecraft:uniform" | "clamped_normal" | "minecraft:clamped_normal" | "trapezoid" | "minecraft:trapezoid" | "constant" | "minecraft:constant";
    type IntProviderType = "uniform" | "minecraft:uniform" | "biased_to_bottom" | "minecraft:biased_to_bottom" | "clamped" | "minecraft:clamped" | "clamped_normal" | "minecraft:clamped_normal" | "constant" | "minecraft:constant" | "weighted_list" | "minecraft:weighted_list";
    type HeightProviderType = "uniform" | "minecraft:uniform" | "biased_to_bottom" | "minecraft:biased_to_bottom" | "very_biased_to_bottom" | "minecraft:very_biased_to_bottom" | "trapezoid" | "minecraft:trapezoid" | "constant" | "minecraft:constant" | "weighted_list" | "minecraft:weighted_list";
    type BlockPredicateType = "any_of" | "minecraft:any_of" | "all_of" | "minecraft:all_of" | "not" | "minecraft:not" | "matching_fluids" | "minecraft:matching_fluids" | "would_survive" | "minecraft:would_survive" | "inside_world_bounds" | "minecraft:inside_world_bounds" | "true" | "minecraft:true" | "solid" | "minecraft:solid" | "matching_blocks" | "minecraft:matching_blocks" | "replaceable" | "minecraft:replaceable" | "matching_block_tag" | "minecraft:matching_block_tag" | "has_sturdy_face" | "minecraft:has_sturdy_face";
    type WorldCarver = "cave" | "minecraft:cave" | "nether_cave" | "minecraft:nether_cave" | "canyon" | "minecraft:canyon";
    type Feature = "no_op" | "minecraft:no_op" | "tree" | "minecraft:tree" | "flower" | "minecraft:flower" | "no_bonemeal_flower" | "minecraft:no_bonemeal_flower" | "random_patch" | "minecraft:random_patch" | "block_pile" | "minecraft:block_pile" | "spring_feature" | "minecraft:spring_feature" | "chorus_plant" | "minecraft:chorus_plant" | "replace_single_block" | "minecraft:replace_single_block" | "void_start_platform" | "minecraft:void_start_platform" | "desert_well" | "minecraft:desert_well" | "fossil" | "minecraft:fossil" | "huge_red_mushroom" | "minecraft:huge_red_mushroom" | "huge_brown_mushroom" | "minecraft:huge_brown_mushroom" | "ice_spike" | "minecraft:ice_spike" | "glowstone_blob" | "minecraft:glowstone_blob" | "freeze_top_layer" | "minecraft:freeze_top_layer" | "vines" | "minecraft:vines" | "block_column" | "minecraft:block_column" | "vegetation_patch" | "minecraft:vegetation_patch" | "waterlogged_vegetation_patch" | "minecraft:waterlogged_vegetation_patch" | "root_system" | "minecraft:root_system" | "glow_lichen" | "minecraft:glow_lichen" | "underwater_magma" | "minecraft:underwater_magma" | "monster_room" | "minecraft:monster_room" | "blue_ice" | "minecraft:blue_ice" | "iceberg" | "minecraft:iceberg" | "forest_rock" | "minecraft:forest_rock" | "disk" | "minecraft:disk" | "ice_patch" | "minecraft:ice_patch" | "lake" | "minecraft:lake" | "ore" | "minecraft:ore" | "end_spike" | "minecraft:end_spike" | "end_island" | "minecraft:end_island" | "end_gateway" | "minecraft:end_gateway" | "seagrass" | "minecraft:seagrass" | "kelp" | "minecraft:kelp" | "coral_tree" | "minecraft:coral_tree" | "coral_mushroom" | "minecraft:coral_mushroom" | "coral_claw" | "minecraft:coral_claw" | "sea_pickle" | "minecraft:sea_pickle" | "simple_block" | "minecraft:simple_block" | "bamboo" | "minecraft:bamboo" | "huge_fungus" | "minecraft:huge_fungus" | "nether_forest_vegetation" | "minecraft:nether_forest_vegetation" | "weeping_vines" | "minecraft:weeping_vines" | "twisting_vines" | "minecraft:twisting_vines" | "basalt_columns" | "minecraft:basalt_columns" | "delta_feature" | "minecraft:delta_feature" | "netherrack_replace_blobs" | "minecraft:netherrack_replace_blobs" | "fill_layer" | "minecraft:fill_layer" | "bonus_chest" | "minecraft:bonus_chest" | "basalt_pillar" | "minecraft:basalt_pillar" | "scattered_ore" | "minecraft:scattered_ore" | "random_selector" | "minecraft:random_selector" | "simple_random_selector" | "minecraft:simple_random_selector" | "random_boolean_selector" | "minecraft:random_boolean_selector" | "geode" | "minecraft:geode" | "dripstone_cluster" | "minecraft:dripstone_cluster" | "large_dripstone" | "minecraft:large_dripstone" | "pointed_dripstone" | "minecraft:pointed_dripstone";
    type StructureFeature = "pillager_outpost" | "minecraft:pillager_outpost" | "mineshaft" | "minecraft:mineshaft" | "mansion" | "minecraft:mansion" | "jungle_pyramid" | "minecraft:jungle_pyramid" | "desert_pyramid" | "minecraft:desert_pyramid" | "igloo" | "minecraft:igloo" | "ruined_portal" | "minecraft:ruined_portal" | "shipwreck" | "minecraft:shipwreck" | "swamp_hut" | "minecraft:swamp_hut" | "stronghold" | "minecraft:stronghold" | "monument" | "minecraft:monument" | "ocean_ruin" | "minecraft:ocean_ruin" | "fortress" | "minecraft:fortress" | "endcity" | "minecraft:endcity" | "buried_treasure" | "minecraft:buried_treasure" | "village" | "minecraft:village" | "nether_fossil" | "minecraft:nether_fossil" | "bastion_remnant" | "minecraft:bastion_remnant";
    type StructurePlacementType = "concentric_rings" | "minecraft:concentric_rings" | "random_spread" | "minecraft:random_spread";
    type StructurePieceType = "nescsc" | "minecraft:nescsc" | "shli" | "minecraft:shli" | "btp" | "minecraft:btp" | "shph" | "minecraft:shph" | "msstairs" | "minecraft:msstairs" | "shpr" | "minecraft:shpr" | "ompenthouse" | "minecraft:ompenthouse" | "omdxr" | "minecraft:omdxr" | "omdxyr" | "minecraft:omdxyr" | "nemt" | "minecraft:nemt" | "shlt" | "minecraft:shlt" | "iglu" | "minecraft:iglu" | "wmp" | "minecraft:wmp" | "nerc" | "minecraft:nerc" | "nebcr" | "minecraft:nebcr" | "nefos" | "minecraft:nefos" | "omwr" | "minecraft:omwr" | "msroom" | "minecraft:msroom" | "omentry" | "minecraft:omentry" | "omsimple" | "minecraft:omsimple" | "orp" | "minecraft:orp" | "omdyzr" | "minecraft:omdyzr" | "tedp" | "minecraft:tedp" | "nesc" | "minecraft:nesc" | "shrc" | "minecraft:shrc" | "mscorridor" | "minecraft:mscorridor" | "nebs" | "minecraft:nebs" | "shfc" | "minecraft:shfc" | "omcr" | "minecraft:omcr" | "nece" | "minecraft:nece" | "nesclt" | "minecraft:nesclt" | "nesr" | "minecraft:nesr" | "shrt" | "minecraft:shrt" | "necsr" | "minecraft:necsr" | "nebef" | "minecraft:nebef" | "sh5c" | "minecraft:sh5c" | "omdzr" | "minecraft:omdzr" | "shipwreck" | "minecraft:shipwreck" | "shssd" | "minecraft:shssd" | "ecp" | "minecraft:ecp" | "mscrossing" | "minecraft:mscrossing" | "nestart" | "minecraft:nestart" | "shsd" | "minecraft:shsd" | "shstart" | "minecraft:shstart" | "neccs" | "minecraft:neccs" | "nectb" | "minecraft:nectb" | "shs" | "minecraft:shs" | "omb" | "minecraft:omb" | "tejp" | "minecraft:tejp" | "shcc" | "minecraft:shcc" | "omdyr" | "minecraft:omdyr" | "rupo" | "minecraft:rupo" | "nescrt" | "minecraft:nescrt" | "omsimplet" | "minecraft:omsimplet" | "tesh" | "minecraft:tesh" | "jigsaw" | "minecraft:jigsaw";
    type PlacementModifierType = "block_predicate_filter" | "minecraft:block_predicate_filter" | "random_offset" | "minecraft:random_offset" | "noise_based_count" | "minecraft:noise_based_count" | "height_range" | "minecraft:height_range" | "rarity_filter" | "minecraft:rarity_filter" | "noise_threshold_count" | "minecraft:noise_threshold_count" | "environment_scan" | "minecraft:environment_scan" | "in_square" | "minecraft:in_square" | "surface_water_depth_filter" | "minecraft:surface_water_depth_filter" | "surface_relative_threshold_filter" | "minecraft:surface_relative_threshold_filter" | "count_on_every_layer" | "minecraft:count_on_every_layer" | "biome" | "minecraft:biome" | "count" | "minecraft:count" | "carving_mask" | "minecraft:carving_mask" | "heightmap" | "minecraft:heightmap";
    type BlockStateProviderType = "simple_state_provider" | "minecraft:simple_state_provider" | "weighted_state_provider" | "minecraft:weighted_state_provider" | "noise_threshold_provider" | "minecraft:noise_threshold_provider" | "noise_provider" | "minecraft:noise_provider" | "dual_noise_provider" | "minecraft:dual_noise_provider" | "rotated_block_provider" | "minecraft:rotated_block_provider" | "randomized_int_state_provider" | "minecraft:randomized_int_state_provider";
    type FoliagePlacerType = "blob_foliage_placer" | "minecraft:blob_foliage_placer" | "spruce_foliage_placer" | "minecraft:spruce_foliage_placer" | "pine_foliage_placer" | "minecraft:pine_foliage_placer" | "acacia_foliage_placer" | "minecraft:acacia_foliage_placer" | "bush_foliage_placer" | "minecraft:bush_foliage_placer" | "fancy_foliage_placer" | "minecraft:fancy_foliage_placer" | "jungle_foliage_placer" | "minecraft:jungle_foliage_placer" | "mega_pine_foliage_placer" | "minecraft:mega_pine_foliage_placer" | "dark_oak_foliage_placer" | "minecraft:dark_oak_foliage_placer" | "random_spread_foliage_placer" | "minecraft:random_spread_foliage_placer";
    type TrunkPlacerType = "straight_trunk_placer" | "minecraft:straight_trunk_placer" | "giant_trunk_placer" | "minecraft:giant_trunk_placer" | "bending_trunk_placer" | "minecraft:bending_trunk_placer" | "fancy_trunk_placer" | "minecraft:fancy_trunk_placer" | "forking_trunk_placer" | "minecraft:forking_trunk_placer" | "dark_oak_trunk_placer" | "minecraft:dark_oak_trunk_placer" | "mega_jungle_trunk_placer" | "minecraft:mega_jungle_trunk_placer";
    type TreeDecoratorType = "trunk_vine" | "minecraft:trunk_vine" | "leave_vine" | "minecraft:leave_vine" | "cocoa" | "minecraft:cocoa" | "beehive" | "minecraft:beehive" | "alter_ground" | "minecraft:alter_ground";
    type FeatureSizeType = "three_layers_feature_size" | "minecraft:three_layers_feature_size" | "two_layers_feature_size" | "minecraft:two_layers_feature_size";
    type MapCodec$MapCodecCodec = "multi_noise" | "minecraft:multi_noise" | "checkerboard" | "minecraft:checkerboard" | "fixed" | "minecraft:fixed" | "the_end" | "minecraft:the_end";
    type MapCodec$MapCodecCodec = "debug" | "minecraft:debug" | "flat" | "minecraft:flat" | "noise" | "minecraft:noise";
    type MapCodec$MapCodecCodec = "hole" | "minecraft:hole" | "noise_threshold" | "minecraft:noise_threshold" | "biome" | "minecraft:biome" | "not" | "minecraft:not" | "above_preliminary_surface" | "minecraft:above_preliminary_surface" | "water" | "minecraft:water" | "stone_depth" | "minecraft:stone_depth" | "temperature" | "minecraft:temperature" | "vertical_gradient" | "minecraft:vertical_gradient" | "y_above" | "minecraft:y_above" | "steep" | "minecraft:steep";
    type MapCodec$MapCodecCodec = "bandlands" | "minecraft:bandlands" | "condition" | "minecraft:condition" | "sequence" | "minecraft:sequence" | "block" | "minecraft:block";
    type MapCodec$MapCodecCodec = "quarter_negative" | "minecraft:quarter_negative" | "max" | "minecraft:max" | "add" | "minecraft:add" | "blend_alpha" | "minecraft:blend_alpha" | "half_negative" | "minecraft:half_negative" | "y_clamped_gradient" | "minecraft:y_clamped_gradient" | "min" | "minecraft:min" | "clamp" | "minecraft:clamp" | "range_choice" | "minecraft:range_choice" | "cache_once" | "minecraft:cache_once" | "noise" | "minecraft:noise" | "shifted_noise" | "minecraft:shifted_noise" | "blend_density" | "minecraft:blend_density" | "weird_scaled_sampler" | "minecraft:weird_scaled_sampler" | "cache_all_in_cell" | "minecraft:cache_all_in_cell" | "shift" | "minecraft:shift" | "squeeze" | "minecraft:squeeze" | "mul" | "minecraft:mul" | "cube" | "minecraft:cube" | "square" | "minecraft:square" | "old_blended_noise" | "minecraft:old_blended_noise" | "constant" | "minecraft:constant" | "spline" | "minecraft:spline" | "interpolated" | "minecraft:interpolated" | "shift_b" | "minecraft:shift_b" | "abs" | "minecraft:abs" | "blend_offset" | "minecraft:blend_offset" | "cache_2d" | "minecraft:cache_2d" | "flat_cache" | "minecraft:flat_cache" | "shift_a" | "minecraft:shift_a" | "slide" | "minecraft:slide" | "end_islands" | "minecraft:end_islands" | "beardifier" | "minecraft:beardifier" | "terrain_shaper_spline" | "minecraft:terrain_shaper_spline";
    type StructureProcessorType = "nop" | "minecraft:nop" | "lava_submerged_block" | "minecraft:lava_submerged_block" | "block_ignore" | "minecraft:block_ignore" | "jigsaw_replacement" | "minecraft:jigsaw_replacement" | "block_age" | "minecraft:block_age" | "gravity" | "minecraft:gravity" | "rule" | "minecraft:rule" | "blackstone_replace" | "minecraft:blackstone_replace" | "block_rot" | "minecraft:block_rot" | "protected_blocks" | "minecraft:protected_blocks";
    type StructurePoolElementType = "empty_pool_element" | "minecraft:empty_pool_element" | "list_pool_element" | "minecraft:list_pool_element" | "legacy_single_pool_element" | "minecraft:legacy_single_pool_element" | "single_pool_element" | "minecraft:single_pool_element" | "feature_pool_element" | "minecraft:feature_pool_element";
}
declare namespace io.netty.channel {
    interface Channel extends Internal.Comparable<io.netty.channel.Channel>, Internal.ChannelOutboundInvoker, io.netty.util.AttributeMap {
        isWritable(): boolean;
        localAddress(): Internal.SocketAddress;
        bytesBeforeUnwritable(): number;
        pipeline(): Internal.ChannelPipeline;
        alloc(): Internal.ByteBufAllocator;
        eventLoop(): Internal.EventLoop;
        flush(): this;
        isRegistered(): boolean;
        isActive(): boolean;
        parent(): this;
        unsafe(): Internal.Channel$Unsafe;
        read(): this;
        closeFuture(): Internal.ChannelFuture;
        isOpen(): boolean;
        bytesBeforeWritable(): number;
        metadata(): Internal.ChannelMetadata;
        remoteAddress(): Internal.SocketAddress;
        config(): Internal.ChannelConfig;
        id(): Internal.ChannelId;
        get writable(): boolean
        get registered(): boolean
        get active(): boolean
        get open(): boolean
    }
    type Channel_ = Channel;
}
declare namespace com.mojang.datafixers.util {
    class Unit extends Internal.Enum<com.mojang.datafixers.util.Unit> {
        static valueOf(arg0: string): com.mojang.datafixers.util.Unit;
        toString(): string;
        static values(): com.mojang.datafixers.util.Unit[];
        readonly static "INSTANCE": com.mojang.datafixers.util.Unit;
    }
    type Unit_ = "instance" | Unit;
    class Pair <F, S> implements Internal.App<Internal.Pair$Mu<S>, F> {
        constructor(arg0: F, arg1: S)
        hashCode(): number;
        toString(): string;
        static unbox(arg0: Internal.App_<Internal.Pair$Mu_<S>, F>): com.mojang.datafixers.util.Pair<F, S>;
        static toMap(): Internal.Collector<com.mojang.datafixers.util.Pair<F, S>, any, Internal.Map<F, S>>;
        swap(): com.mojang.datafixers.util.Pair<S, F>;
        mapFirst(arg0: Internal.Function_<any, any>): com.mojang.datafixers.util.Pair<F2, S>;
        static of(arg0: F, arg1: S): com.mojang.datafixers.util.Pair<F, S>;
        equals(arg0: any): boolean;
        getSecond(): S;
        getFirst(): F;
        mapSecond(arg0: Internal.Function_<any, any>): com.mojang.datafixers.util.Pair<F, S2>;
        get second(): S
        get first(): F
    }
    type Pair_<F, S> = Pair<F, S>;
}
declare namespace com.mojang.bridge.game {
    class PackType extends Internal.Enum<com.mojang.bridge.game.PackType> {
        static valueOf(arg0: string): com.mojang.bridge.game.PackType;
        static values(): com.mojang.bridge.game.PackType[];
        readonly static "RESOURCE": com.mojang.bridge.game.PackType;
        readonly static "DATA": com.mojang.bridge.game.PackType;
    }
    type PackType_ = PackType | "data" | "resource";
    interface Language {
        getCode(): string;
        getName(): string;
        getRegion(): string;
        get code(): string
        get name(): string
        get region(): string
    }
    type Language_ = Language;
}
declare namespace net.minecraft.world.level.levelgen.placement {
    class BiomeFilter extends Internal.PlacementFilter {
        type(): Internal.PlacementModifierType<any>;
        static biome(): net.minecraft.world.level.levelgen.placement.BiomeFilter;
        static "CODEC": any;
    }
    type BiomeFilter_ = BiomeFilter;
}
declare namespace it.unimi.dsi.fastutil {
    interface Function <K, V> extends Internal.Function<K, V> {
        size(): number;
        apply(arg0: K): V;
        containsKey(arg0: any): boolean;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, V>;
        put(arg0: K, arg1: V): V;
        clear(): void;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<K, V>;
        getOrDefault(arg0: any, arg1: V): V;
        get(arg0: any): V;
        remove(arg0: any): V;
    }
    type Function_<K, V> = ((arg0: any)=>V) | Function<K, V>;
}
declare namespace io.netty.util {
    interface AttributeMap {
        attr(arg0: Internal.AttributeKey_<T>): io.netty.util.Attribute<T>;
        hasAttr(arg0: Internal.AttributeKey_<T>): boolean;
    }
    type AttributeMap_ = AttributeMap;
    interface Attribute <T> {
        setIfAbsent(arg0: T): T;
        getAndSet(arg0: T): T;
        remove(): void;
        compareAndSet(arg0: T, arg1: T): boolean;
        getAndRemove(): T;
        key(): Internal.AttributeKey<T>;
        get(): T;
        set(arg0: T): void;
        set ifAbsent(arg0: T)
        get andRemove(): T
    }
    type Attribute_<T> = Attribute<T>;
}
declare namespace dev.architectury.fluid {
    class FluidStack {
        setTag(tag: Internal.CompoundTag_): void;
        getRawFluid(): Internal.Fluid;
        getOrCreateChildTag(childName: string): Internal.CompoundTag;
        static read(tag: Internal.CompoundTag_): dev.architectury.fluid.FluidStack;
        removeChildTag(childName: string): void;
        isFluidStackEqual(other: dev.architectury.fluid.FluidStack_): boolean;
        isEmpty(): boolean;
        static create(fluid: Internal.Supplier_<Internal.Fluid_>, amount: number, tag: Internal.CompoundTag_): dev.architectury.fluid.FluidStack;
        copy(): this;
        getAmount(): number;
        isTagEqual(other: dev.architectury.fluid.FluidStack_): boolean;
        write(tag: Internal.CompoundTag_): Internal.CompoundTag;
        static create(fluid: Internal.Fluid_, amount: number): dev.architectury.fluid.FluidStack;
        static empty(): dev.architectury.fluid.FluidStack;
        static create(fluid: Internal.Supplier_<Internal.Fluid_>, amount: number): dev.architectury.fluid.FluidStack;
        write(buf: Internal.FriendlyByteBuf_): void;
        isFluidEqual(other: dev.architectury.fluid.FluidStack_): boolean;
        getName(): Internal.Component;
        static init(): void;
        getRawFluidSupplier(): Internal.Supplier<Internal.Fluid>;
        static create(fluid: Internal.Fluid_, amount: number, tag: Internal.CompoundTag_): dev.architectury.fluid.FluidStack;
        static read(buf: Internal.FriendlyByteBuf_): dev.architectury.fluid.FluidStack;
        getTranslationKey(): string;
        setAmount(amount: number): void;
        hashCode(): number;
        shrink(amount: number): void;
        getOrCreateTag(): Internal.CompoundTag;
        getChildTag(childName: string): Internal.CompoundTag;
        grow(amount: number): void;
        hasTag(): boolean;
        static bucketAmount(): number;
        getTag(): Internal.CompoundTag;
        getFluid(): Internal.Fluid;
        equals(o: any): boolean;
        copyWithAmount(amount: number): this;
        static create(stack: dev.architectury.fluid.FluidStack_, amount: number): dev.architectury.fluid.FluidStack;
        set tag(tag: Internal.CompoundTag_)
        get rawFluid(): Internal.Fluid
        get empty(): boolean
        get amount(): number
        get name(): Internal.Component
        get rawFluidSupplier(): Internal.Supplier<Internal.Fluid>
        get translationKey(): string
        set amount(amount: number)
        get orCreateTag(): Internal.CompoundTag
        get tag(): Internal.CompoundTag
        get fluid(): Internal.Fluid
    }
    type FluidStack_ = FluidStack;
}
declare namespace it.unimi.dsi.fastutil.ints {
    interface IntBinaryOperator extends Internal.IntBinaryOperator, Internal.BinaryOperator<number> {
        apply(arg0: number, arg1: number): number;
        apply(arg0: any, arg1: any): any;
        andThen(arg0: Internal.Function_<any, any>): Internal.BiFunction<number, number, V>;
        applyAsInt(arg0: number, arg1: number): number;
        apply(arg0: number, arg1: number): number;
    }
    type IntBinaryOperator_ = IntBinaryOperator | ((arg0: number, arg1: number)=>number);
    interface IntPredicate extends Internal.Predicate<number>, Internal.IntPredicate {
        test(arg0: any): boolean;
        and(arg0: Internal.IntPredicate_): Internal.IntPredicate;
        and(arg0: it.unimi.dsi.fastutil.ints.IntPredicate_): this;
        or(arg0: Internal.Predicate_<any>): Internal.Predicate<number>;
        and(arg0: Internal.Predicate_<any>): Internal.Predicate<number>;
        or(arg0: it.unimi.dsi.fastutil.ints.IntPredicate_): this;
        negate(): Internal.IntPredicate;
        test(arg0: number): boolean;
        or(arg0: Internal.IntPredicate_): this;
    }
    type IntPredicate_ = IntPredicate;
    interface IntConsumer extends Internal.Consumer<number>, Internal.IntConsumer {
        andThen(arg0: Internal.Consumer_<any>): Internal.Consumer<number>;
        andThen(arg0: it.unimi.dsi.fastutil.ints.IntConsumer_): this;
        accept(arg0: any): void;
        accept(arg0: number): void;
        andThen(arg0: Internal.IntConsumer_): Internal.IntConsumer;
    }
    type IntConsumer_ = IntConsumer;
    interface IntUnaryOperator extends Internal.IntUnaryOperator, Internal.UnaryOperator<number> {
        apply(arg0: number): number;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
        apply(arg0: any): any;
        identity(): this;
        apply(arg0: number): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        applyAsInt(arg0: number): number;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        negation(): this;
    }
    type IntUnaryOperator_ = ((arg0: number)=>number) | IntUnaryOperator;
}
declare namespace org.objectweb.asm {
    class Type {
        getOpcode(arg0: number): number;
        getSort(): number;
        getClassName(): string;
        getDescriptor(): string;
        static getDescriptor(arg0: Internal.Class_<any>): string;
        getSize(): number;
        static getConstructorDescriptor(arg0: Internal.Constructor_<any>): string;
        getDimensions(): number;
        static getType(arg0: Internal.Constructor_<any>): org.objectweb.asm.Type;
        static getType(arg0: Internal.Class_<any>): org.objectweb.asm.Type;
        static getInternalName(arg0: Internal.Class_<any>): string;
        getElementType(): this;
        toString(): string;
        static getMethodType(arg0: org.objectweb.asm.Type_, ...arg1: org.objectweb.asm.Type_[]): org.objectweb.asm.Type;
        static getMethodDescriptor(arg0: org.objectweb.asm.Type_, ...arg1: org.objectweb.asm.Type_[]): string;
        static getReturnType(arg0: Internal.Method_): org.objectweb.asm.Type;
        getInternalName(): string;
        static getReturnType(arg0: string): org.objectweb.asm.Type;
        getArgumentTypes(): org.objectweb.asm.Type[];
        static getObjectType(arg0: string): org.objectweb.asm.Type;
        static getMethodType(arg0: string): org.objectweb.asm.Type;
        getArgumentsAndReturnSizes(): number;
        static getMethodDescriptor(arg0: Internal.Method_): string;
        static getType(arg0: Internal.Method_): org.objectweb.asm.Type;
        static getArgumentTypes(arg0: string): org.objectweb.asm.Type[];
        getReturnType(): this;
        static getType(arg0: string): org.objectweb.asm.Type;
        hashCode(): number;
        static getArgumentsAndReturnSizes(arg0: string): number;
        static getArgumentTypes(arg0: Internal.Method_): org.objectweb.asm.Type[];
        equals(arg0: any): boolean;
        get sort(): number
        get className(): string
        get descriptor(): string
        get size(): number
        get dimensions(): number
        get elementType(): org.objectweb.asm.Type
        get internalName(): string
        get argumentTypes(): org.objectweb.asm.Type[]
        get argumentsAndReturnSizes(): number
        get returnType(): org.objectweb.asm.Type
        readonly static "ARRAY": 9;
        readonly static "VOID_TYPE": org.objectweb.asm.Type;
        readonly static "INT": 5;
        readonly static "LONG": 7;
        readonly static "SHORT_TYPE": org.objectweb.asm.Type;
        readonly static "INT_TYPE": org.objectweb.asm.Type;
        readonly static "CHAR": 2;
        readonly static "BYTE": 3;
        readonly static "CHAR_TYPE": org.objectweb.asm.Type;
        readonly static "SHORT": 4;
        readonly static "METHOD": 11;
        readonly static "OBJECT": 10;
        readonly static "BYTE_TYPE": org.objectweb.asm.Type;
        readonly static "LONG_TYPE": org.objectweb.asm.Type;
        readonly static "VOID": 0;
        readonly static "FLOAT": 6;
        readonly static "DOUBLE": 8;
        readonly static "FLOAT_TYPE": org.objectweb.asm.Type;
        readonly static "DOUBLE_TYPE": org.objectweb.asm.Type;
        readonly static "BOOLEAN_TYPE": org.objectweb.asm.Type;
        readonly static "BOOLEAN": 1;
    }
    type Type_ = Type;
}
declare namespace it.unimi.dsi.fastutil.longs {
    interface LongConsumer extends Internal.LongConsumer, Internal.Consumer<number> {
        andThen(arg0: Internal.LongConsumer_): Internal.LongConsumer;
        andThen(arg0: it.unimi.dsi.fastutil.longs.LongConsumer_): this;
        accept(arg0: any): void;
        accept(arg0: number): void;
        andThen(arg0: Internal.Consumer_<any>): Internal.Consumer<number>;
    }
    type LongConsumer_ = LongConsumer;
    interface LongPredicate extends Internal.Predicate<number>, Internal.LongPredicate {
        or(arg0: Internal.Predicate_<any>): Internal.Predicate<number>;
        test(arg0: any): boolean;
        or(arg0: it.unimi.dsi.fastutil.longs.LongPredicate_): this;
        negate(): Internal.LongPredicate;
        and(arg0: it.unimi.dsi.fastutil.longs.LongPredicate_): this;
        and(arg0: Internal.Predicate_<any>): Internal.Predicate<number>;
        or(arg0: Internal.LongPredicate_): this;
        test(arg0: number): boolean;
        and(arg0: Internal.LongPredicate_): Internal.LongPredicate;
    }
    type LongPredicate_ = LongPredicate;
}
declare namespace net.minecraft.tags {
    class Tag <T> {
        constructor(arg0: Internal.Collection_<T>)
        static empty(): net.minecraft.tags.Tag<T>;
        getValues(): Internal.List<T>;
        get values(): Internal.List<T>
    }
    type Tag_<T> = Tag<T>;
}
declare namespace net.minecraftforge.client.event.sound {
    class SoundEvent extends Internal.Event {
        constructor()
        constructor(arg0: Internal.SoundEngine_)
        getListenerList(): Internal.ListenerList;
        getEngine(): Internal.SoundEngine;
        get listenerList(): Internal.ListenerList
        get engine(): Internal.SoundEngine
    }
    type SoundEvent_ = SoundEvent;
}
declare namespace dev.latvian.mods.rhino {
    interface Callable {
        call(arg0: Internal.Context_, arg1: Internal.Scriptable_, arg2: Internal.Scriptable_, arg3: any[]): any;
    }
    type Callable_ = Callable;
    interface Function extends dev.latvian.mods.rhino.Callable, Internal.Scriptable {
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        call(arg0: Internal.Context_, arg1: Internal.Scriptable_, arg2: Internal.Scriptable_, arg3: any[]): any;
        getTypeOf(): Internal.MemberType;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getAllIds(): any[];
        construct(arg0: Internal.Context_, arg1: Internal.Scriptable_, arg2: any[]): Internal.Scriptable;
        get typeOf(): Internal.MemberType
        get allIds(): any[]
    }
    type Function_ = Function;
}
declare namespace com.mojang.datafixers.types {
    abstract class Type <A> implements Internal.App<Internal.Type$Mu, A> {
        constructor()
        findType(arg0: com.mojang.datafixers.types.Type_<FT>, arg1: com.mojang.datafixers.types.Type_<FR>, arg2: Internal.Type$TypeMatcher_<FT, FR>, arg3: boolean): Internal.Either<Internal.TypedOptic<A, any, FT, FR>, Internal.Type$FieldNotFoundException>;
        codec(): Internal.Codec<A>;
        findChoiceType(arg0: string, arg1: number): Internal.Optional<Internal.TaggedChoice$TaggedChoiceType<any>>;
        readTyped(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<com.mojang.datafixers.util.Pair<Internal.Typed<A>, T>>;
        writeDynamic(arg0: Internal.DynamicOps_<T>, arg1: A): Internal.DataResult<Internal.Dynamic<T>>;
        all(arg0: Internal.TypeRewriteRule_, arg1: boolean, arg2: boolean): Internal.RewriteResult<A, any>;
        getSetType(arg0: Internal.OpticFinder_<FT>, arg1: com.mojang.datafixers.types.Type_<FR>): com.mojang.datafixers.types.Type<any>;
        readAndWrite(arg0: Internal.DynamicOps_<T>, arg1: com.mojang.datafixers.types.Type_<any>, arg2: Internal.TypeRewriteRule_, arg3: Internal.PointFreeRule_, arg4: T): Internal.DataResult<T>;
        rewrite(arg0: Internal.TypeRewriteRule_, arg1: Internal.PointFreeRule_): Internal.Optional<Internal.RewriteResult<A, any>>;
        ifSame(arg0: com.mojang.datafixers.types.Type_<B>, arg1: B): Internal.Optional<A>;
        findField(arg0: string): Internal.OpticFinder<any>;
        one(arg0: Internal.TypeRewriteRule_): Internal.Optional<Internal.RewriteResult<A, any>>;
        everywhere(arg0: Internal.TypeRewriteRule_, arg1: Internal.PointFreeRule_, arg2: boolean, arg3: boolean): Internal.Optional<Internal.RewriteResult<A, any>>;
        pointTyped(arg0: Internal.DynamicOps_<any>): Internal.Optional<Internal.Typed<A>>;
        point(arg0: Internal.DynamicOps_<any>): Internal.Optional<A>;
        static unbox(arg0: Internal.App_<Internal.Type$Mu_, A>): com.mojang.datafixers.types.Type<A>;
        readTyped(arg0: Internal.Dynamic_<T>): Internal.DataResult<com.mojang.datafixers.util.Pair<Internal.Typed<A>, T>>;
        equals(arg0: any, arg1: boolean, arg2: boolean): boolean;
        findTypeCached(arg0: com.mojang.datafixers.types.Type_<FT>, arg1: com.mojang.datafixers.types.Type_<FR>, arg2: Internal.Type$TypeMatcher_<FT, FR>, arg3: boolean): Internal.Either<Internal.TypedOptic<A, any, FT, FR>, Internal.Type$FieldNotFoundException>;
        findTypeInChildren(arg0: com.mojang.datafixers.types.Type_<FT>, arg1: com.mojang.datafixers.types.Type_<FR>, arg2: Internal.Type$TypeMatcher_<FT, FR>, arg3: boolean): Internal.Either<Internal.TypedOptic<A, any, FT, FR>, Internal.Type$FieldNotFoundException>;
        ifSame(arg0: com.mojang.datafixers.types.Type_<B>, arg1: Internal.RewriteResult_<B, any>): Internal.Optional<Internal.RewriteResult<A, any>>;
        static opticView(arg0: com.mojang.datafixers.types.Type_<S>, arg1: Internal.RewriteResult_<A, B>, arg2: Internal.TypedOptic_<S, T, A, B>): Internal.RewriteResult<S, T>;
        read(arg0: Internal.DynamicOps_<T>, arg1: Internal.TypeRewriteRule_, arg2: Internal.PointFreeRule_, arg3: T): Internal.DataResult<com.mojang.datafixers.util.Pair<Internal.Optional<any>, T>>;
        findCheckedType(arg0: number): Internal.Optional<com.mojang.datafixers.types.Type<any>>;
        findFieldTypeOpt(arg0: string): Internal.Optional<com.mojang.datafixers.types.Type<any>>;
        read(arg0: Internal.Dynamic_<T>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, Internal.Dynamic<T>>>;
        findFieldType(arg0: string): com.mojang.datafixers.types.Type<any>;
        rewriteOrNop(arg0: Internal.TypeRewriteRule_): Internal.RewriteResult<A, any>;
        ifSame(arg0: Internal.Typed_<B>): Internal.Optional<A>;
        finder(): Internal.OpticFinder<A>;
        equals(arg0: any): boolean;
        updateMu(arg0: Internal.RecursiveTypeFamily_): com.mojang.datafixers.types.Type<any>;
        write(arg0: Internal.DynamicOps_<T>, arg1: A): Internal.DataResult<T>;
        buildTemplate(): Internal.TypeTemplate;
        template(): Internal.TypeTemplate;
    }
    type Type_<A> = Type<A>;
}
declare namespace it.unimi.dsi.fastutil.doubles {
    interface DoublePredicate extends Internal.DoublePredicate, Internal.Predicate<number> {
        or(arg0: Internal.DoublePredicate_): this;
        test(arg0: any): boolean;
        and(arg0: Internal.Predicate_<any>): Internal.Predicate<number>;
        or(arg0: Internal.Predicate_<any>): Internal.Predicate<number>;
        and(arg0: Internal.DoublePredicate_): Internal.DoublePredicate;
        or(arg0: it.unimi.dsi.fastutil.doubles.DoublePredicate_): this;
        test(arg0: number): boolean;
        negate(): Internal.DoublePredicate;
        and(arg0: it.unimi.dsi.fastutil.doubles.DoublePredicate_): this;
    }
    type DoublePredicate_ = DoublePredicate;
    interface DoubleUnaryOperator extends Internal.DoubleUnaryOperator, Internal.UnaryOperator<number> {
        compose(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        negation(): this;
        andThen(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        andThen(arg0: Internal.Function_<any, any>): Internal.Function<number, V>;
        apply(arg0: any): any;
        apply(arg0: number): number;
        identity(): this;
        apply(arg0: number): number;
        applyAsDouble(arg0: number): number;
        compose(arg0: Internal.Function_<any, any>): Internal.Function<V, number>;
    }
    type DoubleUnaryOperator_ = ((arg0: number)=>number) | DoubleUnaryOperator;
    interface DoubleConsumer extends Internal.DoubleConsumer, Internal.Consumer<number> {
        andThen(arg0: Internal.Consumer_<any>): Internal.Consumer<number>;
        accept(arg0: any): void;
        accept(arg0: number): void;
        andThen(arg0: Internal.DoubleConsumer_): Internal.DoubleConsumer;
        andThen(arg0: it.unimi.dsi.fastutil.doubles.DoubleConsumer_): this;
    }
    type DoubleConsumer_ = DoubleConsumer;
}
